

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/dajiangdahe/img/favicon.png">
  <link rel="icon" href="/dajiangdahe/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Hello,here is kengkeng&#39;s blog.">
  <meta name="author" content="kengkeng">
  <meta name="keywords" content="">
  
  <title>MySQL是怎样运行的--小孩子 - kengkeng&#39;s life</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/dajiangdahe/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/dajiangdahe/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"kengkengya.github.io","root":"/dajiangdahe/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/dajiangdahe/js/utils.js" ></script>
  <script  src="/dajiangdahe/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/dajiangdahe/">&nbsp;<strong>kengkeng's life</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/dajiangdahe/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="MySQL是怎样运行的--小孩子">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      kengkeng
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-29 10:15" pubdate>
        2021年11月29日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      121.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      1334
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL是怎样运行的--小孩子</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：8 天前
                
              </p>
            
            <div class="markdown-body">
              <h1>MySQL是怎样运行的–小孩子</h1>
<p>原书地址：<a target="_blank" rel="noopener" href="https://juejin.cn/book/6844733769996304392">https://juejin.cn/book/6844733769996304392</a></p>
<h1><strong>1.重新认识MySQL</strong></h1>
<h2 id="MySQL的客户端／服务器架构">MySQL的客户端／服务器架构</h2>
<p>以我们平时使用的微信为例，它其实是由两部分组成的，一部分是客户端程序，一部分是服务器程序。客户端可能有很多种形式，比如手机APP，电脑软件或者是网页版微信，每个客户端都有一个唯一的用户名，就是你的微信号，另一方面，腾讯公司在他们的机房里运行着一个服务器软件，我们平时操作微信其实都是用客户端来和这个服务器来打交道。比如狗哥用微信给猫爷发了一条消息的过程其实是这样的：</p>
<ol>
<li>消息被客户端包装了一下，添加了发送者和接收者信息，然后从狗哥的微信客户端传送给微信服务器；</li>
<li>微信服务器从消息里获取到它的发送者和接收者，根据消息的接收者信息把这条消息送达到猫爷的微信客户端，猫爷的微信客户端里就显示出狗哥给他发了一条消息。</li>
</ol>
<p><code>MySQL</code>的使用过程跟这个是一样的，它的服务器程序直接和我们存储的数据打交道，然后可以有好多客户端程序连接到这个服务器程序，发送增删改查的请求，然后服务器就响应这些请求，从而操作它维护的数据。和微信一样，<code>MySQL</code>的每个客户端都需要提供用户名密码才能登录，登录之后才能给服务器发请求来操作某些数据。我们日常使用<code>MySQL</code>的情景一般是这样的：</p>
<ol>
<li>启动<code>MySQL</code>服务器程序。</li>
<li>启动<code>MySQL</code>客户端程序并连接到服务器程序。</li>
<li>在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果。</li>
</ol>
<p>我们知道计算机很牛逼，在一台计算机上可以同时运行多个程序，比如微信、QQ、音乐播放器、文本编辑器啥的，每一个运行着的程序也被称为一个<code>进程</code>。我们的<code>MySQL</code>服务器程序和客户端程序本质上都算是计算机上的一个<code>进程</code>，这个代表着<code>MySQL</code>服务器程序的进程也被称为<code>MySQL数据库实例</code>，简称<code>数据库实例</code>。</p>
<p>每个进程都有一个唯一的编号，称为<code>进程ID</code>，英文名叫<code>PID</code>，这个编号是在我们启动程序的时候由操作系统随机分配的，操作系统会保证在某一时刻同一台机器上的进程号不重复。比如你打开了计算机中的QQ程序，那么操作系统会为它分配一个唯一的进程号，如果你把这个程序关掉了，那操作系统就会把这个进程号回收，之后可能会重新分配给别的进程。当我们下一次再启动 QQ程序的时候分配的就可能是另一个编号。每个进程都有一个名称，这个名称是编写程序的人自己定义的，比如我们启动的<code>MySQL</code>服务器进程的默认名称为<code>mysqld</code>， 而我们常用的<code>MySQL</code>客户端进程的默认名称为<code>mysql</code>。</p>
<h2 id="MySQL的安装">MySQL的安装</h2>
<p>不论我们通过下载源代码自行编译安装的方式还是直接使用官方提供的安装包进行安装之后，<code>MySQL</code>的服务器程序和客户端程序都会被安装到我们的机器上。不论使用上述两者的哪种安装方式，一定一定一定（重要的话说三遍）要记住你把<code>MySQL</code>安装到哪了，换句话说，一定要记住<code>MySQL</code>的安装目录。</p>
<blockquote>
<p>小贴士： <code>MySQL</code>的大部分安装包都包含了服务器程序和客户端程序，不过在Linux下使用RPM包时会有单独的服务器RPM包和客户端RPM包，需要分别安装。</p>
</blockquote>
<p>另外，<code>MySQL</code>可以运行在各种各样的操作系统上，我们后边会讨论在类<code>UNIX</code>操作系统和<code>Windows</code>操作系统上使用的一些差别。为了方便大家理解，我在<code>macOS</code> 操作系统（苹果电脑使用的操作系统）和<code>Windows</code>操作系统上都安装了<code>MySQL</code>，它们的安装目录分别是：</p>
<ul>
<li><code>macOS</code>操作系统上的安装目录：</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>Windows</code>操作系统上的安装目录：</li>
</ul>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\M</span>ySQL<span class="hljs-symbol">\M</span>ySQL Server 5.7<br></code></pre></td></tr></table></figure>
<p>下边我会以这两个安装目录为例来进一步扯出更多的概念，不过一定要注意，这两个安装目录是我的运行不同操作系统的机器上的安装目录，一定要记着把下边示例中用到安装目录的地方替换为你自己机器上的安装目录。</p>
<blockquote>
<p>小贴士： 类UNIX操作系统非常多，比如FreeBSD、Linux、macOS、Solaris等都属于UNIX操作系统的范畴，我们这里使用macOS操作系统代表类UNIX操作系统来运行MySQL。</p>
</blockquote>
<h3 id="bin目录下的可执行文件">bin目录下的可执行文件</h3>
<p>在<code>MySQL</code>的安装目录下有一个特别特别重要的<code>bin</code>目录，这个目录下存放着许多可执行文件，以<code>macOS</code>系统为例，这个<code>bin</code>目录的绝对路径就是（在我的机器上）：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>bin<br></code></pre></td></tr></table></figure>
<p>我们列出一些在<code>macOS</code>中这个<code>bin</code>目录下的一部分可执行文件来看一下（文件太多，全列出来会刷屏的）：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs elm">.<br>├── mysql<br>├── mysql.server -&gt; ../sup<span class="hljs-keyword">port</span>-files/mysql.server<br>├── mysqladmin<br>├── mysqlbinlog<br>├── mysqlcheck<br>├── mysqld<br>├── mysqld_multi<br>├── mysqld_safe<br>├── mysqldump<br>├── mysql<span class="hljs-keyword">import</span><br>├── mysqlpump<br>... (省略其他文件)<br><span class="hljs-number">0</span> directories, <span class="hljs-number">40</span> files<br></code></pre></td></tr></table></figure>
<p><code>Windows</code>中的可执行文件与<code>macOS</code>中的类似，不过都是以<code>.exe</code>为扩展名的。这些可执行文件都是与服务器程序和客户端程序相关的，后边我们会详细唠叨一些比较重要的可执行文件，现在先看看执行这些文件的方式。</p>
<p>对于有可视化界面的操作系统来说，我们拿着鼠标点点点就可以执行某个可执行文件，不过现在我们更关注在命令行环境下如何执行这些可执行文件，命令行通俗的说就是那些黑框框，这里的指的是类<code>UNIX</code>系统中的<code>Shell</code>或者<code>Windows</code>系统中的<code>cmd.exe</code>，如果你现在还不知道怎么启动这些命令行工具，网上搜搜吧～ 下边我们以<code>macOS</code>系统为例来看看如何启动这些可执行文件（<code>Windows</code>中的操作是类似的，依葫芦画瓢就好了）</p>
<ul>
<li>
<p>使用可执行文件的相对／绝对路径</p>
<p>假设我们现在所处的工作目录是<code>MySQL</code>的安装目录，也就是<code>/usr/local/mysql</code>，我们想启动<code>bin</code>目录下的<code>mysqld</code>这个可执行文件，可以使用相对路径来启动：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/my</span>sqld<br></code></pre></td></tr></table></figure>
<p>或者直接输入<code>mysqld</code>的绝对路径也可以：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>bin/mysqld<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>将该<code>bin</code>目录的路径加入到环境变量<code>PATH</code>中</p>
<p>如果我们觉得每次执行一个文件都要输入一串长长的路径名贼麻烦的话，可以把该<code>bin</code>目录所在的路径添加到环境变量<code>PATH</code>中。环境变量<code>PATH</code>是一系列路径的集合，各个路径之间使用冒号<code>:</code>隔离开，比方说我的机器上的环境变量<code>PATH</code>的值就是：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin:/u</span>sr<span class="hljs-regexp">/bin:/</span>bin:<span class="hljs-regexp">/usr/</span>sbin:/sbin<br></code></pre></td></tr></table></figure>
<p>我的系统中这个环境变量<code>PATH</code>的值表明：当我在输入一个命令时，系统便会在<code>/usr/local/bin</code>、<code>/usr/bin:</code>、<code>/bin:</code>、<code>/usr/sbin</code>、<code>/sbin</code>这些目录下依次寻找是否存在我们输入的那个命令，如果寻找成功，则执行该目录下对应的可执行文件。所以我们现在可以修改一下这个环境变量<code>PATH</code>，把<code>MySQL</code>安装目录下的<code>bin</code>目录的路径也加入到<code>PATH</code>中，在我的机器上修改后的环境变量<code>PATH</code>的值为：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin:/u</span>sr<span class="hljs-regexp">/bin:/</span>bin:<span class="hljs-regexp">/usr/</span>sbin:<span class="hljs-regexp">/sbin:/u</span>sr<span class="hljs-regexp">/local/my</span>sql/bin<br></code></pre></td></tr></table></figure>
<p>这样现在不论我们所处的工作目录是啥，我们都可以直接输入可执行文件的名字就可以启动它，比如这样：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mysqld</span><br></code></pre></td></tr></table></figure>
<p>方便多了哈～</p>
<blockquote>
<p>小贴士： 关于啥是环境变量以及如何在当前系统中添加或修改系统变量不是我们唠叨的范围，大家找本相关的书或者上网查一查哈～</p>
</blockquote>
</li>
</ul>
<h2 id="启动MySQL服务器程序">启动MySQL服务器程序</h2>
<h3 id="UNIX里启动服务器程序">UNIX里启动服务器程序</h3>
<p>在类<code>UNIX</code>系统中用来启动<code>MySQL</code>服务器程序的可执行文件有很多，大多在<code>MySQL</code>安装目录的<code>bin</code>目录下，我们一起来瞅瞅。</p>
<h4 id="mysqld">mysqld</h4>
<p><code>mysqld</code>这个可执行文件就代表着<code>MySQL</code>服务器程序，运行这个可执行文件就可以直接启动一个服务器进程。但这个命令不常用，我们继续往下看更牛逼的启动命令。</p>
<h4 id="mysqld-safe">mysqld_safe</h4>
<p><code>mysqld_safe</code>是一个启动脚本，它会间接的调用<code>mysqld</code>，而且还顺便启动了另外一个监控进程，这个监控进程在服务器进程挂了的时候，可以帮助重启它。另外，使用<code>mysqld_safe</code>启动服务器程序时，它会将服务器程序的出错信息和其他诊断信息重定向到某个文件中，产生出错日志，这样可以方便我们找出发生错误的原因。</p>
<h4 id="mysql-server">mysql.server</h4>
<p><code>mysql.server</code>也是一个启动脚本，它会间接的调用<code>mysqld_safe</code>，在调用<code>mysql.server</code>时在后边指定<code>start</code>参数就可以启动服务器程序了，就像这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql.<span class="hljs-keyword">server</span> <span class="hljs-keyword">start</span><br></code></pre></td></tr></table></figure>
<p>需要注意的是，这个 <em><strong>mysql.server</strong></em> 文件其实是一个链接文件，它的实际文件是 <em><strong>…/support-files/mysql.server</strong></em>。我使用的<code>macOS</code>操作系统会帮我们在<code>bin</code>目录下自动创建一个指向实际文件的链接文件，如果你的操作系统没有帮你自动创建这个链接文件，那就自己创建一个呗～ 别告诉我你不会创建链接文件，上网搜搜呗～</p>
<p>另外，我们还可以使用<code>mysql.server</code>命令来关闭正在运行的服务器程序，只要把<code>start</code>参数换成<code>stop</code>就好了：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">mysql.<span class="hljs-built_in">server</span> <span class="hljs-keyword">stop</span><br></code></pre></td></tr></table></figure>
<h4 id="mysqld-multi">mysqld_multi</h4>
<p>其实我们一台计算机上也可以运行多个服务器实例，也就是运行多个<code>MySQL</code>服务器进程。<code>mysql_multi</code>可执行文件可以对每一个服务器进程的启动或停止进行监控。这个命令的使用比较复杂，本书主要是为了讲清楚<code>MySQL</code>服务器和客户端运行的过程，不会对启动多个服务器程序进行过多唠叨。</p>
<h3 id="Windows里启动服务器程序">Windows里启动服务器程序</h3>
<p><code>Windows</code>里没有像类<code>UNIX</code>系统中那么多的启动脚本，但是也提供了手动启动和以服务的形式启动这两种方式，下边我们详细看。</p>
<h4 id="mysqld-2">mysqld</h4>
<p>同样的，在<code>MySQL</code>安装目录下的<code>bin</code>目录下有一个<code>mysqld</code>可执行文件，在命令行里输入<code>mysqld</code>，或者直接双击运行它就算启动了<code>MySQL</code>服务器程序了。</p>
<h4 id="以服务的方式运行服务器程序">以服务的方式运行服务器程序</h4>
<p>首先看看啥是个<code>Windows</code> 服务？如果无论是谁正在使用这台计算机，我们都需要长时间的运行某个程序，而且需要在计算机启动的时候便启动它，一般我们都会把它注册为一个<code>Windows 服务</code>，操作系统会帮我们管理它。把某个程序注册为<code>Windows</code>服务的方式挺简单，如下：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;完整的可执行文件路径&quot;</span> --install [-manual] [服务名]<br></code></pre></td></tr></table></figure>
<p>其中的<code>-manual</code>可以省略，加上它的话表示在<code>Windows</code>系统启动的时候不自动启动该服务，否则会自动启动。<code>服务名</code>也可以省略，默认的服务名就是<code>MySQL</code>。比如我的<code>Windows</code>计算机上<code>mysqld</code>的完整路径是：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\M</span>ySQL<span class="hljs-symbol">\M</span>ySQL Server 5.7<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\m</span>ysqld<br></code></pre></td></tr></table></figure>
<p>所以如果我们想把它注册为服务的话可以在命令行里这么写：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">&quot;C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\M</span>ySQL<span class="hljs-symbol">\M</span>ySQL Server 5.7<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\m</span>ysqld&quot; --install<br></code></pre></td></tr></table></figure>
<p>在把<code>mysqld</code>注册为<code>Windows</code>服务之后，我们就可以通过下边这个命令来启动<code>MySQL</code>服务器程序了：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> MySQL<br></code></pre></td></tr></table></figure>
<p>当然，如果你喜欢图形界面的话，你可以通过<code>Windows</code>的服务管理器通过用鼠标点点点的方式来启动和停止服务（作为一个程序猿，还是用黑框框吧～）。</p>
<p>关闭这个服务也非常简单，只要把上边的<code>start</code>换成<code>stop</code>就行了，就像这样：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">net stop MySQL<br></code></pre></td></tr></table></figure>
<h2 id="启动MySQL客户端程序">启动MySQL客户端程序</h2>
<p>在我们成功启动<code>MySQL</code>服务器程序后，就可以接着启动客户端程序来连接到这个服务器喽，<code>bin</code>目录下有许多客户端程序，比方说<code>mysqladmin</code>、<code>mysqldump</code>、<code>mysqlcheck</code>等等等等（好多呢，就不一一列举了）。这里我们重点要关注的是可执行文件<code>mysql</code>，通过这个可执行文件可以让我们和服务器程序进程交互，也就是发送请求，接收服务器的处理结果。启动这个可执行文件时一般需要一些参数，格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -h主机名  -u用户名 -<span class="hljs-selector-tag">p</span>密码<br></code></pre></td></tr></table></figure>
<p>各个参数的意义如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-h</code></td>
<td>表示服务器进程所在计算机的域名或者IP地址，如果服务器进程就运行在本机的话，可以省略这个参数，或者填<code>localhost</code>或者<code>127.0.0.1</code>。也可以写作 <code>--host=主机名</code>的形式。</td>
</tr>
<tr>
<td style="text-align:left"><code>-u</code></td>
<td>表示用户名。也可以写作 <code>--user=用户名</code>的形式。</td>
</tr>
<tr>
<td style="text-align:left"><code>-p</code></td>
<td>表示密码。也可以写作 <code>--password=密码</code>的形式。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>小贴士： **像 h、u、p 这样名称只有一个英文字母的参数称为短形式的参数，使用时前边需要加单短划线，像 host、user、password 这样大于一个英文字母的参数称为长形式的参数，使用时前边需要加双短划线。**后边会详细讨论这些参数的使用方式的，稍安勿躁～</p>
</blockquote>
<p>比如我这样执行下边这个可执行文件(用户名密码按你的实际情况填写)，就可以启动<code>MySQL</code>客户端，并且连接到服务器了。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span> -hlocalhost -uroot -p<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure>
<p>我们看一下连接成功后的界面：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs smali">Welcome to the MySQ<span class="hljs-class">L monitor.  Commands end with ;</span><span class="hljs-built_in"> or </span>\g.<br>Your MySQL connection id is 2<br>Server version: 5.7.21 Homebrew<br><br>Copyright (c) 2000, 2018, Oracle<span class="hljs-built_in"> and/or </span>its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation<span class="hljs-built_in"> and/or </span>its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br>Type &#x27;help;&#x27;<span class="hljs-built_in"> or </span>&#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.<br><br>mysql&gt; <br></code></pre></td></tr></table></figure>
<p>最后一行的<code>mysql&gt;</code>是一个客户端的提示符，之后客户端发送给服务器的命令都需要写在这个提示符后边。</p>
<p>如果我们想断开客户端与服务器的连接并且关闭客户端的话，可以在<code>mysql&gt;</code>提示符后输入下边任意一个命令：</p>
<ol>
<li><code>quit</code></li>
<li><code>exit</code></li>
<li><code>\q</code></li>
</ol>
<p>比如我们输入<code>quit</code>试试：</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">mysql&gt; <span class="hljs-keyword">quit</span><br>Bye<br></code></pre></td></tr></table></figure>
<p>输出了<code>Bye</code>说明客户端程序已经关掉了。注意注意注意，这是关闭客户端程序的方式，不是关闭服务器程序的方式，怎么关闭服务器程序上一节里唠叨过了。</p>
<p>如果你愿意，你可以多打开几个黑框框，每个黑框框都使用<code>mysql -hlocalhost -uroot -p123456</code>来运行多个客户端程序，每个客户端程序都是互不影响的。如果你有多个电脑，也可以试试把它们用局域网连起来，在一个电脑上启动<code>MySQL</code>服务器程序，在另一个电脑上执行<code>mysql</code>命令时使用<code>IP</code>地址作为主机名来连接到服务器。</p>
<table>
<thead>
<tr>
<th>客户端程序</th>
<th>服务器程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动：mysql -h -u -p</td>
<td>启动：mysqld、mysql_safe、mysql.server、mysqld_multi</td>
</tr>
<tr>
<td>关闭：quit、exit、\q</td>
<td>关闭：xxx stop 或者 net  stop xxx</td>
</tr>
</tbody>
</table>
<blockquote>
<p>xxx代表启动方式，类unix系统为前者，windows系统为后者。</p>
</blockquote>
<h3 id="连接注意事项">连接注意事项</h3>
<ul>
<li>
<p>最好不要在一行命令中输入密码。</p>
<p>我们直接在黑框框里输入密码很可能被别人看到，这和你当着别人的面输入银行卡密码没啥区别，所以我们在执行<code>mysql</code>连接服务器的时候可以不显式的写出密码，就像这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -hlocalhost -uroot -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure>
<p>点击回车之后才会提示你输入密码：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Enter</span> <span class="hljs-variable">password</span><span class="hljs-operator">:</span><br></code></pre></td></tr></table></figure>
<p>不过这回你输入的密码不会被显示出来，心怀不轨的人也就看不到了，输入完成点击回车就成功连接到了服务器。</p>
</li>
<li>
<p>如果你非要在一行命令中显式的把密码输出来，那<code>-p</code>和密码值之间不能有空白字符（其他参数名之间可以有空白字符），就像这样：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span> -h localhost -u root -p<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure>
<p>如果加上了空白字符就是错误的，比如这样：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span> -h localhost -u root -p <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>mysql</code>的各个参数的摆放顺序没有硬性规定，也就是说你也可以这么写：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -<span class="hljs-selector-tag">p</span>  -u root -h localhost<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>如果你的服务器和客户端安装在同一台机器上，<code>-h</code>参数可以省略，就像这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u root -<span class="hljs-selector-tag">p</span>  <br></code></pre></td></tr></table></figure>
</li>
<li>
<p>如果你使用的是类<code>UNIX</code>系统，并且省略<code>-u</code>参数后，会把你登陆操作系统的用户名当作<code>MySQL</code>的用户名去处理。</p>
<p>比方说我用登录操作系统的用户名是<code>xiaohaizi</code>，那么在我的机器上下边这两条命令是等价的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u xiaohaizi -<span class="hljs-selector-tag">p</span><br>mysql -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure>
<p>对于<code>Windows</code>系统来说，默认的用户名是<code>ODBC</code>，你可以通过设置环境变量<code>USER</code>来添加一个默认用户名。</p>
</li>
</ul>
<h2 id="客户端与服务器连接的过程">客户端与服务器连接的过程</h2>
<p>我们现在已经知道如何启动<code>MySQL</code>的服务器程序，以及如何启动客户端程序来连接到这个服务器程序。运行着的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到回复的过程本质上是一个进程间通信的过程！<code>MySQL</code>支持下边三种客户端进程和服务器进程的通信方式。</p>
<h3 id="TCP-IP">TCP/IP</h3>
<p>真实环境中，<strong>数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间必须通过网络来进行通讯</strong>。<code>MySQL</code>采用<code>TCP</code>作为服务器和客户端之间的网络通信协议。在网络环境下，每台计算机都有一个唯一的<code>IP地址</code>，如果某个进程有需要采用<code>TCP</code>协议进行网络通信方面的需求，可以向操作系统申请一个<code>端口号</code>，这是一个整数值，它的取值范围是<code>0~65535</code>。这样在网络中的其他进程就可以通过<code>IP地址 + 端口号</code>的方式来与这个进程连接，这样进程之间就可以通过网络进行通信了。</p>
<p><code>MySQL</code>服务器启动的时候会默认申请<code>3306</code>端口号，之后就在这个端口号上等待客户端进程进行连接，用书面一点的话来说，<code>MySQL</code>服务器会默认监听<code>3306</code>端口。</p>
<blockquote>
<p>小贴士： <code>TCP/IP</code>网络体系结构是现在通用的一种网络体系结构，其中的<code>TCP</code>和<code>IP</code>是体系结构中两个非常重要的网络协议，如果你并不知道协议是什么，或者并不知道网络是什么，那恐怕兄弟你来错地方了，找本计算机网络的书去瞅瞅吧！ 什么？计算机网络的书写的都贼晦涩，看不懂？没关系，等我～</p>
</blockquote>
<p>如果<code>3306</code>端口号已经被别的进程占用了或者我们单纯的想自定义该数据库实例监听的端口号，那我们可以在启动服务器程序的命令行里添加<code>-P</code>参数来明确指定一下端口号，比如这样：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysqld</span> -P<span class="hljs-number">3307</span><br></code></pre></td></tr></table></figure>
<p>这样<code>MySQL</code>服务器在启动时就会去监听我们指定的端口号<code>3307</code>。</p>
<p>如果客户端进程想要使用<code>TCP/IP</code>网络来连接到服务器进程，比如我们在使用<code>mysql</code>来启动客户端程序时，在<code>-h</code>参数后必须跟随<code>IP地址</code>来作为需要连接的服务器进程所在主机的主机名，如果客户端进程和服务器进程在一台计算机中的话，我们可以使用<code>127.0.0.1</code>来代表本机的<code>IP地址</code>。另外，如果服务器进程监听的端口号不是默认的<code>3306</code>，我们也可以在使用<code>mysql</code>启动客户端程序时使用<code>-P</code>参数（大写的<code>P</code>，小写的<code>p</code>是用来指定密码的）来指定需要连接到的端口号。比如我们现在已经在本机启动了服务器进程，监听的端口号为<code>3307</code>，那我们启动客户端程序时可以这样写：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span> -h<span class="hljs-number">127.0.0.1</span> -uroot -P<span class="hljs-number">3307</span> -p<br></code></pre></td></tr></table></figure>
<p>不知大家发现了没有，我们在启动服务器程序的命令<code>mysqld</code>和启动客户端程序的命令<code>mysql</code>后边都可以使用<code>-P</code>参数，关于如何在命令后边指定参数，指定哪些参数我们稍后会详细唠叨的，稍微等等哈～</p>
<h3 id="命名管道和共享内存">命名管道和共享内存</h3>
<p>如果你是一个<code>Windows</code>用户，那么<strong>客户端进程和服务器进程之间可以考虑使用<code>命名管道</code>或<code>共享内存</code>进行通信</strong>。不过启用这些通信方式的时候需要在启动服务器程序和客户端程序时添加一些参数：</p>
<ul>
<li>
<p>使用<code>命名管道</code>来进行进程间通信</p>
<p>需要在启动服务器程序的命令中加上<code>--enable-named-pipe</code>参数，然后在启动客户端程序的命令中加入<code>--pipe</code>或者<code>--protocol=pipe</code>参数。</p>
</li>
<li>
<p>使用<code>共享内存</code>来进行进程间通信</p>
<p>需要在启动服务器程序的命令中加上<code>--shared-memory</code>参数，在成功启动服务器后，<code>共享内存</code>便成为本地客户端程序的默认连接方式，不过我们也可以在启动客户端程序的命令中加入<code>--protocol=memory</code>参数来显式的指定使用共享内存进行通信。</p>
<p>不过需要注意的是，使用<code>共享内存</code>的方式进行通信的服务器进程和客户端进程必须在同一台<code>Windows</code>主机中。</p>
</li>
</ul>
<blockquote>
<p>小贴士： 命名管道和共享内存是Windows操作系统中的两种进程间通信方式，如果你没听过的话也不用纠结，并不妨碍我们介绍MySQL的知识～</p>
</blockquote>
<h3 id="Unix域套接字文件">Unix域套接字文件</h3>
<p>如果我们的<strong>服务器进程和客户端进程都运行在同一台操作系统为类<code>Unix</code>的机器上的话</strong>，我们可以使用<code>Unix域套接字文件</code>来进行进程间通信。如果我们在启动客户端程序的时候指定的主机名为<code>localhost</code>，或者指定了<code>--protocol=socket</code>的启动参数，那服务器程序和客户端程序之间就可以通过<code>Unix</code>域套接字文件来进行通信了。<code>MySQL</code>服务器程序默认监听的<code>Unix</code>域套接字文件路径为<code>/tmp/mysql.sock</code>，客户端程序也默认连接到这个<code>Unix</code>域套接字文件。如果我们想改变这个默认路径，可以在启动服务器程序时指定<code>socket</code>参数，就像这样：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysqld <span class="hljs-comment">--socket=/tmp/a.txt</span><br></code></pre></td></tr></table></figure>
<p>这样服务器启动后便会监听<code>/tmp/a.txt</code>。在服务器改变了默认的<code>UNIX</code>域套接字文件后，如果客户端程序想通过<code>UNIX</code>域套接字文件进行通信的话，也需要显式的指定连接到的<code>UNIX</code>域套接字文件路径，就像这样：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysql -hlocalhost -uroot <span class="hljs-comment">--socket=/tmp/a.txt -p</span><br></code></pre></td></tr></table></figure>
<p>这样该客户端进程和服务器进程就可以通过路径为<code>/tmp/a.txt</code>的<code>Unix</code>域套接字文件进行通信了。</p>
<h2 id="服务器处理客户端请求">服务器处理客户端请求</h2>
<p>其实不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？客户端可以向服务器发送增删改查各类请求，我们这里以比较复杂的查询请求为例来画个图展示一下大致的过程：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167f4c7b99f87e1c~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c8d26fmg1af0ms81cpc7gm8lv39.png-97.9kB">
<p>从图中我们可以看出，服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是<code>连接管理</code>、<code>解析与优化</code>、<code>存储引擎</code>。下边我们来详细看一下这三个部分都干了什么。</p>
<h3 id="连接管理">连接管理</h3>
<p>客户端进程可以采用我们上边介绍的<code>TCP/IP</code>、<code>命名管道或共享内存</code>、<code>Unix域套接字</code>这几种方式之一来与服务器进程建立连接，**每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。**从这一点大家也能看出，<code>MySQL</code>服务器会为每一个连接进来的客户端分配一个线程，但是线程分配的太多了会严重影响系统性能，所以我们也需要限制一下可以同时连接到服务器的客户端数量，至于怎么限制我们后边再说哈～</p>
<p><strong>在客户端程序发起连接的时候，需要携带主机信息、用户名、密码</strong>，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。另外，如果客户端程序和服务器程序不运行在一台计算机上，我们还可以采用使用了<code>SSL</code>（安全套接字）的网络连接进行通信，来保证数据传输的安全性。</p>
<p>当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求，<code>MySQL</code>服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理，预知后事如何，继续往下看哈～</p>
<h3 id="解析与优化">解析与优化</h3>
<p>到现在为止，<code>MySQL</code>服务器已经获得了文本形式的请求，接着 还要经过九九八十一难的处理，其中的几个比较重要的部分分别是<code>查询缓存</code>、<code>语法解析</code>和<code>查询优化</code>，下边我们详细来看。</p>
<h4 id="查询缓存">查询缓存</h4>
<p>如果我问你<code>9+8×16-3×2×17</code>的值是多少，你可能会用计算器去算一下，或者牛逼一点用心算，最终得到了结果<code>35</code>，如果我再问你一遍<code>9+8×16-3×2×17</code>的值是多少，你还用再傻呵呵的算一遍么？我们刚刚已经算过了，直接说答案就好了。<strong><code>MySQL</code>服务器程序处理查询请求的过程也是这样，会把刚刚处理过的查询请求和结果<code>缓存</code>起来</strong>，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。</p>
<p>当然，<code>MySQL</code>服务器并没有人聪明，如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。另外，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数<code>NOW</code>，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！</p>
<p><code>MySQL</code>	缓存失效原因：</p>
<ul>
<li>查询请求不一致</li>
<li>包含某些系统函数或者自定义变量、函数之类的信息。如<code>Now</code>函数等。</li>
</ul>
<p>不过既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、 <code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或 <code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！</p>
<blockquote>
<p>小贴士： 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</p>
</blockquote>
<h4 id="语法解析">语法解析</h4>
<p>如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以<code>MySQL</code>服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到<code>MySQL</code>服务器内部使用的一些数据结构上来。</p>
<blockquote>
<p>小贴士： 这个从指定的文本中提取出我们需要的信息本质上算是一个编译过程，涉及词法解析、语法分析、语义分析等阶段，这些问题不属于我们讨论的范畴，大家只要了解在处理请求的过程中需要这个步骤就好了。</p>
</blockquote>
<h4 id="查询优化">查询优化</h4>
<p>语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的<code>MySQL</code>语句执行起来效率可能并不是很高，<code>MySQL</code>的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接吧啦吧啦的一堆东西。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们可以使用<code>EXPLAIN</code>语句来查看某个语句的执行计划，关于查询优化这部分的详细内容我们后边会仔细唠叨，现在你只需要知道在<code>MySQL</code>服务器程序处理请求的过程中有这么一个步骤就好了。</p>
<h3 id="存储引擎">存储引擎</h3>
<p>截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，<code>MySQL</code>服务器把数据的存储和提取操作都封装到了一个叫<code>存储引擎</code>的模块里。我们知道<code>表</code>是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是<code>存储引擎</code>负责的事情。为了实现不同的功能，<code>MySQL</code>提供了各式各样的<code>存储引擎</code>，不同<code>存储引擎</code>管理的表具体的存储结构可能不同，采用的存取算法也可能不同。</p>
<blockquote>
<p>小贴士： 为什么叫<code>引擎</code>呢？因为这个名字更拉风～ 其实这个存储引擎以前叫做<code>表处理器</code>，后来可能人们觉得太土，就改成了<code>存储引擎</code>的叫法，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</p>
</blockquote>
<p>为了管理方便，人们把<code>连接管理</code>、<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code>这些并不涉及真实数据存储的功能划分为<code>MySQL server</code>的功能，把真实存取数据的功能划分为<code>存储引擎</code>的功能。各种不同的存储引擎向上边的<code>MySQL server</code>层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像&quot;读取索引第一条内容&quot;、“读取索引下一条内容”、&quot;插入记录&quot;等等。</p>
<blockquote>
<p><code>Mysql</code>分为引擎层和server层。</p>
</blockquote>
<p>所以在<code>MySQL server</code>完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p>
<h2 id="常用存储引擎">常用存储引擎</h2>
<p><code>MySQL</code>支持非常多种存储引擎，我这先列举一些：</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ARCHIVE</code></td>
<td>用于数据存档（行被插入后不能再修改）</td>
</tr>
<tr>
<td><code>BLACKHOLE</code></td>
<td>丢弃写操作，读操作会返回空内容</td>
</tr>
<tr>
<td><code>CSV</code></td>
<td>在存储数据时，以逗号分隔各个数据项</td>
</tr>
<tr>
<td><code>FEDERATED</code></td>
<td>用来访问远程表</td>
</tr>
<tr>
<td><code>InnoDB</code></td>
<td>具备外键支持功能的事务存储引擎</td>
</tr>
<tr>
<td><code>MEMORY</code></td>
<td>置于内存的表</td>
</tr>
<tr>
<td><code>MERGE</code></td>
<td>用来管理多个MyISAM表构成的表集合</td>
</tr>
<tr>
<td><code>MyISAM</code></td>
<td>主要的非事务处理存储引擎</td>
</tr>
<tr>
<td><code>NDB</code></td>
<td>MySQL集群专用存储引擎</td>
</tr>
</tbody>
</table>
<p>这么多我们怎么挑啊，哈哈，你多虑了，其实我们最常用的就是<code>InnoDB</code>和<code>MyISAM</code>，有时会提一下<code>Memory</code>。其中<code>InnoDB</code>是<code>MySQL</code>默认的存储引擎，我们之后会详细唠叨这个存储引擎的各种功能，现在先看一下一些存储引擎对于某些功能的支持情况：</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>MyISAM</th>
<th>Memory</th>
<th>InnoDB</th>
<th>Archive</th>
<th>NDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>B-tree indexes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Backup/point-in-time recovery</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Cluster database support</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Clustered indexes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Compressed data</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>Data caches</td>
<td>no</td>
<td>N/A</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Encrypted data</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Foreign key support</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Full-text search indexes</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Geospatial data type support</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Geospatial indexing support</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Hash indexes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Index caches</td>
<td>yes</td>
<td>N/A</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Locking granularity</td>
<td>Table</td>
<td>Table</td>
<td>Row</td>
<td>Row</td>
<td>Row</td>
</tr>
<tr>
<td>MVCC</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Query cache support</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Replication support</td>
<td>yes</td>
<td>Limited</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Storage limits</td>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>None</td>
<td>384EB</td>
</tr>
<tr>
<td>T-tree indexes</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Transactions</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Update statistics for data dictionary</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
<p>密密麻麻列了这么多，看的头皮都发麻了，达到的效果就是告诉你：这玩意儿很复杂。其实这些东西大家没必要立即就给记住，我列出来的目的就是想让大家明白不同的存储引擎支持不同的功能，有些重要的功能我们会在后边的唠叨中慢慢让大家理解的～</p>
<h2 id="关于存储引擎的一些操作">关于存储引擎的一些操作</h2>
<h3 id="查看当前服务器程序支持的存储引擎">查看当前服务器程序支持的存储引擎</h3>
<p>我们可以用下边这个命令来查看当前服务器程序支持的存储引擎：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">SHOW ENGINES<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>来看一下调用效果：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW ENGINES;<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>|<span class="hljs-string"> Engine             </span>|<span class="hljs-string"> Support </span>|<span class="hljs-string"> Comment                                                        </span>|<span class="hljs-string"> Transactions </span>|<span class="hljs-string"> XA   </span>|<span class="hljs-string"> Savepoints </span>|<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>|<span class="hljs-string"> InnoDB             </span>|<span class="hljs-string"> DEFAULT </span>|<span class="hljs-string"> Supports transactions, row-level locking, and foreign keys     </span>|<span class="hljs-string"> YES          </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> YES        </span>|<br>|<span class="hljs-string"> MRG_MYISAM         </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> Collection of identical MyISAM tables                          </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> MEMORY             </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> Hash based, stored in memory, useful for temporary tables      </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> BLACKHOLE          </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> /dev/null storage engine (anything you write to it disappears) </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> MyISAM             </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> MyISAM storage engine                                          </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> CSV                </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> CSV storage engine                                             </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> ARCHIVE            </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> Archive storage engine                                         </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> PERFORMANCE_SCHEMA </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> Performance Schema                                             </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> FEDERATED          </span>|<span class="hljs-string"> NO      </span>|<span class="hljs-string"> Federated MySQL storage engine                                 </span>|<span class="hljs-string"> NULL         </span>|<span class="hljs-string"> NULL </span>|<span class="hljs-string"> NULL       </span>|<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>9 rows in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure>
<p>其中的<code>Support</code>列表示该存储引擎是否可用，<code>DEFAULT</code>值代表是当前服务器程序的默认存储引擎。<code>Comment</code>列是对存储引擎的一个描述，英文的，将就着看吧。<code>Transactions</code>列代表该存储引擎是否支持事务处理。<code>XA</code>列代表着该存储引擎是否支持分布式事务。<code>Savepoints</code>代表着该存储引擎是否支持部分事务回滚。</p>
<blockquote>
<p>小贴士： 好吧，也许你并不知道什么是个事务、更别提分布式事务了，这些内容我们在后边的章节会详细唠叨，现在瞅一眼看个新鲜就得了。</p>
</blockquote>
<h3 id="设置表的存储引擎">设置表的存储引擎</h3>
<p>我们前边说过，存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p>
<h4 id="创建表时指定存储引擎">创建表时指定存储引擎</h4>
<p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎<code>InnoDB</code>（当然这个默认的存储引擎也是可以修改的，我们在后边的章节中再说怎么改）。如果我们想显式的指定一下表的存储引擎，那可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>    建表语句;<br>) ENGINE <span class="hljs-operator">=</span> 存储引擎名称;<br></code></pre></td></tr></table></figure>
<p>比如我们想创建一个存储引擎为<code>MyISAM</code>的表可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> engine_demo_table(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     i <span class="hljs-type">int</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) ENGINE <span class="hljs-operator">=</span> MyISAM;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.02</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="修改表的存储引擎">修改表的存储引擎</h4>
<p>如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 ENGINE <span class="hljs-operator">=</span> 存储引擎名称;<br></code></pre></td></tr></table></figure>
<p>比如我们修改一下<code>engine_demo_table</code>表的存储引擎：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; ALTER TABLE engine_demo_table ENGINE = InnoDB;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">05</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br><span class="hljs-attribute">mysql</span>&gt;<br></code></pre></td></tr></table></figure>
<p>这时我们再查看一下<code>engine_demo_table</code>的表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> engine_demo_table\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>       <span class="hljs-keyword">Table</span>: engine_demo_table<br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">Table</span>: <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `engine_demo_table` (<br>  `i` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure>
<p>可以看到该表的存储引擎已经改为<code>InnoDB</code>了。</p>
<h1>2.启动选项和系统变量</h1>
<p><code>MySQL</code>和所有的软件一样，具有很多功能，诸如是否使用<code>TCP/IP</code>、<code>套接字</code>进行通信，查询缓存，最大连接数，指定端口号，主机地址等功能。</p>
<p>接下来用<code>Mac</code>下的<code>mysqld</code>方式来进行演示。</p>
<h2 id="在命令行上使用选项">在命令行上使用选项</h2>
<p>如果我们在启动客户端程序时在<code>-h</code>参数后边紧跟服务器的IP地址，这就意味着客户端和服务器之间需要通过<code>TCP/IP</code>网络进行通信。因为我的客户端程序和服务器程序都装在一台计算机上，所以在使用客户端程序连接服务器程序时指定的主机名是<code>127.0.0.1</code>的情况下，客户端进程和服务器进程之间会使用<code>TCP/IP</code>网络进行通信。如果我们在启动服务器程序的时候就禁止各客户端使用<code>TCP/IP</code>网络进行通信，可以在启动服务器程序的命令行里添加<code>skip-networking</code>启动选项，就像这样：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mysqld --skip-networking <span class="hljs-regexp">//</span>禁用客户端使用TCP/IP网络进行通信。<br></code></pre></td></tr></table></figure>
<p>可以看到，我们在命令行中指定启动选项时需要在选项名前加上<code>--</code>前缀。另外，如果选项名是由多个单词构成的，它们之间可以由短划线<code>-</code>连接起来，也可以使用下划线<code>_</code>连接起来，也就是说<code>skip-networking</code>和<code>skip_networking</code>表示的含义是相同的。所以上边的写法与下边的写法是等价的：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysqld <span class="hljs-comment">--skip_networking</span><br></code></pre></td></tr></table></figure>
<p>在按照上述命令启动服务器程序后，如果我们再使用<code>mysql</code>来启动客户端程序时，再把服务器主机名指定为<code>127.0.0.1</code>（IP地址的形式）的话会显示连接失败：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit"> mysql -h127.0.0.1 -uroot -p<br>Enter password:<br><br><span class="hljs-keyword">ERROR </span>2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;127.0.0.1&#x27; (61)<br></code></pre></td></tr></table></figure>
<p>这就意味着我们指定的启动选项<code>skip-networking</code>生效了！</p>
<p>再举一个例子，我们前边说过如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用<code>InnoDB</code>作为表的存储引擎。如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">mysqld --<span class="hljs-keyword">default</span>-storage-engine=MyISAM <span class="hljs-comment">//指定默认引擎。</span><br></code></pre></td></tr></table></figure>
<p>我们现在就已经把表的默认存储引擎改为<code>MyISAM</code>了，在客户端程序连接到服务器程序后试着创建一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sys_var_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     i <span class="hljs-type">INT</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.02</span> sec)<br></code></pre></td></tr></table></figure>
<p>这个定义语句中我们并没有明确指定表的存储引擎，创建成功后再看一下这个表的结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sys_var_demo\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>       <span class="hljs-keyword">Table</span>: sys_var_demo<br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">Table</span>: <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `sys_var_demo` (<br>  `i` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>MyISAM <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure>
<p>可以看到该表的存储引擎已经是<code>MyISAM</code>了，说明启动选项<code>default-storage-engine</code>生效了。</p>
<p>所以在启动服务器程序的命令行后边指定启动选项的通用格式就是这样的：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">--<span class="hljs-comment">启动选项1</span><span class="hljs-title">[</span><span class="hljs-comment">=值1</span><span class="hljs-title">]</span> --<span class="hljs-comment">启动选项2</span><span class="hljs-title">[</span><span class="hljs-comment">=值2</span><span class="hljs-title">]</span> <span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span> --<span class="hljs-comment">启动选项n</span><span class="hljs-title">[</span><span class="hljs-comment">=值n</span><span class="hljs-title">]</span><br></code></pre></td></tr></table></figure>
<p>也就是说我们可以将各个启动选项写到一行中，各个启动选项之间使用空白字符隔开，在每一个启动选项名称前边添加<code>--</code>。对于不需要值的启动选项，比方说<code>skip-networking</code>，它们就不需要指定对应的值。对于需要指定值的启动选项，比如<code>default-storage-engine</code>我们在指定这个设置项的时候需要显式的指定它的值，比方说<code>InnoDB</code>、<code>MyISAM</code>啦什么的～ 在命令行上指定有值的启动选项时需要注意，选项名、=、选项值之间不可以有空白字符，比如写成下边这样就是不正确的：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">mysqld --<span class="hljs-keyword">default</span>-storage-engine = MyISAM<br></code></pre></td></tr></table></figure>
<p>每个MySQL程序都有许多不同的选项。大多数程序提供了一个–help选项，你可以查看该程序支持的全部启动选项以及它们的默认值。例如，使用<code>mysql --help</code>可以看到<code>mysql</code>程序支持的启动选项，<code>mysqld_safe --help</code>可以看到<code>mysqld_safe</code>程序支持的启动选项。查看<code>mysqld</code>支持的启动选项有些特别，需要使用<code>mysqld --verbose --help</code>。</p>
<h3 id="选项的长形式和短形式">选项的长形式和短形式</h3>
<p>我们前边提到的<code>skip-networking</code>、<code>default-storage-engine</code>称之为长形式的选项（因为它们很长），设计<code>MySQL</code>的大叔为了我们使用的方便，对于一些常用的选项提供了短形式，我们列举一些具有短形式的启动选项来瞅瞅（<code>MySQL</code>支持的短形式选项太多了，全列出来会刷屏的）：</p>
<table>
<thead>
<tr>
<th>长形式</th>
<th>短形式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--host</code></td>
<td><code>-h</code></td>
<td>主机名</td>
</tr>
<tr>
<td><code>--user</code></td>
<td><code>-u</code></td>
<td>用户名</td>
</tr>
<tr>
<td><code>--password</code></td>
<td><code>-p</code></td>
<td>密码</td>
</tr>
<tr>
<td><code>--port</code></td>
<td><code>-P</code></td>
<td>端口</td>
</tr>
<tr>
<td><code>--version</code></td>
<td><code>-V</code></td>
<td>版本信息</td>
</tr>
</tbody>
</table>
<p>短形式的选项名只有一个字母，与使用长形式选项时需要在选项名前加两个短划线<code>--</code>不同的是，使用短形式选项时在选项名前只加一个短划线<code>-</code>前缀。有一些短形式的选项我们之前已经接触过了，比方说我们在启动服务器程序时指定监听的端口号：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysqld</span> -P<span class="hljs-number">3307</span><br></code></pre></td></tr></table></figure>
<p>使用短形式指定启动选项时，选项名和选项值之间可以没有间隙，或者用空白字符隔开（<code>-p</code>选项有些特殊，<code>-p</code>和密码值之间不能有空白字符），也就是说上边的命令形式和下边的是等价的：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysqld</span> -P <span class="hljs-number">3307</span><br></code></pre></td></tr></table></figure>
<p>另外，选项名是区分大小写的，比如<code>-p</code>和<code>-P</code>选项拥有完全不同的含义，大家需要注意一下。</p>
<h2 id="配置文件中使用选项">配置文件中使用选项</h2>
<p>在命令行中设置启动选项只对当次启动生效，也就是说如果下一次重启程序的时候我们还想保留这些启动选项的话，还得重复把这些选项写到启动命令行中，这样真的神烦唉！于是设计<code>MySQL</code>的大叔们提出一种<code>配置文件</code>（也称为<code>选项文件</code>）的概念，我们把需要设置的启动选项都写在这个配置文件中，每次启动服务器的时候都从这个文件里加载相应的启动选项。由于这个配置文件可以长久的保存在计算机的硬盘里，所以只需我们配置一次，以后就都不用显式的把启动选项都写在启动命令行中了，所以我们推荐使用配置文件的方式来设置启动选项。</p>
<h3 id="配置文件的路径">配置文件的路径</h3>
<p><code>MySQL</code>程序在启动时会寻找多个路径下的配置文件，这些路径有的是固定的，有的是可以在命令行指定的。根据操作系统的不同，配置文件的路径也有所不同，我们分开看一下。</p>
<h4 id="Windows操作系统的配置文件">Windows操作系统的配置文件</h4>
<p>在<code>Windows</code>操作系统中，<code>MySQL</code>会按照下列路径来寻找配置文件：</p>
<table>
<thead>
<tr>
<th>路径名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%WINDIR%\my.ini</code>， <code>%WINDIR%\my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>C:\my.ini</code>， <code>C:\my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>BASEDIR\my.ini</code>， <code>BASEDIR\my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>defaults-extra-file</code></td>
<td>命令行指定的额外配置文件路径</td>
</tr>
<tr>
<td><code>%APPDATA%\MySQL\.mylogin.cnf</code></td>
<td>登录路径选项（仅限客户端）</td>
</tr>
</tbody>
</table>
<p>在阅读这些<code>Windows</code>操作系统下配置文件路径的时候需要注意一些事情：</p>
<ul>
<li>
<p>在给定的前三个路径中，配置文件可以使用<code>.ini</code>的扩展名，也可以使用<code>.cnf</code>的扩展名。</p>
</li>
<li>
<p><code>%WINDIR%</code>指的是你机器上<code>Windows</code>目录的位置，通常是<code>C:\WINDOWS</code>，如果你不确定，可以使用这个命令来查看：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">echo</span> <span class="hljs-variable">%WINDIR%</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>BASEDIR</code>指的是<code>MySQL</code>安装目录的路径，在我的<code>Windows</code>机器上的<code>BASEDIR</code>的值是：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\M</span>ySQL<span class="hljs-symbol">\M</span>ySQL Server 5.7<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>第四个路径指的是我们在启动程序时可以通过指定<code>defaults-extra-file</code>参数的值来添加额外的配置文件路径，比方说我们在命令行上可以这么写：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">mysqld --defaults-extra-file=C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\x</span>iaohaizi<span class="hljs-symbol">\m</span>y_extra_file.txt<br></code></pre></td></tr></table></figure>
<p>这样<code>MySQL</code>服务器启动时就可以额外在<code>C:\Users\xiaohaizi\my_extra_file.txt</code>这个路径下查找配置文件。</p>
</li>
<li>
<p><code>%APPDATA%</code>表示<code>Windows</code>应用程序数据目录的值，可以使用下列命令查看：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">echo</span> <span class="hljs-variable">%APPDATA%</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>列表中最后一个名为<code>.mylogin.cnf</code>配置文件有点儿特殊，它不是一个纯文本文件（其他的配置文件都是纯文本文件），而是使用<code>mysql_config_editor</code>实用程序创建的加密文件。文件中只能包含一些用于启动客户端软件时连接服务器的一些选项，包括 <code>host</code>、<code>user</code>、<code>password</code>、<code>port</code>和 <code>socket</code>。而且它只能被客户端程序所使用。</p>
</li>
</ul>
<blockquote>
<p>小贴士： mysql_config_editor实用程序其实是MySQL安装目录下的bin目录下的一个可执行文件，这个实用程序有专用的语法来生成或修改 .mylogin.cnf 文件中的内容，如何使用这个程序不是我们讨论的主题，可以到MySQL的官方文档中查看。</p>
</blockquote>
<h4 id="类Unix操作系统中的配置文件">类Unix操作系统中的配置文件</h4>
<p>在类<code>UNIX</code>操作系统中，<code>MySQL</code>会按照下列路径来寻找配置文件：</p>
<table>
<thead>
<tr>
<th>路径名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/etc/my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>/etc/mysql/my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>SYSCONFDIR/my.cnf</code></td>
<td></td>
</tr>
<tr>
<td><code>$MYSQL_HOME/my.cnf</code></td>
<td>特定于服务器的选项（仅限服务器）</td>
</tr>
<tr>
<td><code>defaults-extra-file</code></td>
<td>命令行指定的额外配置文件路径</td>
</tr>
<tr>
<td><code>~/.my.cnf</code></td>
<td>用户特定选项</td>
</tr>
<tr>
<td><code>~/.mylogin.cnf</code></td>
<td>用户特定的登录路径选项（仅限客户端）</td>
</tr>
</tbody>
</table>
<p>在阅读这些<code>UNIX</code>操作系统下配置文件路径的时候需要注意一些事情：</p>
<ul>
<li>
<p><code>SYSCONFDIR</code>表示在使用<code>CMake</code>构建<code>MySQL</code>时使用<code>SYSCONFDIR</code>选项指定的目录。默认情况下，这是位于编译安装目录下的<code>etc</code>目录。</p>
<blockquote>
<p>小贴士： 如果你不懂啥是个CMAKE，啥是个编译，那就跳过吧，对我们后续的文章没啥影响。</p>
</blockquote>
</li>
<li>
<p><code>MYSQL_HOME</code>是一个环境变量，该变量的值是我们自己设置的，我们想设置就设置，不想设置就不设置。该变量的值代表一个路径，我们可以在该路径下创建一个<code>my.cnf</code>配置文件，那么这个配置文件中只能放置关于启动服务器程序相关的选项（言外之意就是其他的配置文件既能存放服务器相关的选项也能存放客户端相关的选项，<code>.mylogin.cnf</code>除外，它只能存放客户端相关的一些选项）。</p>
<blockquote>
<p>小贴士： 如果大家使用mysqld_safe启动服务器程序，而且我们也没有主动设置这个MySQL_HOME环境变量的值，那这个环境变量的值将自动被设置为MySQL的安装目录，也就是MySQL服务器将会在安装目录下查找名为my.cnf配置文件（别忘了mysql.server会调用mysqld_safe，所以使用mysql.server启动服务器时也会在安装目录下查找配置文件）。</p>
</blockquote>
</li>
<li>
<p>列表中的最后两个以<code>~</code>开头的路径是用户相关的，类<code>UNIX</code> 系统中都有一个当前登陆用户的概念，每个用户都可以有一个用户目录，<code>~</code>就代表这个用户目录，大家可以查看<code>HOME</code>环境变量的值来确定一下当前用户的用户目录，比方说我的<code>macOS</code>机器上的用户目录就是<code>/Users/xiaohaizi</code>。之所以说列表中最后两个配置文件是用户相关的，是因为不同的类<code>UNIX</code>系统的用户都可以在自己的用户目录下创建<code>.my.cnf</code>或者<code>.mylogin.cnf</code>，换句话说，不同登录用户使用的<code>.my.cnf</code>或者<code>.mylogin.cnf</code>配置文件是不同的。</p>
</li>
<li>
<p><code>defaults-extra-file</code>的含义与Windows中的一样。</p>
</li>
<li>
<p><code>.mylogin.cnf</code>的含义也同<code>Windows</code>中的一样，再次强调一遍，它不是纯文本文件，只能使用<code>mysql_config_editor</code>实用程序去创建或修改，用于存放客户端登陆服务器时的相关选项。</p>
</li>
</ul>
<p>这也就是说，在我的计算机中这几个路径中的任意一个都可以当作配置文件来使用，如果它们不存在，你可以手动创建一个，比方说我手动在<code>~/.my.cnf</code>这个路径下创建一个配置文件。</p>
<p>另外，我们在唠叨如何启动<code>MySQL</code>服务器程序的时候说过，使用<code>mysqld_safe</code>程序启动服务器时，会间接调用<code>mysqld</code>，所以对于传递给<code>mysqld_safe</code>的启动选项来说，如果<code>mysqld_safe</code>程序不处理，会接着传递给<code>mysqld</code>程序处理。比方说<code>skip-networking</code>选项是由<code>mysqld</code>处理的，<code>mysqld_safe</code>并不处理，但是如果我们我们在命令行上这样执行：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysqld_safe <span class="hljs-comment">--skip-networking</span><br></code></pre></td></tr></table></figure>
<p>则在<code>mysqld_safe</code>调用<code>mysqld</code>时，会把它处理不了的这个<code>skip-networking</code>选项交给<code>mysqld</code>处理。</p>
<h4 id="配置文件的内容">配置文件的内容</h4>
<p>与在命令行中指定启动选项不同的是，配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号<code>[]</code>扩起来，像这样：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs clojure">[server]<br>(具体的启动选项...)<br><br>[mysqld]<br>(具体的启动选项...)<br><br>[mysqld_safe]<br>(具体的启动选项...)<br><br>[client]<br>(具体的启动选项...)<br><br>[mysql]<br>(具体的启动选项...)<br><br>[mysqladmin]<br>(具体的启动选项...)<br></code></pre></td></tr></table></figure>
<p>像这个配置文件里就定义了许多个组，组名分别是<code>server</code>、<code>mysqld</code>、<code>mysqld_safe</code>、<code>client</code>、<code>mysql</code>、<code>mysqladmin</code>。每个组下边可以定义若干个启动选项，我们以<code>[server]</code>组为例来看一下填写启动选项的形式（其他组中启动选项的形式是一样的）：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">[server]<br>optio<span class="hljs-symbol">n1</span>     <span class="hljs-attr">#这是option1</span>，该选项不需要选项值<br>optio<span class="hljs-symbol">n2</span> = value<span class="hljs-number">2</span>      <span class="hljs-attr">#这是option2</span>，该选项需要选项值<br>...<br></code></pre></td></tr></table></figure>
<p>在配置文件中指定启动选项的语法类似于命令行语法，但是<strong>配置文件中只能使用长形式的选项。在配置文件中指定的启动选项不允许加<code>--</code>前缀，并且每行只指定一个选项，而且<code>=</code>周围可以有空白字符</strong>（命令行中选项名、<code>=</code>、选项值之间不允许有空白字符）。另外，在配置文件中，我们可以使用<code>#</code>来添加注释，从<code>#</code>出现直到行尾的内容都属于注释内容，读取配置文件时会忽略这些注释内容。为了大家更容易对比启动选项在命令行和配置文件中指定的区别，我们再把命令行中指定<code>option1</code>和<code>option2</code>两个选项的格式写一遍看看：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">--<span class="hljs-comment">option1</span> --<span class="hljs-comment">option2=value2</span><br></code></pre></td></tr></table></figure>
<p>配置文件中不同的选项组是给不同的启动命令使用的，如果选项组名称与程序名称相同，则组中的选项将专门应用于该程序。例如， <code>[mysqld]</code>和<code>[mysql]</code>组分别应用于<code>mysqld</code>服务器程序和<code>mysql</code>客户端程序。不过有两个选项组比较特别：</p>
<ul>
<li><code>[server]</code>组下边的启动选项将作用于所有的服务器程序。</li>
<li><code>[client]</code>组下边的启动选项将作用于所有的客户端程序。</li>
</ul>
<p>需要注意的一点是，<code>mysqld_safe</code>和<code>mysql.server</code>这两个程序在启动时都会读取<code>[mysqld]</code>选项组中的内容。为了直观感受一下，我们挑一些启动命令来看一下它们能读取的选项组都有哪些：</p>
<table>
<thead>
<tr>
<th>启动命令</th>
<th>类别</th>
<th>能读取的组</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mysqld</code></td>
<td>启动服务器</td>
<td><code>[mysqld]</code>、<code>[server]</code></td>
</tr>
<tr>
<td><code>mysqld_safe</code></td>
<td>启动服务器</td>
<td><code>[mysqld]</code>、<code>[server]</code>、<code>[mysqld_safe]</code></td>
</tr>
<tr>
<td><code>mysql.server</code></td>
<td>启动服务器</td>
<td><code>[mysqld]</code>、<code>[server]</code>、<code>[mysql.server]</code></td>
</tr>
<tr>
<td><code>mysql</code></td>
<td>启动客户端</td>
<td><code>[mysql]</code>、<code>[client]</code></td>
</tr>
<tr>
<td><code>mysqladmin</code></td>
<td>启动客户端</td>
<td><code>[mysqladmin]</code>、<code>[client]</code></td>
</tr>
<tr>
<td><code>mysqldump</code></td>
<td>启动客户端</td>
<td><code>[mysqldump]</code>、<code>[client]</code></td>
</tr>
</tbody>
</table>
<p>现在我们以<code>macOS</code>操作系统为例，在<code>/etc/mysql/my.cnf</code>这个配置文件中添加一些内容（<code>Windows</code>系统参考上边提到的配置文件路径）：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">server</span>]<br>skip-networking<br><span class="hljs-keyword">default</span>-<span class="hljs-keyword">storage</span>-engine=MyISAM<br></code></pre></td></tr></table></figure>
<p>然后直接用<code>mysqld</code>启动服务器程序：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mysqld</span><br></code></pre></td></tr></table></figure>
<p>虽然在命令行没有添加启动选项，但是在程序启动的时候，就会默认的到我们上边提到的配置文件路径下查找配置文件，其中就包括<code>/etc/mysql/my.cnf</code>。又由于<code>mysqld</code>命令可以读取<code>[server]</code>选项组的内容，所以<code>skip-networking</code>和<code>default-storage-engine=MyISAM</code>这两个选项是生效的。你可以把这些启动选项放在<code>[client]</code>组里再试试用<code>mysqld</code>启动服务器程序，看一下里边的启动选项生效不（剧透一下，不生效）。</p>
<blockquote>
<p>小贴士： 如果我们想指定mysql.server程序的启动参数，则必须将它们放在配置文件中，而不是放在命令行中。mysql.server仅支持start和stop作为命令行参数。</p>
</blockquote>
<h4 id="特定MySQL版本的专用选项组">特定MySQL版本的专用选项组</h4>
<p>我们可以在选项组的名称后加上特定的<code>MySQL</code>版本号，比如对于<code>[mysqld]</code>选项组来说，我们可以定义一个<code>[mysqld-5.7]</code>的选项组，它的含义和<code>[mysqld]</code>一样，只不过只有版本号为<code>5.7</code>的<code>mysqld</code>程序才能使用这个选项组中的选项。</p>
<h4 id="配置文件的优先级">配置文件的优先级</h4>
<p>我们前边唠叨过<code>MySQL</code>将在某些固定的路径下搜索配置文件，我们也可以通过在命令行上指定<code>defaults-extra-file</code>启动选项来指定额外的配置文件路径。<code>MySQL</code>将按照我们在上表中给定的顺序依次读取各个配置文件，如果该文件不存在则忽略。**值得注意的是，如果我们在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准。**比方说<code>/etc/my.cnf</code>文件的内容是这样的：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">default-storage-engine</span>=InnoDB<br></code></pre></td></tr></table></figure>
<p>而<code>~/.my.cnf</code>文件中的内容是这样的：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">default-storage-engine</span>=MyISAM<br></code></pre></td></tr></table></figure>
<p>又因为<code>~/.my.cnf</code>比<code>/etc/my.cnf</code>顺序靠后，所以如果两个配置文件中出现相同的启动选项，以<code>~/.my.cnf</code>中的为准，所以<code>MySQL</code>服务器程序启动之后，<code>default-storage-engine</code>的值就是<code>MyISAM</code>。</p>
<h4 id="同一个配置文件中多个组的优先级">同一个配置文件中多个组的优先级</h4>
<p>我们说同一个命令可以访问配置文件中的多个组，比如<code>mysqld</code>可以访问<code>[mysqld]</code>、<code>[server]</code>组，如果在同一个配置文件中，比如<code>~/.my.cnf</code>，在这些组里出现了同样的配置项，比如这样：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">default-storage-engine</span>=InnoDB<br><br><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">default-storage-engine</span>=MyISAM<br></code></pre></td></tr></table></figure>
<p>那么，将以最后一个出现的组中的启动选项为准，比方说例子中<code>default-storage-engine</code>既出现在<code>[mysqld]</code>组也出现在<code>[server]</code>组，因为<code>[mysqld]</code>组在<code>[server]</code>组后边，就以<code>[mysqld]</code>组中的配置项为准。</p>
<h4 id="defaults-file的使用">defaults-file的使用</h4>
<p>如果我们不想让<code>MySQL</code>到默认的路径下搜索配置文件（就是上表中列出的那些），可以在命令行指定<code>defaults-file</code>选项，比如这样（以<code>UNIX</code>系统为例）：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mysqld --defaults-<span class="hljs-keyword">file</span>=<span class="hljs-regexp">/tmp/my</span>config.txt<br></code></pre></td></tr></table></figure>
<p>这样，在程序启动的时候将只在<code>/tmp/myconfig.txt</code>路径下搜索配置文件。如果文件不存在或无法访问，则会发生错误。</p>
<blockquote>
<p>小贴士： 注意<code>defaults-extra-file</code>和<code>defaults-file</code>的区别，使用<code>defaults-extra-file</code>可以指定额外的配置文件搜索路径（也就是说那些固定的配置文件路径也会被搜索）。</p>
</blockquote>
<h4 id="命令行和配置文件中启动选项的区别">命令行和配置文件中启动选项的区别</h4>
<p>在命令行上指定的绝大部分启动选项都可以放到配置文件中，但是有一些选项是专门为命令行设计的，比方说<code>defaults-extra-file</code>、<code>defaults-file</code>这样的选项本身就是为了指定配置文件路径的，再放在配置文件中使用就没啥意义了。剩下的一些只能用在命令行上而不能用到配置文件中的启动选项就不一一列举了，用到的时候再提哈（本书中基本用不到，有兴趣的到官方文档看哈）。</p>
<p>另外有一点需要特别注意，如果同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准！比如我们在配置文件中写了：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">default-storage-engine</span>=InnoDB<br></code></pre></td></tr></table></figure>
<p>而我们的启动命令是：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql.<span class="hljs-keyword">server</span> <span class="hljs-keyword">start</span> <span class="hljs-comment">--default-storage-engine=MyISAM</span><br></code></pre></td></tr></table></figure>
<p>那最后<code>default-storage-engine</code>的值就是<code>MyISAM</code>！</p>
<h2 id="系统变量">系统变量</h2>
<h3 id="系统变量简介">系统变量简介</h3>
<p><code>MySQL</code>服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为<code>MySQL</code>系统变量，比如允许同时连入的客户端数量用系统变量<code>max_connections</code>表示，表的默认存储引擎用系统变量<code>default_storage_engine</code>表示，查询缓存的大小用系统变量<code>query_cache_size</code>表示，<code>MySQL</code>服务器程序的系统变量有好几百条，我们就不一一列举了。每个系统变量都有一个默认值，我们可以使用命令行或者配置文件中的选项在启动服务器时改变一些系统变量的值。大多数的系统变量的值也可以在程序运行过程中修改，而无需停止并重新启动它。</p>
<h3 id="查看系统变量">查看系统变量</h3>
<p>我们可以使用下列命令查看<code>MySQL</code>服务器程序支持的系统变量以及它们的当前值：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> [LIKE 匹配的模式<span class="hljs-comment">]</span>;<br></code></pre></td></tr></table></figure>
<p>由于<code>系统变量</code>实在太多了，如果我们直接使用<code>SHOW VARIABLES</code>查看的话就直接刷屏了，所以通常都会带一个<code>LIKE</code>过滤条件来查看我们需要的系统变量的值，比方说这么写：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | InnoDB |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.01 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES like &#x27;max_connections&#x27;;</span><br><span class="hljs-section">+-----------------+-------+</span><br><span class="hljs-section">| Variable_name   | Value |</span><br><span class="hljs-section">+-----------------+-------+</span><br><span class="hljs-section">| max_connections | 151   |</span><br><span class="hljs-section">+-----------------+-------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>可以看到，现在服务器程序使用的默认存储引擎就是<code>InnoDB</code>，允许同时连接的客户端数量最多为<code>151</code>。别忘了<code>LIKE</code>表达式后边可以跟通配符来进行模糊查询，也就是说我们可以这么写：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;default%&#x27;;</span><br><span class="hljs-section">+-------------------------------+-----------------------+</span><br><span class="hljs-section">| Variable_name                 | Value                 |</span><br><span class="hljs-section">+-------------------------------+-----------------------+</span><br>| default<span class="hljs-emphasis">_authentication_plugin | mysql_native_password |</span><br><span class="hljs-emphasis">| default_password_lifetime     | 0                     |</span><br><span class="hljs-emphasis">| default_storage_engine        | InnoDB                |</span><br><span class="hljs-emphasis">| default_tmp_storage_engine    | InnoDB                |</span><br><span class="hljs-emphasis">| default_week_</span>format           | 0                     |<br><span class="hljs-code">+-------------------------------+</span>-----------------------+<br>5 rows in set (0.01 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure>
<p>这样就查出了所有以<code>default</code>开头的系统变量的值。</p>
<h3 id="设置系统变量">设置系统变量</h3>
<h4 id="通过启动选项设置">通过启动选项设置</h4>
<p>大部分的<code>系统变量</code>都可以通过启动服务器时传送启动选项的方式来进行设置。如何填写启动选项我们上边已经花了大篇幅来唠叨了，就是下边两种方式：</p>
<ul>
<li>
<p>通过命令行添加启动选项。</p>
<p>比方说我们在启动服务器程序时用这个命令：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysqld <span class="hljs-attribute">--default-storage-engine</span>=MyISAM <span class="hljs-attribute">--max-connections</span>=10<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>通过配置文件添加启动选项。</p>
<p>我们可以这样填写配置文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">default-storage-engine</span>=MyISAM<br><span class="hljs-attr">max-connections</span>=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>当使用上边两种方式中的任意一种启动服务器程序后，我们再来查看一下系统变量的值：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | MyISAM |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;max_connections&#x27;;</span><br><span class="hljs-section">+-----------------+-------+</span><br><span class="hljs-section">| Variable_name   | Value |</span><br><span class="hljs-section">+-----------------+-------+</span><br><span class="hljs-section">| max_connections | 10    |</span><br><span class="hljs-section">+-----------------+-------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure>
<p>可以看到<code>default_storage_engine</code>和<code>max_connections</code>这两个系统变量的值已经被修改了。有一点需要注意的是，<strong>对于启动选项来说，如果启动选项名由多个单词组成，各个单词之间用短划线<code>-</code>或者下划线<code>_</code>连接起来都可以，但是它对应的系统变量的单词之间必须使用下划线<code>_</code>连接起来。</strong></p>
<h4 id="服务器程序运行过程中设置">服务器程序运行过程中设置</h4>
<p><code>系统变量</code>比较牛逼的一点就是，对于大部分系统变量来说，它们的值可以在服务器程序运行过程中进行动态修改而无需停止并重启服务器。不过系统变量有作用范围之分，下边详细唠叨下。</p>
<h5 id="设置不同作用范围的系统变量">设置不同作用范围的系统变量</h5>
<p>我们前边说过，多个客户端程序可以同时连接到一个服务器程序。对于同一个系统变量，我们有时想让不同的客户端有不同的值。比方说狗哥使用客户端A，他想让当前客户端对应的默认存储引擎为<code>InnoDB</code>，所以他可以把系统变量<code>default_storage_engine</code>的值设置为<code>InnoDB</code>；猫爷使用客户端B，他想让当前客户端对应的默认存储引擎为<code>MyISAM</code>，所以他可以把系统变量<code>default_storage_engine</code>的值设置为<code>MyISAM</code>。这样可以使狗哥和猫爷的的客户端拥有不同的默认存储引擎，使用时互不影响，十分方便。但是这样各个客户端都私有一份系统变量会产生这么两个问题：</p>
<ul>
<li>有一些系统变量并不是针对单个客户端的，比如允许同时连接到服务器的客户端数量<code>max_connections</code>，查询缓存的大小<code>query_cache_size</code>，这些公有的系统变量让某个客户端私有显然不合适。</li>
<li>一个新连接到服务器的客户端对应的系统变量的值该怎么设置？</li>
</ul>
<p>为了解决这两个问题，设计<code>MySQL</code>的大叔提出了系统变量的<code>作用范围</code>的概念，具体来说<code>作用范围</code>分为这两种：</p>
<ul>
<li><code>GLOBAL</code>：全局变量，影响服务器的整体操作。</li>
<li><code>SESSION</code>：会话变量，影响某个客户端连接的操作。（注：<code>SESSION</code>有个别名叫<code>LOCAL</code>）</li>
</ul>
<p>在服务器启动时，会将每个全局变量初始化为其默认值（可以通过命令行或选项文件中指定的选项更改这些默认值）。然后服务器还为每个连接的客户端维护一组会话变量，客户端的会话变量在连接时使用相应全局变量的当前值初始化。</p>
<p>这话有点儿绕，还是以<code>default_storage_engine</code>举例，在服务器启动时会初始化一个名为<code>default_storage_engine</code>，作用范围为<code>GLOBAL</code>的系统变量。之后每当有一个客户端连接到该服务器时，服务器都会单独为该客户端分配一个名为<code>default_storage_engine</code>，作用范围为<code>SESSION</code>的系统变量，该作用范围为<code>SESSION</code>的系统变量值按照当前作用范围为<code>GLOBAL</code>的同名系统变量值进行初始化。</p>
<p>很显然，通过启动选项设置的系统变量的作用范围都是<code>GLOBAL</code>的，也就是对所有客户端都有效的，因为在系统启动的时候还没有客户端程序连接进来呢。了解了系统变量的<code>GLOBAL</code>和<code>SESSION</code>作用范围之后，我们再看一下在服务器程序运行期间通过客户端程序设置系统变量的语法：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> [<span class="hljs-keyword">GLOBAL</span>|<span class="hljs-keyword">SESSION</span>] 系统变量名 = 值;<br></code></pre></td></tr></table></figure>
<p>或者写成这样也行：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> [@@(<span class="hljs-keyword">GLOBAL</span>|<span class="hljs-keyword">SESSION</span>).]var_name = XXX;<br></code></pre></td></tr></table></figure>
<p>比如我们想在服务器运行过程中把作用范围为<code>GLOBAL</code>的系统变量<code>default_storage_engine</code>的值修改为<code>MyISAM</code>，也就是想让之后新连接到服务器的客户端都用<code>MyISAM</code>作为默认的存储引擎，那我们可以选择下边两条语句中的任意一条来进行设置：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">语句一：<span class="hljs-keyword">SET</span> GLOBAL <span class="hljs-comment">default_storage_engine = MyISAM</span>;<br>语句二：<span class="hljs-keyword">SET</span> @@GLOBAL.default_storage_engine <span class="hljs-comment">= MyISAM</span>;<br></code></pre></td></tr></table></figure>
<p>如果只想对本客户端生效，也可以选择下边三条语句中的任意一条来进行设置：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">语句一：<span class="hljs-keyword">SET</span> SESSION <span class="hljs-comment">default_storage_engine = MyISAM</span>;<br>语句二：<span class="hljs-keyword">SET</span> @@SESSION.default_storage_engine <span class="hljs-comment">= MyISAM</span>;<br>语句三：<span class="hljs-keyword">SET</span> default_storage_engine <span class="hljs-comment">= MyISAM</span>;<br></code></pre></td></tr></table></figure>
<p>从上边的<code>语句三</code>也可以看出，如果在设置系统变量的语句中省略了作用范围，默认的作用范围就是<code>SESSION</code>。也就是说<code>SET 系统变量名 = 值</code>和<code>SET SESSION 系统变量名 = 值</code>是等价的。</p>
<h5 id="查看不同作用范围的系统变量">查看不同作用范围的系统变量</h5>
<p><code>系统变量</code>有<code>作用范围</code>之分，<code>SHOW VARIABLES</code>默认查看的是<code>SESSION</code>作用范围的系统变量。</p>
<p>当然我们也可以在查看系统变量的语句上加上要查看哪个<code>作用范围</code>的系统变量，就像这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> [<span class="hljs-keyword">GLOBAL</span>|<span class="hljs-keyword">SESSION</span>] VARIABLES [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br></code></pre></td></tr></table></figure>
<p>下边我们演示一下完整的设置并查看系统变量的过程：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW SESSION VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | InnoDB |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW GLOBAL VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | InnoDB |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt; SET SESSION default_storage_engine = MyISAM;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW SESSION VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | MyISAM |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW GLOBAL VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | InnoDB |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure>
<p>可以看到，最初<code>default_storage_engine</code>的系统变量无论是在<code>GLOBAL</code>作用范围上还是在<code>SESSION</code>作用范围上的值都是<code>InnoDB</code>，我们在<code>SESSION</code>作用范围把它的值设置为<code>MyISAM</code>之后，可以看到<code>GLOBAL</code>作用范围的值并没有改变。</p>
<blockquote>
<p>小贴士： 如果某个客户端改变了某个系统变量在<code>GLOBAL</code>作用范围的值，并不会影响该系统变量在当前已经连接的客户端作用范围为<code>SESSION</code>的值，只会影响后续连入的客户端在作用范围为<code>SESSION</code>的值。</p>
</blockquote>
<h5 id="注意事项">注意事项</h5>
<ul>
<li>并不是所有系统变量都具有<code>GLOBAL</code>和<code>SESSION</code>的作用范围。
<ul>
<li>有一些系统变量只具有<code>GLOBAL</code>作用范围，比方说<code>max_connections</code>，表示服务器程序支持同时最多有多少个客户端程序进行连接。</li>
<li>有一些系统变量只具有<code>SESSION</code>作用范围，比如<code>insert_id</code>，表示在对某个包含<code>AUTO_INCREMENT</code>列的表进行插入时，该列初始的值。</li>
<li>有一些系统变量的值既具有<code>GLOBAL</code>作用范围，也具有<code>SESSION</code>作用范围，比如我们前边用到的<code>default_storage_engine</code>，而且其实大部分的系统变量都是这样的，</li>
</ul>
</li>
<li>有些系统变量是只读的，并不能设置值。</li>
</ul>
<h4 id="启动选项和系统变量的区别">启动选项和系统变量的区别</h4>
<p><code>启动选项</code>是在程序启动时我们程序员传递的一些参数，而<code>系统变量</code>是影响服务器程序运行行为的变量，它们之间的关系如下：</p>
<ul>
<li>大部分的系统变量都可以被当作启动选项传入。</li>
<li>有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置，比如<code>auto_increment_offset</code>、<code>character_set_client</code>啥的。</li>
<li>有些启动选项也不是系统变量，比如<code>defaults-file</code>。</li>
</ul>
<h3 id="状态变量">状态变量</h3>
<p>为了让我们更好的了解服务器程序的运行情况，<code>MySQL</code>服务器程序中维护了好多关于程序运行状态的变量，它们被称为<code>状态变量</code>。比方说<code>Threads_connected</code>表示当前有多少客户端与服务器建立了连接，<code>Handler_update</code>表示已经更新了多少行记录吧啦吧啦，像这样显示服务器程序状态信息的<code>状态变量</code>还有好几百个，我们就不一一唠叨了，等遇到了会详细说它们的作用的。</p>
<p>由于<code>状态变量</code>是用来显示服务器程序运行状况的，所以它们的值只能由服务器程序自己来设置，我们程序员是不能设置的。与<code>系统变量</code>类似，<code>状态变量</code>也有<code>GLOBAL</code>和<code>SESSION</code>两个作用范围的，所以查看<code>状态变量</code>的语句可以这么写：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> [<span class="hljs-keyword">GLOBAL</span>|<span class="hljs-keyword">SESSION</span>] STATUS [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br></code></pre></td></tr></table></figure>
<p>类似的，如果我们不写明作用范围，默认的作用范围是<code>SESSION</code>，比方说这样：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW STATUS LIKE &#x27;thread%&#x27;;</span><br><span class="hljs-section">+-------------------+-------+</span><br><span class="hljs-section">| Variable_name     | Value |</span><br><span class="hljs-section">+-------------------+-------+</span><br>| Threads<span class="hljs-emphasis">_cached    | 0     |</span><br><span class="hljs-emphasis">| Threads_connected | 1     |</span><br><span class="hljs-emphasis">| Threads_created   | 1     |</span><br><span class="hljs-emphasis">| Threads_</span>running   | 1     |<br><span class="hljs-code">+-------------------+</span>-------+<br>4 rows in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure>
<p>所有以<code>Thread</code>开头的<code>SESSION</code>作用范围的状态变量就都被展示出来了。</p>
<p>比方说<code>version</code>，表示当前<code>MySQL</code>的版本，我们客户端是不能设置它的值的，只能在<code>SHOW VARIABLES</code>语句里查看。</p>
<h1>3.字符集和比较规则</h1>
<h2 id="字符集和比较规则简介">字符集和比较规则简介</h2>
<h3 id="字符集简介">字符集简介</h3>
<p>我们知道在计算机中只能存储二进制数据，那该怎么存储字符串呢？当然是建立字符与二进制数据的映射关系了，建立这个关系最起码要搞清楚两件事儿：</p>
<ol>
<li>
<p>你要把哪些字符映射成二进制数据？</p>
<p>也就是界定清楚字符范围。</p>
</li>
<li>
<p>怎么映射？</p>
<p>将一个字符映射成一个二进制数据的过程也叫做<code>编码</code>，将一个二进制数据映射到一个字符的过程叫做<code>解码</code>。</p>
</li>
</ol>
<p>人们抽象出一个<code>字符集</code>的概念来描述某个字符范围的编码规则。比方说我们来自定义一个名称为<code>xiaohaizi</code>的字符集，它包含的字符范围和编码规则如下：</p>
<ul>
<li>
<p>包含字符<code>'a'</code>、<code>'b'</code>、<code>'A'</code>、<code>'B'</code>。</p>
</li>
<li>
<p>编码规则如下：</p>
<p>采用1个字节编码一个字符的形式，字符和字节的映射关系如下：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;a&#x27;</span> -&gt; <span class="hljs-number">00000001</span> (十六进制：<span class="hljs-number">0x01</span>)<br><span class="hljs-string">&#x27;b&#x27;</span> -&gt; <span class="hljs-number">00000010</span> (十六进制：<span class="hljs-number">0x02</span>)<br><span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">00000011</span> (十六进制：<span class="hljs-number">0x03</span>)<br><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">00000100</span> (十六进制：<span class="hljs-number">0x04</span>)<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>有了<code>xiaohaizi</code>字符集，我们就可以用二进制形式表示一些字符串了，下边是一些字符串用<code>xiaohaizi</code>字符集编码后的二进制表示：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;bA&#x27;</span> -&gt; <span class="hljs-number">0000001000000011</span>  (十六进制：<span class="hljs-number">0x0203</span>)<br><span class="hljs-string">&#x27;baB&#x27;</span> -&gt; <span class="hljs-number">000000100000000100000100</span>  (十六进制：<span class="hljs-number">0x020104</span>)<br><span class="hljs-string">&#x27;cd&#x27;</span> -&gt; 无法表示，字符集xiaohaizi不包含字符<span class="hljs-string">&#x27;c&#x27;</span>和<span class="hljs-string">&#x27;d&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="比较规则简介">比较规则简介</h3>
<p>在我们确定了<code>xiaohaizi</code>字符集表示字符的范围以及编码规则后，怎么比较两个字符的大小呢？最容易想到的就是直接比较这两个字符对应的二进制编码的大小，比方说字符<code>'a'</code>的编码为<code>0x01</code>，字符<code>'b'</code>的编码为<code>0x02</code>，所以<code>'a'</code>小于<code>'b'</code>，这种简单的比较规则也可以被称为二进制比较规则，英文名为<code>binary collation</code>。</p>
<p>二进制比较规则是简单，但有时候并不符合现实需求，比如在很多场合对于英文字符我们都是不区分大小写的，也就是说<code>'a'</code>和<code>'A'</code>是相等的，在这种场合下就不能简单粗暴的使用二进制比较规则了，这时候我们可以这样指定比较规则：</p>
<ol>
<li>将两个大小写不同的字符全都转为大写或者小写。</li>
<li>再比较这两个字符对应的二进制数据。</li>
</ol>
<p>这是一种稍微复杂一点点的比较规则，但是实际生活中的字符不止英文字符一种，比如我们的汉字有几万之多，对于某一种字符集来说，比较两个字符大小的规则可以制定出很多种，也就是说同一种字符集可以有多种比较规则，我们稍后就要介绍各种现实生活中用的字符集以及它们的一些比较规则。</p>
<h3 id="一些重要的字符集">一些重要的字符集</h3>
<p>不幸的是，这个世界太大了，不同的人制定出了好多种<code>字符集</code>，它们表示的字符范围和用到的编码规则可能都不一样。我们看一下一些常用字符集的情况：</p>
<ul>
<li>
<p><code>ASCII</code>字符集–<strong>1个字节</strong></p>
<p>共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才128个字符，所以可以使用1个字节来进行编码，我们看一些字符的编码方式：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;L&#x27;</span> -&gt;  <span class="hljs-number">01001100</span>（十六进制：<span class="hljs-number">0x4C</span>，十进制：<span class="hljs-number">76</span>）<br><span class="hljs-string">&#x27;M&#x27;</span> -&gt;  <span class="hljs-number">01001101</span>（十六进制：<span class="hljs-number">0x4D</span>，十进制：<span class="hljs-number">77</span>）<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>ISO 8859-1</code>字符集–<strong>1个字节</strong></p>
<p>共收录256个字符，是在<code>ASCII</code>字符集的基础上又扩充了128个西欧常用字符(包括德法两国的字母)，也可以使用1个字节来进行编码。这个字符集也有一个别名<code>latin1</code>。</p>
</li>
<li>
<p><code>GB2312</code>字符集–<strong>1个字节or2个字节</strong></p>
<p>收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个，其他文字符号682个。同时这种字符集又兼容<code>ASCII</code>字符集，所以在编码方式上显得有些奇怪：</p>
<ul>
<li>如果该字符在<code>ASCII</code>字符集中，则采用1字节编码。</li>
<li>否则采用2字节编码。</li>
</ul>
<p>这种表示一个字符需要的字节数可能不同的编码方式称为<code>变长编码方式</code>。比方说字符串<code>'爱u'</code>，其中<code>'爱'</code>需要用2个字节进行编码，编码后的十六进制表示为<code>0xB0AE</code>，<code>'u'</code>需要用1个字节进行编码，编码后的十六进制表示为<code>0x75</code>，所以拼合起来就是<code>0xB0AE75</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>我们怎么区分某个字节代表一个单独的字符还是代表某个字符的一部分呢？别忘了`ASCII`字符集只收录128个字符，使用0～127就可以表示全部字符，所以如果某个字节是在0～127之内的，就意味着一个字节代表一个单独的字符，否则就是两个字节代表一个单独的字符。<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>GBK</code>字符集–<strong>中文2个字节，英文1个字节</strong></p>
<p><code>GBK</code>字符集只是在收录字符范围上对<code>GB2312</code>字符集作了扩充，编码方式上兼容<code>GB2312</code>。</p>
</li>
<li>
<p><code>utf8</code>字符集–<strong>1～4个字节</strong></p>
<p>收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容<code>ASCII</code>字符集，采用变长编码方式，编码一个字符需要使用1～4个字节，比方说这样：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;L&#x27;</span> -&gt;  <span class="hljs-number">01001100</span>（十六进制：<span class="hljs-number">0x4C</span>）<br><span class="hljs-string">&#x27;啊&#x27;</span> -&gt;  <span class="hljs-number">111001011001010110001010</span>（十六进制：<span class="hljs-number">0xE5958A</span>）<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>其实准确的说，utf8只是Unicode字符集的一种编码方案，Unicode字符集可以采用utf8、utf16、utf32这几种编码方案，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符。更详细的Unicode和其编码方案的知识不是本书的重点，大家上网查查哈～<br><br>MySQL中并不区分字符集和编码方案的概念，所以后边唠叨的时候把utf8、utf16、utf32都当作一种字符集对待。<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>对于同一个字符，不同字符集也可能有不同的编码方式。比如对于汉字<code>'我'</code>来说，<code>ASCII</code>字符集中根本没有收录这个字符，<code>utf8</code>和<code>gb2312</code>字符集对汉字<code>我</code>的编码方式如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">utf8</span>编码：<span class="hljs-number">111001101000100010010001</span> (<span class="hljs-number">3</span>个字节，十六进制表示是：<span class="hljs-number">0</span>xE<span class="hljs-number">68891</span>)<br><span class="hljs-attribute">gb2312</span>编码：<span class="hljs-number">1011000010101110</span> (<span class="hljs-number">2</span>个字节，十六进制表示是：<span class="hljs-number">0</span>xB<span class="hljs-number">0</span>AE)<br></code></pre></td></tr></table></figure>
<h2 id="MySQL中支持的字符集和排序规则">MySQL中支持的字符集和排序规则</h2>
<h3 id="MySQL中的utf8和utf8mb4">MySQL中的utf8和utf8mb4</h3>
<p>我们上边说<code>utf8</code>字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在<code>MySQL</code>中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计<code>MySQL</code>的大叔偷偷的定义了两个概念：</p>
<ul>
<li><code>utf8mb3</code>：阉割过的<code>utf8</code>字符集，只使用1～3个字节表示字符。</li>
<li><code>utf8mb4</code>：正宗的<code>utf8</code>字符集，使用1～4个字节表示字符。</li>
</ul>
<p>有一点需要大家十分的注意，在<code>MySQL</code>中<code>utf8</code>是<code>utf8mb3</code>的别名，所以之后在<code>MySQL</code>中提到<code>utf8</code>就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如<strong>存储一些emoji表情啥的，那请使用<code>utf8mb4</code></strong>。</p>
<h3 id="字符集的查看">字符集的查看</h3>
<p><code>MySQL</code>支持好多好多种字符集，查看当前<code>MySQL</code>中支持的字符集可以用下边这个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> (<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span><span class="hljs-operator">|</span>CHARSET) [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br></code></pre></td></tr></table></figure>
<p>其中<code>CHARACTER SET</code>和<code>CHARSET</code>是同义词，用任意一个都可以。我们查询一下（支持的字符集太多了，我们省略了一些）：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW CHARSET;<br>+----------+---------------------------------+---------------------+--------+<br>|<span class="hljs-string"> Charset  </span>|<span class="hljs-string"> Description                     </span>|<span class="hljs-string"> Default collation   </span>|<span class="hljs-string"> Maxlen </span>|<br>+----------+---------------------------------+---------------------+--------+<br>|<span class="hljs-string"> big5     </span>|<span class="hljs-string"> Big5 Traditional Chinese        </span>|<span class="hljs-string"> big5_chinese_ci     </span>|<span class="hljs-string">      2 </span>|<br>...<br>|<span class="hljs-string"> latin1   </span>|<span class="hljs-string"> cp1252 West European            </span>|<span class="hljs-string"> latin1_swedish_ci   </span>|<span class="hljs-string">      1 </span>|<br>|<span class="hljs-string"> latin2   </span>|<span class="hljs-string"> ISO 8859-2 Central European     </span>|<span class="hljs-string"> latin2_general_ci   </span>|<span class="hljs-string">      1 </span>|<br>...<br>|<span class="hljs-string"> ascii    </span>|<span class="hljs-string"> US ASCII                        </span>|<span class="hljs-string"> ascii_general_ci    </span>|<span class="hljs-string">      1 </span>|<br>...<br>|<span class="hljs-string"> gb2312   </span>|<span class="hljs-string"> GB2312 Simplified Chinese       </span>|<span class="hljs-string"> gb2312_chinese_ci   </span>|<span class="hljs-string">      2 </span>|<br>...<br>|<span class="hljs-string"> gbk      </span>|<span class="hljs-string"> GBK Simplified Chinese          </span>|<span class="hljs-string"> gbk_chinese_ci      </span>|<span class="hljs-string">      2 </span>|<br>|<span class="hljs-string"> latin5   </span>|<span class="hljs-string"> ISO 8859-9 Turkish              </span>|<span class="hljs-string"> latin5_turkish_ci   </span>|<span class="hljs-string">      1 </span>|<br>...<br>|<span class="hljs-string"> utf8     </span>|<span class="hljs-string"> UTF-8 Unicode                   </span>|<span class="hljs-string"> utf8_general_ci     </span>|<span class="hljs-string">      3 </span>|<br>|<span class="hljs-string"> ucs2     </span>|<span class="hljs-string"> UCS-2 Unicode                   </span>|<span class="hljs-string"> ucs2_general_ci     </span>|<span class="hljs-string">      2 </span>|<br>...<br>|<span class="hljs-string"> latin7   </span>|<span class="hljs-string"> ISO 8859-13 Baltic              </span>|<span class="hljs-string"> latin7_general_ci   </span>|<span class="hljs-string">      1 </span>|<br>|<span class="hljs-string"> utf8mb4  </span>|<span class="hljs-string"> UTF-8 Unicode                   </span>|<span class="hljs-string"> utf8mb4_general_ci  </span>|<span class="hljs-string">      4 </span>|<br>|<span class="hljs-string"> utf16    </span>|<span class="hljs-string"> UTF-16 Unicode                  </span>|<span class="hljs-string"> utf16_general_ci    </span>|<span class="hljs-string">      4 </span>|<br>|<span class="hljs-string"> utf16le  </span>|<span class="hljs-string"> UTF-16LE Unicode                </span>|<span class="hljs-string"> utf16le_general_ci  </span>|<span class="hljs-string">      4 </span>|<br>...<br>|<span class="hljs-string"> utf32    </span>|<span class="hljs-string"> UTF-32 Unicode                  </span>|<span class="hljs-string"> utf32_general_ci    </span>|<span class="hljs-string">      4 </span>|<br>|<span class="hljs-string"> binary   </span>|<span class="hljs-string"> Binary pseudo charset           </span>|<span class="hljs-string"> binary              </span>|<span class="hljs-string">      1 </span>|<br>...<br>|<span class="hljs-string"> gb18030  </span>|<span class="hljs-string"> China National Standard GB18030 </span>|<span class="hljs-string"> gb18030_chinese_ci  </span>|<span class="hljs-string">      4 </span>|<br>+----------+---------------------------------+---------------------+--------+<br>41 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure>
<p>可以看到，我使用的这个<code>MySQL</code>版本一共支持<code>41</code>种字符集，其中的<code>Default collation</code>列表示这种字符集中一种默认的<code>比较规则</code>。大家注意返回结果中的最后一列<code>Maxlen</code>，它代表该种字符集表示一个字符最多需要几个字节。为了让大家的印象更深刻，我把几个常用到的字符集的<code>Maxlen</code>列摘抄下来，大家务必记住：</p>
<table>
<thead>
<tr>
<th>字符集名称</th>
<th>Maxlen</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ascii</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>latin1</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>gb2312</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>gbk</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>utf8</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>utf8mb4</code></td>
<td><code>4</code></td>
</tr>
</tbody>
</table>
<h3 id="比较规则的查看">比较规则的查看</h3>
<p>查看<code>MySQL</code>中支持的比较规则的命令如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">COLLATION</span> [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br></code></pre></td></tr></table></figure>
<p>我们前边说过一种字符集可能对应着若干种比较规则，<code>MySQL</code>支持的字符集就已经非常多了，所以支持的比较规则更多，我们先只查看一下<code>utf8</code>字符集下的比较规则：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW COLLATION LIKE &#x27;utf8\_%&#x27;;<br>+--------------------------+---------+-----+---------+----------+---------+<br>|<span class="hljs-string"> Collation                </span>|<span class="hljs-string"> Charset </span>|<span class="hljs-string"> Id  </span>|<span class="hljs-string"> Default </span>|<span class="hljs-string"> Compiled </span>|<span class="hljs-string"> Sortlen </span>|<br>+--------------------------+---------+-----+---------+----------+---------+<br>|<span class="hljs-string"> utf8_general_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string">  33 </span>|<span class="hljs-string"> Yes     </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       1 </span>|<br>|<span class="hljs-string"> utf8_bin                 </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string">  83 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       1 </span>|<br>|<span class="hljs-string"> utf8_unicode_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 192 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_icelandic_ci        </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 193 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_latvian_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 194 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_romanian_ci         </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 195 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_slovenian_ci        </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 196 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_polish_ci           </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 197 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_estonian_ci         </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 198 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_spanish_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 199 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_swedish_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 200 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_turkish_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 201 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_czech_ci            </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 202 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_danish_ci           </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 203 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_lithuanian_ci       </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 204 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_slovak_ci           </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 205 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_spanish2_ci         </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 206 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_roman_ci            </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 207 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_persian_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 208 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_esperanto_ci        </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 209 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_hungarian_ci        </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 210 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_sinhala_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 211 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_german2_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 212 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_croatian_ci         </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 213 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_unicode_520_ci      </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 214 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_vietnamese_ci       </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 215 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_general_mysql500_ci </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 223 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       1 </span>|<br>+--------------------------+---------+-----+---------+----------+---------+<br>27 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>这些比较规则的命名还挺有规律的，具体规律如下：</p>
<ul>
<li>
<p>比较规则名称以与其关联的字符集的名称开头。如上图的查询结果的比较规则名称都是以<code>utf8</code>开头的。</p>
</li>
<li>
<p>后边紧跟着该比较规则主要作用于哪种语言，比如<code>utf8_polish_ci</code>表示以波兰语的规则比较，<code>utf8_spanish_ci</code>是以西班牙语的规则比较，<code>utf8_general_ci</code>是一种通用的比较规则。</p>
</li>
<li>
<p>名称后缀意味着该比较规则是否区分语言中的重音、大小写啥的，具体可以用的值如下：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>英文释义</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_ai</code></td>
<td><code>accent insensitive</code></td>
<td>不区分重音</td>
</tr>
<tr>
<td><code>_as</code></td>
<td><code>accent sensitive</code></td>
<td>区分重音</td>
</tr>
<tr>
<td><code>_ci</code></td>
<td><code>case insensitive</code></td>
<td>不区分大小写</td>
</tr>
<tr>
<td><code>_cs</code></td>
<td><code>case sensitive</code></td>
<td>区分大小写</td>
</tr>
<tr>
<td><code>_bin</code></td>
<td><code>binary</code></td>
<td>以二进制方式比较</td>
</tr>
</tbody>
</table>
<p>比如<code>utf8_general_ci</code>这个比较规则是以<code>ci</code>结尾的，说明不区分大小写。</p>
</li>
</ul>
<p>每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则，<code>SHOW COLLATION</code>的返回结果中的<code>Default</code>列的值为<code>YES</code>的就是该字符集的默认比较规则，比方说<code>utf8</code>字符集默认的比较规则就是<code>utf8_general_ci</code>。</p>
<h2 id="字符集和比较规则的应用">字符集和比较规则的应用</h2>
<h3 id="各级别的字符集和比较规则">各级别的字符集和比较规则</h3>
<p><code>MySQL</code>有4个级别的字符集和比较规则，分别是：</p>
<ul>
<li>服务器级别</li>
<li>数据库级别</li>
<li>表级别</li>
<li>列级别</li>
</ul>
<p>我们接下来仔细看一下怎么设置和查看这几个级别的字符集和比较规则。</p>
<h4 id="服务器级别">服务器级别</h4>
<p><code>MySQL</code>提供了两个系统变量来表示服务器级别的字符集和比较规则：</p>
<table>
<thead>
<tr>
<th>系统变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>character_set_server</code></td>
<td>服务器级别的字符集</td>
</tr>
<tr>
<td><code>collation_server</code></td>
<td>服务器级别的比较规则</td>
</tr>
</tbody>
</table>
<p>我们看一下这两个系统变量的值：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_server&#x27;;</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| Variable_name        | Value |</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| character_set_server | utf8  |</span><br><span class="hljs-section">+----------------------+-------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_server&#x27;;</span><br><span class="hljs-section">+------------------+-----------------+</span><br><span class="hljs-section">| Variable_name    | Value           |</span><br><span class="hljs-section">+------------------+-----------------+</span><br><span class="hljs-section">| collation_server | utf8_general_ci |</span><br><span class="hljs-section">+------------------+-----------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>可以看到在我的计算机中服务器级别默认的字符集是<code>utf8</code>，默认的比较规则是<code>utf8_general_ci</code>。</p>
<p>我们可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用<code>SET</code>语句修改这两个变量的值。比如我们可以在配置文件中这样写：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">character_set_server</span>=gbk<br><span class="hljs-attr">collation_server</span>=gbk_chinese_ci<br></code></pre></td></tr></table></figure>
<p>当服务器启动的时候读取这个配置文件后这两个系统变量的值便修改了。</p>
<h4 id="数据库级别">数据库级别</h4>
<p>我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> 数据库名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> 比较规则名称];<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">DATABASE</span> 数据库名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> 比较规则名称];<br></code></pre></td></tr></table></figure>
<p>其中的<code>DEFAULT</code>可以省略，并不影响语句的语义。比方说我们新创建一个名叫<code>charset_demo_db</code>的数据库，在创建的时候指定它使用的字符集为<code>gb2312</code>，比较规则为<code>gb2312_chinese_ci</code>：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> charset_demo_db<br>    -&gt; <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> gb2312<br>    -&gt; <span class="hljs-keyword">COLLATE</span> gb2312_chinese_ci;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> affected (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure>
<p>如果想查看当前数据库使用的字符集和比较规则，可以查看下面两个系统变量的值（前提是使用<code>USE</code>语句选择当前默认数据库，如果没有默认数据库，则变量与相应的服务器级系统变量具有相同的值）：</p>
<table>
<thead>
<tr>
<th>系统变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>character_set_database</code></td>
<td>当前数据库的字符集</td>
</tr>
<tr>
<td><code>collation_database</code></td>
<td>当前数据库的比较规则</td>
</tr>
</tbody>
</table>
<p>我们来查看一下刚刚创建的<code>charset_demo_db</code>数据库的字符集和比较规则：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; USE charset_demo_db;<br>Database changed<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_database&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| character_set_database | gb2312 |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_database&#x27;;</span><br><span class="hljs-section">+--------------------+-------------------+</span><br><span class="hljs-section">| Variable_name      | Value             |</span><br><span class="hljs-section">+--------------------+-------------------+</span><br><span class="hljs-section">| collation_database | gb2312_chinese_ci |</span><br><span class="hljs-section">+--------------------+-------------------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure>
<p>可以看到这个<code>charset_demo_db</code>数据库的字符集和比较规则就是我们在创建语句中指定的。需要注意的一点是： <em><strong>character_set_database</strong></em> 和 <em><strong>collation_database</strong></em> 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则。</p>
<p>数据库的创建语句中也可以不指定字符集和比较规则，比如这样：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> 数据库名;<br></code></pre></td></tr></table></figure>
<p>这样的话将使用服务器级别的字符集和比较规则作为数据库的字符集和比较规则。</p>
<h4 id="表级别">表级别</h4>
<p>我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (列的信息)<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [<span class="hljs-keyword">COLLATE</span> 比较规则名称]]<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [<span class="hljs-keyword">COLLATE</span> 比较规则名称]<br></code></pre></td></tr></table></figure>
<p>比方说我们在刚刚创建的<code>charset_demo_db</code>数据库中创建一个名为<code>t</code>的表，并指定这个表的字符集和比较规则：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     col <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure>
<p>如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。假设我们的创建表<code>t</code>的语句是这么写的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t(<br>    col <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>)<br>);<br></code></pre></td></tr></table></figure>
<p>因为表<code>t</code>的建表语句中并没有明确指定字符集和比较规则，则表<code>t</code>的字符集和比较规则将继承所在数据库<code>charset_demo_db</code>的字符集和比较规则，也就是<code>gb2312</code>和<code>gb2312_chinese_ci</code>。</p>
<h4 id="列级别">列级别</h4>
<p>需要注意的是，对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>    列名 字符串类型 [<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称] [<span class="hljs-keyword">COLLATE</span> 比较规则名称],<br>    其他列...<br>);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 列名 字符串类型 [<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称] [<span class="hljs-keyword">COLLATE</span> 比较规则名称];<br></code></pre></td></tr></table></figure>
<p>比如我们修改一下表<code>t</code>中列<code>col</code>的字符集和比较规则可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> t MODIFY col <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> gbk <span class="hljs-keyword">COLLATE</span> gbk_chinese_ci;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.04</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>mysql<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure>
<p>对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则。比方说表<code>t</code>的字符集是<code>utf8</code>，比较规则是<code>utf8_general_ci</code>，修改列<code>col</code>的语句是这么写的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> t MODIFY col <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>
<p>那列<code>col</code>的字符集和编码将使用表<code>t</code>的字符集和比较规则，也就是<code>utf8</code>和<code>utf8_general_ci</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示会发生错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的话就会出错，因为ascii字符集并不能表示汉字字符。<br></code></pre></td></tr></table></figure>
<h4 id="仅修改字符集或仅修改比较规则">仅修改字符集或仅修改比较规则</h4>
<p>由于字符集和比较规则是互相有联系的，如果我们只修改了字符集，比较规则也会跟着变化，如果只修改了比较规则，字符集也会跟着变化，具体规则如下：</p>
<ul>
<li>只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。</li>
<li>只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。</li>
</ul>
<p>不论哪个级别的字符集和比较规则，这两条规则都适用，我们以服务器级别的字符集和比较规则为例来看一下详细过程：</p>
<ul>
<li>
<p>只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; SET character_set_server = gb2312;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_server&#x27;;</span><br><span class="hljs-section">+----------------------+--------+</span><br><span class="hljs-section">| Variable_name        | Value  |</span><br><span class="hljs-section">+----------------------+--------+</span><br><span class="hljs-section">| character_set_server | gb2312 |</span><br><span class="hljs-section">+----------------------+--------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt;  SHOW VARIABLES LIKE &#x27;collation_server&#x27;;</span><br><span class="hljs-section">+------------------+-------------------+</span><br><span class="hljs-section">| Variable_name    | Value             |</span><br><span class="hljs-section">+------------------+-------------------+</span><br><span class="hljs-section">| collation_server | gb2312_chinese_ci |</span><br><span class="hljs-section">+------------------+-------------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>我们只修改了<code>character_set_server</code>的值为<code>gb2312</code>，<code>collation_server</code>的值自动变为了<code>gb2312_chinese_ci</code>。</p>
</li>
<li>
<p>只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; SET collation_server = utf8_general_ci;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_server&#x27;;</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| Variable_name        | Value |</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| character_set_server | utf8  |</span><br><span class="hljs-section">+----------------------+-------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_server&#x27;;</span><br><span class="hljs-section">+------------------+-----------------+</span><br><span class="hljs-section">| Variable_name    | Value           |</span><br><span class="hljs-section">+------------------+-----------------+</span><br><span class="hljs-section">| collation_server | utf8_general_ci |</span><br><span class="hljs-section">+------------------+-----------------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure>
<p>我们只修改了<code>collation_server</code>的值为<code>utf8_general_ci</code>，<code>character_set_server</code>的值自动变为了<code>utf8</code>。</p>
</li>
</ul>
<h4 id="各级别字符集和比较规则小结">各级别字符集和比较规则小结</h4>
<p>我们介绍的这4个级别字符集和比较规则的联系如下：</p>
<ul>
<li>如果<strong>创建或修改列</strong>时没有显式的指定字符集和比较规则，<strong>则该列默认用表的字符集和比较规则</strong></li>
<li>如果<strong>创建表</strong>时没有显式的指定字符集和比较规则，<strong>则该表默认用数据库的字符集和比较规则</strong></li>
<li>如果<strong>创建数据库</strong>时没有显式的指定字符集和比较规则，<strong>则该数据库默认用服务器的字符集和比较规则</strong></li>
</ul>
<p>知道了这些规则之后，对于给定的表，我们应该知道它的各个列的字符集和比较规则是什么，从而根据这个列的类型来确定存储数据时每个列的实际数据占用的存储空间大小了。比方说我们向表<code>t</code>中插入一条记录：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; INSERT INTO t(col) VALUES(<span class="hljs-emphasis">&#x27;我我&#x27;</span>);<br>Query OK, 1 row affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM t;</span><br><span class="hljs-section">+--------+</span><br><span class="hljs-section">| s      |</span><br><span class="hljs-section">+--------+</span><br><span class="hljs-section">| 我我   |</span><br><span class="hljs-section">+--------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>首先列<code>col</code>使用的字符集是<code>gbk</code>，一个字符<code>'我'</code>在<code>gbk</code>中的编码为<code>0xCED2</code>，占用两个字节，两个字符的实际数据就占用4个字节。如果把该列的字符集修改为<code>utf8</code>的话，这两个字符就实际占用6个字节啦～</p>
<h3 id="客户端和服务器通信中的字符集">客户端和服务器通信中的字符集</h3>
<h4 id="编码和解码使用的字符集不一致的后果">编码和解码使用的字符集不一致的后果</h4>
<p>说到底，字符串在计算机上的体现就是一个字节串，如果你使用不同字符集去解码这个字节串，最后得到的结果可能让你挠头。</p>
<p>我们知道字符<code>'我'</code>在<code>utf8</code>字符集编码下的字节串长这样：<code>0xE68891</code>，如果一个程序把这个字节串发送到另一个程序里，另一个程序用不同的字符集去解码这个字节串，假设使用的是<code>gbk</code>字符集来解释这串字节，解码过程就是这样的：</p>
<ol>
<li>首先看第一个字节<code>0xE6</code>，它的值大于<code>0x7F</code>（十进制：127），说明是两字节编码，继续读一字节后是<code>0xE688</code>，然后从<code>gbk</code>编码表中查找字节为<code>0xE688</code>对应的字符，发现是字符<code>'鎴'</code></li>
<li>继续读一个字节<code>0x91</code>，它的值也大于<code>0x7F</code>，再往后读一个字节发现木有了，所以这是半个字符。</li>
<li>所以<code>0xE68891</code>被<code>gbk</code>字符集解释成一个字符<code>'鎴'</code>和半个字符。</li>
</ol>
<p>假设用<code>iso-8859-1</code>，也就是<code>latin1</code>字符集去解释这串字节，解码过程如下：</p>
<ol>
<li>先读第一个字节<code>0xE6</code>，它对应的<code>latin1</code>字符为<code>æ</code>。</li>
<li>再读第二个字节<code>0x88</code>，它对应的<code>latin1</code>字符为<code>ˆ</code>。</li>
<li>再读第三个字节<code>0x91</code>，它对应的<code>latin1</code>字符为<code>‘</code>。</li>
<li>所以整串字节<code>0xE68891</code>被<code>latin1</code>字符集解释后的字符串就是<code>'æˆ‘'</code></li>
</ol>
<p>可见，如果对于同一个字符串编码和解码使用的字符集不一样，会产生意想不到的结果，作为人类的我们看上去就像是产生了乱码一样。</p>
<h4 id="字符集转换的概念">字符集转换的概念</h4>
<p>如果接收<code>0xE68891</code>这个字节串的程序按照<code>utf8</code>字符集进行解码，然后又把它按照<code>gbk</code>字符集进行编码，最后编码后的字节串就是<code>0xCED2</code>，我们把这个过程称为<code>字符集的转换</code>，也就是字符串<code>'我'</code>从<code>utf8</code>字符集转换为<code>gbk</code>字符集。</p>
<h4 id="MySQL中字符集的转换">MySQL中字符集的转换</h4>
<p>我们知道从客户端发往服务器的请求本质上就是一个字符串，服务器向客户端返回的结果本质上也是一个字符串，而字符串其实是使用某种字符集编码的二进制数据。这个字符串可不是使用一种字符集的编码方式一条道走到黑的，从发送请求到返回结果这个过程中伴随着多次字符集的转换，在这个过程中会用到3个系统变量，我们先把它们写出来看一下：</p>
<table>
<thead>
<tr>
<th>系统变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>character_set_client</code></td>
<td>服务器解码请求时使用的字符集</td>
</tr>
<tr>
<td><code>character_set_connection</code></td>
<td>服务器处理请求时会把请求字符串从<code>character_set_client</code>转为<code>character_set_connection</code></td>
</tr>
<tr>
<td><code>character_set_results</code></td>
<td>服务器向客户端返回数据时使用的字符集</td>
</tr>
</tbody>
</table>
<p>这几个系统变量在我的计算机上的默认值如下（不同操作系统的默认值可能不同）：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_client&#x27;;</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| Variable_name        | Value |</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| character_set_client | utf8  |</span><br><span class="hljs-section">+----------------------+-------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_connection&#x27;;</span><br><span class="hljs-section">+--------------------------+-------+</span><br><span class="hljs-section">| Variable_name            | Value |</span><br><span class="hljs-section">+--------------------------+-------+</span><br><span class="hljs-section">| character_set_connection | utf8  |</span><br><span class="hljs-section">+--------------------------+-------+</span><br>1 row in set (0.01 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_results&#x27;;</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| Variable_name         | Value |</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| character_set_results | utf8  |</span><br><span class="hljs-section">+-----------------------+-------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>大家可以看到这几个系统变量的值都是<code>utf8</code>，为了体现出字符集在请求处理过程中的变化，我们这里特意修改一个系统变量的值：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; set character_set_connection = gbk;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br></code></pre></td></tr></table></figure>
<p>所以现在系统变量<code>character_set_client</code>和<code>character_set_results</code>的值还是<code>utf8</code>，而<code>character_set_connection</code>的值为<code>gbk</code>。现在假设我们客户端发送的请求是下边这个字符串：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> s = <span class="hljs-string">&#x27;我&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>为了方便大家理解这个过程，我们只分析字符<code>'我'</code>在这个过程中字符集的转换。</p>
<p>现在看一下在请求从发送到结果返回过程中字符集的变化：</p>
<ol>
<li>
<p>客户端发送请求所使用的字符集</p>
<p>一般情况下客户端所使用的字符集和当前操作系统一致，不同操作系统使用的字符集可能不一样，如下：</p>
<ul>
<li>类<code>Unix</code>系统使用的是<code>utf8</code></li>
<li><code>Windows</code>使用的是<code>gbk</code></li>
</ul>
<p>例如我在使用的<code>macOS</code>操作系统时，客户端使用的就是<code>utf8</code>字符集。所以字符<code>'我'</code>在发送给服务器的请求中的字节形式就是：<code>0xE68891</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>如果你使用的是可视化工具，比如navicat之类的，这些工具可能会使用自定义的字符集来编码发送到服务器的字符串，而不采用操作系统默认的字符集（所以在学习的时候还是尽量用黑框框哈）。<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>服务器接收到客户端发送来的请求其实是一串二进制的字节，它会认为这串字节采用的字符集是<code>character_set_client</code>，然后把这串字节转换为<code>character_set_connection</code>字符集编码的字符。</p>
<p>由于我的计算机上<code>character_set_client</code>的值是<code>utf8</code>，首先会按照<code>utf8</code>字符集对字节串<code>0xE68891</code>进行解码，得到的字符串就是<code>'我'</code>，然后按照<code>character_set_connection</code>代表的字符集，也就是<code>gbk</code>进行编码，得到的结果就是字节串<code>0xCED2</code>。</p>
</li>
<li>
<p>因为表<code>t</code>的列<code>col</code>采用的是<code>gbk</code>字符集，与<code>character_set_connection</code>一致，所以直接到列中找字节值为<code>0xCED2</code>的记录，最后找到了一条记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>如果某个列使用的字符集和character_set_connection代表的字符集不一致的话，还需要进行一次字符集转换。<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>上一步骤找到的记录中的<code>col</code>列其实是一个字节串<code>0xCED2</code>，<code>col</code>列是采用<code>gbk</code>进行编码的，所以首先会将这个字节串使用<code>gbk</code>进行解码，得到字符串<code>'我'</code>，然后再把这个字符串使用<code>character_set_results</code>代表的字符集，也就是<code>utf8</code>进行编码，得到了新的字节串：<code>0xE68891</code>，然后发送给客户端。</p>
</li>
<li>
<p>由于客户端是用的字符集是<code>utf8</code>，所以可以顺利的将<code>0xE68891</code>解释成字符<code>我</code>，从而显示到我们的显示器上，所以我们人类也读懂了返回的结果。</p>
</li>
</ol>
<p>如果你读上边的文字有点晕，可以参照这个图来仔细分析一下这几个步骤：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a2f479833d3340~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d6dfk4orjaj1ra8536aijb99.png-112.4kB">
<p>从这个分析中我们可以得出这么几点需要注意的地方：</p>
<ul>
<li>
<p>服务器认为客户端发送过来的请求是用<code>character_set_client</code>编码的。</p>
<p>假设你的客户端采用的字符集和 <em><strong>character_set_client</strong></em> 不一样的话，这就会出现意想不到的情况。比如我的客户端使用的是<code>utf8</code>字符集，如果把系统变量<code>character_set_client</code>的值设置为<code>ascii</code>的话，服务器可能无法理解我们发送的请求，更别谈处理这个请求了。</p>
</li>
<li>
<p>服务器将把得到的结果集使用<code>character_set_results</code>编码后发送给客户端。</p>
<p>假设你的客户端采用的字符集和 <em><strong>character_set_results</strong></em> 不一样的话，这就可能会出现客户端无法解码结果集的情况，结果就是在你的屏幕上出现乱码。比如我的客户端使用的是<code>utf8</code>字符集，如果把系统变量<code>character_set_results</code>的值设置为<code>ascii</code>的话，可能会产生乱码。</p>
</li>
<li>
<p><code>character_set_connection</code>只是服务器在将请求的字节串从<code>character_set_client</code>转换为<code>character_set_connection</code>时使用，它是什么其实没多重要，但是一定要注意，该字符集包含的字符范围一定涵盖请求中的字符，要不然会导致有的字符无法使用<code>character_set_connection</code>代表的字符集进行编码。比如你把<code>character_set_client</code>设置为<code>utf8</code>，把<code>character_set_connection</code>设置成<code>ascii</code>，那么此时你如果从客户端发送一个汉字到服务器，那么服务器无法使用<code>ascii</code>字符集来编码这个汉字，就会向用户发出一个警告。</p>
</li>
</ul>
<p>知道了在<code>MySQL</code>中从发送请求到返回结果过程里发生的各种字符集转换，但是为啥要转来转去的呢？不晕么？</p>
<p>答：是的，很头晕，所以我们通常都把 <em><strong>character_set_client</strong></em> 、<em><strong>character_set_connection</strong></em>、<em><strong>character_set_results</strong></em> 这三个系统变量设置成和客户端使用的字符集一致的情况，这样减少了很多无谓的字符集转换。为了方便我们设置，<code>MySQL</code>提供了一条非常简便的语句：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> NAMES 字符集名;<br></code></pre></td></tr></table></figure>
<p>这一条语句产生的效果和我们执行这3条的效果是一样的：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">SET character_set_client</span> = 字符集名;<br><span class="hljs-attribute">SET character_set_connection</span> = 字符集名;<br><span class="hljs-attribute">SET character_set_results</span> = 字符集名;<br></code></pre></td></tr></table></figure>
<p>比方说我的客户端使用的是<code>utf8</code>字符集，所以需要把这几个系统变量的值都设置为<code>utf8</code>：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; SET NAMES utf8;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_client&#x27;;</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| Variable_name        | Value |</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| character_set_client | utf8  |</span><br><span class="hljs-section">+----------------------+-------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt;  SHOW VARIABLES LIKE &#x27;character_set_connection&#x27;;</span><br><span class="hljs-section">+--------------------------+-------+</span><br><span class="hljs-section">| Variable_name            | Value |</span><br><span class="hljs-section">+--------------------------+-------+</span><br><span class="hljs-section">| character_set_connection | utf8  |</span><br><span class="hljs-section">+--------------------------+-------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_results&#x27;;</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| Variable_name         | Value |</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| character_set_results | utf8  |</span><br><span class="hljs-section">+-----------------------+-------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt;<br>小贴士：<br><br>如果你使用的是Windows系统，那应该设置成gbk。<br></code></pre></td></tr></table></figure>
<p>另外，如果你想在启动客户端的时候就把<code>character_set_client</code>、<code>character_set_connection</code>、<code>character_set_results</code>这三个系统变量的值设置成一样的，那我们可以在启动客户端的时候指定一个叫<code>default-character-set</code>的启动选项，比如在配置文件里可以这么写：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">client</span>]<br><span class="hljs-literal">default</span>-character-<span class="hljs-keyword">set</span>=utf8<br></code></pre></td></tr></table></figure>
<p>它起到的效果和执行一遍<code>SET NAMES utf8</code>是一样一样的，都会将那三个系统变量的值设置成<code>utf8</code>。</p>
<h3 id="比较规则的应用">比较规则的应用</h3>
<p>结束了字符集的漫游，我们把视角再次聚焦到<code>比较规则</code>，<code>比较规则</code>的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中，所以有时候也称为<code>排序规则</code>。比方说表<code>t</code>的列<code>col</code>使用的字符集是<code>gbk</code>，使用的比较规则是<code>gbk_chinese_ci</code>，我们向里边插入几条记录：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">mysql</span>&gt; <span class="hljs-selector-tag">INSERT</span> <span class="hljs-selector-tag">INTO</span> <span class="hljs-selector-tag">t</span>(col) <span class="hljs-selector-tag">VALUES</span>(<span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-string">&#x27;A&#x27;</span>), (<span class="hljs-string">&#x27;B&#x27;</span>);<br><span class="hljs-selector-tag">Query</span> <span class="hljs-selector-tag">OK</span>, <span class="hljs-selector-tag">4</span> <span class="hljs-selector-tag">rows</span> <span class="hljs-selector-tag">affected</span> (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-selector-tag">Records</span>: <span class="hljs-selector-tag">4</span>  <span class="hljs-selector-tag">Duplicates</span>: <span class="hljs-selector-tag">0</span>  <span class="hljs-selector-tag">Warnings</span>: <span class="hljs-selector-tag">0</span><br><br><span class="hljs-selector-tag">mysql</span>&gt;<br></code></pre></td></tr></table></figure>
<p>我们查询的时候按照<code>t</code>列排序一下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t ORDER BY col;</span><br><span class="hljs-section">+------+</span><br><span class="hljs-section">| col  |</span><br><span class="hljs-section">+------+</span><br>| a    |<br>| A    |<br>| b    |<br>| B    |<br><span class="hljs-section">| 我   |</span><br><span class="hljs-section">+------+</span><br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>可以看到在默认的比较规则<code>gbk_chinese_ci</code>中是不区分大小写的，我们现在把列<code>col</code>的比较规则修改为<code>gbk_bin</code>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; ALTER TABLE t MODIFY col VARCHAR(<span class="hljs-number">10</span>) COLLATE gbk_bin;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">5</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">02</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">5</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>由于<code>gbk_bin</code>是直接比较字符的编码，所以是区分大小写的，我们再看一下排序后的查询结果：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t ORDER BY s;</span><br><span class="hljs-section">+------+</span><br><span class="hljs-section">| s    |</span><br><span class="hljs-section">+------+</span><br>| A    |<br>| B    |<br>| a    |<br>| b    |<br><span class="hljs-section">| 我   |</span><br><span class="hljs-section">+------+</span><br>5 rows in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure>
<p>所以如果以后大家在对字符串做比较或者对某个字符串列做排序操作时没有得到想象中的结果，需要思考一下是不是<code>比较规则</code>的问题～</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">小贴士：<br><br>列`col`中各个字符在使用gbk字符集编码后对应的数字如下：<br><span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">65</span> （十进制）<br><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">66</span> （十进制）<br><span class="hljs-string">&#x27;a&#x27;</span> -&gt; <span class="hljs-number">97</span> （十进制）<br><span class="hljs-string">&#x27;b&#x27;</span> -&gt; <span class="hljs-number">98</span> （十进制）<br><span class="hljs-string">&#x27;我&#x27;</span> -&gt; <span class="hljs-number">25105</span> （十进制）<br></code></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ol>
<li>
<p><code>字符集</code>指的是某个字符范围的编码规则。</p>
</li>
<li>
<p><code>比较规则</code>是针对某个字符集中的字符比较大小的一种规则。</p>
</li>
<li>
<p>在<code>MySQL</code>中，一个字符集可以有若干种比较规则，其中有一个默认的比较规则，一个比较规则必须对应一个字符集。</p>
</li>
<li>
<p>查看<code>MySQL</code>中查看支持的字符集和比较规则的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> (<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span><span class="hljs-operator">|</span>CHARSET) [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">COLLATION</span> [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>MySQL有四个级别的字符集和比较规则</p>
</li>
</ol>
<ul>
<li>
<p>服务器级别</p>
<p><code>character_set_server</code>表示服务器级别的字符集，<code>collation_server</code>表示服务器级别的比较规则。</p>
</li>
<li>
<p>数据库级别</p>
<p>创建和修改数据库时可以指定字符集和比较规则：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> 数据库名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> 比较规则名称];<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">DATABASE</span> 数据库名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> 比较规则名称];<br></code></pre></td></tr></table></figure>
<p><code>character_set_database</code>表示当前数据库的字符集，<code>collation_database</code>表示当前默认数据库的比较规则，这两个系统变量是只读的，不能修改。如果没有指定当前默认数据库，则变量与相应的服务器级系统变量具有相同的值。</p>
</li>
<li>
<p>表级别</p>
<p>创建和修改表的时候指定表的字符集和比较规则：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (列的信息)<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [<span class="hljs-keyword">COLLATE</span> 比较规则名称]];<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [<span class="hljs-keyword">COLLATE</span> 比较规则名称];<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>列级别</p>
<p>创建和修改列定义的时候可以指定该列的字符集和比较规则：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>    列名 字符串类型 [<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称] [<span class="hljs-keyword">COLLATE</span> 比较规则名称],<br>    其他列...<br>);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 列名 字符串类型 [<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称] [<span class="hljs-keyword">COLLATE</span> 比较规则名称];<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>
<p>从发送请求到接收结果过程中发生的字符集转换：</p>
<ul>
<li>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</li>
<li>服务器将客户端发送来的字节串采用<code>character_set_client</code>代表的字符集进行解码，将解码后的字符串再按照<code>character_set_connection</code>代表的字符集进行编码。</li>
<li>如果<code>character_set_connection</code>代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从<code>character_set_connection</code>代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</li>
<li>将从某个列获取到的字节串从该列使用的字符集转换为<code>character_set_results</code>代表的字符集后发送到客户端。</li>
<li>客户端使用操作系统的字符集解析收到的结果集字节串。</li>
</ul>
<p>在这个过程中各个系统变量的含义如下：</p>
<table>
<thead>
<tr>
<th>系统变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>character_set_client</code></td>
<td>服务器解码请求时使用的字符集</td>
</tr>
<tr>
<td><code>character_set_connection</code></td>
<td>服务器处理请求时会把请求字符串从<code>character_set_client</code>转为<code>character_set_connection</code></td>
</tr>
<tr>
<td><code>character_set_results</code></td>
<td>服务器向客户端返回数据时使用的字符集</td>
</tr>
</tbody>
</table>
<p>一般情况下要使用保持这三个变量的值和客户端使用的字符集相同。</p>
</li>
<li>
<p>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</p>
</li>
</ol>
<h1>4.InnoDB记录存储结构</h1>
<h2 id="准备工作">准备工作</h2>
<p><code>MySQL</code>服务器上负责对表中数据的读取和写入工作的部分是<code>存储引擎</code>，而服务器又支持不同类型的存储引擎，比如<code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>啥的，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，真实数据在不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如<code>Memory</code>都不用磁盘来存储数据，也就是说关闭服务器后表中的数据就消失了。</p>
<h2 id="InnoDB页简介">InnoDB页简介</h2>
<p><code>InnoDB</code>是一个<strong>将表中的数据存储到磁盘上的存储引擎</strong>，所以即使关机后重启我们的数据还是存在的。**真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。**而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，<code>InnoDB</code>存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，<code>InnoDB</code>采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 <em><strong>16</strong></em> KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p>
<h2 id="InnoDB行格式">InnoDB行格式</h2>
<p>我们平时是以<strong>记录为单位</strong>来向表中插入数据的，这些记录在磁盘上的存放方式也被称为<code>行格式</code>或者<code>记录格式</code>。设计<code>InnoDB</code>存储引擎的大叔们到现在为止设计了4种不同类型的<code>行格式</code>，分别是<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>和<code>Compressed</code>行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。</p>
<h3 id="指定行格式的语法">指定行格式的语法</h3>
<p>我们可以在创建或修改表的语句中指定<code>行格式</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="hljs-operator">=</span>行格式名称<br>    <br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 ROW_FORMAT<span class="hljs-operator">=</span>行格式名称<br></code></pre></td></tr></table></figure>
<p>比如我们在<code>xiaohaizi</code>数据库里创建一个演示用的表<code>record_format_demo</code>，可以这样指定它的<code>行格式</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> USE xiaohaizi;<br>Database changed<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> record_format_demo (<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c3 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c4 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>COMPACT;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure>
<p>可以看到我们刚刚创建的这个表的<code>行格式</code>就是<code>Compact</code>，另外，我们还显式指定了这个表的字符集为<code>ascii</code>，因为<code>ascii</code>字符集只包括空格、标点符号、数字、大小写字母和一些不可见字符，所以我们的汉字是不能存到这个表里的。我们现在向这个表中插入两条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> record_format_demo(c1, c2, c3, c4) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;aaaa&#x27;</span>, <span class="hljs-string">&#x27;bbb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>), (<span class="hljs-string">&#x27;eeee&#x27;</span>, <span class="hljs-string">&#x27;fff&#x27;</span>, <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">NULL</span>);<br>Query OK, <span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.02</span> sec)<br>Records: <span class="hljs-number">2</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>现在表中的记录就是这个样子的：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM record_format_demo;</span><br><span class="hljs-section">+------+-----+------+------+</span><br><span class="hljs-section">| c1   | c2  | c3   | c4   |</span><br><span class="hljs-section">+------+-----+------+------+</span><br>| aaaa | bbb | cc   | d    |<br><span class="hljs-section">| eeee | fff | NULL | NULL |</span><br><span class="hljs-section">+------+-----+------+------+</span><br>2 rows in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure>
<p>演示表的内容也填充好了，现在我们就来看看各个行格式下的存储方式到底有啥不同吧～</p>
<h3 id="COMPACT行格式">COMPACT行格式</h3>
<p>废话不多说，直接看图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e8fafc21aa~tplv-t2oaga2asx-watermark-20211201102238092.awebp" class="" title="image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB">
<p>大家从图中可以看出来，一条完整的记录其实可以被分为<code>记录的额外信息</code>和<code>记录的真实数据</code>两大部分，下边我们详细看一下这两部分的组成。</p>
<h4 id="记录的额外信息">记录的额外信息</h4>
<p>这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是<code>变长字段长度列表</code>、<code>NULL值列表</code>和<code>记录头信息</code>，我们分别看一下。</p>
<h5 id="变长字段长度列表">变长字段长度列表</h5>
<p>我们知道<code>MySQL</code>支持一些变长的数据类型，比如<code>VARCHAR(M)</code>、<code>VARBINARY(M)</code>、各种<code>TEXT</code>类型，各种<code>BLOB</code>类型，我们也可以把拥有这些数据类型的列称为<code>变长字段</code>，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把<code>MySQL</code>服务器搞懵，所以这些变长字段占用的存储空间分为两部分：</p>
<ol>
<li>真正的数据内容</li>
<li>占用的字节数</li>
</ol>
<p>在<code>Compact</code>行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，<strong>各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！</strong></p>
<p>我们拿<code>record_format_demo</code>表中的第一条记录来举个例子。因为<code>record_format_demo</code>表的<code>c1</code>、<code>c2</code>、<code>c4</code>列都是<code>VARCHAR(10)</code>类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为<code>record_format_demo</code>表中的各个列都使用的是<code>ascii</code>字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各变长字段内容的长度：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>存储内容</th>
<th>内容长度（十进制表示）</th>
<th>内容长度（十六进制表示）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c1</code></td>
<td><code>'aaaa'</code></td>
<td><code>4</code></td>
<td><code>0x04</code></td>
</tr>
<tr>
<td><code>c2</code></td>
<td><code>'bbb'</code></td>
<td><code>3</code></td>
<td><code>0x03</code></td>
</tr>
<tr>
<td><code>c4</code></td>
<td><code>'d'</code></td>
<td><code>1</code></td>
<td><code>0x01</code></td>
</tr>
</tbody>
</table>
<p>又因为这些长度值需要按照列的逆序存放，所以最后<code>变长字段长度列表</code>的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">01 </span><span class="hljs-number">03</span> <span class="hljs-number">04</span> <br></code></pre></td></tr></table></figure>
<p>把这个字节串组成的<code>变长字段长度列表</code>填入上边的示意图中的效果就是：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e8fb363bb4~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9gbruvo504dlg1qsf19nbeu878.png-37kB">
<p>由于第一行记录中<code>c1</code>、<code>c2</code>、<code>c4</code>列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。具体用1个还是2个字节来表示真实数据占用的字节数，<code>InnoDB</code>有它的一套规则，我们首先声明一下<code>W</code>、<code>M</code>和<code>L</code>的意思：</p>
<ol>
<li>假设某个字符集中表示一个字符最多需要使用的字节数为<code>W</code>，也就是使用<code>SHOW CHARSET</code>语句的结果中的<code>Maxlen</code>列，比方说<code>utf8</code>字符集中的<code>W</code>就是<code>3</code>，<code>gbk</code>字符集中的<code>W</code>就是<code>2</code>，<code>ascii</code>字符集中的<code>W</code>就是<code>1</code>。</li>
<li>对于变长类型<code>VARCHAR(M)</code>来说，这种类型表示能存储最多<code>M</code>个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是<code>M×W</code>。</li>
<li>假设它实际存储的字符串占用的字节数是<code>L</code>。</li>
</ol>
<p>所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：</p>
<ul>
<li>
<p>如果<code>M×W &lt;= 255</code>，那么使用1个字节来表示真正字符串占用的字节数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs !">也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>如果<code>M×W &gt; 255</code>，则分为两种情况：</p>
<ul>
<li>如果<code>L &lt;= 127</code>，则用1个字节来表示真正字符串占用的字节数。</li>
<li>如果<code>L &gt; 127</code>，则用2个字节来表示真正字符串占用的字节数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？设计InnoDB的大叔使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。<br><br>对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中（我们后边会唠叨），在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>总结一下就是说：<strong>如果该可变字段允许存储的最大字节数（<code>M×W</code>）超过255字节并且真实存储的字节数（<code>L</code>）超过127字节，则使用2个字节，否则使用1个字节。</strong></p>
<p>另外需要注意的一点是，变长字段长度列表中只存储值为 <em><strong>非NULL</strong></em> 的列内容占用的长度，值为 <em><strong>NULL</strong></em> 的列的长度是不储存的 。也就是说对于第二条记录来说，因为<code>c4</code>列的值为<code>NULL</code>，所以第二条记录的<code>变长字段长度列表</code>只需要存储<code>c1</code>和<code>c2</code>列的长度即可。其中<code>c1</code>列存储的值为<code>'eeee'</code>，占用的字节数为<code>4</code>，<code>c2</code>列存储的值为<code>'fff'</code>，占用的字节数为<code>3</code>。数字<code>4</code>可以用1个字节表示，<code>3</code>也可以用1个字节表示，所以整个<code>变长字段长度列表</code>共需2个字节。填充完<code>变长字段长度列表</code>的两条记录的对比图如下：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e8fe4ee6b0~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9grq2b2jok1062t8tov21lqjbj.png-42.6kB">
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。<br></code></pre></td></tr></table></figure>
<h5 id="NULL值列表">NULL值列表</h5>
<p>我们知道表中的某些列可能存储<code>NULL</code>值，如果把这些<code>NULL</code>值都放到<code>记录的真实数据</code>中存储会很占地方，所以<code>Compact</code>行格式把这些值为<code>NULL</code>的列统一管理起来，存储到<code>NULL</code>值列表中，它的处理过程是这样的：</p>
<ol>
<li>
<p>首先统计表中允许存储<code>NULL</code>的列有哪些。</p>
<p>我们前边说过，主键列、被<code>NOT NULL</code>修饰的列都是不可以存储<code>NULL</code>值的，所以在统计的时候不会把这些列算进去。比方说表<code>record_format_demo</code>的3个列<code>c1</code>、<code>c3</code>、<code>c4</code>都是允许存储<code>NULL</code>值的，而<code>c2</code>列是被<code>NOT NULL</code>修饰，不允许存储<code>NULL</code>值。</p>
</li>
<li>
<p>如果表中没有允许存储 <em><strong>NULL</strong></em> 的列，则 <em>NULL值列表</em> 也不存在了，否则将每个允许存储<code>NULL</code>的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：</p>
<ul>
<li>二进制位的值为<code>1</code>时，代表该列的值为<code>NULL</code>。</li>
<li>二进制位的值为<code>0</code>时，代表该列的值不为<code>NULL</code>。</li>
</ul>
<p>因为表<code>record_format_demo</code>有3个值允许为<code>NULL</code>的列，所以这3个列和二进制位的对应关系就是这样：</p>
</li>
</ol>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9018133f7~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9g88mtt1tj51ua1qh51vjo12pg5k.png-10.4kB">
<ol>
<li>
<p>再一次强调，二进制位按照列的顺序逆序排列，所以第一个列<code>c1</code>和最后一个二进制位对应。</p>
</li>
<li>
<p><code>MySQL</code>规定<code>NULL值列表</code>必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补<code>0</code>。</p>
<p>表<code>record_format_demo</code>只有3个值允许为<code>NULL</code>的列，对应3个二进制位，不足一个字节，所以在字节的高位补<code>0</code>，效果就是这样：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e901669f45~tplv-t2oaga2asx-watermark.awebp" alt="image_1c9g8g27b1bdlu7t187emsc46s61.png-19.4kB"></p>
<p>以此类推，如果一个表中有9个允许为<code>NULL</code>，那这个记录的<code>NULL</code>值列表部分就需要2个字节来表示了。</p>
</li>
</ol>
<p>知道了规则之后，我们再返回头看表<code>record_format_demo</code>中的两条记录中的<code>NULL值列表</code>应该怎么储存。因为只有<code>c1</code>、<code>c3</code>、<code>c4</code>这3个列允许存储<code>NULL</code>值，所以所有记录的<code>NULL值列表</code>只需要一个字节。</p>
<ul>
<li>
<p>对于第一条记录来说，<code>c1</code>、<code>c3</code>、<code>c4</code>这3个列的值都不为<code>NULL</code>，所以它们对应的二进制位都是<code>0</code>，画个图就是这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e901befeac~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9g8m05b19ge1c8v2bf163djre6e.png-21.5kB"> 所以第一条记录的`NULL值列表`用十六进制表示就是：`0x00`。
</li>
<li>
<p>对于第二条记录来说，<code>c1</code>、<code>c3</code>、<code>c4</code>这3个列中<code>c3</code>和<code>c4</code>的值都为<code>NULL</code>，所以这3个列对应的二进制位的情况就是：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e944a8af0c~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9g8ps5c1snv1bhj3m48151sfl6r.png-20.6kB">
<p>所以第二条记录的<code>NULL值列表</code>用十六进制表示就是：<code>0x06</code>。</p>
</li>
</ul>
<p>所以这两条记录在填充了<code>NULL值列表</code>后的示意图就是这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e95903144f~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9grs9m4co8134u1t2rjhm1q6rc0.png-39kB">
<h5 id="记录头信息">记录头信息</h5>
<p>除了<code>变长字段长度列表</code>、<code>NULL值列表</code>之外，还有一个用于描述记录的<code>记录头信息</code>，它是由固定的<code>5</code>个字节组成。<code>5</code>个字节也就是<code>40</code>个二进制位，不同的位代表不同的意思，如图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e97718ef01~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9geiglj1ah31meo80ci8n1eli8f.png-29.5kB">
<p>这些二进制位代表的详细信息如下表：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>预留位1</code></td>
<td><code>1</code></td>
<td>没有使用</td>
</tr>
<tr>
<td><code>预留位2</code></td>
<td><code>1</code></td>
<td>没有使用</td>
</tr>
<tr>
<td><code>delete_mask</code></td>
<td><code>1</code></td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td><code>min_rec_mask</code></td>
<td><code>1</code></td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td><code>n_owned</code></td>
<td><code>4</code></td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td><code>heap_no</code></td>
<td><code>13</code></td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td><code>record_type</code></td>
<td><code>3</code></td>
<td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td>
</tr>
<tr>
<td><code>next_record</code></td>
<td><code>16</code></td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody>
</table>
<p>大家不要被这么多的属性和陌生的概念给吓着，我这里只是为了内容的完整性把这些位代表的意思都写了出来，现在没必要把它们的意思都记住，记住也没啥用，现在只需要看一遍混个脸熟，等之后用到这些属性的时候我们再回过头来看。</p>
<p>因为我们并不清楚这些属性详细的用法，所以这里就不分析各个属性值是怎么产生的了，之后我们遇到会详细看的。所以我们现在直接看一下<code>record_format_demo</code>中的两条记录的<code>头信息</code>分别是什么：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/17075b82cb070959~tplv-t2oaga2asx-watermark.awebp" class="" title="img">
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>再一次强调，大家如果看不懂记录头信息里各个位代表的概念千万别纠结，我们后边会说的～<br></code></pre></td></tr></table></figure>
<h4 id="记录的真实数据">记录的真实数据</h4>
<p>对于<code>record_format_demo</code>表来说，<code>记录的真实数据</code>除了<code>c1</code>、<code>c2</code>、<code>c3</code>、<code>c4</code>这几个我们自己定义的列的数据以外，<code>MySQL</code>会为每个记录默认的添加一些列（也称为<code>隐藏列</code>），具体的列如下：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>row_id</code></td>
<td>否</td>
<td><code>6</code>字节</td>
<td>行ID，唯一标识一条记录</td>
</tr>
<tr>
<td><code>transaction_id</code></td>
<td>是</td>
<td><code>6</code>字节</td>
<td>事务ID</td>
</tr>
<tr>
<td><code>roll_pointer</code></td>
<td>是</td>
<td><code>7</code>字节</td>
<td>回滚指针</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，我们为了美观才写成了row_id、transaction_id和roll_pointer。<br></code></pre></td></tr></table></figure>
<p>这里需要提一下<code>InnoDB</code>表对主键的生成策略：优**先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个<code>Unique</code>键作为主键，如果表中连<code>Unique</code>键都没有定义的话，则<code>InnoDB</code>会为表默认添加一个名为<code>row_id</code>的隐藏列作为主键。**所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 <em><strong>transaction_id</strong></em> 和 <em><strong>roll_pointer</strong></em> 这两个列，但是 <em><strong>row_id</strong></em> 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心，<code>InnoDB</code>存储引擎会自己帮我们生成的。</p>
<p>因为表<code>record_format_demo</code>并没有定义主键，所以<code>MySQL</code>服务器会为每条记录增加上述的3个列。现在看一下加上<code>记录的真实数据</code>的两个记录长什么样吧：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e973b70372~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9h256f9nke14311adhtu61ie2dn.png-92kB">
<p>看这个图的时候我们需要注意几点：</p>
<ol>
<li>表<code>record_format_demo</code>使用的是<code>ascii</code>字符集，所以<code>0x61616161</code>就表示字符串<code>'aaaa'</code>，<code>0x626262</code>就表示字符串<code>'bbb'</code>，以此类推。</li>
<li>注意第1条记录中<code>c3</code>列的值，它是<code>CHAR(10)</code>类型的，它实际存储的字符串是：<code>'cc'</code>，而<code>ascii</code>字符集中的字节表示是<code>'0x6363'</code>，虽然表示这个字符串只占用了2个字节，但整个<code>c3</code>列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用空格字符填充，空格字符在<code>ascii</code>字符集的表示就是<code>0x20</code>。</li>
<li>注意第2条记录中<code>c3</code>和<code>c4</code>列的值都为<code>NULL</code>，它们被存储在了前边的<code>NULL值列表</code>处，在记录的真实数据处就不再冗余存储，从而节省存储空间。</li>
</ol>
<h4 id="CHAR-M-列的存储格式">CHAR(M)列的存储格式</h4>
<p><code>record_format_demo</code>表的<code>c1</code>、<code>c2</code>、<code>c4</code>列的类型是<code>VARCHAR(10)</code>，而<code>c3</code>列的类型是<code>CHAR(10)</code>，我们说在<code>Compact</code>行格式下只会把变长类型的列的长度逆序存到<code>变长字段长度列表</code>中，就像这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e985c8d9a7~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9jdkga71kegkjs14o111ov1ce3kn.png-12.5kB">
<p>但是这只是因为我们的<code>record_format_demo</code>表采用的是<code>ascii</code>字符集，这个字符集是一个定长字符集，也就是说表示一个字符采用固定的一个字节，如果采用变长的字符集（也就是表示一个字符需要的字节数不确定，比如<code>gbk</code>表示一个字符要1～2个字节、<code>utf8</code>表示一个字符要1~3个字节等）的话，<code>c3</code>列的长度也会被存储到<code>变长字段长度列表</code>中，比如我们修改一下<code>record_format_demo</code>表的字符集：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; ALTER TABLE record_format_demo MODIFY COLUMN c<span class="hljs-number">3</span> CHAR(<span class="hljs-number">10</span>) CHARACTER SET utf<span class="hljs-number">8</span>;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">2</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">02</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">2</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>修改该列字符集后记录的<code>变长字段长度列表</code>也发生了变化，如图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e973ff4fde~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9jeb6defgf1o981lgfciokjl4.png-43.1kB">
<p>这就意味着：<strong>对于 <em>CHAR(M)</em> 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。</strong></p>
<p>另外有一点还需要注意，变长字符集的<code>CHAR(M)</code>类型的列要求至少占用<code>M</code>个字节，而<code>VARCHAR(M)</code>却没有这个要求。比方说对于使用<code>utf8</code>字符集的<code>CHAR(10)</code>的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用<code>10</code>个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。（这里你感受到设计<code>Compact</code>行格式的大叔既想节省存储空间，又不想更新<code>CHAR(M)</code>类型的列产生碎片时的纠结心情了吧。）</p>
<h3 id="Redundant行格式">Redundant行格式</h3>
<p>其实知道了<code>Compact</code>行格式之后，其他的行格式就是依葫芦画瓢了。我们现在要介绍的<code>Redundant</code>行格式是<code>MySQL5.0</code>之前用的一种行格式，也就是说它已经非常老了，但是本着知识完整性的角度还是要提一下，大家乐呵乐呵的看就好。</p>
<p>画个图展示一下<code>Redundant</code>行格式的全貌：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e99a69ba3d~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9h896lcuqi16081qub1v8c12jkft.png-36.2kB">
<p>现在我们把表<code>record_format_demo</code>的行格式修改为<code>Redundant</code>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; ALTER TABLE record_format_demo ROW_FORMAT=Redundant;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">05</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>为了方便大家理解和节省篇幅，我们直接把表<code>record_format_demo</code>在<code>Redundant</code>行格式下的两条记录的真实存储数据提供出来，之后我们着重分析两种行格式的不同即可。</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9a5b7c847~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9h8tnav166c187m1nhap61153qgn.png-91.6kB">
<p>下边我们从各个方面看一下<code>Redundant</code>行格式有什么不同的地方：</p>
<ul>
<li>
<p>字段长度偏移列表</p>
<p>注意<code>Compact</code>行格式的开头是<code>变长字段长度列表</code>，而<code>Redundant</code>行格式的开头是<code>字段长度偏移列表</code>，与<code>变长字段长度列表</code>有两处不同：</p>
<ul>
<li>
<p>没有了变长两个字，意味着<code>Redundant</code>行格式会把该条记录中所有列（包括<code>隐藏列</code>）的长度信息都按照逆序存储到<code>字段长度偏移列表</code>。</p>
</li>
<li>
<p>多了个偏移两个字，这意味着计算列值长度的方式不像<code>Compact</code>行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。</p>
<p>比如第一条记录的<code>字段长度偏移列表</code>就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">25 </span><span class="hljs-number">24</span> <span class="hljs-number">1</span>A <span class="hljs-number">17</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span>C <span class="hljs-number">06</span><br></code></pre></td></tr></table></figure>
<p>因为它是逆序排放的，所以按照列的顺序排列就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">06 </span><span class="hljs-number">0</span>C <span class="hljs-number">13</span> <span class="hljs-number">17</span> <span class="hljs-number">1</span>A <span class="hljs-number">24</span> <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure>
<p>按照两个相邻数值的差值来计算各个列值的长度的意思就是：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">第一列(`row_id`)的长度就是 <span class="hljs-number">0</span>x06个字节，也就是<span class="hljs-number">6</span>个字节。<br><br>第二列(`transaction_id`)的长度就是 (<span class="hljs-number">0</span>x0C - <span class="hljs-number">0</span>x06)个字节，也就是<span class="hljs-number">6</span>个字节。<br><br>第三列(`roll_pointer`)的长度就是 (<span class="hljs-number">0</span>x13 - <span class="hljs-number">0</span>x0C)个字节，也就是<span class="hljs-number">7</span>个字节。<br><br>第四列(`c1`)的长度就是 (<span class="hljs-number">0</span>x17 - <span class="hljs-number">0</span>x13)个字节，也就是<span class="hljs-number">4</span>个字节。<br><br>第五列(`c2`)的长度就是 (<span class="hljs-number">0</span>x1A - <span class="hljs-number">0</span>x17)个字节，也就是<span class="hljs-number">3</span>个字节。<br><br>第六列(`c3`)的长度就是 (<span class="hljs-number">0</span>x24 - <span class="hljs-number">0</span>x1A)个字节，也就是<span class="hljs-number">10</span>个字节。<br><br>第七列(`c4`)的长度就是 (<span class="hljs-number">0</span>x25 - <span class="hljs-number">0</span>x24)个字节，也就是<span class="hljs-number">1</span>个字节。<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>记录头信息</p>
<p><code>Redundant</code>行格式的记录头信息占用<code>6</code>字节，<code>48</code>个二进制位，这些二进制位代表的意思如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>预留位1</code></td>
<td><code>1</code></td>
<td>没有使用</td>
</tr>
<tr>
<td><code>预留位2</code></td>
<td><code>1</code></td>
<td>没有使用</td>
</tr>
<tr>
<td><code>delete_mask</code></td>
<td><code>1</code></td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td><code>min_rec_mask</code></td>
<td><code>1</code></td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td><code>n_owned</code></td>
<td><code>4</code></td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td><code>heap_no</code></td>
<td><code>13</code></td>
<td>表示当前记录在页面堆的位置信息</td>
</tr>
<tr>
<td><code>n_field</code></td>
<td><code>10</code></td>
<td>表示记录中列的数量</td>
</tr>
<tr>
<td><code>1byte_offs_flag</code></td>
<td><code>1</code></td>
<td>标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的</td>
</tr>
<tr>
<td><code>next_record</code></td>
<td><code>16</code></td>
<td>表示下一条记录的绝对位置</td>
</tr>
</tbody>
</table>
<p>第一条记录中的头信息是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">0</span>F <span class="hljs-number">00</span> BC<br></code></pre></td></tr></table></figure>
<p>根据这六个字节可以计算出各个属性的值，如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">预留位1：0x00<br>预留位2：0x00<br><span class="hljs-section">delete_mask: 0x00</span><br><span class="hljs-section">min_rec_mask: 0x00</span><br><span class="hljs-section">n_owned: 0x00</span><br><span class="hljs-section">heap_no: 0x02</span><br><span class="hljs-section">n_field: 0x07</span><br><span class="hljs-section">1byte_offs_flag: 0x01</span><br><span class="hljs-section">next_record:0xBC</span><br></code></pre></td></tr></table></figure>
<p>与<code>Compact</code>行格式的记录头信息对比来看，有两处不同：</p>
<ul>
<li><code>Redundant</code>行格式多了<code>n_field</code>和<code>1byte_offs_flag</code>这两个属性。</li>
<li><code>Redundant</code>行格式没有<code>record_type</code>这个属性。</li>
</ul>
</li>
<li>
<p><code>1byte_offs_flag</code>的值是怎么选择的</p>
<p><code>字段长度偏移列表</code>实质上是存储每个列中的值占用的空间在<code>记录的真实数据</code>处结束的位置，还是拿<code>record_format_demo</code>第一条记录为例，<code>0x06</code>代表第一个列在<code>记录的真实数据</code>第6个字节处结束，<code>0x0C</code>代表第二个列在<code>记录的真实数据</code>第12个字节处结束，<code>0x13</code>代表第三个列在<code>记录的真实数据</code>第19个字节处结束，等等等等，最后一个列对应的偏移量值为<code>0x25</code>，也就意味着最后一个列在<code>记录的真实数据</code>第37个字节处结束，也就意味着整条记录的<code>真实数据</code>实际上占用<code>37</code>个字节。</p>
<p>我们前边说过每个列对应的偏移量可以占用1个字节或者2个字节来存储，那到底什么时候用1个字节，什么时候用2个字节呢？其实是根据该条<code>Redundant</code>行格式<code>记录的真实数据</code>占用的总大小来判断的：</p>
<ul>
<li>当记录的真实数据占用的字节数不大于127（十六进制<code>0x7F</code>，二进制<code>01111111</code>）时，每个列对应的偏移量占用1个字节。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>如果整个记录的真实数据占用的存储空间都不大于127个字节，那么每个列对应的偏移量值肯定也就不大于127，也就可以使用1个字节来表示喽。<br></code></pre></td></tr></table></figure>
<ul>
<li>当记录的真实数据占用的字节数大于127，但不大于32767（十六进制<code>0x7FFF</code>，二进制<code>0111111111111111</code>）时，每个列对应的偏移量占用2个字节。</li>
<li>有没有记录的真实数据大于32767的情况呢？有，不过此时的记录已经存放到了溢出页中，在本页中只保留前<code>768</code>个字节和20个字节的溢出页面地址（当然这20个字节中还记录了一些别的信息）。因为<code>字段长度偏移列表</code>处只需要记录每个列在本页面中的偏移就好了，所以每个列使用2个字节来存储偏移量就够了。</li>
</ul>
<p>大家可以看出来，设计<code>Redundant</code>行格式的大叔还是比较简单粗暴的，直接使用整个<code>记录的真实数据</code>长度来决定使用1个字节还是2个字节存储列对应的偏移量。只要整条记录的真实数据占用的存储空间大小大于127，即使第一个列的值占用存储空间小于127，那对不起，也需要使用2个字节来表示该列对应的偏移量。简单粗暴，就是这么简单粗暴（所以这种行格式有些过时了～）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>大家有没有疑惑，一个字节能表示的范围是0～255，为啥在记录的真实数据占用的存储空间大于127时就采用2个字节表示各个列的偏移量呢？稍安勿躁，后边马上揭晓。<br></code></pre></td></tr></table></figure>
<p>为了在解析记录时知道每个列的偏移量是使用1个字节还是2个字节表示的，设计<code>Redundant</code>行格式的大叔特意在<code>记录头信息</code>里放置了一个称之为<code>1byte_offs_flag</code>的属性：</p>
<ul>
<li>当它的值为1时，表明使用1个字节存储。</li>
<li>当它的值为0时，表明使用2个字节存储。</li>
</ul>
</li>
<li>
<p><code>Redundant</code>行格式中<code>NULL</code>值的处理</p>
<p>因为<code>Redundant</code>行格式并没有<code>NULL值列表</code>，所以设计<code>Redundant</code>行格式的大叔在<code>字段长度偏移列表</code>中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为<code>NULL</code>的依据，该比特位也可以被称之为<code>NULL比特位</code>。也就是说在解析一条记录的某个列时，首先看一下该列对应的偏移量的<code>NULL比特位</code>是不是为<code>1</code>，如果为<code>1</code>，那么该列的值就是<code>NULL</code>，否则不是<code>NULL</code>。</p>
<p>这也就解释了上边介绍为什么只要记录的真实数据大于127（十六进制<code>0x7F</code>，二进制<code>01111111</code>）时，就采用2个字节来表示一个列对应的偏移量，主要是第一个比特位是所谓的<code>NULL比特位</code>，用来标记该列的值是否为<code>NULL</code>。</p>
<p>但是还有一点要注意，对于值为<code>NULL</code>的列来说，该列的类型是否为定长类型决定了<code>NULL</code>值的实际存储方式，我们接下来分析一下<code>record_format_demo</code>表的第二条记录，它对应的<code>字段长度偏移列表</code>如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A4</span> A<span class="hljs-number">4</span> <span class="hljs-number">1</span>A <span class="hljs-number">17</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span>C <span class="hljs-number">06</span><br></code></pre></td></tr></table></figure>
<p>按照列的顺序排放就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">06 </span><span class="hljs-number">0</span>C <span class="hljs-number">13</span> <span class="hljs-number">17</span> <span class="hljs-number">1</span>A A4 A4<br></code></pre></td></tr></table></figure>
<p>我们分情况看一下：</p>
<ul>
<li>
<p>如果存储<code>NULL</code>值的字段是定长类型的，比方说<code>CHAR(M)</code>数据类型的，则<code>NULL</code>值也将占用记录的真实数据部分，并把该字段对应的数据使用<code>0x00</code>字节填充。</p>
<p>如图第二条记录的<code>c3</code>列的值是<code>NULL</code>，而<code>c3</code>列的类型是<code>CHAR(10)</code>，占用记录的真实数据部分10字节，所以我们看到在<code>Redundant</code>行格式中使用<code>0x00000000000000000000</code>来表示<code>NULL</code>值。</p>
<p>另外，<code>c3</code>列对应的偏移量为<code>0xA4</code>，它对应的二进制实际是：<code>10100100</code>，可以看到最高位为<code>1</code>，意味着该列的值是<code>NULL</code>。将最高位去掉后的值变成了<code>0100100</code>，对应的十进制值为<code>36</code>，而<code>c2</code>列对应的偏移量为<code>0x1A</code>，也就是十进制的<code>26</code>。<code>36 - 26 = 10</code>，也就是说最终<code>c3</code>列占用的存储空间为10个字节。</p>
</li>
<li>
<p>如果该存储<code>NULL</code>值的字段是变长数据类型的，则不在<code>记录的真实数据</code>处占用任何存储空间。</p>
<p>比如<code>record_format_demo</code>表的<code>c4</code>列是<code>VARCHAR(10)</code>类型的，<code>VARCHAR(10)</code>是一个变长数据类型，<code>c4</code>列对应的偏移量为<code>0xA4</code>，与<code>c3</code>列对应的偏移量相同，这也就意味着它的值也为<code>NULL</code>，将<code>0xA4</code>的最高位去掉后对应的十进制值也是<code>36</code>，<code>36 - 36 = 0</code>，也就意味着<code>c4</code>列本身不占用任何<code>记录的实际数据</code>处的空间。</p>
</li>
</ul>
</li>
</ul>
<p>除了以上的几点之外，<code>Redundant</code>行格式和<code>Compact</code>行格式还是大致相同的。</p>
<h4 id="CHAR-M-列的存储格式-2">CHAR(M)列的存储格式</h4>
<p>我们知道<code>Compact</code>行格式在<code>CHAR(M)</code>类型的列中存储数据的时候还挺麻烦，分变长字符集和定长字符集的情况，而在<code>Redundant</code>行格式中十分干脆，不管该列使用的字符集是啥，只要是使用<code>CHAR(M)</code>类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和<code>M</code>的乘积。比方说使用<code>utf8</code>字符集的<code>CHAR(10)</code>类型的列占用的真实数据空间始终为<code>30</code>个字节，使用<code>gbk</code>字符集的<code>CHAR(10)</code>类型的列占用的真实数据空间始终为<code>20</code>个字节。<strong>由此可以看出来，使用<code>Redundant</code>行格式的<code>CHAR(M)</code>类型的列是不会产生碎片的。</strong></p>
<h3 id="行溢出数据">行溢出数据</h3>
<h4 id="VARCHAR-M-最多能存储的数据">VARCHAR(M)最多能存储的数据</h4>
<p>我们知道对于<code>VARCHAR(M)</code>类型的列最多可以占用<code>65535</code>个字节。其中的<code>M</code>代表该类型最多存储的字符数量，如果我们使用<code>ascii</code>字符集的话，一个字符就代表一个字节，我们看看<code>VARCHAR(65535)</code>是否可用：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> varchar_size_demo(<br>    -&gt;     c <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">65535</span>)<br>    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;<br>ERROR <span class="hljs-number">1118</span> (<span class="hljs-number">42000</span>): <span class="hljs-keyword">Row</span> size too <span class="hljs-keyword">large</span>. The maximum <span class="hljs-keyword">row</span> size <span class="hljs-keyword">for</span> the used <span class="hljs-keyword">table</span> <span class="hljs-keyword">type</span>, <span class="hljs-keyword">not</span> counting BLOBs, <span class="hljs-keyword">is</span> <span class="hljs-number">65535.</span> This includes <span class="hljs-keyword">storage</span> overhead, <span class="hljs-keyword">check</span> the manual. You have <span class="hljs-keyword">to</span> change <span class="hljs-keyword">some</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">to</span> <span class="hljs-type">TEXT</span> <span class="hljs-keyword">or</span> BLOBs<br>mysql&gt;<br></code></pre></td></tr></table></figure>
<p>从报错信息里可以看出，<code>MySQL</code>对一条记录占用的最大存储空间是有限制的，除了<code>BLOB</code>或者<code>TEXT</code>类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过<code>65535</code>个字节。所以<code>MySQL</code>服务器建议我们把存储类型改为<code>TEXT</code>或者<code>BLOB</code>的类型。这个<code>65535</code>个字节除了列本身的数据之外，还包括一些其他的数据（<code>storage overhead</code>），比如说我们为了存储一个<code>VARCHAR(M)</code>类型的列，其实需要占用3部分存储空间：</p>
<ul>
<li>真实数据</li>
<li>真实数据占用字节的长度</li>
<li><code>NULL</code>值标识，如果该列有<code>NOT NULL</code>属性则可以没有这部分存储空间</li>
</ul>
<p>如果该<code>VARCHAR</code>类型的列没有<code>NOT NULL</code>属性，那最多只能存储<code>65532</code>个字节的数据，因为真实数据的长度可能占用2个字节，<code>NULL</code>值标识需要占用1个字节：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> varchar_size_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>      c <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">65532</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>Compact;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.02</span> sec)<br></code></pre></td></tr></table></figure>
<p>如果<code>VARCHAR</code>类型的列有<code>NOT NULL</code>属性，那最多只能存储<code>65533</code>个字节的数据，因为真实数据的长度可能占用2个字节，不需要<code>NULL</code>值标识：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> varchar_size_demo;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> varchar_size_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>      c <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">65533</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>Compact;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.02</span> sec)<br></code></pre></td></tr></table></figure>
<p>如果<code>VARCHAR(M)</code>类型的列使用的不是<code>ascii</code>字符集，那会怎么样呢？来看一下：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs subunit">mysql&gt; DROP TABLE varchar_size_demo;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; CREATE TABLE varchar_size_demo(<br>    -&gt;       c VARCHAR(65532)<br>    -&gt; ) CHARSET=gbk ROW_FORMAT=Compact;<br><span class="hljs-keyword">ERROR </span>1074 (42000): Column length too big for column &#x27;c&#x27; (max = 32767); use BLOB or TEXT instead<br><br>mysql&gt; CREATE TABLE varchar_size_demo(<br>    -&gt;       c VARCHAR(65532)<br>    -&gt; ) CHARSET=utf8 ROW_FORMAT=Compact;<br><span class="hljs-keyword">ERROR </span>1074 (42000): Column length too big for column &#x27;c&#x27; (max = 21845); use BLOB or TEXT instead<br></code></pre></td></tr></table></figure>
<p>从执行结果中可以看出，如果<code>VARCHAR(M)</code>类型的列使用的不是<code>ascii</code>字符集，那<code>M</code>的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为<code>NULL</code>的情况下，<code>gbk</code>字符集表示一个字符最多需要<code>2</code>个字节，那在该字符集下，<code>M</code>的最大取值就是<code>32766</code>（也就是：65532/2），也就是说最多能存储<code>32766</code>个字符；<code>utf8</code>字符集表示一个字符最多需要<code>3</code>个字节，那在该字符集下，<code>M</code>的最大取值就是<code>21844</code>，就是说最多能存储<code>21844</code>（也就是：65532/3）个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！<br></code></pre></td></tr></table></figure>
<h4 id="记录中的数据太多产生的溢出">记录中的数据太多产生的溢出</h4>
<p>我们以<code>ascii</code>字符集下的<code>varchar_size_demo</code>表为例，插入一条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> varchar_size_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>       c <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">65532</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>Compact;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> varchar_size_demo(c) <span class="hljs-keyword">VALUES</span>(REPEAT(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">65532</span>));<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>
<p>其中的<code>REPEAT('a', 65532)</code>是一个函数调用，它表示生成一个把字符<code>'a'</code>重复<code>65532</code>次的字符串。前边说过，<code>MySQL</code>中磁盘和内存交互的基本单位是<code>页</code>，也就是说<code>MySQL</code>是以<code>页</code>为基本单位来管理存储空间的，我们的记录都会被分配到某个<code>页</code>中存储。而一个页的大小一般是<code>16KB</code>，也就是<code>16384</code>字节，而一个<code>VARCHAR(M)</code>类型的列就最多可以存储<code>65532</code>个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</p>
<p>在<code>Compact</code>和<code>Redundant</code>行格式中，对于占用存储空间非常大的列，在<code>记录的真实数据</code>处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后<code>记录的真实数据</code>处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9aab47ea5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d48e3imu1vcp5rsh8cg0b1o169.png-149kB">
<p>从图中可以看出来，**对于<code>Compact</code>和<code>Redundant</code>行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前<code>768</code>个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做<code>行溢出</code>，**存储超出<code>768</code>字节的那些页面也被称为<code>溢出页</code>。画一个简图就是这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9a5d5637a~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1conbskr7apj19ns1d194vs1buo1t.png-35.8kB">
<p>最后需要注意的是，不只是 <em><strong>VARCHAR(M)</strong></em> 类型的列，其他的 <em><strong>TEXT</strong></em>、<em><strong>BLOB</strong></em> 类型的列在存储数据非常多的时候也会发生<code>行溢出</code>。</p>
<h4 id="行溢出的临界点">行溢出的临界点</h4>
<p>那发生<code>行溢出</code>的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生<code>行溢出</code>？</p>
<p><strong><code>MySQL</code>中规定一个页中至少存放两行记录</strong>，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。以上边的<code>varchar_size_demo</code>表为例，它只有一个列<code>c</code>，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会<code>行溢出</code>的现象呢？这得分析一下页中的空间都是如何利用的。</p>
<ul>
<li>
<p>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要<code>132</code>个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。</p>
</li>
<li>
<p>每个记录需要的额外信息是<code>27</code>字节。</p>
<p>这27个字节包括下边这些部分：</p>
<ul>
<li>2个字节用于存储真实数据的长度</li>
<li>1个字节用于存储列是否是NULL值</li>
<li>5个字节大小的头信息</li>
<li>6个字节的<code>row_id</code>列</li>
<li>6个字节的<code>transaction_id</code>列</li>
<li>7个字节的<code>roll_pointer</code>列</li>
</ul>
</li>
</ul>
<p>假设一个列中存储的数据字节数为n，设计<code>MySQL</code>的大叔规定如果该列不发生溢出的现象，就需要满足下边这个式子：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">132 </span>+ <span class="hljs-number">2</span>×(<span class="hljs-number">27</span> + n) &lt; <span class="hljs-number">16384</span><br></code></pre></td></tr></table></figure>
<p>求解这个式子得出的解是：<code>n &lt; 8099</code>。也就是说如果一个列中存储的数据小于<code>8099</code>个字节，那么该列就不会成为<code>溢出列</code>，否则该列就需要成为<code>溢出列</code>。不过这个<code>8099</code>个字节的结论只是针对只有一个列的<code>varchar_size_demo</code>表来说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：<strong>你不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为<code>溢出列</code>。</strong></p>
<h3 id="Dynamic和Compressed行格式">Dynamic和Compressed行格式</h3>
<p>下边要介绍另外两个行格式，<code>Dynamic</code>和<code>Compressed</code>行格式，我现在使用的<code>MySQL</code>版本是<code>5.7</code>，它的默认行格式就是<code>Dynamic</code>，这俩行格式和<code>Compact</code>行格式挺像，只不过在处理<code>行溢出</code>数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9b2c2b71e~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1conbtnmr1sg1hao1nf41pi1eb72a.png-29.9kB">
<p><code>Compressed</code>行格式和<code>Dynamic</code>不同的一点是，<code>Compressed</code>行格式会采用压缩算法对页面进行压缩，以节省空间。</p>
<h2 id="总结-2">总结</h2>
<ol>
<li>
<p>页是<code>MySQL</code>中磁盘和内存交互的基本单位，也是<code>MySQL</code>是管理存储空间的基本单位。</p>
</li>
<li>
<p>指定和修改行格式的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="hljs-operator">=</span>行格式名称<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 ROW_FORMAT<span class="hljs-operator">=</span>行格式名称<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>InnoDB</code>目前定义了4种行格式</p>
<ul>
<li>
<p>COMPACT行格式</p>
<p>具体组成如图： <img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e8fafc21aa~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB"></p>
</li>
<li>
<p>Redundant行格式</p>
<p>具体组成如图： <img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9ca9cbeb5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctfppb4c1cng1m8718l91760jde9.png-36.2kB"></p>
</li>
<li>
<p>Dynamic和Compressed行格式</p>
<p>这两种行格式类似于<code>COMPACT行格式</code>，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。</p>
<p>另外，<code>Compressed</code>行格式会采用压缩算法对页面进行压缩。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>一个页一般是<code>16KB</code>，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为<code>行溢出</code>。</li>
</ul>
<h1>5.InnoDB数据页结构</h1>
<h2 id="不同类型的页简介">不同类型的页简介</h2>
<p><strong>前边我们简单提了一下<code>页</code>的概念，它是<code>InnoDB</code>管理存储空间的基本单位，一个页的大小一般是<code>16KB</code>。</strong><code>InnoDB</code>为了不同的目的而设计了许多种不同类型的<code>页</code>，比如存放表空间头部信息的页，存放<code>Insert Buffer</code>信息的页，存放<code>INODE</code>信息的页，存放<code>undo</code>日志信息的页等等等等。当然了，如果我说的这些名词你一个都没有听过，就当我放了个屁吧～ 不过这没有一毛钱关系，我们今儿个也不准备说这些类型的页，我们聚焦的是那些存放我们表中记录的那种类型的页，官方称这种存放记录的页为索引（<code>INDEX</code>）页，鉴于我们还没有了解过索引是个什么东西，而这些表中的记录就是我们日常口中所称的<code>数据</code>，所以目前还是叫这种存放记录的页为<code>数据页</code>吧。</p>
<h2 id="数据页结构的快速浏览">数据页结构的快速浏览</h2>
<p>数据页代表的这块<code>16KB</code>大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16f13ee1e2dfac7c~tplv-t2oaga2asx-watermark.awebp" class="" title="img">
<p>从图中可以看出，一个<code>InnoDB</code>数据页的存储空间大致被划分成了<code>7</code>个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。下边我们用表格的方式来大致描述一下这7个部分都存储一些啥内容（快速的瞅一眼就行了，后边会详细唠叨的）：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>File Header</code></td>
<td>文件头部</td>
<td><code>38</code>字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td><code>Page Header</code></td>
<td>页面头部</td>
<td><code>56</code>字节</td>
<td>数据页专有的一些信息</td>
</tr>
<tr>
<td><code>Infimum + Supremum</code></td>
<td>最小记录和最大记录</td>
<td><code>26</code>字节</td>
<td>两个虚拟的行记录</td>
</tr>
<tr>
<td><code>User Records</code></td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td><code>Free Space</code></td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td><code>Page Directory</code></td>
<td>页面目录</td>
<td>不确定</td>
<td>页中的某些记录的相对位置</td>
</tr>
<tr>
<td><code>File Trailer</code></td>
<td>文件尾部</td>
<td><code>8</code>字节</td>
<td>校验页是否完整</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>我们接下来并不打算按照页中各个部分的出现顺序来依次介绍它们，因为各个部分中会出现很多大家目前不理解的概念，这会打击各位读文章的信心与兴趣，希望各位能接受这种拍摄手法～<br></code></pre></td></tr></table></figure>
<h2 id="记录在页中的存储">记录在页中的存储</h2>
<p>在页的7个组成部分中，我们自己存储的记录会按照我们指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有<code>User Records</code>这个部分，每当我们插入一条记录，都会从<code>Free Space</code>部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到<code>User Records</code>部分，当<code>Free Space</code>部分的空间全部被<code>User Records</code>部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c0fe86555ed~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cosvi1in9st476cdqfki1n39m.png-133.8kB">
<p>为了更好的管理在<code>User Records</code>中的这些记录，<code>InnoDB</code>可费了一番力气呢，在哪费力气了呢？不就是把记录按照指定的行格式一条一条摆在<code>User Records</code>部分么？其实这话还得从记录行格式的<code>记录头信息</code>中说起。</p>
<h3 id="记录头信息的秘密">记录头信息的秘密</h3>
<p>为了故事的顺利发展，我们先创建一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> page_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c1 <span class="hljs-type">INT</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c2 <span class="hljs-type">INT</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10000</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">PRIMARY</span> KEY (c1)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>Compact;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure>
<p>这个新创建的<code>page_demo</code>表有3个列，其中<code>c1</code>和<code>c2</code>列是用来存储整数的，<code>c3</code>列是用来存储字符串的。需要注意的是，我们把 <em><strong>c1</strong></em> 列指定为主键，所以在具体的行格式中InnoDB就没必要为我们去创建那个所谓的 <em><strong>row_id</strong></em> 隐藏列了。而且我们为这个表指定了<code>ascii</code>字符集以及<code>Compact</code>的行格式。所以这个表中记录的行格式示意图就是这样的：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c0feca77be3~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9o2eib2vl11qnf1dfl1d2lco313.png-76.4kB">
<p>从图中可以看到，我们特意把<code>记录头信息</code>的5个字节的数据给标出来了，说明它很重要，我们再次先把这些<code>记录头信息</code>中各个属性的大体意思浏览一下（我们目前使用<code>Compact</code>行格式进行演示）：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>预留位1</code></td>
<td><code>1</code></td>
<td>没有使用</td>
</tr>
<tr>
<td><code>预留位2</code></td>
<td><code>1</code></td>
<td>没有使用</td>
</tr>
<tr>
<td><code>delete_mask</code></td>
<td><code>1</code></td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td><code>min_rec_mask</code></td>
<td><code>1</code></td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td><code>n_owned</code></td>
<td><code>4</code></td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td><code>heap_no</code></td>
<td><code>13</code></td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td><code>record_type</code></td>
<td><code>3</code></td>
<td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td>
</tr>
<tr>
<td><code>next_record</code></td>
<td><code>16</code></td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody>
</table>
<p>由于我们现在主要在唠叨<code>记录头信息</code>的作用，所以为了大家理解上的方便，我们只在<code>page_demo</code>表的行格式演示图中画出有关的头信息属性以及<code>c1</code>、<code>c2</code>、<code>c3</code>列的信息（其他信息没画不代表它们不存在啊，只是为了理解上的方便在图中省略了～），简化后的行格式示意图就是这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c0ff1ae5364~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9o52lt41v5c7vk1vm91fsm174b2d.png-49.5kB">
<p>下边我们试着向<code>page_demo</code>表中插入几条记录：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; INSERT INTO page_demo VALUES(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, &#x27;aaaa&#x27;), (<span class="hljs-number">2</span>, <span class="hljs-number">200</span>, &#x27;bbbb&#x27;), (<span class="hljs-number">3</span>, <span class="hljs-number">300</span>, &#x27;cccc&#x27;), (<span class="hljs-number">4</span>, <span class="hljs-number">400</span>, &#x27;dddd&#x27;);<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">4</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">4</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>为了方便大家分析这些记录在<code>页</code>的<code>User Records</code>部分中是怎么表示的，我把记录中头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c0ff83f9870~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9qs0j281knc16hc1hqsgj01v0o2c.png-82.8kB">
<p>看这个图的时候需要注意一下，各条记录在<code>User Records</code>中存储的时候并没有空隙，这里只是为了大家观看方便才把每条记录单独画在一行中。我们对照着这个图来看看记录头信息中的各个属性是啥意思：</p>
<ul>
<li>
<p><code>delete_mask</code></p>
<p>这个属性标记着当前记录是否被删除，占用1个二进制位，值为<code>0</code>的时候代表记录并没有被删除，为<code>1</code>的时候代表记录被删除掉了。</p>
<p>啥？被删除的记录还在<code>页</code>中么？是的，摆在台面上的和背地里做的可能大相径庭，你以为它删除了，可它还在真实的磁盘上[摊手]（忽然想起冠希～）。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的<code>垃圾链表</code>，在这个链表中的记录占用的空间称之为所谓的<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>将这个delete_mask位设置为1和将被删除的记录加入到垃圾链表中其实是两个阶段，我们后边在介绍事务的时候会详细唠叨删除操作的详细过程，稍安勿躁。<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>min_rec_mask</code></p>
<p>B+树的每层非叶子节点中的最小记录都会添加该标记，什么是个<code>B+</code>树？什么是个非叶子节点？好吧，等会再聊这个问题。反正我们自己插入的四条记录的<code>min_rec_mask</code>值都是<code>0</code>，意味着它们都不是<code>B+</code>树的非叶子节点中的最小记录。</p>
</li>
<li>
<p><code>n_owned</code></p>
<p>这个暂时保密，稍后它是主角～</p>
</li>
<li>
<p><code>heap_no</code></p>
<p>这个属性表示当前记录在本<code>页</code>中的位置，从图中可以看出来，我们插入的4条记录在本<code>页</code>中的位置分别是：<code>2</code>、<code>3</code>、<code>4</code>、<code>5</code>。是不是少了点啥？是的，怎么不见<code>heap_no</code>值为<code>0</code>和<code>1</code>的记录呢？</p>
<p>这其实是设计<code>InnoDB</code>的大叔们玩的一个小把戏，他们自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为<code>伪记录</code>或者<code>虚拟记录</code>。这两个伪记录一个代表<code>最小记录</code>，一个代表<code>最大记录</code>，等一下哈~，记录可以比大小么？</p>
<p>是的，记录也可以比大小，对于一条完整的记录来说，比较记录的大小就是比较<code>主键</code>的大小。比方说我们插入的4行记录的主键值分别是：<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>，这也就意味着这4条记录的大小从小到大依次递增。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>请注意我强调了对于`一条完整的记录`来说，比较记录的大小就相当于比的是主键的大小。后边我们还会介绍只存储一条记录的部分列的情况，敬请期待～<br></code></pre></td></tr></table></figure>
<p>但是不管我们向<code>页</code>中插入了多少自己的记录，设计<code>InnoDB</code>的大叔们都规定他们定义的两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的<code>记录头信息</code>和8字节大小的一个固定的部分组成的，如图所示</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c100ff0ccc2~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9ra45eam7t1mil9o1h3ucqdhv.png-50.4kB">
<p>由于这两条记录不是我们自己定义的记录，所以它们并不存放在<code>页</code>的<code>User Records</code>部分，他们被单独放在一个称为<code>Infimum + Supremum</code>的部分，如图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c10773d8cee~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9qs1mn2t3j1nt344116nk15uf2p.png-119.7kB">
<p>从图中我们可以看出来，最小记录和最大记录的<code>heap_no</code>值分别是<code>0</code>和<code>1</code>，也就是说它们的位置最靠前。</p>
</li>
<li>
<p><code>record_type</code></p>
<p>这个属性表示当前记录的类型，一共有4种类型的记录，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的<code>record_type</code>值都是<code>0</code>，而最小记录和最大记录的<code>record_type</code>值分别为<code>2</code>和<code>3</code>。</p>
<p>至于<code>record_type</code>为<code>1</code>的情况，我们之后在说索引的时候会重点强调的。</p>
</li>
<li>
<p><code>next_record</code></p>
<p>这玩意儿非常重要，它**表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。**比方说第一条记录的<code>next_record</code>值为<code>32</code>，意味着从第一条记录的真实数据的地址处向后找<code>32</code>个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个<code>链表</code>，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，<code>下一条记录</code>指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 <em><strong>Infimum记录（也就是最小记录）</strong></em> 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 <em><strong>Supremum记录（也就是最大记录）</strong></em> ，为了更形象的表示一下这个<code>next_record</code>起到的作用，我们用箭头来替代一下<code>next_record</code>中的地址偏移量：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c1084c440b4~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cot1r96210ph1jng1td41ouj85c13.png-120.5kB">
<p>从图中可以看出来，我们的记录按照主键从小到大的顺序形成了一个单链表。<code>最大记录</code>的<code>next_record</code>的值为<code>0</code>，这也就是说最大记录是没有<code>下一条记录</code>了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; DELETE FROM page_demo WHERE c<span class="hljs-number">1</span> = <span class="hljs-number">2</span>;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">1</span> row affected (<span class="hljs-number">0</span>.<span class="hljs-number">02</span> sec)<br></code></pre></td></tr></table></figure>
<p>删掉第2条记录后的示意图就是：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c108ee1da43~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cul8slbp1om0p31b3u1be11gco9.png-119.6kB">
<p>从图中可以看出来，删除第2条记录前后主要发生了这些变化：</p>
<ul>
<li>第2条记录并没有从存储空间中移除，而是把该条记录的<code>delete_mask</code>值设置为<code>1</code>。</li>
<li>第2条记录的<code>next_record</code>值变为了0，意味着该记录没有下一条记录了。</li>
<li>第1条记录的<code>next_record</code>指向了第3条记录。</li>
<li>还有一点你可能忽略了，就是<code>最大记录</code>的<code>n_owned</code>值从<code>5</code>变成了<code>4</code>，关于这一点的变化我们稍后会详细说明的。</li>
</ul>
<p>所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>你会不会觉得next_record这个指针有点儿怪，为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？<br><br>因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表、NULL值列表中的信息都是逆序存放，这样可以使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。当然如果你看不懂这句话的话就不要勉强了，果断跳过～<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>再来看一个有意思的事情，因为主键值为<code>2</code>的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中，会发生什么事呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> page_demo <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;bbbb&#x27;</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>
<p>我们看一下记录的存储情况：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c109f25d55d~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cot2j9n94a511jd15clrrfp6p1t.png-137.8kB">
<p>从图中可以看到，<code>InnoDB</code>并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。<br></code></pre></td></tr></table></figure>
<h2 id="Page-Directory（页目录）">Page Directory（页目录）</h2>
<p>现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> page_demo <span class="hljs-keyword">WHERE</span> c1 = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>
<p>最笨的办法：从<code>Infimum</code>记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到[摊手]），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。</p>
<p>这个方法在页中存储的记录数量比较少的情况用起来也没啥问题，比方说现在我们的表里只有<code>4</code>条自己插入的记录，所以最多找<code>4</code>次就可以把所有记录都遍历一遍，但是如果一个页中存储了非常多的记录，这么查找对性能来说还是有损耗的，所以我们说这种遍历查找这是一个<code>笨</code>办法。但是设计<code>InnoDB</code>的大叔们是什么人，他们能用这么笨的办法么，当然是要设计一种更6的查找方式喽，他们从书的目录中找到了灵感。</p>
<p>我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计<code>InnoDB</code>的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：</p>
<ol>
<li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li>
<li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的<code>n_owned</code>属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li>
<li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近<code>页</code>的尾部的地方，这个地方就是所谓的<code>Page Directory</code>，也就是<code>页目录</code>（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为<code>槽</code>（英文名：<code>Slot</code>），所以这个页面目录就是由<code>槽</code>组成的。</li>
</ol>
<p>比方说现在的<code>page_demo</code>表中正常的记录共有6条，<code>InnoDB</code>会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c10c57164a6~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1couapvdmb5mvm1i0l5m0vcb2a.png-128.2kB">
<p>从这个图中我们需要注意这么几点：</p>
<ul>
<li>现在<code>页目录</code>部分中有两个槽，也就意味着我们的记录被分成了两个组，<code>槽1</code>中的值是<code>112</code>，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；<code>槽0</code>中的值是<code>99</code>，代表最小记录的地址偏移量。</li>
<li>注意最小和最大记录的头信息中的<code>n_owned</code>属性
<ul>
<li>最小记录的<code>n_owned</code>值为<code>1</code>，这就代表着以最小记录结尾的这个分组中只有<code>1</code>条记录，也就是最小记录本身。</li>
<li>最大记录的<code>n_owned</code>值为<code>5</code>，这就代表着以最大记录结尾的这个分组中只有<code>5</code>条记录，包括最大记录本身还有我们自己插入的<code>4</code>条记录。</li>
</ul>
</li>
</ul>
<p><code>99</code>和<code>112</code>这样的地址偏移量很不直观，我们用箭头指向的方式替代数字</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c10f2e61ad5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1couate3jr19gc18gl1cva1fcg34.png-100.8kB">
<p>这样看就顺眼多了嘛！为什么最小记录的<code>n_owned</code>值为1，而最大记录的<code>n_owned</code>值为<code>5</code>呢，这里头有什么猫腻么？</p>
<p>是的，设计<code>InnoDB</code>的大叔们对每个分组中的记录条数是有规定的：<strong>对于最小记录所在的分组只能有 <em>1</em> 条记录，最大记录所在的分组拥有的记录条数只能在 <em>1~8</em> 条之间，剩下的分组中记录的条数范围只能在是 <em>4~8</em> 条之间</strong>。所以分组是按照下边的步骤进行的：</p>
<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li>
<li>之后每插入一条记录，都会从<code>页目录</code>中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的<code>n_owned</code>值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li>
<li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在<code>页目录</code>中新增一个<code>槽</code>来记录这个新增分组中最大的那条记录的偏移量。</li>
</ul>
<p>由于现在<code>page_demo</code>表中的记录太少，无法演示添加了<code>页目录</code>之后加快查找速度的过程，所以再往<code>page_demo</code>表中添加一些记录：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; INSERT INTO page_demo VALUES(<span class="hljs-number">5</span>, <span class="hljs-number">500</span>, &#x27;eeee&#x27;), (<span class="hljs-number">6</span>, <span class="hljs-number">600</span>, &#x27;ffff&#x27;), (<span class="hljs-number">7</span>, <span class="hljs-number">700</span>, &#x27;gggg&#x27;), (<span class="hljs-number">8</span>, <span class="hljs-number">800</span>, &#x27;hhhh&#x27;), (<span class="hljs-number">9</span>, <span class="hljs-number">900</span>, &#x27;iiii&#x27;), (<span class="hljs-number">10</span>, <span class="hljs-number">1000</span>, &#x27;jjjj&#x27;), (<span class="hljs-number">11</span>, <span class="hljs-number">1100</span>, &#x27;kkkk&#x27;), (<span class="hljs-number">12</span>, <span class="hljs-number">1200</span>, &#x27;llll&#x27;), (<span class="hljs-number">13</span>, <span class="hljs-number">1300</span>, &#x27;mmmm&#x27;), (<span class="hljs-number">14</span>, <span class="hljs-number">1400</span>, &#x27;nnnn&#x27;), (<span class="hljs-number">15</span>, <span class="hljs-number">1500</span>, &#x27;oooo&#x27;), (<span class="hljs-number">16</span>, <span class="hljs-number">1600</span>, &#x27;pppp&#x27;);<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">12</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">12</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>哈，我们一口气又往表中添加了12条记录，现在页里边就一共有18条记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c10e3449897~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d6g64af2sgj1816ktl1q22dehp.png-189.1kB">
<p>因为把16条记录的全部信息都画在一张图里太占地方，让人眼花缭乱的，所以只保留了用户记录头信息中的<code>n_owned</code>和<code>next_record</code>属性，也省略了各个记录之间的箭头，我没画不等于没有啊！现在看怎么从这个<code>页目录</code>中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的<code>二分法</code>来进行快速查找。5个槽的编号分别是：<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>，所以初始情况下最低的槽就是<code>low=0</code>，最高的槽就是<code>high=4</code>。比方说我们想找主键值为<code>6</code>的记录，过程是这样的：</p>
<ol>
<li>计算中间槽的位置：<code>(0+4)/2=2</code>，所以查看<code>槽2</code>对应记录的主键值为<code>8</code>，又因为<code>8 &gt; 6</code>，所以设置<code>high=2</code>，<code>low</code>保持不变。</li>
<li>重新计算中间槽的位置：<code>(0+2)/2=1</code>，所以查看<code>槽1</code>对应的主键值为<code>4</code>，又因为<code>4 &lt; 6</code>，所以设置<code>low=1</code>，<code>high</code>保持不变。</li>
<li>因为<code>high - low</code>的值为1，所以确定主键值为<code>6</code>的记录在<code>槽2</code>对应的组中。此刻我们需要找到<code>槽2</code>中主键值最小的那条记录，然后沿着单向链表遍历<code>槽2</code>中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里<code>槽2</code>对应的记录是主键值为<code>8</code>的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到<code>槽1</code>对应的记录（主键值为<code>4</code>），该条记录的下一条记录就是<code>槽2</code>中主键值最小的记录，该记录的主键值为<code>5</code>。所以我们可以从这条主键值为<code>5</code>的记录出发，遍历<code>槽2</code>中的各条记录，直到找到主键值为<code>6</code>的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li>
</ol>
<p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p>
<ol>
<li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li>
<li>通过记录的<code>next_record</code>属性遍历该槽所在的组中的各个记录。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>如果你不知道二分法是个什么东西，找个基础算法书看看吧。什么？算法书写的看不懂？等我～<br></code></pre></td></tr></table></figure>
<h2 id="Page-Header（页面头部）">Page Header（页面头部）</h2>
<p>设计<code>InnoDB</code>的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫<code>Page Header</code>的部分，它是<code>页</code>结构的第二部分，这个部分占用固定的<code>56</code>个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PAGE_N_DIR_SLOTS</code></td>
<td><code>2</code>字节</td>
<td>在页目录中的槽数量</td>
</tr>
<tr>
<td><code>PAGE_HEAP_TOP</code></td>
<td><code>2</code>字节</td>
<td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td>
</tr>
<tr>
<td><code>PAGE_N_HEAP</code></td>
<td><code>2</code>字节</td>
<td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td>
</tr>
<tr>
<td><code>PAGE_FREE</code></td>
<td><code>2</code>字节</td>
<td>第一个已经标记为删除的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td>
</tr>
<tr>
<td><code>PAGE_GARBAGE</code></td>
<td><code>2</code>字节</td>
<td>已删除记录占用的字节数</td>
</tr>
<tr>
<td><code>PAGE_LAST_INSERT</code></td>
<td><code>2</code>字节</td>
<td>最后插入记录的位置</td>
</tr>
<tr>
<td><code>PAGE_DIRECTION</code></td>
<td><code>2</code>字节</td>
<td>记录插入的方向</td>
</tr>
<tr>
<td><code>PAGE_N_DIRECTION</code></td>
<td><code>2</code>字节</td>
<td>一个方向连续插入的记录数量</td>
</tr>
<tr>
<td><code>PAGE_N_RECS</code></td>
<td><code>2</code>字节</td>
<td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td>
</tr>
<tr>
<td><code>PAGE_MAX_TRX_ID</code></td>
<td><code>8</code>字节</td>
<td>修改当前页的最大事务ID，该值仅在二级索引中定义</td>
</tr>
<tr>
<td><code>PAGE_LEVEL</code></td>
<td><code>2</code>字节</td>
<td>当前页在B+树中所处的层级</td>
</tr>
<tr>
<td><code>PAGE_INDEX_ID</code></td>
<td><code>8</code>字节</td>
<td>索引ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td><code>PAGE_BTR_SEG_LEAF</code></td>
<td><code>10</code>字节</td>
<td>B+树叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
<tr>
<td><code>PAGE_BTR_SEG_TOP</code></td>
<td><code>10</code>字节</td>
<td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
</tbody>
</table>
<p>如果大家认真看过前边的文章，从<code>PAGE_N_DIR_SLOTS</code>到<code>PAGE_LAST_INSERT</code>以及<code>PAGE_N_RECS</code>的意思大家一定是清楚的，如果不清楚，对不起，你应该回头再看一遍前边的文章。剩下的状态信息看不明白不要着急，饭要一口一口吃，东西要一点一点学（一定要稍安勿躁哦，不要被这些名词吓到）。在这里我们先唠叨一下<code>PAGE_DIRECTION</code>和<code>PAGE_N_DIRECTION</code>的意思：</p>
<ul>
<li>
<p><code>PAGE_DIRECTION</code></p>
<p>假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是<code>PAGE_DIRECTION</code>。</p>
</li>
<li>
<p><code>PAGE_N_DIRECTION</code></p>
<p>假设连续几次插入新记录的方向都是一致的，<code>InnoDB</code>会把沿着同一个方向插入记录的条数记下来，这个条数就用<code>PAGE_N_DIRECTION</code>这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</p>
</li>
</ul>
<p>至于我们没提到的那些属性，我没说是因为现在不需要大家知道。不要着急，当我们学完了后边的内容，你再回头看，一切都是那么清晰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>说到这个有些东西后边我们学过后回头看就很清晰的事儿不禁让我想到了乔布斯在斯坦福大学的演讲，摆一下原文：<br><br>“You can&#x27;t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future.You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.”<br><br>上边这段话纯属心血来潮写的，大意是坚持做自己喜欢的事儿，你在做的时候可能并不能搞清楚这些事儿对自己之后的人生有啥影响，但当你一路走来回头看时，一切都是那么清晰，就像是命中注定的一样。上述内容跟MySQL毫无干系，请忽略～<br></code></pre></td></tr></table></figure>
<h2 id="File-Header（文件头部）">File Header（文件头部）</h2>
<p>上边唠叨的<code>Page Header</code>是专门针对<code>数据页</code>记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。我们现在描述的<code>File Header</code>针对各种类型的页都通用，也就是说不同类型的页都会以<code>File Header</code>作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁啦吧啦吧啦～ 这个部分占用固定的<code>38</code>个字节，是由下边这些内容组成的：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td>
<td><code>4</code>字节</td>
<td>页的校验和（checksum值）</td>
</tr>
<tr>
<td><code>FIL_PAGE_OFFSET</code></td>
<td><code>4</code>字节</td>
<td>页号</td>
</tr>
<tr>
<td><code>FIL_PAGE_PREV</code></td>
<td><code>4</code>字节</td>
<td>上一个页的页号</td>
</tr>
<tr>
<td><code>FIL_PAGE_NEXT</code></td>
<td><code>4</code>字节</td>
<td>下一个页的页号</td>
</tr>
<tr>
<td><code>FIL_PAGE_LSN</code></td>
<td><code>8</code>字节</td>
<td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE</code></td>
<td><code>2</code>字节</td>
<td>该页的类型</td>
</tr>
<tr>
<td><code>FIL_PAGE_FILE_FLUSH_LSN</code></td>
<td><code>8</code>字节</td>
<td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td>
</tr>
<tr>
<td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td>
<td><code>4</code>字节</td>
<td>页属于哪个表空间</td>
</tr>
</tbody>
</table>
<p>对照着这个表格，我们看几个目前比较重要的部分：</p>
<ul>
<li>
<p><code>FIL_PAGE_SPACE_OR_CHKSUM</code></p>
<p>这个代表当前页面的校验和（checksum）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为<code>校验和</code>。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</p>
</li>
<li>
<p><code>FIL_PAGE_OFFSET</code></p>
<p>每一个<code>页</code>都有一个单独的页号，就跟你的身份证号码一样，<code>InnoDB</code>通过页号来可以唯一定位一个<code>页</code>。</p>
</li>
<li>
<p><code>FIL_PAGE_TYPE</code></p>
<p>这个代表当前<code>页</code>的类型，我们前边说过，<code>InnoDB</code>为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的<code>数据页</code>，其实还有很多别的类型的页，具体如下表：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>十六进制</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FIL_PAGE_TYPE_ALLOCATED</code></td>
<td>0x0000</td>
<td>最新分配，还没使用</td>
</tr>
<tr>
<td><code>FIL_PAGE_UNDO_LOG</code></td>
<td>0x0002</td>
<td>Undo日志页</td>
</tr>
<tr>
<td><code>FIL_PAGE_INODE</code></td>
<td>0x0003</td>
<td>段信息节点</td>
</tr>
<tr>
<td><code>FIL_PAGE_IBUF_FREE_LIST</code></td>
<td>0x0004</td>
<td>Insert Buffer空闲列表</td>
</tr>
<tr>
<td><code>FIL_PAGE_IBUF_BITMAP</code></td>
<td>0x0005</td>
<td>Insert Buffer位图</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE_SYS</code></td>
<td>0x0006</td>
<td>系统页</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE_TRX_SYS</code></td>
<td>0x0007</td>
<td>事务系统数据</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE_FSP_HDR</code></td>
<td>0x0008</td>
<td>表空间头部信息</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE_XDES</code></td>
<td>0x0009</td>
<td>扩展描述页</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE_BLOB</code></td>
<td>0x000A</td>
<td>溢出页</td>
</tr>
<tr>
<td><code>FIL_PAGE_INDEX</code></td>
<td>0x45BF</td>
<td>索引页，也就是我们所说的<code>数据页</code></td>
</tr>
</tbody>
</table>
<p>我们存放记录的数据页的类型其实是<code>FIL_PAGE_INDEX</code>，也就是所谓的<code>索引页</code>。至于啥是个索引，且听下回分解～</p>
</li>
<li>
<p><code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code></p>
<p>我们前边强调过，<code>InnoDB</code>都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），<code>InnoDB</code>可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们本集中唠叨的<code>数据页</code>（也就是类型为<code>FIL_PAGE_INDEX</code>的页）是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c10eb9d61ce~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ca00fhg418pl1f1a1iav1uo3aou9.png-90.9kB">
</li>
</ul>
<p>关于<code>File Header</code>的其他属性我们暂时用不到，等用到的时候再提哈～</p>
<h2 id="File-Trailer">File Trailer</h2>
<p>我们知道<code>InnoDB</code>存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以<code>页</code>为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计<code>InnoDB</code>的大叔们在每个页的尾部都加了一个<code>File Trailer</code>部分，这个部分由<code>8</code>个字节组成，可以分成2个小部分：</p>
<ul>
<li>
<p>前4个字节代表页的校验和</p>
<p>这个部分是和<code>File Header</code>中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为<code>File Header</code>在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在<code>File Header</code>中的校验和就代表着已经修改过的页，而在<code>File Trailer</code>中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p>
</li>
<li>
<p>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）</p>
<p>这个部分也是为了校验页的完整性的，只不过我们目前还没说<code>LSN</code>是个什么意思，所以大家可以先不用管这个属性。</p>
</li>
</ul>
<p>这个<code>File Trailer</code>与<code>File Header</code>类似，都是所有类型的页通用的。</p>
<h2 id="总结-3">总结</h2>
<ol>
<li>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做<code>数据页</code>。</li>
<li>一个数据页可以被大致划分为7个部分，分别是
<ul>
<li><code>File Header</code>，表示页的一些通用信息，占固定的38字节。</li>
<li><code>Page Header</code>，表示数据页专有的一些信息，占固定的56个字节。</li>
<li><code>Infimum + Supremum</code>，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的<code>26</code>个字节。</li>
<li><code>User Records</code>：真实存储我们插入的记录的部分，大小不固定。</li>
<li><code>Free Space</code>：页中尚未使用的部分，大小不确定。</li>
<li><code>Page Directory</code>：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。</li>
<li><code>File Trailer</code>：用于检验页是否完整的部分，占用固定的8个字节。</li>
</ul>
</li>
<li>每个记录的头信息中都有一个<code>next_record</code>属性，从而使页中的所有记录串联成一个<code>单链表</code>。</li>
<li><code>InnoDB</code>会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个<code>槽</code>，存放在<code>Page Directory</code>中，所以在一个页中根据主键查找记录是非常快的，分为两步：
<ul>
<li>通过二分法确定该记录所在的槽。</li>
<li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li>
</ul>
</li>
<li>每个数据页的<code>File Header</code>部分都有上一个和下一个页的编号，所以所有的数据页会组成一个<code>双链表</code>。</li>
<li>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的<code>LSN</code>值，如果首部和尾部的校验和和<code>LSN</code>值校验不成功的话，就说明同步过程出现了问题。</li>
</ol>
<h1>6.B+树索引</h1>
<p>前边我们详细唠叨了<code>InnoDB</code>数据页的7个组成部分，知道了各个数据页可以组成一个<code>双向链表</code>，而每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边儿的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在<code>页目录</code>中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录（如果你对这段话有一丁点儿疑惑，那么接下来的部分不适合你，返回去看一下数据页结构吧）。页和记录的关系示意图如下：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1b8eafbb4~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cov976plf2u1j3g1jp8serjc616.png-87.7kB">
<p>其中页a、页b、页c … 页n 这些页可以不在物理结构上相连，只要通过双向链表相关联即可。</p>
<h2 id="没有索引的查找">没有索引的查找</h2>
<p>本集的主题是<code>索引</code>，在正式介绍<code>索引</code>之前，我们需要了解一下没有索引的时候是怎么查找记录的。为了方便大家理解，我们下边先只唠叨搜索条件为对某个列精确匹配的情况，所谓精确匹配，就是搜索条件中用等于<code>=</code>连接起的表达式，比如这样：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> [列名列表] <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 列名 = xxx;<br></code></pre></td></tr></table></figure>
<h3 id="在一个页中的查找">在一个页中的查找</h3>
<p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li>
<p>以主键为搜索条件</p>
<p>这个查找过程我们已经很熟悉了，可以在<code>页目录</code>中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
</li>
<li>
<p>以其他列作为搜索条件</p>
<p>对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的<code>页目录</code>，所以我们无法通过二分法快速定位相应的<code>槽</code>。这种情况下只能从<code>最小记录</code>开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p>
</li>
</ul>
<h3 id="在很多页中查找">在很多页中查找</h3>
<p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p>
<ol>
<li>定位到记录所在的页。</li>
<li>从所在的页内中查找相应的记录。</li>
</ol>
<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的，如果一个表有一亿条记录，使用这种方式去查找记录那要等到猴年马月才能等到查找结果。所以祖国和人民都在期盼一种能高效完成搜索的方法，<code>索引</code>同志就要亮相登台了。</p>
<h2 id="索引">索引</h2>
<p>为了故事的顺利发展，我们先建一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> index_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c1 <span class="hljs-type">INT</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c2 <span class="hljs-type">INT</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c3 <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">PRIMARY</span> KEY(c1)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure>
<p>这个新建的<code>index_demo</code>表中有2个<code>INT</code>类型的列，1个<code>CHAR(1)</code>类型的列，而且我们规定了<code>c1</code>列为主键，这个表使用<code>Compact</code>行格式来实际存储记录的。为了我们理解上的方便，我们简化了一下<code>index_demo</code>表的行格式示意图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1ba8d05b2~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caac8jr7hhcld017gd1lch1n1m33.png-97.1kB">
<p>我们只在示意图里展示记录的这几个部分：</p>
<ul>
<li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录、<code>2</code>表示最小记录、<code>3</code>表示最大记录、<code>1</code>我们还没用过，等会再说～</li>
<li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。</li>
<li><code>各个列的值</code>：这里只记录在<code>index_demo</code>表中的三个列，分别是<code>c1</code>、<code>c2</code>和<code>c3</code>。</li>
<li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p>为了节省篇幅，我们之后的示意图中会把记录的<code>其他信息</code>这个部分省略掉，因为它占地方并且不会有什么观赏效果。另外，为了方便理解，我们觉得把记录竖着放看起来感觉更好，所以将记录格式示意图的<code>其他信息</code>去掉并把它竖起来的效果就是这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1b0cad198~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caacokob6ne1nv41meda0s7vk3g.png-68.1kB">
<p>把一些记录放到页里边的示意图就是：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1be0d43ce~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caadhc4g1pb7hk81fcd4vt1u6r3t.png-79.8kB">
<h3 id="一个简单的索引方案">一个简单的索引方案</h3>
<p>回到正题，我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 <em><strong>不得不</strong></em> 依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？还记得我们为根据主键值快速定位一条记录在页中的位置而设立的页目录么？我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完成下边这些事儿：</p>
<ul>
<li>
<p>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</p>
<p>为了故事的顺利发展，我们这里需要做一个假设：假设我们的每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设之后我们向<code>index_demo</code>表插入3条记录：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; INSERT INTO index_demo VALUES(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, &#x27;u&#x27;), (<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, &#x27;d&#x27;), (<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, &#x27;y&#x27;);<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">3</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">01</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">3</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1b5a6e2af~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caaf26411d51bq7jtrvesr04a.png-29.5kB">
<p>从图中可以看出来，<code>index_demo</code>表中的3条记录都被插入到了编号为<code>10</code>的数据页中了。此时我们再来插入一条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> index_demo <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure>
<p>因为<code>页10</code>最多只能放3条记录，所以我们不得不再分配一个新页：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1b581b013~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caafbcj1qpo1ad2j8q1ci4136s4n.png-44.5kB">
<p>咦？怎么分配的页号是<code>28</code>呀，不应该是<code>11</code>么？再次强调一遍，新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。它们只是通过维护着上一个页和下一个页的编号而建立了链表关系。另外，<code>页10</code>中用户记录最大的主键值是<code>5</code>，而<code>页28</code>中有一条记录的主键值是<code>4</code>，因为<code>5 &gt; 4</code>，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为<code>4</code>的记录的时候需要伴随着一次记录移动，也就是把主键值为<code>5</code>的记录移动到<code>页28</code>中，然后再把主键值为<code>4</code>的记录插入到<code>页10</code>中，这个过程的示意图如下：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2641f1c47~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caafkq3h1akv1mde14h2kjul6554.png-96.9kB">
<p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为<code>页分裂</code>。</p>
</li>
<li>
<p>给所有的页建立一个目录项。</p>
<p>由于数据页的编号可能并不是连续的，所以在向<code>index_demo</code>表中插入许多条记录后，可能是这样的效果：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd27e1f3cf3~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cab9u9midn61fgq1mi58j0gadm.png-65.7kB">
<p>因为这些<code>16KB</code>的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：</p>
<ul>
<li>页的用户记录中最小的主键值，我们用<code>key</code>来表示。</li>
<li>页号，我们用<code>page_no</code>表示。</li>
</ul>
<p>所以我们为上边几个页做好的目录就像这样子：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd282d6b9b9~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caba0afo11fa1cli1nu070m16bg1j.png-119.1kB">
<p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为<code>20</code>的记录，具体查找过程分两步：</p>
<ol>
<li>先从目录项中根据二分法快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 <code>12 &lt; 20 &lt; 209</code>），它对应的页是<code>页9</code>。</li>
<li>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</li>
</ol>
</li>
</ul>
<p>至此，针对数据页做的简易目录就搞定了。不过忘了说了，这个<code>目录</code>有一个别名，称为<code>索引</code>。</p>
<h3 id="InnoDB中的索引方案">InnoDB中的索引方案</h3>
<p>上边之所以称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储，但是这样做有几个问题：</p>
<ul>
<li><code>InnoDB</code>是使用页来作为管理存储空间的基本单位，也就是最多能保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li>
<li>我们时常会对记录进行增删，假设我们把<code>页28</code>中的记录都删除了，<code>页28</code>也就没有存在的必要了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把<code>目录项2</code>后的目录项都向前移动一下，这种牵一发而动全身的设计不是什么好主意～</li>
</ul>
<p>所以，设计<code>InnoDB</code>的大叔们需要一种可以灵活管理所有<code>目录项</code>的方式。他们灵光乍现，忽然发现这些<code>目录项</code>其实长得跟我们的用户记录差不多，只不过<code>目录项</code>中的两个列是<code>主键</code>和<code>页号</code>而已，所以他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。那<code>InnoDB</code>怎么区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>呢？别忘了记录头信息里的<code>record_type</code>属性，它的各个取值代表的意思如下：</p>
<ul>
<li><code>0</code>：普通的用户记录</li>
<li><code>1</code>：目录项记录</li>
<li><code>2</code>：最小记录</li>
<li><code>3</code>：最大记录</li>
</ul>
<p>哈哈，原来这个值为<code>1</code>的<code>record_type</code>是这个意思呀，我们把前边使用到的目录项放到数据页中的样子就是这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd295fd42b5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caahuomf15m11e5k19v1bf21inq9.png-145.9kB">
<p>从图中可以看出来，我们新分配了一个编号为<code>30</code>的页来专门存储<code>目录项记录</code>。这里再次强调一遍<code>目录项记录</code>和普通的<code>用户记录</code>的不同点：</p>
<ul>
<li><code>目录项记录</code>的<code>record_type</code>值是1，而普通用户记录的<code>record_type</code>值是0。</li>
<li><code>目录项记录</code>只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有<code>InnoDB</code>自己添加的隐藏列。</li>
<li>还记得我们之前在唠叨记录头信息的时候说过一个叫<code>min_rec_mask</code>的属性么，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li>
</ul>
<p>除了上述几点外，这两者就没啥差别了，它们用的是一样的数据页（页面类型都是<code>0x45BF</code>，这个属性在<code>File Header</code>中，忘了的话可以翻到前边的文章看），页的组成结构也是一样一样的（就是我们前边介绍过的7个部分），都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ol>
<li>先到存储<code>目录项记录</code>的页，也就是页<code>30</code>中通过二分法快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以定位到对应的记录所在的页就是<code>页9</code>。</li>
<li>再到存储用户记录的<code>页9</code>中根据二分法快速定位到主键值为<code>20</code>的用户记录。</li>
</ol>
<p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的<code>目录项记录</code>，该咋办呢？</p>
<p>当然是再多整一个存储<code>目录项记录</code>的页喽～ 为了大家更好的理解新分配一个<code>目录项记录</code>页的过程，我们假设一个存储<code>目录项记录</code>的页最多只能存放4条<code>目录项记录</code>（请注意是假设哦，真实情况下可以存放好多条的），所以如果此时我们再向上图中插入一条主键值为<code>320</code>的用户记录的话，那就需要分配一个新的存储<code>目录项记录</code>的页喽：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd29ebc7a4c~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cacabsrh17a5133q1otf725gi92q.png-135.7kB">
<p>从图中可以看出，我们插入了一条主键值为<code>320</code>的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了<code>页31</code>。</li>
<li>因为原先存储<code>目录项记录</code>的<code>页30</code>的容量已满（我们前边假设只能存储4条<code>目录项记录</code>），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li>
</ul>
<p>现在因为存储<code>目录项记录</code>的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p>
<ol>
<li>
<p>确定<code>目录项记录</code>页</p>
<p>我们现在的存储<code>目录项记录</code>的页有两个，即<code>页30</code>和<code>页32</code>，又因为<code>页30</code>表示的目录项的主键值的范围是<code>[1, 320)</code>，<code>页32</code>表示的目录项的主键值不小于<code>320</code>，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p>
</li>
<li>
<p>通过<code>目录项记录</code>页确定用户记录真实所在的页。</p>
<p>在一个存储<code>目录项记录</code>的页中通过主键值定位一条目录项记录的方式说过了，不赘述了～</p>
</li>
<li>
<p>在真实存储用户记录的页中定位到具体的记录。</p>
<p>在一个存储用户记录的页中通过主键值定位一条用户记录的方式已经说过200遍了，你再不会我就，我就，我就求你到上一篇唠叨数据页结构的文章中多看几遍，求你了～</p>
</li>
</ol>
<p>那么问题来了，在这个查询步骤的第1步中我们需要定位存储<code>目录项记录</code>的页，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多存储<code>目录项记录</code>的页，那我们怎么根据主键值快速定位一个存储<code>目录项记录</code>的页呢？其实也简单，为这些存储<code>目录项记录</code>的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2a6c7a65f~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cacafpso19vpkik1j5rtrd17cm3a.png-158.1kB">
<p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表<code>页30</code>和<code>页32</code>，如果用户记录的主键值在<code>[1, 320)</code>之间，则到<code>页30</code>中查找更详细的<code>目录项记录</code>，如果主键值不小于<code>320</code>的话，就到<code>页32</code>中查找更详细的<code>目录项记录</code>。不过这张图好漂亮喔，随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2a6fb9126~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ca80gps314u9121u1rdp9r7md8cm.png-55.6kB">
<p>这玩意儿像不像一个倒过来的<code>树</code>呀，上头是树根，下头是树叶！其实这是一种组织数据的形式，或者说是一种数据结构，它的名称是<code>B+</code>树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>为啥叫`B+`呢，`B`树是个啥？喔对不起，这不是我们讨论的范围，你可以去找一本数据结构或算法的书来看。什么？数据结构的书看不懂？等我～<br></code></pre></td></tr></table></figure>
<p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到<code>B+</code>树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<code>叶子节点</code>或<code>叶节点</code>，其余用来存放<code>目录项</code>的节点称为<code>非叶子节点</code>或者<code>内节点</code>，其中<code>B+</code>树最上边的那个节点也称为<code>根节点</code>。</p>
<p>从图中可以看出来，一个<code>B+</code>树的节点其实可以分成好多层，设计<code>InnoDB</code>的大叔们为了讨论方便，规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前的讨论我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设，假设，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：</p>
<ul>
<li>如果<code>B+</code>树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li>
<li>如果<code>B+</code>树有2层，最多能存放<code>1000×100=100000</code>条记录。</li>
<li>如果<code>B+</code>树有3层，最多能存放<code>1000×1000×100=100000000</code>条记录。</li>
<li>如果<code>B+</code>树有4层，最多能存放<code>1000×1000×1000×100=100000000000</code>条记录。哇咔咔～这么多的记录！！！</li>
</ul>
<p>你的表里能存放<code>100000000000</code>条记录么？所以一般情况下，我们用到的<code>B+</code>树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过二分法实现快速定位记录，这不是很牛么，哈哈！</p>
<h4 id="聚簇索引">聚簇索引</h4>
<p>我们上边介绍的<code>B+</code>树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p>
<ol>
<li>
<p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li>页内的记录是按照主键的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li>
</ul>
</li>
<li>
<p><code>B+</code>树的叶子节点存储的是完整的用户记录。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</li>
</ol>
<p>我们把具有这两种特性的<code>B+</code>树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种<code>聚簇索引</code>并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建（后边会介绍索引相关的语句），<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的索引即数据，数据即索引。</p>
<h4 id="二级索引">二级索引</h4>
<p>大家有木有发现，上边介绍的<code>聚簇索引</code>只能在搜索条件是主键值时才能发挥作用，因为<code>B+</code>树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？</p>
<p>不，我们可以多建几棵<code>B+</code>树，不同的<code>B+</code>树中的数据采用不同的排序规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一棵<code>B+</code>树，效果如下图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2a89adfa5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cactc8jg14j91likvmd1h8cn3o4h.png-161.6kB">
<p>这个<code>B+</code>树与上边介绍的聚簇索引有几处不同：</p>
<ul>
<li>使用记录<code>c2</code>列的大小进行记录和页的排序，这包括三个方面的含义：
<ul>
<li>页内的记录是按照<code>c2</code>列的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中记录的<code>c2</code>列大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的<code>c2</code>列大小顺序排成一个双向链表。</li>
</ul>
</li>
<li><code>B+</code>树的叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。</li>
<li>目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>c2列+页号</code>的搭配。</li>
</ul>
<p>所以如果我们现在想通过<code>c2</code>列的值查找某些记录的话就可以使用我们刚刚建好的这个<code>B+</code>树了。以查找<code>c2</code>列的值为<code>4</code>的记录为例，查找过程如下：</p>
<ol>
<li>
<p>确定<code>目录项记录</code>页</p>
<p>根据<code>根页面</code>，也就是<code>页44</code>，可以快速定位到<code>目录项记录</code>所在的页为<code>页42</code>（因为<code>2 &lt; 4 &lt; 9</code>）。</p>
</li>
<li>
<p>通过<code>目录项记录</code>页确定用户记录真实所在的页。</p>
<p>在<code>页42</code>中可以快速定位到实际存储用户记录的页，但是由于<code>c2</code>列并没有唯一性约束，所以<code>c2</code>列值为<code>4</code>的记录可能分布在多个数据页中，又因为<code>2 &lt; 4 ≤ 4</code>，所以确定实际存储用户记录的页在<code>页34</code>和<code>页35</code>中。</p>
</li>
<li>
<p>在真实存储用户记录的页中定位到具体的记录。</p>
<p>到<code>页34</code>和<code>页35</code>中定位到具体的记录。</p>
</li>
<li>
<p>但是这个<code>B+</code>树的叶子节点中的记录只存储了<code>c2</code>和<code>c1</code>（也就是<code>主键</code>）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</p>
</li>
</ol>
<p>各位各位，看到步骤4的操作了么？我们根据这个以<code>c2</code>列大小排序的<code>B+</code>树只能确定我们要查找记录的主键值，所以如果我们想根据<code>c2</code>列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程也被称为<code>回表</code>。也就是根据<code>c2</code>列的值查询一条完整的用户记录需要使用到<code>2</code>棵<code>B+</code>树！！！</p>
<p>为什么我们还需要一次<code>回表</code>操作呢？直接把完整的用户记录放到<code>叶子节点</code>不就好了么？你说的对，如果把完整的用户记录放到<code>叶子节点</code>是可以不用<code>回表</code>，但是太占地方了呀～相当于每建立一棵<code>B+</code>树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照<code>非主键列</code>建立的<code>B+</code>树需要一次<code>回表</code>操作才可以定位到完整的用户记录，所以这种<code>B+</code>树也被称为<code>二级索引</code>（英文名<code>secondary index</code>），或者<code>辅助索引</code>。由于我们使用的是<code>c2</code>列的大小作为<code>B+</code>树的排序规则，所以我们也称这个<code>B+</code>树为为c2列建立的索引。</p>
<h5 id="联合索引">联合索引</h5>
<p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让<code>B+</code>树按照<code>c2</code>和<code>c3</code>列的大小进行排序，这个包含两层含义：</p>
<ul>
<li>先把各个记录和页按照<code>c2</code>列进行排序。</li>
<li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li>
</ul>
<p>为<code>c2</code>和<code>c3</code>列建立的索引的示意图如下：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2b0b70d72~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d80rmun21al711ok1tvo1i161rnpp.png-172.2kB">
<p>如图所示，我们需要注意一下几点：</p>
<ul>
<li>每条<code>目录项记录</code>都由<code>c2</code>、<code>c3</code>、<code>页号</code>这三个部分组成，各条记录先按照<code>c2</code>列的值进行排序，如果记录的<code>c2</code>列相同，则按照<code>c3</code>列的值进行排序。</li>
<li><code>B+</code>树叶子节点处的用户记录由<code>c2</code>、<code>c3</code>和主键<code>c1</code>列组成。</li>
</ul>
<p>千万要注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立<code>联合索引</code>只会建立如上图一样的1棵<code>B+</code>树。</li>
<li>为c2和c3列分别建立索引会分别以<code>c2</code>和<code>c3</code>列的大小为排序规则建立2棵<code>B+</code>树。</li>
</ul>
<h3 id="InnoDB的B-树索引的注意事项">InnoDB的B+树索引的注意事项</h3>
<h4 id="根页面万年不动窝">根页面万年不动窝</h4>
<p>我们前边介绍<code>B+</code>树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上<code>B+</code>树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个<code>B+</code>树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个<code>B+</code>树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li>
<li>当<code>根节点</code>中的可用空间用完时继续插入记录，此时会将<code>根节点</code>中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程需要大家特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的<code>根节点</code>的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出<code>根节点</code>的页号，从而来访问这个索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>跟大家剧透一下，这个存储某个索引的根节点在哪个页面中的信息就是传说中的数据字典中的一项信息，关于更多数据字典的内容，后边会详细唠叨，别着急哈。<br></code></pre></td></tr></table></figure>
<h4 id="内节点中目录项记录的唯一性">内节点中目录项记录的唯一性</h4>
<p>我们知道<code>B+</code>树索引的内节点中目录项记录的内容是<code>索引列 + 页号</code>的搭配，但是这个搭配对于二级索引来说有点儿不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的：</p>
<table>
<thead>
<tr>
<th><code>c1</code></th>
<th><code>c2</code></th>
<th><code>c3</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>‘u’</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>‘d’</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>‘y’</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>‘a’</td>
</tr>
</tbody>
</table>
<p>如果二级索引中目录项记录的内容只是<code>索引列 + 页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的<code>B+</code>树应该长这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2c5b9ef01~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cp9vthl71h9n8091dkdjek16qg1j.png-58.6kB">
<p>如果我们想新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>'c'</code>，那么在修改这个为<code>c2</code>列建立的二级索引对应的<code>B+</code>树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的<code>c2</code>列的值都是<code>1</code>，而我们新插入的这条记录的<code>c2</code>列的值也是<code>1</code>，那我们这条新插入的记录到底应该放到<code>页4</code>中，还是应该放到<code>页5</code>中啊？答案是：对不起，懵逼了。</p>
<p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除<code>页号</code>这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录了，这样就能保证<code>B+</code>树每一层节点中各条目录项记录除<code>页号</code>这个字段外是唯一的，所以我们为<code>c2</code>列建立二级索引后的示意图实际上应该是这样子的：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2c92fbca0~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cpb919suginpp7lbgsk0147f20.png-58.6kB">
<p>这样我们再插入记录<code>(9, 1, 'c')</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 主键 + 页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为<code>B+</code>树同一层中不同目录项记录的<code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p>
<h4 id="一个页面最少存储2条记录">一个页面最少存储2条记录</h4>
<p>我们前边说过一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？逗我呢？所以<code>InnoDB</code>的一个数据页至少可以存放两条记录，这也是我们之前唠叨记录行格式的时候说过一个结论（我们当时依据这个结论推导了表中只有一个列时该列在不发生行溢出的情况下最多能存储多少字节，忘了的话回去看看吧）。</p>
<h3 id="MyISAM中的索引方案简单介绍">MyISAM中的索引方案简单介绍</h3>
<p>至此，我们介绍的都是<code>InnoDB</code>存储引擎中的索引方案，为了内容的完整性，以及各位可能在面试的时候遇到这类的问题，我们有必要再简单介绍一下<code>MyISAM</code>存储引擎中的索引方案。我们知道<code>InnoDB</code>中索引即数据，也就是聚簇索引的那棵<code>B+</code>树的叶子节点中已经把所有完整的用户记录都包含了，而<code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p>
<ul>
<li>
<p>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。</p>
<p><code>MyISAM</code>记录也需要记录头信息来存储一些额外数据，我们以上边唠叨过的<code>index_demo</code>表为例，看一下这个表中的记录使用<code>MyISAM</code>作为存储引擎在存储空间中的表示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2d0c5ad53~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cpc7go2o12t1ocd17nvr6msth9.png-58.9kB">
<p>由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。</p>
</li>
<li>
<p>使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<code>主键值 + 行号</code>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！</p>
<p>这一点和<code>InnoDB</code>是完全不相同的，在<code>InnoDB</code>存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着<code>MyISAM</code>中建立的索引相当于全部都是<code>二级索引</code>！</p>
</li>
<li>
<p>如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和<code>InnoDB</code>中的索引差不多，不过在叶子节点处存储的是<code>相应的列 + 行号</code>。这些索引也全部都是<code>二级索引</code>。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>MyISAM的行格式有定长记录格式（Static）、变长记录格式（Dynamic）、压缩记录格式（Compressed）。上边用到的index_demo表采用定长记录格式，也就是一条记录占用存储空间的大小是固定的，这样就可以轻松算出某条记录在数据文件中的地址偏移量。但是变长记录格式就不行了，MyISAM会直接在索引叶子节点处存储该条记录在数据文件中的地址偏移量。通过这个可以看出，MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里边儿找记录，虽然说也不慢，但还是比不上直接用地址去访问。<br><br>此处我们只是非常简要的介绍了一下MyISAM的索引，具体细节全拿出来又可以写一篇文章了。这里只是希望大家理解InnoDB中的索引即数据，数据即索引，而MyISAM中却是索引是索引、数据是数据。<br></code></pre></td></tr></table></figure>
<h3 id="MySQL中创建和删除索引的语句">MySQL中创建和删除索引的语句</h3>
<p>光顾着唠叨索引的原理了，那我们如何使用<code>MySQL</code>语句去建立这种索引呢？<code>InnoDB</code>和<code>MyISAM</code>会自动为主键或者声明为<code>UNIQUE</code>的列去自动建立<code>B+</code>树索引，但是如果我们想为其他的列建立索引就需要我们显式的去指明。为啥不自动为每个列都建立个索引呢？别忘了，每建立一个索引都会建立一棵<code>B+</code>树，每插入一条记录都要维护各个记录、数据页的排序关系，这是很费性能和存储空间的。</p>
<p>我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TALBE 表名 (<br>    各种列的信息 ··· , <br>    [<span class="hljs-keyword">KEY</span>|<span class="hljs-keyword">INDEX</span>] 索引名 (需要被索引的单个列或多个列)<br>)<br></code></pre></td></tr></table></figure>
<p>其中的<code>KEY</code>和<code>INDEX</code>是同义词，任意选用一个就可以。我们也可以在修改表结构的时候添加索引：</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">ALTER</span> <span class="hljs-meta">TABLE</span> 表名 <span class="hljs-meta">ADD</span> [<span class="hljs-meta">INDEX</span>|<span class="hljs-meta">KEY</span>] 索引名 (需要被索引的单个列或多个列);<br></code></pre></td></tr></table></figure>
<p>也可以在修改表结构的时候删除索引：</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">ALTER</span> <span class="hljs-meta">TABLE</span> 表名 <span class="hljs-meta">DROP</span> [<span class="hljs-meta">INDEX</span>|<span class="hljs-meta">KEY</span>] 索引名;<br></code></pre></td></tr></table></figure>
<p>比方说我们想在创建<code>index_demo</code>表的时候就为<code>c2</code>和<code>c3</code>列添加一个<code>联合索引</code>，可以这么写建表语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> index_demo(<br>    c1 <span class="hljs-type">INT</span>,<br>    c2 <span class="hljs-type">INT</span>,<br>    c3 <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY(c1),<br>    INDEX idx_c2_c3 (c2, c3)<br>);<br></code></pre></td></tr></table></figure>
<p>在这个建表语句中我们创建的索引名是<code>idx_c2_c3</code>，这个名称可以随便起，不过我们还是建议以<code>idx_</code>为前缀，后边跟着需要建立索引的列名，多个列名之间用下划线<code>_</code>分隔开。</p>
<p>如果我们想删除这个索引，可以这么写：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> index_demo <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> idx_c2_c3;<br></code></pre></td></tr></table></figure>
<h1>7.B+树索引的使用</h1>
<p>我们前边详细、详细又详细的唠叨了<code>InnoDB</code>存储引擎的<code>B+</code>树索引，我们必须熟悉下边这些结论：</p>
<ul>
<li>每个索引都对应一棵<code>B+</code>树，<code>B+</code>树分为好多层，最下边一层是叶子节点，其余的是内节点。所有<code>用户记录</code>都存储在<code>B+</code>树的叶子节点，所有<code>目录项记录</code>都存储在非叶节点。</li>
<li><code>InnoDB</code>存储引擎会自动为主键（如果没有它会自动帮我们添加）建立<code>聚簇索引</code>，聚簇索引的叶子节点包含完整的用户记录。</li>
<li>我们可以为自己感兴趣的列建立<code>二级索引</code>，<code>二级索引</code>的叶子节点包含的用户记录由<code>索引列 + 主键</code>组成，所以如果想通过<code>二级索引</code>来查找完整的用户记录的话，需要通过<code>回表</code>操作，也就是在通过<code>二级索引</code>找到主键值之后再到<code>聚簇索引</code>中查找完整的用户记录。</li>
<li><code>B+</code>树中<strong>每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表</strong>，而且每个<strong>页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表</strong>。如果是<code>联合索引</code>的话，则页面和记录先按照<code>联合索引</code>前边的列排序，如果该列值相同，再按照<code>联合索引</code>后边的列排序。</li>
<li>通过索引查找记录是从<code>B+</code>树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了<code>Page Directory</code>（页目录），所以在这些页面中的查找非常快。</li>
</ul>
<p>如果你读上边的几点结论有些任何一点点疑惑的话，那下边的内容不适合你，回过头先去看前边的内容去。</p>
<h2 id="索引的代价">索引的代价</h2>
<p>在熟悉了<code>B+</code>树索引原理之后，本篇文章的主题是唠叨如何更好的使用索引，虽然索引是个好东西，可不能乱建，在介绍如何更好的使用索引之前先要了解一下使用这玩意儿的代价，它在空间和时间上都会拖后腿：</p>
<ul>
<li>
<p>空间上的代价</p>
<p>这个是显而易见的，每建立一个索引都要为它建立一棵<code>B+</code>树，每一棵<code>B+</code>树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的<code>B+</code>树由许多数据页组成，那可是很大的一片存储空间呢。</p>
</li>
<li>
<p>时间上的代价</p>
<p>每次对表中的数据进行增、删、改操作时，都需要去修改各个<code>B+</code>树索引。而且我们讲过，<code>B+</code>树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的<code>B+</code>树都要进行相关的维护操作，这还能不给性能拖后腿么？</p>
</li>
</ul>
<p>所以说，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们先得学学这些索引在哪些条件下起作用的。</p>
<h2 id="B-树索引适用的条件">B+树索引适用的条件</h2>
<p>下边我们将唠叨许多种让<code>B+</code>树索引发挥最大效能的技巧和注意事项，不过大家要清楚，所有的技巧都是源自你对<code>B+</code>树索引本质的理解，所以如果你还不能保证对<code>B+</code>树索引充分的理解，那么再次建议回过头把前边的内容看完了再来，要不然读文章对你来说是一种折磨。首先，<code>B+</code>树索引并不是万能的，并不是所有的查询语句都能用到我们建立的索引。下边介绍几个我们可能使用<code>B+</code>树索引来进行查询的情况。为了故事的顺利发展，我们需要先创建一个表，这个表是用来存储人的一些基本信息的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> auto_increment,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    KEY idx_name_birthday_phone_number (name, birthday, phone_number)<br>);<br></code></pre></td></tr></table></figure>
<p>对于这个<code>person_info</code>表我们需要注意两点：</p>
<ul>
<li>表中的主键是<code>id</code>列，它存储一个自动递增的整数。所以<code>InnoDB</code>存储引擎会自动为<code>id</code>列建立聚簇索引。</li>
<li>我们额外定义了一个二级索引<code>idx_name_birthday_phone_number</code>，它是由3个列组成的联合索引。所以在这个索引对应的<code>B+</code>树的叶子节点处存储的用户记录只保留<code>name</code>、<code>birthday</code>、<code>phone_number</code>这三个列的值以及主键<code>id</code>的值，并不会保存<code>country</code>列的值。</li>
</ul>
<p>从这两点注意中我们可以再次看到，一个表中有多少索引就会建立多少棵<code>B+</code>树，<code>person_info</code>表会为聚簇索引和<code>idx_name_birthday_phone_number</code>索引建立2棵<code>B+</code>树。下边我们画一下索引<code>idx_name_birthday_phone_number</code>的示意图，不过既然我们已经掌握了<code>InnoDB</code>的<code>B+</code>树索引原理，那我们在画图的时候为了让图更加清晰，所以在省略一些不必要的部分，比如记录的额外信息，各页面的页号等等，其中内节点中目录项记录的页号信息我们用箭头来代替，在记录结构中只保留<code>name</code>、<code>birthday</code>、<code>phone_number</code>、<code>id</code>这四个列的真实数据值，所以示意图就长这样（留心的同学看出来了，这其实和《高性能MySQL》里举的例子的图差不多，我觉得这个例子特别好，所以就借鉴了一下）：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16db02bc665cf0b1~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1dmo2n5c11ij019unpjtpf21tdr9.png-121.1kB">
<p>为了方便大家理解，我们特意标明了哪些是内节点，哪些是叶子节点。再次强调一下，内节点中存储的是<code>目录项记录</code>，叶子节点中存储的是<code>用户记录</code>（由于不是聚簇索引，所以用户记录是不完整的，缺少<code>country</code>列的值）。从图中可以看出，这个<code>idx_name_birthday_phone_number</code>索引对应的<code>B+</code>树中页面和记录的排序方式就是这样的：</p>
<ul>
<li>先按照<code>name</code>列的值进行排序。</li>
<li>如果<code>name</code>列的值相同，则按照<code>birthday</code>列的值进行排序。</li>
<li>如果<code>birthday</code>列的值也相同，则按照<code>phone_number</code>的值进行排序。</li>
</ul>
<p>这个排序方式十分、特别、非常、巨、very very very重要，因为只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找。下边的内容都仰仗这个图了，大家对照着图理解。</p>
<h3 id="全值匹配">全值匹配</h3>
<p>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span> <span class="hljs-keyword">AND</span> phone_number = <span class="hljs-string">&#x27;15123983239&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>我们建立的<code>idx_name_birthday_phone_number</code>索引包含的3个列在这个查询语句中都展现出来了。大家可以想象一下这个查询过程：</p>
<ul>
<li>因为<code>B+</code>树的数据页和记录先是按照<code>name</code>列的值进行排序的，所以先可以很快定位<code>name</code>列的值是<code>Ashburn</code>的记录位置。</li>
<li>在<code>name</code>列相同的记录里又是按照<code>birthday</code>列的值进行排序的，所以在<code>name</code>列的值是<code>Ashburn</code>的记录里又可以快速定位<code>birthday</code>列的值是<code>'1990-09-27'</code>的记录。</li>
<li>如果很不幸，<code>name</code>和<code>birthday</code>列的值都是相同的，那记录是按照<code>phone_number</code>列的值排序的，所以联合索引中的三个列都可能被用到。</li>
</ul>
<p>有的同学也许有个疑问，<code>WHERE</code>子句中的几个搜索条件的顺序对查询结果有啥影响么？也就是说如果我们调换<code>name</code>、<code>birthday</code>、<code>phone_number</code>这几个搜索列的顺序对查询的执行过程有影响么？比方说写成下边这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span> <span class="hljs-keyword">AND</span> phone_number = <span class="hljs-string">&#x27;15123983239&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>答案是：没影响哈。<code>MySQL</code>有一个叫查询优化器的东东，会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。我们后边儿会有专门的章节来介绍查询优化器，敬请期待。</p>
<h3 id="匹配左边的列">匹配左边的列</h3>
<p>其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>或者包含多个左边的列也行：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>那为什么搜索条件中必须出现左边的列才可以使用到这个<code>B+</code>树索引呢？比如下边的语句就用不到这个<code>B+</code>树索引么？</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>是的，的确用不到，因为<code>B+</code>树的数据页和记录先是按照<code>name</code>列的值排序的，在<code>name</code>列的值相同的情况下才使用<code>birthday</code>列进行排序，也就是说<code>name</code>列的值不同的记录中<code>birthday</code>的值可能是无序的。而现在你跳过<code>name</code>列直接根据<code>birthday</code>的值去查找，臣妾做不到呀～ 那如果我就想在只使用<code>birthday</code>的值去通过<code>B+</code>树索引进行查找咋办呢？这好办，你再对<code>birthday</code>列建一个<code>B+</code>树索引就行了，创建索引的语法不用我唠叨了吧。</p>
<p>但是需要特别注意的一点是，如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列。比方说联合索引<code>idx_name_birthday_phone_number</code>中列的定义顺序是<code>name</code>、<code>birthday</code>、<code>phone_number</code>，如果我们的搜索条件中只有<code>name</code>和<code>phone_number</code>，而没有中间的<code>birthday</code>，比方说这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> phone_number = <span class="hljs-string">&#x27;15123983239&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>这样只能用到<code>name</code>列的索引，<code>birthday</code>和<code>phone_number</code>的索引就用不上了，因为<code>name</code>值相同的记录先按照<code>birthday</code>的值进行排序，<code>birthday</code>值相同的记录才按照<code>phone_number</code>值进行排序。</p>
<h3 id="匹配列前缀">匹配列前缀</h3>
<p>我们前边说过为某个列建立索引的意思其实就是在对应的<code>B+</code>树的记录中使用该列的值进行排序，比方说<code>person_info</code>表上建立的联合索引<code>idx_name_birthday_phone_number</code>会先用<code>name</code>列的值进行排序，所以这个联合索引对应的<code>B+</code>树中的记录的<code>name</code>列的排列就是这样的：</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">Aaron<br>Aaron<br><span class="hljs-meta">...</span><br>Aaron<br>Asa<br>Ashburn<br><span class="hljs-meta">...</span><br>Ashburn<br>Baird<br>Barlow<br><span class="hljs-meta">...</span><br>Barlow<br></code></pre></td></tr></table></figure>
<p>字符串排序的本质就是比较哪个字符串大一点儿，哪个字符串小一点，比较字符串大小就用到了该列的字符集和比较规则，这个我们前边儿唠叨过，就不多唠叨了。这里需要注意的是，一般的比较规则都是逐个比较字符的大小，也就是说我们比较两个字符串的大小的过程其实是这样的：</p>
<ul>
<li>先比较字符串的第一个字符，第一个字符小的那个字符串就比较小。</li>
<li>如果两个字符串的第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小。</li>
<li>如果两个字符串的第二个字符也相同，那就接着比较第三个字符，依此类推。</li>
</ul>
<p>所以一个排好序的字符串列其实有这样的特点：</p>
<ul>
<li>先按照字符串的第一个字符进行排序。</li>
<li>如果第一个字符相同再按照第二个字符进行排序。</li>
<li>如果第二个字符相同再按照第三个字符进行排序，依此类推。</li>
</ul>
<p>也就是说这些字符串的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的，比方说我们想查询名字以<code>'As'</code>开头的记录，那就可以这么写查询语句：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;As%&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%As%&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p><code>MySQL</code>就无法快速定位记录位置了，因为字符串中间有<code>'As'</code>的字符串并没有排好序，所以只能全表扫描了。有时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个<code>url</code>列，该列中存储了许多url：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------------+</span><br><span class="hljs-section">| url            |</span><br><span class="hljs-section">+----------------+</span><br>| www.baidu.com  |<br>| www.google.com |<br>| www.gov.cn     |<br>| ...            |<br><span class="hljs-section">| www.wto.org    |</span><br><span class="hljs-section">+----------------+</span><br></code></pre></td></tr></table></figure>
<p>假设已经对该<code>url</code>列创建了索引，如果我们想查询以<code>com</code>为后缀的网址的话可以这样写查询条件：<code>WHERE url LIKE '%com'</code>，但是这样的话无法使用该<code>url</code>列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存<code>url</code>列中的数据：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------------+</span><br><span class="hljs-section">| url            |</span><br><span class="hljs-section">+----------------+</span><br>| moc.udiab.www  |<br>| moc.elgoog.www |<br>| nc.vog.www     |<br>| ...            |<br><span class="hljs-section">| gro.otw.www    |</span><br><span class="hljs-section">+----------------+</span><br></code></pre></td></tr></table></figure>
<p>这样再查找以<code>com</code>为后缀的网址时搜索条件便可以这么写：<code>WHERE url LIKE 'moc%'</code>，这样就可以用到索引了。</p>
<h3 id="匹配范围值">匹配范围值</h3>
<p>回头看我们<code>idx_name_birthday_phone_number</code>索引的<code>B+</code>树示意图，所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>由于<code>B+</code>树中的数据页和记录是先按<code>name</code>列排序的，所以我们上边的查询过程其实是这样的：</p>
<ul>
<li>通过B+树在叶子节点中找到第一条<code>name</code>值大于<code>Asa</code>的二级索引记录，读取该记录的主键值进行回表操作，获得对应的聚簇索引记录后发送给客户端。</li>
<li>根据上一步找到的记录，沿着记录所在的链表向后查找（同一页面中的记录使用单向链表连接起来，数据页之间用双向链表连接起来）下一条二级索引记录，判断该记录是否符合name &lt; 'Barlow’条件，如果符合，则进行回表操作后发送至客户端。</li>
<li>重复上一步骤，直到某条二级索引记录不符合name &lt;'Barlow’条件为止。</li>
</ul>
<p>不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到<code>B+</code>树索引，比方说这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span> <span class="hljs-keyword">AND</span> birthday &gt; <span class="hljs-string">&#x27;1980-01-01&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>上边这个查询可以分成两个部分：</p>
<ol>
<li>通过条件<code>name &gt; 'Asa' AND name &lt; 'Barlow' </code>来对<code>name</code>进行范围，查找的结果可能有多条<code>name</code>值不同的记录，</li>
<li>对这些<code>name</code>值不同的记录继续通过<code>birthday &gt; '1980-01-01'</code>条件继续过滤。</li>
</ol>
<p>这样子对于联合索引<code>idx_name_birthday_phone_number</code>来说，只能用到<code>name</code>列的部分，而用不到<code>birthday</code>列的部分，因为只有<code>name</code>值相同的情况下才能用<code>birthday</code>列的值进行排序，而这个查询中通过<code>name</code>进行范围查找的记录中可能并不是按照<code>birthday</code>列进行排序的，所以在搜索条件中继续以<code>birthday</code>列进行查找时是用不到这个<code>B+</code>树索引的。</p>
<h3 id="精确匹配某一列并范围匹配另外一列">精确匹配某一列并范围匹配另外一列</h3>
<p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday &gt; <span class="hljs-string">&#x27;1980-01-01&#x27;</span> <span class="hljs-keyword">AND</span> birthday &lt; <span class="hljs-string">&#x27;2000-12-31&#x27;</span> <span class="hljs-keyword">AND</span> phone_number &gt; <span class="hljs-string">&#x27;15100000000&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>这个查询的条件可以分为3个部分：</p>
<ol>
<li><code>name = 'Ashburn'</code>，对<code>name</code>列进行精确查找，当然可以使用<code>B+</code>树索引了。</li>
<li><code>birthday &gt; '1980-01-01' AND birthday &lt; '2000-12-31'</code>，由于<code>name</code>列是精确查找，所以通过<code>name = 'Ashburn'</code>条件查找后得到的结果的<code>name</code>值都是相同的，它们会再按照<code>birthday</code>的值进行排序。所以此时对<code>birthday</code>列进行范围查找是可以用到<code>B+</code>树索引的。</li>
<li><code>phone_number &gt; '15100000000'</code>，通过<code>birthday</code>的范围查找的记录的<code>birthday</code>的值可能不同，所以这个条件无法再利用<code>B+</code>树索引了，只能遍历上一步查询得到的记录。</li>
</ol>
<p>同理，下边的查询也是可能用到这个<code>idx_name_birthday_phone_number</code>联合索引的：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday = <span class="hljs-string">&#x27;1980-01-01&#x27;</span> <span class="hljs-keyword">AND</span> phone_number &gt; <span class="hljs-string">&#x27;15100000000&#x27;</span>;<br></code></pre></td></tr></table></figure>
<h3 id="用于排序">用于排序</h3>
<p>我们在写查询语句的时候经常需要对查询出来的记录通过<code>ORDER BY</code>子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、吧啦吧啦排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在<code>MySQL</code>中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>），跟<code>文件</code>这个词儿一沾边儿，就显得这些排序操作非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果<code>ORDER BY</code>子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday, phone_number <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>这个查询的结果集需要先按照<code>name</code>值排序，如果记录的<code>name</code>值相同，则需要按照<code>birthday</code>来排序，如果<code>birthday</code>的值相同，则需要按照<code>phone_number</code>排序。大家可以回过头去看我们建立的<code>idx_name_birthday_phone_number</code>索引的示意图，因为这个<code>B+</code>树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行<code>回表</code>操作取出该索引中不包含的列就好了。简单吧？是的，索引就是这么牛逼。</p>
<h4 id="使用联合索引进行排序注意事项">使用联合索引进行排序注意事项</h4>
<p>对于<code>联合索引</code>有个问题需要注意，<code>ORDER BY</code>的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出<code>ORDER BY phone_number, birthday, name</code>的顺序，那也是用不了<code>B+</code>树索引，这种颠倒顺序就不能使用索引的原因我们上边详细说过了，这就不赘述了。</p>
<p>同理，<code>ORDER BY name</code>、<code>ORDER BY name, birthday</code>这种匹配索引左边的列的形式可以使用部分的<code>B+</code>树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> birthday, phone_number <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>这个查询能使用联合索引进行排序是因为<code>name</code>列的值相同的记录是按照<code>birthday</code>, <code>phone_number</code>排序的，说了好多遍了都。</p>
<h4 id="不可以使用索引进行排序的几种情况">不可以使用索引进行排序的几种情况</h4>
<h5 id="ASC、DESC混用">ASC、DESC混用</h5>
<p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是<code>ASC</code>规则排序，要么都是<code>DESC</code>规则排序。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">小贴士：<br><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>子句后的列如果不加<span class="hljs-keyword">ASC</span>或者<span class="hljs-keyword">DESC</span>默认是按照<span class="hljs-keyword">ASC</span>排序规则排序的，也就是升序排序的。<br></code></pre></td></tr></table></figure>
<p>为啥会有这种奇葩规定呢？这个还得回头想想这个<code>idx_name_birthday_phone_number</code>联合索引中记录的结构：</p>
<ul>
<li>先按照记录的<code>name</code>列的值进行升序排列。</li>
<li>如果记录的<code>name</code>列的值相同，再按照<code>birthday</code>列的值进行升序排列。</li>
<li>如果记录的<code>birthday</code>列的值相同，再按照<code>phone_number</code>列的值进行升序排列。</li>
</ul>
<p>如果查询中的各个排序列的排序顺序是一致的，比方说下边这两种情况：</p>
<ul>
<li>
<p><code>ORDER BY name, birthday LIMIT 10</code></p>
<p>这种情况直接从索引的最左边开始往右读10行记录就可以了。</p>
</li>
<li>
<p><code>ORDER BY name DESC, birthday DESC LIMIT 10</code>，</p>
<p>这种情况直接从索引的最右边开始往左读10行记录就可以了。</p>
</li>
</ul>
<p>但是如果我们查询的需求是先按照<code>name</code>列进行升序排列，再按照<code>birthday</code>列进行降序排列的话，比如说这样的查询语句：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>这样如果使用索引排序的话过程就是这样的：</p>
<ul>
<li>先从索引的最左边确定<code>name</code>列最小的值，然后找到<code>name</code>列等于该值的所有记录，然后从<code>name</code>列等于该值的最右边的那条记录开始往左找10条记录。</li>
<li>如果<code>name</code>列等于最小的值的记录不足10条，再继续往右找<code>name</code>值第二小的记录，重复上边那个过程，直到找到10条记录为止。</li>
</ul>
<p>累不累？累！重点是这样不能高效使用索引，而要采取更复杂的算法去从索引中取数据，设计<code>MySQL</code>的大叔觉得这样还不如直接文件排序来的快，所以就规定使用联合索引的各个排序列的排序顺序必须是一致的。</p>
<h5 id="排序列包含非同一个索引的列">排序列包含非同一个索引的列</h5>
<p>有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, country <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p><code>name</code>和<code>country</code>并不属于一个联合索引中的列，所以无法使用索引进行排序，至于为啥我就不想再唠叨了，自己用前边的理论自己捋一捋吧～</p>
<h5 id="排序列使用了复杂的表达式">排序列使用了复杂的表达式</h5>
<p>要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> UPPER(<span class="hljs-type">name</span>) <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>使用了<code>UPPER</code>函数修饰过的列就不是单独的列啦，这样就无法使用索引进行排序啦。</p>
<h3 id="用于分组">用于分组</h3>
<p>有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span>, birthday, phone_number, COUNT(*) <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday, phone_number<br></code></pre></td></tr></table></figure>
<p>这个查询语句相当于做了3次分组操作：</p>
<ol>
<li>先把记录按照<code>name</code>值进行分组，所有<code>name</code>值相同的记录划分为一组。</li>
<li>将每个<code>name</code>值相同的分组里的记录再按照<code>birthday</code>的值进行分组，将<code>birthday</code>值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</li>
<li>再将上一步中产生的小分组按照<code>phone_number</code>的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把<code>大分组</code>分成若干个<code>小分组</code>，然后把若干个<code>小分组</code>再细分成更多的<code>小小分组</code>。</li>
</ol>
<p>然后针对那些<code>小小分组</code>进行统计，比如在我们这个查询语句中就是统计每个<code>小小分组</code>包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的<code>B+</code>树中的索引列的顺序是一致的，而我们的<code>B+</code>树索引又是按照索引列排好序的，这不正好么，所以可以直接使用<code>B+</code>树索引进行分组。</p>
<p>和使用<code>B+</code>树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组，吧啦吧啦的～</p>
<h2 id="回表的代价">回表的代价</h2>
<p>上边的讨论对<code>回表</code>这个词儿多是一带而过，可能大家没啥深刻的体会，下边我们详细唠叨下。还是用<code>idx_name_birthday_phone_number</code>索引为例，看下边这个查询：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>在使用<code>idx_name_birthday_phone_number</code>索引进行查询时大致可以分为这两个步骤：</p>
<ol>
<li>从索引<code>idx_name_birthday_phone_number</code>对应的<code>B+</code>树中取出<code>name</code>值在<code>Asa</code>～<code>Barlow</code>之间的用户记录。</li>
<li>由于索引<code>idx_name_birthday_phone_number</code>对应的<code>B+</code>树用户记录中只包含<code>name</code>、<code>birthday</code>、<code>phone_number</code>、<code>id</code>这4个字段，而查询列表是<code>*</code>，意味着要查询表中所有字段，也就是还要包括<code>country</code>字段。这时需要把从上一步中获取到的每一条记录的<code>id</code>字段都到聚簇索引对应的<code>B+</code>树中找到完整的用户记录，也就是我们通常所说的<code>回表</code>，然后把完整的用户记录返回给查询用户。</li>
</ol>
<p>由于索引<code>idx_name_birthday_phone_number</code>对应的<code>B+</code>树中的记录首先会按照<code>name</code>列的值进行排序，所以值在<code>Asa</code>～<code>Barlow</code>之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为<code>顺序I/O</code>。根据第1步中获取到的**记录的<code>id</code>字段的值可能并不相连，而在聚簇索引中记录是根据<code>id</code>（也就是主键）的顺序排列的，所以根据这些并不连续的<code>id</code>值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为<code>随机I/O</code>。**一般情况下，顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。所以这个使用索引<code>idx_name_birthday_phone_number</code>的查询有这么两个特点：</p>
<ul>
<li>会使用到两个<code>B+</code>树索引，一个二级索引，一个聚簇索引。</li>
<li>访问二级索引使用<code>顺序I/O</code>，访问聚簇索引使用<code>随机I/O</code>。</li>
</ul>
<p>需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用<code>二级索引</code>。比方说<code>name</code>值在<code>Asa</code>～<code>Barlow</code>之间的用户记录数量占全部记录数量90%以上，那么如果使用<code>idx_name_birthday_phone_number</code>索引的话，有90%多的<code>id</code>值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。</p>
<p>那什么时候采用全表扫描的方式，什么时候使用采用<code>二级索引 + 回表</code>的方式去执行查询呢？这个就是传说中的查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用<code>二级索引 + 回表</code>的方式。当然优化器做的分析工作不仅仅是这么简单，但是大致上是个这个过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用<code>二级索引 + 回表</code>的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>添加了<code>LIMIT 10</code>的查询更容易让优化器采用<code>二级索引 + 回表</code>的方式进行查询。</p>
<p>对于有排序需求的查询，上边讨论的采用<code>全表扫描</code>还是<code>二级索引 + 回表</code>的方式进行查询的条件也是成立的，比方说下边这个查询：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday, phone_number;<br></code></pre></td></tr></table></figure>
<p>由于查询列表是<code>*</code>，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（<code>filesort</code>）低，所以优化器会倾向于使用<code>全表扫描</code>的方式执行查询。如果我们加了<code>LIMIT</code>子句，比如这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday, phone_number <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>这样需要回表的记录特别少，优化器就会倾向于使用<code>二级索引 + 回表</code>的方式执行查询。</p>
<h3 id="覆盖索引">覆盖索引</h3>
<p>为了彻底告别<code>回表</code>操作带来的性能损耗，我们建议：最好在查询列表里只包含索引列，比如这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span>, birthday, phone_number <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span><br></code></pre></td></tr></table></figure>
<p>因为我们只查询<code>name</code>, <code>birthday</code>, <code>phone_number</code>这三个索引列的值，所以在通过<code>idx_name_birthday_phone_number</code>索引得到结果后就不必到<code>聚簇索引</code>中再查找记录的剩余列，也就是<code>country</code>列的值了，这样就省去了<code>回表</code>操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为<code>索引覆盖</code>。排序操作也优先使用<code>覆盖索引</code>的方式进行查询，比方说这个查询：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span>, birthday, phone_number  <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday, phone_number;<br></code></pre></td></tr></table></figure>
<p>虽然这个查询中没有<code>LIMIT</code>子句，但是采用了<code>覆盖索引</code>，所以查询优化器就会直接使用<code>idx_name_birthday_phone_number</code>索引进行排序而不需要回表操作了。</p>
<p>当然，如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是我们很不鼓励用<code>*</code>号作为查询列表，最好把我们需要查询的列依次标明。</p>
<h2 id="如何挑选索引">如何挑选索引</h2>
<p>上边我们以<code>idx_name_birthday_phone_number</code>索引为例对索引的适用条件进行了详细的唠叨，下边看一下我们在建立索引时或者编写查询语句时就应该注意的一些事项。</p>
<h3 id="只为用于搜索、排序或分组的列创建索引">只为用于搜索、排序或分组的列创建索引</h3>
<p>也就是说，只为出现在<code>WHERE</code>子句中的列、连接子句中的连接列，或者出现在<code>ORDER BY</code>或<code>GROUP BY</code>子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> birthday, country <span class="hljs-keyword">FROM</span> person_name <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>像查询列表中的<code>birthday</code>、<code>country</code>这两个列就不需要建立索引，我们只需要为出现在<code>WHERE</code>子句中的<code>name</code>列创建索引就可以了。</p>
<h3 id="考虑列的基数">考虑列的基数</h3>
<p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2, 5, 8, 2, 5, 8, 2, 5, 8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。这个<code>列的基数</code>指标非常重要，直接影响我们是否能有效的利用索引。假设某个列的基数为<code>1</code>，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了～ 而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。所以结论就是：<strong>最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</strong></p>
<h3 id="索引列的类型尽量小">索引列的类型尽量小</h3>
<p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<code>TINYINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>这么几种，它们占用的存储空间依次递增，我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用<code>INT</code>就不要使用<code>BIGINT</code>，能使用<code>MEDIUMINT</code>就不要使用<code>INT</code>～ 这是因为：</p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul>
<p>这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的<code>I/O</code>。</p>
<h3 id="索引字符串值的前缀">索引字符串值的前缀</h3>
<p>我们知道一个字符串其实是由若干个字符组成，如果我们在<code>MySQL</code>中使用<code>utf8</code>字符集去存储字符串的话，编码一个字符需要占用<code>1~3</code>个字节。假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的<code>B+</code>树中有这么两个问题：</p>
<ul>
<li><code>B+</code>树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。</li>
<li>如果<code>B+</code>树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li>
</ul>
<p>我们前边儿说过索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案 — 只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样只在<code>B+</code>树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题，何乐而不为，比方说我们在建表语句中只对<code>name</code>列的前10个字符进行索引可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    KEY idx_name_birthday_phone_number (name(<span class="hljs-number">10</span>), birthday, phone_number)<br>);    <br></code></pre></td></tr></table></figure>
<p><code>name(10)</code>就表示在建立的<code>B+</code>树索引中只保留记录的前<code>10</code>个字符的编码，这种只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。</p>
<h4 id="索引列前缀对排序的影响">索引列前缀对排序的影响</h4>
<p>如果使用了索引列前缀，比方说前边只把<code>name</code>列的前10个字符放到了二级索引中，下边这个查询可能就有点儿尴尬了：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>因为二级索引中不包含完整的<code>name</code>列信息，所以无法对前十个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只好乖乖的用文件排序喽。</p>
<h3 id="让索引列在比较表达式中单独出现">让索引列在比较表达式中单独出现</h3>
<p>假设表中有一个整数列<code>my_col</code>，我们为这个列建立了索引。下边的两个<code>WHERE</code>子句虽然语义是一致的，但是在效率上却有差别：</p>
<ol>
<li><code>WHERE my_col * 2 &lt; 4</code></li>
<li><code>WHERE my_col &lt; 4/2</code></li>
</ol>
<p>第1个<code>WHERE</code>子句中<code>my_col</code>列并不是以单独列的形式出现的，而是以<code>my_col * 2</code>这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于<code>4</code>，所以这种情况下是使用不到为<code>my_col</code>列建立的<code>B+</code>树索引的。而第2个<code>WHERE</code>子句中<code>my_col</code>列并是以单独列的形式出现的，这样的情况可以直接使用<code>B+</code>树索引。</p>
<p>所以结论就是：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p>
<h3 id="主键插入顺序">主键插入顺序</h3>
<p>我们知道，对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在<code>1~100</code>之间：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16db02bc7153fee5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1capq3r1o1geqdck1cnc1fkihj39.png-28.1kB">
<p>如果此时再插入一条主键值为<code>9</code>的记录，那它插入的位置就如下图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16db02bc77059366~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1capq7nnv13en8b31lvtj2i1e8lm.png-35.3kB">
<p>可这个数据页已经满了啊，再插进来咋办呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：性能损耗！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：让主键具有<code>AUTO_INCREMENT</code>，让存储引擎自己为表生成主键，而不是我们手动插入 ，比方说我们可以这样定义<code>person_info</code>表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>    id <span class="hljs-type">INT</span> UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    KEY idx_name_birthday_phone_number (name(<span class="hljs-number">10</span>), birthday, phone_number)<br>);    <br></code></pre></td></tr></table></figure>
<p>我们自定义的主键列<code>id</code>拥有<code>AUTO_INCREMENT</code>属性，在插入记录时存储引擎会自动为我们填入自增的主键值。</p>
<h3 id="冗余和重复索引">冗余和重复索引</h3>
<p>有时候有的同学有意或者无意的就对同一个列创建了多个索引，比方说这样写建表语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>    id <span class="hljs-type">INT</span> UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    KEY idx_name_birthday_phone_number (name(<span class="hljs-number">10</span>), birthday, phone_number),<br>    KEY idx_name (name(<span class="hljs-number">10</span>))<br>);    <br></code></pre></td></tr></table></figure>
<p>我们知道，通过<code>idx_name_birthday_phone_number</code>索引就可以对<code>name</code>列进行快速搜索，再创建一个专门针对<code>name</code>列的索引就算是一个<code>冗余</code>索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p>
<p>另一种情况，我们可能会对某个列重复建立索引，比方说这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> repeat_index_demo (<br>    c1 <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    c2 <span class="hljs-type">INT</span>,<br>    <span class="hljs-keyword">UNIQUE</span> uidx_c1 (c1),<br>    INDEX idx_c1 (c1)<br>);  <br></code></pre></td></tr></table></figure>
<p>我们看到，<code>c1</code>既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p>
<h2 id="总结-4">总结</h2>
<p>上边只是我们在创建和使用<code>B+</code>树索引的过程中需要注意的一些点，后边我们还会陆续介绍更多的优化方法和注意事项，敬请期待。本集内容总结如下：</p>
<ol>
<li><code>B+</code>树索引在空间和时间上都有代价，所以没事儿别瞎建索引。</li>
<li><code>B+</code>树索引适用于下边这些情况：
<ul>
<li>全值匹配</li>
<li>匹配左边的列</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>用于排序</li>
<li>用于分组</li>
</ul>
</li>
<li>在使用索引时需要注意下边这些事项：
<ul>
<li>只为用于搜索、排序或分组的列创建索引</li>
<li>为列的基数大的列创建索引</li>
<li>索引列的类型尽量小</li>
<li>可以只对字符串值的前缀建立索引</li>
<li>只有索引列在比较表达式中单独出现才可以适用索引</li>
<li>为了尽可能少的让<code>聚簇索引</code>发生页面分裂和记录移位的情况，建议让主键拥有<code>AUTO_INCREMENT</code>属性。</li>
<li>定位并删除表中的重复和冗余索引</li>
<li>尽量使用<code>覆盖索引</code>进行查询，避免<code>回表</code>带来的性能损耗。</li>
</ul>
</li>
</ol>
<h1>8.MySQL 的数据目录</h1>
<h2 id="数据库和文件系统的关系">数据库和文件系统的关系</h2>
<p>我们知道像<code>InnoDB</code>、<code>MyISAM</code>这样的存储引擎都是把表存储在磁盘上的，而操作系统用来管理磁盘的那个东东又被称为<code>文件系统</code>，所以用专业一点的话来表述就是：像 <em><strong>InnoDB</strong></em> 、 <em><strong>MyISAM</strong></em> 这样的存储引擎都是把表存储在文件系统上的。当我们想读取数据的时候，这些存储引擎会从文件系统中把数据读出来返回给我们，当我们想写入数据的时候，这些存储引擎会把这些数据又写回文件系统。本章就是要唠叨一下<code>InnoDB</code>和<code>MyISAM</code>这两个存储引擎的数据如何在文件系统中存储的。</p>
<h2 id="MySQL数据目录">MySQL数据目录</h2>
<p>MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件，之后在运行过程中产生的数据也都会存储到这个目录下的某些文件中，这个目录就称为<code>数据目录</code>，我们下边就要详细唠唠这个目录下具体都有哪些重要的东西。</p>
<h3 id="数据目录和安装目录的区别">数据目录和安装目录的区别</h3>
<p>我们之前只接触过<code>MySQL</code>的安装目录（在安装<code>MySQL</code>的时候我们可以自己指定），我们重点强调过这个<code>安装目录</code>下非常重要的<code>bin</code>目录，它里边存储了许多关于控制客户端程序和服务器程序的命令（许多可执行文件，比如<code>mysql</code>，<code>mysqld</code>，<code>mysqld_safe</code>等等等等好几十个）。而<code>数据目录</code>是用来存储<code>MySQL</code>在运行过程中产生的数据，一定要和本章要讨论的<code>安装目录</code>区别开！一定要区分开！一定要区分开！一定要区分开！</p>
<h3 id="如何确定MySQL中的数据目录">如何确定MySQL中的数据目录</h3>
<p>那说了半天，到底<code>MySQL</code>把数据都存到哪个路径下呢？其实<code>数据目录</code>对应着一个系统变量<code>datadir</code>，我们在使用客户端与服务器建立连接之后查看这个系统变量的值就可以了：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;datadir&#x27;;</span><br><span class="hljs-section">+---------------+-----------------------+</span><br><span class="hljs-section">| Variable_name | Value                 |</span><br><span class="hljs-section">+---------------+-----------------------+</span><br><span class="hljs-section">| datadir       | /usr/local/var/mysql/ |</span><br><span class="hljs-section">+---------------+-----------------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>从结果中可以看出，在我的计算机上<code>MySQL</code>的数据目录就是<code>/usr/local/var/mysql/</code>，你用你的计算机试试呗～</p>
<h2 id="数据目录的结构">数据目录的结构</h2>
<p><code>MySQL</code>在运行过程中都会产生哪些数据呢？当然会包含我们创建的数据库、表、视图和触发器吧啦吧啦的用户数据，除了这些用户数据，为了程序更好的运行，<code>MySQL</code>也会创建一些其他的额外数据，我们接下来细细的品味一下这个<code>数据目录</code>下的内容。</p>
<h3 id="数据库在文件系统中的表示">数据库在文件系统中的表示</h3>
<p>每当我们使用<code>CREATE DATABASE 数据库名</code>语句创建一个数据库的时候，在文件系统上实际发生了什么呢？其实很简单，每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹，我们每当我们新建一个数据库时，<code>MySQL</code>会帮我们做这两件事儿：</p>
<ol>
<li>在<code>数据目录</code>下创建一个和数据库名同名的子目录（或者说是文件夹）。</li>
<li>在该与数据库名同名的子目录下创建一个名为<code>db.opt</code>的文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则是个啥。</li>
</ol>
<p>比方说我们查看一下在我的计算机上当前有哪些数据库：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW DATABASES;</span><br><span class="hljs-section">+--------------------+</span><br><span class="hljs-section">| Database           |</span><br><span class="hljs-section">+--------------------+</span><br>| information<span class="hljs-emphasis">_schema |</span><br><span class="hljs-emphasis">| charset_demo_db    |</span><br><span class="hljs-emphasis">| dahaizi            |</span><br><span class="hljs-emphasis">| mysql              |</span><br><span class="hljs-emphasis">| performance_</span>schema |<br>| sys                |<br><span class="hljs-section">| xiaohaizi          |</span><br><span class="hljs-section">+--------------------+</span><br>7 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>可以看到在我的计算机上当前有7个数据库，其中<code>charset_demo_db</code>、<code>dahaizi</code>和<code>xiaohaizi</code>数据库是我们自定义的，其余4个数据库是属于MySQL自带的系统数据库。我们再看一下我的计算机上的<code>数据目录</code>下的内容：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stata">.<br>├── auto.cnf<br>├── <span class="hljs-keyword">ca</span>-key.pem<br>├── <span class="hljs-keyword">ca</span>.pem<br>├── charset_demo_db<br>├── client-cert.pem<br>├── client-key.pem<br>├── dahaizi<br>├── ib_buffer_pool<br>├── ib_logfile0<br>├── ib_logfile1<br>├── ibdata1<br>├── ibtmp1<br>├── mysql<br>├── performance_schema<br>├── private_key.pem<br>├── public_key.pem<br>├── server-cert.pem<br>├── server-key.pem<br>├── sys<br>├── xiaohaizideMacBook-<span class="hljs-keyword">Pro</span>.<span class="hljs-keyword">local</span>.<span class="hljs-keyword">err</span><br>├── xiaohaizideMacBook-<span class="hljs-keyword">Pro</span>.<span class="hljs-keyword">local</span>.pid<br>└── xiaohaizi<br><br>6 directories, 16 files<br></code></pre></td></tr></table></figure>
<p>当然这个数据目录下的文件和子目录比较多哈，但是如果仔细看的话，除了<code>information_schema</code>这个系统数据库外，其他的数据库在<code>数据目录</code>下都有对应的子目录。这个<code>information_schema</code>比较特殊，设计MySQL的大叔们对它的实现进行了特殊对待，没有使用相应的数据库目录，我们忽略它的存在就好了哈。</p>
<h3 id="表在文件系统中的表示">表在文件系统中的表示</h3>
<p>我们的数据其实都是以记录的形式插入到表中的，每个表的信息其实可以分为两种：</p>
<ol>
<li>表结构的定义</li>
<li>表中的数据</li>
</ol>
<p><code>表结构</code>就是该表的名称是啥，表里边有多少列，每个列的数据类型是啥，有啥约束条件和索引，用的是啥字符集和比较规则吧啦吧啦的各种信息，这些信息都体现在了我们的建表语句中了。为了保存这些信息，<code>InnoDB</code>和<code>MyISAM</code>这两种存储引擎都在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于描述表结构的文件，文件名是这样：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">表名<span class="hljs-string">.frm</span><br></code></pre></td></tr></table></figure>
<p>比方说我们在<code>dahaizi</code>数据库下创建一个名为<code>test</code>的表：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; USE dahaizi;<br><span class="hljs-keyword">Database</span> changed<br><br>mysql&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test (<br>    -&gt;     c1 <span class="hljs-type">INT</span><br>    -&gt; );<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure>
<p>那在数据库<code>dahaizi</code>对应的子目录下就会创建一个名为<code>test.frm</code>的用于描述表结构的文件。值得注意的是，这个后缀名为.frm是以二进制格式存储的，我们直接打开会是乱码的～ 你还不赶紧在你的计算机上创建个表试试～</p>
<p>描述表结构的文件我们知道怎么存储了，那表中的数据存到什么文件中了呢？在这个问题上，不同的存储引擎就产生了分歧了，下边我们分别看一下<code>InnoDB</code>和<code>MyISAM</code>是用什么文件来保存表中数据的。</p>
<h4 id="InnoDB是如何存储表数据的">InnoDB是如何存储表数据的</h4>
<p>我们前边重点唠叨过<code>InnoDB</code>的一些实现原理，到现在为止我们应该熟悉下边这些东东：</p>
<ul>
<li><code>InnoDB</code>其实是使用<code>页</code>为基本单位来管理存储空间的，默认的<code>页</code>大小为<code>16KB</code>。</li>
<li>对于<code>InnoDB</code>存储引擎来说，每个索引都对应着一棵<code>B+</code>树，该<code>B+</code>树的每个节点都是一个数据页，数据页之间不必要是物理连续的，因为数据页之间有<code>双向链表</code>来维护着这些页的顺序。</li>
<li><code>InnoDB</code>的聚簇索引的叶子节点存储了完整的用户记录，也就是所谓的索引即数据，数据即索引。</li>
</ul>
<p>为了更好的管理这些页，设计<code>InnoDB</code>的大叔们提出了一个<code>表空间</code>或者<code>文件空间</code>（英文名：<code>table space</code>或者<code>file space</code>）的概念，这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个<code>表空间</code>可以被划分为很多很多很多个<code>页</code>，我们的表数据就存放在某个<code>表空间</code>下的某些页里。设计<code>InnoDB</code>的大叔将表空间划分为几种不同的类型，我们一个一个看一下。</p>
<h5 id="系统表空间（system-tablespace）">系统表空间（system tablespace）</h5>
<p>这个所谓的<code>系统表空间</code>可以对应文件系统上一个或多个实际的文件，默认情况下，<code>InnoDB</code>会在<code>数据目录</code>下创建一个名为<code>ibdata1</code>（在你的数据目录下找找看有木有）、大小为<code>12M</code>的文件，这个文件就是对应的<code>系统表空间</code>在文件系统上的表示。怎么才<code>12M</code>？这么点儿还没插多少数据就用完了，哈哈，那是因为这个文件是所谓的<code>自扩展文件</code>，也就是当不够用的时候它会自己增加文件大小～</p>
<p>当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的<code>ibdata1</code>这个文件名难听，那可以在<code>MySQL</code>启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下配置文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_data_file_path</span>=data1:<span class="hljs-number">512</span>M<span class="hljs-comment">;data2:512M:autoextend</span><br></code></pre></td></tr></table></figure>
<p>这样在<code>MySQL</code>启动之后就会创建这两个512M大小的文件作为<code>系统表空间</code>，其中的<code>autoextend</code>表明这两个文件如果不够用会自动扩展<code>data2</code>文件的大小。</p>
<p>我们也可以把<code>系统表空间</code>对应的文件路径不配置到<code>数据目录</code>下，甚至可以配置到单独的磁盘分区上，涉及到的启动参数就是<code>innodb_data_file_path</code>和<code>innodb_data_home_dir</code>，具体的配置逻辑挺绕的，我们这就不多唠叨了，知道改哪个参数可以修改<code>系统表空间</code>对应的文件，有需要的时候到官方文档里一查就好了。</p>
<p>需要注意的一点是，在一个MySQL服务器中，系统表空间只有一份。从MySQL5.5.7到MySQL5.6.6之间的各个版本中，我们表中的数据都会被默认存储到这个 <em><strong>系统表空间</strong></em>。</p>
<h5 id="独立表空间-file-per-table-tablespace">独立表空间(file-per-table tablespace)</h5>
<p>在MySQL5.6.6以及之后的版本中，<code>InnoDB</code>并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该<code>独立表空间</code>的文件，文件名和表名相同，只不过添加了一个<code>.ibd</code>的扩展名而已，所以完整的文件名称长这样：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">表名<span class="hljs-string">.ibd</span><br></code></pre></td></tr></table></figure>
<p>比方说假如我们使用了<code>独立表空间</code>去存储<code>xiaohaizi</code>数据库下的<code>test</code>表的话，那么在该表所在数据库对应的<code>xiaohaizi</code>目录下会为<code>test</code>表创建这两个文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">test</span>.frm<br><span class="hljs-keyword">test</span>.ibd<br></code></pre></td></tr></table></figure>
<p>其中<code>test.ibd</code>文件就用来存储<code>test</code>表中的数据和索引。当然我们也可以自己指定使用<code>系统表空间</code>还是<code>独立表空间</code>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code>控制，比如说我们想刻意将表数据都存储到<code>系统表空间</code>时，可以在启动<code>MySQL</code>服务器的时候这样配置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_file_per_table</span>=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>当<code>innodb_file_per_table</code>的值为<code>0</code>时，代表使用系统表空间；当<code>innodb_file_per_table</code>的值为<code>1</code>时，代表使用独立表空间。不过<code>innodb_file_per_table</code>参数只对新建的表起作用，对于已经分配了表空间的表并不起作用。如果我们想把已经存在系统表空间中的表转移到独立表空间，可以使用下边的语法：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">TABLESPACE</span> [=] innodb_file_per_table;<br></code></pre></td></tr></table></figure>
<p>或者把已经存在独立表空间的表转移到系统表空间，可以使用下边的语法：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">TABLESPACE</span> [=] innodb_system;<br></code></pre></td></tr></table></figure>
<p>其中中括号扩起来的<code>=</code>可有可无，比方说我们想把<code>test</code>表从独立表空间移动到系统表空间，可以这么写：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> test <span class="hljs-keyword">TABLESPACE</span> innodb_system;<br></code></pre></td></tr></table></figure>
<h5 id="其他类型的表空间">其他类型的表空间</h5>
<p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、undo表空间（undo tablespace）、临时表空间（temporary tablespace）吧啦吧啦的，具体情况我们就不细唠叨了，等用到的时候再提。</p>
<h4 id="MyISAM是如何存储表数据的">MyISAM是如何存储表数据的</h4>
<p>好了，唠叨完了<code>InnoDB</code>的系统表空间和独立表空间，现在轮到<code>MyISAM</code>了。我们知道不像<code>InnoDB</code>的索引和数据是一个东东，在<code>MyISAM</code>中的索引全部都是<code>二级索引</code>，该存储引擎的数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件。而且和<code>InnoDB</code>不同的是，<code>MyISAM</code>并没有什么所谓的<code>表空间</code>一说，表数据都存放到对应的数据库子目录下。假如<code>test</code>表使用<code>MyISAM</code>存储引擎的话，那么在它所在数据库对应的<code>xiaohaizi</code>目录下会为<code>test</code>表创建这三个文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">test</span>.frm<br><span class="hljs-keyword">test</span>.MYD<br><span class="hljs-keyword">test</span>.MYI<br></code></pre></td></tr></table></figure>
<p>其中<code>test.MYD</code>代表表的数据文件，也就是我们插入的用户记录；<code>test.MYI</code>代表表的索引文件，我们为该表创建的索引都会放到这个文件中。</p>
<h3 id="视图在文件系统中的表示">视图在文件系统中的表示</h3>
<p>我们知道<code>MySQL</code>中的视图其实是虚拟的表，也就是某个查询语句的一个别名而已，所以在存储<code>视图</code>的时候是不需要存储真实的数据的，只需要把它的结构存储起来就行了。和<code>表</code>一样，描述视图结构的文件也会被存储到所属数据库对应的子目录下边，只会存储一个<code>视图名.frm</code>的文件。</p>
<h3 id="其他的文件">其他的文件</h3>
<p>除了我们上边说的这些用户自己存储的数据以外，<code>数据目录</code>下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件：</p>
<ul>
<li>
<p>服务器进程文件。</p>
<p>我们知道每运行一个<code>MySQL</code>服务器程序，都意味着启动一个进程。<code>MySQL</code>服务器会把自己的进程ID写入到一个文件中。</p>
</li>
<li>
<p>服务器日志文件。</p>
<p>在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志吧啦吧啦各种日志，这些日志各有各的用途，我们之后会重点唠叨各种日志的用途，现在先了解一下就可以了。</p>
</li>
<li>
<p>默认/自动生成的SSL和RSA证书和密钥文件。</p>
<p>主要是为了客户端和服务器安全通信而创建的一些文件， 大家看不懂可以忽略～</p>
</li>
</ul>
<h2 id="文件系统对数据库的影响">文件系统对数据库的影响</h2>
<p>因为<code>MySQL</code>的数据都是存在文件系统中的，就不得不受到文件系统的一些制约，这在数据库和表的命名、表的大小和性能方面体现的比较明显，比如下边这些方面：</p>
<ul>
<li>
<p>数据库名称和表名称不得超过文件系统所允许的最大长度。</p>
<p>每个数据库都对应<code>数据目录</code>的一个子目录，数据库名称就是这个子目录的名称；每个表都会在数据库子目录下产生一个和表名同名的<code>.frm</code>文件，如果是<code>InnoDB</code>的独立表空间或者使用<code>MyISAM</code>引擎还会有别的文件的名称与表名一致。这些目录或文件名的长度都受限于文件系统所允许的长度～</p>
</li>
<li>
<p>特殊字符的问题</p>
<p>为了避免因为数据库名和表名出现某些特殊字符而造成文件系统不支持的情况，<code>MySQL</code>会把数据库名和表名中所有除数字和拉丁字母以外的所有字符在文件名里都映射成 <code>@+编码值</code>的形式作为文件名。比方说我们创建的表的名称为<code>'test?'</code>，由于<code>?</code>不属于数字或者拉丁字母，所以会被映射成编码值，所以这个表对应的<code>.frm</code>文件的名称就变成了<code>test@003f.frm</code>。</p>
</li>
<li>
<p>文件长度受文件系统最大长度限制</p>
<p>对于<code>InnoDB</code>的独立表空间来说，每个表的数据都会被存储到一个与表名同名的<code>.ibd</code>文件中；对于<code>MyISAM</code>存储引擎来说，数据和索引会分别存放到与表同名的<code>.MYD</code>和<code>.MYI</code>文件中。这些文件会随着表中记录的增加而增大，它们的大小受限于文件系统支持的最大文件大小。</p>
</li>
</ul>
<h2 id="MySQL系统数据库简介">MySQL系统数据库简介</h2>
<p>我们前边提到了MySQL的几个系统数据库，这几个数据库包含了MySQL服务器运行过程中所需的一些信息以及一些运行状态信息，我们现在稍微了解一下。</p>
<ul>
<li>
<p><code>mysql</code></p>
<p>这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p>
</li>
<li>
<p><code>information_schema</code></p>
<p>这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引吧啦吧啦。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。</p>
</li>
<li>
<p><code>performance_schema</code></p>
<p>这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。</p>
</li>
<li>
<p><code>sys</code></p>
<p>这个数据库主要是通过视图的形式把<code>information_schema</code>和<code>performance_schema</code>结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。</p>
</li>
</ul>
<h1>9.InnoDB的表空间</h1>
<p>通过前边儿的内容大家知道，<code>表空间</code>是一个抽象的概念，对于系统表空间来说，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应着文件系统中一个名为<code>表名.ibd</code>的实际文件。大家可以把表空间想象成被切分为许许多多个<code>页</code>的池子，当我们想为某个表插入一条记录的时候，就从池子中捞出一个对应的页来把数据写进去。本章内容会深入到表空间的各个细节中，带领大家在<code>InnoDB</code>存储结构的池子中畅游。由于本章中将会涉及比较多的概念，虽然这些概念都不难，但是却相互依赖，所以奉劝大家在看的时候：</p>
<ul>
<li>不要跳着看！</li>
<li>不要跳着看！</li>
<li>不要跳着看！</li>
</ul>
<h2 id="回忆一些旧知识">回忆一些旧知识</h2>
<h3 id="页面类型">页面类型</h3>
<p>再一次强调，InnoDB是以页为单位管理存储空间的，我们的聚簇索引（也就是完整的表数据）和其他的二级索引都是以<code>B+</code>树的形式保存到表空间的，而<code>B+</code>树的节点就是数据页。我们前边说过，这个数据页的类型名其实是：<code>FIL_PAGE_INDEX</code>，除了这种存放索引数据的页面类型之外，InnoDB也为了不同的目的设计了若干种不同类型的页面，为了唤醒大家的记忆，我们再一次把各种常用的页面类型提出来：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>十六进制</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FIL_PAGE_TYPE_ALLOCATED</code></td>
<td>0x0000</td>
<td>最新分配，还没使用</td>
</tr>
<tr>
<td><code>FIL_PAGE_UNDO_LOG</code></td>
<td>0x0002</td>
<td>Undo日志页</td>
</tr>
<tr>
<td><code>FIL_PAGE_INODE</code></td>
<td>0x0003</td>
<td>段信息节点</td>
</tr>
<tr>
<td><code>FIL_PAGE_IBUF_FREE_LIST</code></td>
<td>0x0004</td>
<td>Insert Buffer空闲列表</td>
</tr>
<tr>
<td><code>FIL_PAGE_IBUF_BITMAP</code></td>
<td>0x0005</td>
<td>Insert Buffer位图</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE_SYS</code></td>
<td>0x0006</td>
<td>系统页</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE_TRX_SYS</code></td>
<td>0x0007</td>
<td>事务系统数据</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE_FSP_HDR</code></td>
<td>0x0008</td>
<td>表空间头部信息</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE_XDES</code></td>
<td>0x0009</td>
<td>扩展描述页</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE_BLOB</code></td>
<td>0x000A</td>
<td>BLOB页</td>
</tr>
<tr>
<td><code>FIL_PAGE_INDEX</code></td>
<td>0x45BF</td>
<td>索引页，也就是我们所说的<code>数据页</code></td>
</tr>
</tbody>
</table>
<p>因为页面类型前边都有个<code>FIL_PAGE</code>或者<code>FIL_PAGE_TYPE</code>的前缀，为简便起见我们后边唠叨页面类型的时候就把这些前缀省略掉了，比方说<code>FIL_PAGE_TYPE_ALLOCATED</code>类型称为<code>ALLOCATED</code>类型，<code>FIL_PAGE_INDEX</code>类型称为<code>INDEX</code>类型。</p>
<h3 id="页面通用部分">页面通用部分</h3>
<p>我们前边说过数据页，也就是<code>INDEX</code>类型的页由7个部分组成，其中的两个部分是所有类型的页面都通用的。当然我不能寄希望于你把我说的话都记住，所以在这里重新强调一遍，任何类型的页面都有下边这种通用的结构：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f33c338667~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crjupisqne61uer17ikh6l1v8k9.png-44.9kB">
<p>从上图中可以看出，任何类型的页都会包含这两个部分：</p>
<ul>
<li><code>File Header</code>：记录页面的一些通用信息</li>
<li><code>File Trailer</code>：校验页是否完整，保证从内存到磁盘刷新时内容的一致性。</li>
</ul>
<p>对于<code>File Trailer</code>我们不再做过多强调，全部忘记了的话可以到将数据页的那一章回顾一下。我们这里再强调一遍<code>File Header</code>的各个组成部分：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td>
<td><code>4</code>字节</td>
<td>页的校验和（checksum值）</td>
</tr>
<tr>
<td><code>FIL_PAGE_OFFSET</code></td>
<td><code>4</code>字节</td>
<td>页号</td>
</tr>
<tr>
<td><code>FIL_PAGE_PREV</code></td>
<td><code>4</code>字节</td>
<td>上一个页的页号</td>
</tr>
<tr>
<td><code>FIL_PAGE_NEXT</code></td>
<td><code>4</code>字节</td>
<td>下一个页的页号</td>
</tr>
<tr>
<td><code>FIL_PAGE_LSN</code></td>
<td><code>8</code>字节</td>
<td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE</code></td>
<td><code>2</code>字节</td>
<td>该页的类型</td>
</tr>
<tr>
<td><code>FIL_PAGE_FILE_FLUSH_LSN</code></td>
<td><code>8</code>字节</td>
<td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td>
</tr>
<tr>
<td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td>
<td><code>4</code>字节</td>
<td>页属于哪个表空间</td>
</tr>
</tbody>
</table>
<p>现在除了名称里边儿带有<code>LSN</code>的两个字段大家可能看不懂以外，其他的字段肯定都是倍儿熟了，不过我们仍要强调这么几点：</p>
<ul>
<li>表空间中的每一个页都对应着一个页号，也就是<code>FIL_PAGE_OFFSET</code>，这个页号由4个字节组成，也就是32个比特位，所以一个表空间最多可以拥有2³²个页，**如果按照页的默认大小16KB来算，一个表空间最多支持64TB的数据。**表空间的第一个页的页号为0，之后的页号分别是1，2，3…依此类推</li>
<li>某些类型的页可以组成链表，链表中的页可以不按照物理顺序存储，而是根据<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>来存储上一个页和下一个页的页号。需要注意的是，这两个字段主要是为了<code>INDEX</code>类型的页，也就是我们之前一直说的数据页建立<code>B+</code>树后，为每层节点建立双向链表用的，一般类型的页是不使用这两个字段的。</li>
<li>每个页的类型由<code>FIL_PAGE_TYPE</code>表示，比如像数据页的该字段的值就是<code>0x45BF</code>，我们后边会介绍各种不同类型的页，不同类型的页在该字段上的值是不同的。</li>
</ul>
<h2 id="独立表空间结构">独立表空间结构</h2>
<p>我们知道<code>InnoDB</code>支持许多种类型的表空间，本章重点关注独立表空间和系统表空间的结构。它们的结构比较相似，但是由于系统表空间中额外包含了一些关于整个系统的信息，所以我们先挑简单一点的独立表空间来唠叨，稍后再说系统表空间的结构。</p>
<h3 id="区（extent）的概念">区（extent）的概念</h3>
<p>表空间中的页实在是太多了，为了更好的管理这些页面，设计<code>InnoDB</code>的大叔们提出了<code>区</code>（英文名：<code>extent</code>）的概念。**对于16KB的页来说，连续的64个页就是一个<code>区</code>，也就是说一个区默认占用1MB空间大小。**不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。画个图表示就是这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f33c4a1c3a~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cri1nutcorp5ghf5c7vqagt1j.png-71.4kB">
<p>其中<code>extent 0</code> ~ <code>extent 255</code>这256个区算是第一个组，<code>extent 256</code> ~ <code>extent 511</code>这256个区算是第二个组，<code>extent 512</code> ~ <code>extent 767</code>这256个区算是第三个组（上图中并未画全第三个组全部的区，请自行脑补），依此类推可以划分更多的组。这些组的头几个页面的类型都是类似的，就像这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f33df9307a~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crjo0hl4q8u1dkdofe187b10fa9.png-105.2kB">
<p>从上图中我们能得到如下信息：</p>
<ul>
<li><strong>第一个组最开始的3个页面的类型是固定的</strong>，也就是说<code>extent 0</code>这个区最开始的3个页面的类型是固定的，分别是：
<ul>
<li><code>FSP_HDR</code>类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的<code>区</code>，也就是<code>extent 0</code> ~ <code>extent 255</code>这256个区的属性，稍后详细唠叨。需要注意的一点是，整个表空间只有一个<code>FSP_HDR</code>类型的页面。</li>
<li><code>IBUF_BITMAP</code>类型：这个类型的页面是存储本组所有的区的所有页面关于<code>INSERT BUFFER</code>的信息。当然，你现在不用知道啥是个<code>INSERT BUFFER</code>，后边会详细说到你吐。</li>
<li><code>INODE</code>类型：这个类型的页面存储了许多称为<code>INODE</code>的数据结构，还是那句话，现在你不需要知道啥是个<code>INODE</code>，后边儿会说到你吐。</li>
</ul>
</li>
<li><strong>其余各组最开始的2个页面的类型是固定的</strong>，也就是说<code>extent 256</code>、<code>extent 512</code>这些区最开始的2个页面的类型是固定的，分别是：
<ul>
<li><code>XDES</code>类型：全称是<code>extent descriptor</code>，用来登记本组256个区的属性，也就是说对于在<code>extent 256</code>区中的该类型页面存储的就是<code>extent 256</code> ~ <code>extent 511</code>这些区的属性，对于在<code>extent 512</code>区中的该类型页面存储的就是<code>extent 512</code> ~ <code>extent 767</code>这些区的属性。上边介绍的<code>FSP_HDR</code>类型的页面其实和<code>XDES</code>类型的页面的作用类似，只不过<code>FSP_HDR</code>类型的页面还会额外存储一些表空间的属性。</li>
<li><code>IBUF_BITMAP</code>类型：上边介绍过了。</li>
</ul>
</li>
</ul>
<p>好了，宏观的结构介绍完了，里边儿的名词大家也不用记清楚，只要大致记得：表空间被划分为许多连续的<code>区</code>，每个区默认由64个页组成，每256个区划分为一组，每个组的最开始的几个页面类型是固定的就好了。</p>
<h3 id="段（segment）的概念">段（segment）的概念</h3>
<p>为啥好端端的提出一个<code>区</code>（<code>extent</code>）的概念呢？我们以前分析问题的套路都是这样的：表中的记录存储到页里边儿，然后页作为节点组成<code>B+</code>树，这个<code>B+</code>树就是索引，然后吧啦吧啦一堆聚簇索引和二级索引的区别。这套路也没啥不妥的呀～</p>
<p>是的，如果我们表中数据量很少的话，比如说你的表中只有几十条、几百条数据的话，的确用不到<code>区</code>的概念，因为简单的几个页就能把对应的数据存储起来，但是你架不住表里的记录越来越多呀。</p>
<p>？？啥？？表里的记录多了又怎样？<code>B+</code>树的每一层中的页都会形成一个双向链表呀，<code>File Header</code>中的<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>字段不就是为了形成双向链表设置的么？</p>
<p>是的是的，您说的都对，从理论上说，不引入<code>区</code>的概念只使用<code>页</code>的概念对存储引擎的运行并没啥影响，但是我们来考虑一下下边这个场景：</p>
<ul>
<li>我们每向表中**插入一条记录，本质上就是向该表的聚簇索引以及所有二级索引代表的<code>B+</code>树的节点中插入数据。**而<code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页</code>为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍<code>B+</code>树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O</code>是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</li>
</ul>
<p>所以，所以，所以才引入了<code>区</code>（<code>extent</code>）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照<code>区</code>为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个区），但是从性能角度看，可以消除很多的随机<code>I/O</code>，功大于过嘛！</p>
<p>事情到这里就结束了么？太天真了，我们提到的范围查询，其实是对<code>B+</code>树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以设计<code>InnoDB</code>的大叔们对<code>B+</code>树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的<code>区</code>，非叶子节点也有自己独有的<code>区</code>。<strong>存放叶子节点的区的集合就算是一个<code>段</code>（<code>segment</code>），存放非叶子节点的区的集合也算是一个<code>段</code>。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</strong></p>
<p>默认情况下<strong>一个使用<code>InnoDB</code>存储引擎的表只有一个聚簇索引，一个索引会生成2个段</strong>，而段是以区为单位申请存储空间的，一个区默认占用1M存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。设计<code>InnoDB</code>的大叔们都挺节俭的，当然也考虑到了这种情况。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。**现在为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，设计<code>InnoDB</code>的大叔们提出了一个碎片（fragment）区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。**碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：</p>
<ul>
<li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li>
<li>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。</li>
</ul>
<p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。除了索引的叶子节点段和非叶子节点段之外，<code>InnoDB</code>中还有为存储一些特殊的数据而定义的段，比如回滚段，当然我们现在并不关心别的类型的段，现在只需要知道段是一些零散的页面以及一些完整的区的集合就好了。</p>
<h3 id="区的分类">区的分类</h3>
<p>通过上边一通唠叨，大家知道了表空间的是由若干个区组成的，这些区大体上可以分为4种类型：</p>
<ul>
<li>空闲的区：现在还没有用到这个区中的任何页面。</li>
<li>有剩余空间的碎片区：表示碎片区中还有可用的页面。</li>
<li>没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。</li>
<li>附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</li>
</ul>
<p>这4种类型的区也可以被称为区的4种状态（<code>State</code>），设计<code>InnoDB</code>的大叔们为这4种状态的区定义了特定的名词儿：</p>
<table>
<thead>
<tr>
<th>状态名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FREE</code></td>
<td>空闲的区</td>
</tr>
<tr>
<td><code>FREE_FRAG</code></td>
<td>有剩余空间的碎片区</td>
</tr>
<tr>
<td><code>FULL_FRAG</code></td>
<td>没有剩余空间的碎片区</td>
</tr>
<tr>
<td><code>FSEG</code></td>
<td>附属于某个段的区</td>
</tr>
</tbody>
</table>
<p>需要再次强调一遍的是，处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区都是独立的，算是直属于表空间；而处于<code>FSEG</code>状态的区是附属于某个段的。</p>
<blockquote>
<p>小贴士： 如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于<code>FSEG</code>的区全都隶属于某个段，而处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</p>
</blockquote>
<p>为了方便管理这些区，设计<code>InnoDB</code>的大叔设计了一个称为<code>XDES Entry</code>的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个<code>XDES Entry</code>结构，这个结构记录了对应的区的一些属性。我们先看图来对这个结构有个大致的了解：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f343654829~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crre79uq9971bsdj9s1i0j11en8a.png-96.2kB">
<p>从图中我们可以看出，<code>XDES Entry</code>是一个40个字节的结构，大致分为4个部分，各个部分的释义如下：</p>
<ul>
<li>
<p><code>Segment ID</code>（8字节）</p>
<p>每一个段都有一个唯一的编号，用ID表示，此处的<code>Segment ID</code>字段表示就是该区所在的段。当然前提是该区已经被分配给某个段了，不然的话该字段的值没啥意义。</p>
</li>
<li>
<p><code>List Node</code>（12字节）</p>
<p>这个部分可以将若干个<code>XDES Entry</code>结构串联成一个链表，大家看一下这个<code>List Node</code>的结构：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f3444b1515~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crre8tlh1vmqtfipk663l173q97.png-69.1kB">
<p>如果我们想定位表空间内的某一个位置的话，只需指定页号以及该位置在指定页号中的页内偏移量即可。所以：</p>
<ul>
<li><code>Pre Node Page Number</code>和<code>Pre Node Offset</code>的组合就是指向前一个<code>XDES Entry</code>的指针</li>
<li><code>Next Node Page Number</code>和<code>Next Node Offset</code>的组合就是指向后一个<code>XDES Entry</code>的指针。</li>
</ul>
<p>把一些<code>XDES Entry</code>结构连成一个链表有啥用？稍安勿躁，我们稍后唠叨<code>XDES Entry</code>结构组成的链表问题。</p>
</li>
<li>
<p><code>State</code>（4字节）</p>
<p>这个字段表明区的状态。可选的值就是我们前边说过的那4个，分别是：<code>FREE</code>、<code>FREE_FRAG</code>、<code>FULL_FRAG</code>和<code>FSEG</code>。具体释义就不多唠叨了，前边说的够仔细了。</p>
</li>
<li>
<p><code>Page State Bitmap</code>（16字节）</p>
<p>这个部分共占用16个字节，也就是128个比特位。我们说一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。比如<code>Page State Bitmap</code>部分的第1和第2个比特位对应着区中的第1个页面，第3和第4个比特位对应着区中的第2个页面，依此类推，<code>Page State Bitmap</code>部分的第127和128个比特位对应着区中的第64个页面。这两个比特位的第一个位表示对应的页是否是空闲的，第二个比特位还没有用。</p>
</li>
</ul>
<h4 id="XDES-Entry链表">XDES Entry链表</h4>
<p>到现在为止，我们已经提出了五花八门的概念，什么区、段、碎片区、附属于段的区、<code>XDES Entry</code>结构吧啦吧啦的概念，走远了千万别忘了自己为什么出发，我们把事情搞这么麻烦的初心仅仅是想**提高向表插入数据的效率又不至于数据量少的表浪费空间。**现在我们知道向表中插入数据本质上就是向表中各个索引的叶子节点段、非叶子节点段插入数据，也知道了不同的区有不同的状态，再回到最初的起点，捋一捋向某个段中插入数据的过程：</p>
<ul>
<li>
<p>当段中数据较少的时候，首先会查看表空间中是否有状态为<code>FREE_FRAG</code>的区，也就是找还有空闲空间的碎片区，如果找到了，那么从该区中取一些零散的页把数据插进去；否则到表空间下申请一个状态为<code>FREE</code>的区，也就是空闲的区，把该区的状态变为<code>FREE_FRAG</code>，然后从该新申请的区中取一些零散的页把数据插进去。之后不同的段使用零散页的时候都会从该区中取，直到该区中没有空闲空间，然后该区的状态就变成了<code>FULL_FRAG</code>。</p>
<p>现在的问题是你怎么知道表空间里的哪些区是<code>FREE</code>的，哪些区的状态是<code>FREE_FRAG</code>的，哪些区是<code>FULL_FRAG</code>的？要知道表空间的大小是可以不断增大的，当增长到GB级别的时候，区的数量也就上千了，我们总不能每次都遍历这些区对应的<code>XDES Entry</code>结构吧？这时候就是<code>XDES Entry</code>中的<code>List Node</code>部分发挥奇效的时候了，我们可以通过<code>List Node</code>中的指针，做这么三件事：</p>
<ul>
<li>把状态为<code>FREE</code>的区对应的<code>XDES Entry</code>结构通过<code>List Node</code>来连接成一个链表，这个链表我们就称之为<code>FREE</code>链表。</li>
<li>把状态为<code>FREE_FRAG</code>的区对应的<code>XDES Entry</code>结构通过<code>List Node</code>来连接成一个链表，这个链表我们就称之为<code>FREE_FRAG</code>链表。</li>
<li>把状态为<code>FULL_FRAG</code>的区对应的<code>XDES Entry</code>结构通过<code>List Node</code>来连接成一个链表，这个链表我们就称之为<code>FULL_FRAG</code>链表。</li>
</ul>
<p>这样每当我们想找一个<code>FREE_FRAG</code>状态的区时，就直接把<code>FREE_FRAG</code>链表的头节点拿出来，从这个节点中取一些零散的页来插入数据，当这个节点对应的区用完时，就修改一下这个节点的<code>State</code>字段的值，然后从<code>FREE_FRAG</code>链表中移到<code>FULL_FRAG</code>链表中。同理，如果<code>FREE_FRAG</code>链表中一个节点都没有，那么就直接从<code>FREE</code>链表中取一个节点移动到<code>FREE_FRAG</code>链表的状态，并修改该节点的<code>STATE</code>字段值为<code>FREE_FRAG</code>，然后从这个节点对应的区中获取零散的页就好了。</p>
</li>
<li>
<p>当段中数据已经占满了32个零散的页后，就直接申请完整的区来插入数据了。</p>
<p>还是那个问题，我们怎么知道哪些区属于哪个段的呢？再遍历各个<code>XDES Entry</code>结构？遍历是不可能遍历的，这辈子都不可能遍历的，有链表还遍历个毛线啊。所以我们把状态为<code>FSEG</code>的区对应的<code>XDES Entry</code>结构都加入到一个链表喽？傻呀，不同的段哪能共用一个区呢？你想把索引a的叶子节点段和索引b的叶子节点段都存储到一个区中么？显然我们想要每个段都有它独立的链表，所以可以根据段号（也就是<code>Segment ID</code>）来建立链表，有多少个段就建多少个链表？好像也有点问题，因为一个段中可以有好多个区，有的区是完全空闲的，有的区还有一些页面可以用，有的区已经没有空闲页面可以用了，所以我们有必要继续细分，设计<code>InnoDB</code>的大叔们为每个段中的区对应的<code>XDES Entry</code>结构建立了三个链表：</p>
<ul>
<li><code>FREE</code>链表：同一个段中，所有页面都是空闲的区对应的<code>XDES Entry</code>结构会被加入到这个链表。注意和直属于表空间的<code>FREE</code>链表区别开了，此处的<code>FREE</code>链表是附属于某个段的。</li>
<li><code>NOT_FULL</code>链表：同一个段中，仍有空闲空间的区对应的<code>XDES Entry</code>结构会被加入到这个链表。</li>
<li><code>FULL</code>链表：同一个段中，已经没有空闲空间的区对应的<code>XDES Entry</code>结构会被加入到这个链表。</li>
</ul>
<p>再次强调一遍，每一个索引都对应两个段，每个段都会维护上述的3个链表，比如下边这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t (<br>    c1 <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    c2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    c3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (c1),<br>    KEY idx_c2 (c2)<br>)ENGINE<span class="hljs-operator">=</span>InnoDB;<br></code></pre></td></tr></table></figure>
<p>这个表<code>t</code>共有两个索引，一个聚簇索引，一个二级索引<code>idx_c2</code>，所以这个表共有4个段，每个段都会维护上述3个链表，总共是12个链表，加上我们上边说过的直属于表空间的3个链表，整个独立表空间共需要维护15个链表。所以段在数据量比较大时插入数据的话，会先获取<code>NOT_FULL</code>链表的头节点，直接把数据插入这个头节点对应的区中即可，如果该区的空间已经被用完，就把该节点移到<code>FULL</code>链表中。</p>
</li>
</ul>
<h4 id="链表基节点">链表基节点</h4>
<p>上边光是介绍了一堆链表，可我们怎么找到这些链表呢，或者说怎么找到某个链表的头节点或者尾节点在表空间中的位置呢？设计<code>InnoDB</code>的大叔当然考虑了这个问题，他们设计了一个叫<code>List Base Node</code>的结构，翻译成中文就是链表的基节点。这个结构中包含了链表的头节点和尾节点的指针以及这个链表中包含了多少节点的信息，我们画图看一下这个结构的示意图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f388927e1c~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crrehf6i1jsq1j5cubj1mdoh77a4.png-81.6kB">
<p>我们上边介绍的每个链表都对应这么一个<code>List Base Node</code>结构，其中：</p>
<ul>
<li><code>List Length</code>表明该链表一共有多少节点，</li>
<li><code>First Node Page Number</code>和<code>First Node Offset</code>表明该链表的头节点在表空间中的位置。</li>
<li><code>Last Node Page Number</code>和<code>Last Node Offset</code>表明该链表的尾节点在表空间中的位置。</li>
</ul>
<p>一般我们把某个链表对应的<code>List Base Node</code>结构放置在表空间中固定的位置，这样想找定位某个链表就变得so easy啦。</p>
<h4 id="链表小结">链表小结</h4>
<p>综上所述，表空间是由若干个区组成的，每个区都对应一个<code>XDES Entry</code>的结构，直属于表空间的区对应的<code>XDES Entry</code>结构可以分成<code>FREE</code>、<code>FREE_FRAG</code>和<code>FULL_FRAG</code>这3个链表；每个段可以附属若干个区，每个段中的区对应的<code>XDES Entry</code>结构可以分成<code>FREE</code>、<code>NOT_FULL</code>和<code>FULL</code>这3个链表。每个链表都对应一个<code>List Base Node</code>的结构，这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。正是因为这些链表的存在，管理这些区才变成了一件so easy的事情。</p>
<h3 id="段的结构">段的结构</h3>
<p>我们前边说过，段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。像每个区都有对应的<code>XDES Entry</code>来记录这个区中的属性一样，设计<code>InnoDB</code>的大叔为每个段都定义了一个<code>INODE Entry</code>结构来记录一下段中的属性。大家看一下示意图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f4087c4a56~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crrju0cnji91a2fhv91ijb15hgb1.png-111.4kB">
<p>它的各个部分释义如下：</p>
<ul>
<li>
<p><code>Segment ID</code></p>
<p>就是指这个<code>INODE Entry</code>结构对应的段的编号（ID）。</p>
</li>
<li>
<p><code>NOT_FULL_N_USED</code></p>
<p>这个字段指的是在<code>NOT_FULL</code>链表中已经使用了多少个页面。</p>
</li>
<li>
<p>3个<code>List Base Node</code></p>
<p>分别为段的<code>FREE</code>链表、<code>NOT_FULL</code>链表、<code>FULL</code>链表定义了<code>List Base Node</code>，这样我们想查找某个段的某个链表的头节点和尾节点的时候，就可以直接到这个部分找到对应链表的<code>List Base Node</code>。so easy!</p>
</li>
<li>
<p><code>Magic Number</code>：</p>
<p>这个值是用来标记这个<code>INODE Entry</code>是否已经被初始化了（初始化的意思就是把各个字段的值都填进去了）。如果这个数字是值的<code>97937874</code>，表明该<code>INODE Entry</code>已经初始化，否则没有被初始化。（不用纠结这个值有啥特殊含义，人家规定的）。</p>
</li>
<li>
<p><code>Fragment Array Entry</code></p>
<p>我们前边强调过无数次段是一些零散页面和一些完整的区的集合，每个<code>Fragment Array Entry</code>结构都对应着一个零散的页面，这个结构一共4个字节，表示一个零散页面的页号。</p>
</li>
</ul>
<p>结合着这个<code>INODE Entry</code>结构，大家可能对段是一些零散页面和一些完整的区的集合的理解再次深刻一些。</p>
<h3 id="各类型页面详细情况">各类型页面详细情况</h3>
<p>到现在为止我们已经大概清楚了表空间、段、区、XDES Entry、INODE Entry、各种以<code>XDES Entry</code>为节点的链表的基本概念了，可是总有一种飞在天上不踏实的感觉，每个区对应的<code>XDES Entry</code>结构到底存储在表空间的什么地方？直属于表空间的<code>FREE</code>、<code>FREE_FRAG</code>、<code>FULL_FRAG</code>链表的基节点到底存储在表空间的什么地方？每个段对应的<code>INODE Entry</code>结构到底存在表空间的什么地方？我们前边介绍了每256个连续的区算是一个组，想解决刚才提出来的这些个疑问还得从每个组开头的一些类型相同的页面说起，接下来我们一个页面一个页面的分析，真相马上就要浮出水面了。</p>
<h4 id="FSP-HDR类型">FSP_HDR类型</h4>
<p>首先看第一个组的第一个页面，当然也是表空间的第一个页面，页号为<code>0</code>。这个页面的类型是<code>FSP_HDR</code>，它存储了表空间的一些整体属性以及第一个组内256个区的对应的<code>XDES Entry</code>结构，直接看这个类型的页面的示意图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f4733af475~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crmfvigk938c8h1hahglr15329.png-146.8kB">
<p>从图中可以看出，一个完整的<code>FSP_HDR</code>类型的页面大致由5个部分组成，各个部分的具体释义如下表：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>File Header</code></td>
<td>文件头部</td>
<td><code>38</code>字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td><code>File Space Header</code></td>
<td>表空间头部</td>
<td><code>112</code>字节</td>
<td>表空间的一些整体属性信息</td>
</tr>
<tr>
<td><code>XDES Entry</code></td>
<td>区描述信息</td>
<td><code>10240</code>字节</td>
<td>存储本组256个区对应的属性信息</td>
</tr>
<tr>
<td><code>Empty Space</code></td>
<td>尚未使用空间</td>
<td><code>5986</code>字节</td>
<td>用于页结构的填充，没啥实际意义</td>
</tr>
<tr>
<td><code>File Trailer</code></td>
<td>文件尾部</td>
<td><code>8</code>字节</td>
<td>校验页是否完整</td>
</tr>
</tbody>
</table>
<p><code>File Header</code>和<code>File Trailer</code>就不再强调了，另外的几个部分中，<code>Empty Space</code>是尚未使用的空间，我们不用管它，重点来看看<code>File Space Header</code>和<code>XDES Entry</code>这两个部分。</p>
<h5 id="File-Space-Header部分">File Space Header部分</h5>
<p>从名字就可以看出来，这个部分是用来存储表空间的一些整体属性的，废话少说，看图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f47508ede5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crrp2qp310rc10fd33ch716hcp.png-148.1kB">
<p>哇唔，字段有点儿多哦，不急一个一个慢慢看。下面是各个属性的简单描述：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Space ID</code></td>
<td><code>4</code>字节</td>
<td>表空间的ID</td>
</tr>
<tr>
<td><code>Not Used</code></td>
<td><code>4</code>字节</td>
<td>这4个字节未被使用，可以忽略</td>
</tr>
<tr>
<td><code>Size</code></td>
<td><code>4</code>字节</td>
<td>当前表空间占有的页面数</td>
</tr>
<tr>
<td><code>FREE Limit</code></td>
<td><code>4</code>字节</td>
<td>尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表</td>
</tr>
<tr>
<td><code>Space Flags</code></td>
<td><code>4</code>字节</td>
<td>表空间的一些占用存储空间比较小的属性</td>
</tr>
<tr>
<td><code>FRAG_N_USED</code></td>
<td><code>4</code>字节</td>
<td>FREE_FRAG链表中已使用的页面数量</td>
</tr>
<tr>
<td><code>List Base Node for FREE List</code></td>
<td><code>16</code>字节</td>
<td>FREE链表的基节点</td>
</tr>
<tr>
<td><code>List Base Node for FREE_FRAG List</code></td>
<td><code>16</code>字节</td>
<td>FREE_FRAG链表的基节点</td>
</tr>
<tr>
<td><code>List Base Node for FULL_FRAG List</code></td>
<td><code>16</code>字节</td>
<td>FULL_FRAG链表的基节点</td>
</tr>
<tr>
<td><code>Next Unused Segment ID</code></td>
<td><code>8</code>字节</td>
<td>当前表空间中下一个未使用的 Segment ID</td>
</tr>
<tr>
<td><code>List Base Node for SEG_INODES_FULL List</code></td>
<td><code>16</code>字节</td>
<td>SEG_INODES_FULL链表的基节点</td>
</tr>
<tr>
<td><code>List Base Node for SEG_INODES_FREE List</code></td>
<td><code>16</code>字节</td>
<td>SEG_INODES_FREE链表的基节点</td>
</tr>
</tbody>
</table>
<p>这里头的<code>Space ID</code>、<code>Not Used</code>、<code>Size</code>这三个字段大家肯定一看就懂，其他的字段我们再详细瞅瞅，为了大家的阅读体验，我就不严格按照实际的字段顺序来解释各个字段了哈。</p>
<ul>
<li>
<p><code>List Base Node for FREE List</code>、<code>List Base Node for FREE_FRAG List</code>、<code>List Base Node for FULL_FRAG List</code>。</p>
<p>这三个大家看着太亲切了，分别是直属于表空间的<code>FREE</code>链表的基节点、<code>FREE_FRAG</code>链表的基节点、<code>FULL_FRAG</code>链表的基节点，这三个链表的基节点在表空间的位置是固定的，就是在表空间的第一个页面（也就是<code>FSP_HDR</code>类型的页面）的<code>File Space Header</code>部分。所以之后定位这几个链表就so easy啦。</p>
</li>
<li>
<p><code>FRAG_N_USED</code></p>
<p>这个字段表明在<code>FREE_FRAG</code>链表中已经使用的页面数量。</p>
</li>
<li>
<p><code>FREE Limit</code></p>
<p>我们知道表空间都对应着具体的磁盘文件，一开始我们创建表空间的时候对应的磁盘文件中都没有数据，所以我们需要对表空间完成一个初始化操作，包括为表空间中的区建立<code>XDES Entry</code>结构，为各个段建立<code>INODE Entry</code>结构，建立各种链表吧啦吧啦的各种操作。我们可以一开始就为表空间申请一个特别大的空间，但是实际上有绝大部分的区是空闲的，我们可以选择把所有的这些空闲区对应的<code>XDES Entry</code>结构加入<code>FREE</code>链表，也可以选择只把一部分的空闲区加入<code>FREE</code>链表，等啥时候空闲链表中的<code>XDES Entry</code>结构对应的区不够使了，再把之前没有加入<code>FREE</code>链表的空闲区对应的<code>XDES Entry</code>结构加入<code>FREE</code>链表，中心思想就是啥时候用到啥时候初始化，设计<code>InnoDB</code>的大叔采用的就是后者，他们为表空间定义了<code>FREE Limit</code>这个字段，在该字段表示的页号之前的区都被初始化了，之后的区尚未被初始化。</p>
</li>
<li>
<p><code>Next Unused Segment ID</code></p>
<p>表中每个索引都对应2个段，每个段都有一个唯一的ID，那当我们为某个表新创建一个索引的时候，就意味着要创建两个新的段。那怎么为这个新创建的段找一个唯一的ID呢？去遍历现在表空间中所有的段么？我们说过，遍历是不可能遍历的，这辈子都不可能遍历，所以设计<code>InnoDB</code>的大叔们提出了这个名叫<code>Next Unused Segment ID</code>的字段，该字段表明当前表空间中最大的段ID的下一个ID，这样在创建新段的时候赋予新段一个唯一的ID值就so easy啦，直接使用这个字段的值就好了。</p>
</li>
<li>
<p><code>Space Flags</code></p>
<p>表空间对于一些布尔类型的属性，或者只需要寥寥几个比特位搞定的属性都放在了这个<code>Space Flags</code>中存储，虽然它只有4个字节，32个比特位大小，却存储了好多表空间的属性，详细情况如下表：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>占用的空间（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>POST_ANTELOPE</code></td>
<td>1</td>
<td>表示文件格式是否大于<code>ANTELOPE</code></td>
</tr>
<tr>
<td><code>ZIP_SSIZE</code></td>
<td>4</td>
<td>表示压缩页面的大小</td>
</tr>
<tr>
<td><code>ATOMIC_BLOBS</code></td>
<td>1</td>
<td>表示是否自动把值非常长的字段放到BLOB页里</td>
</tr>
<tr>
<td><code>PAGE_SSIZE</code></td>
<td>4</td>
<td>页面大小</td>
</tr>
<tr>
<td><code>DATA_DIR</code></td>
<td>1</td>
<td>表示表空间是否是从默认的数据目录中获取的</td>
</tr>
<tr>
<td><code>SHARED</code></td>
<td>1</td>
<td>是否为共享表空间</td>
</tr>
<tr>
<td><code>TEMPORARY</code></td>
<td>1</td>
<td>是否为临时表空间</td>
</tr>
<tr>
<td><code>ENCRYPTION</code></td>
<td>1</td>
<td>表空间是否加密</td>
</tr>
<tr>
<td><code>UNUSED</code></td>
<td>18</td>
<td>没有使用到的比特位</td>
</tr>
</tbody>
</table>
<blockquote>
<p>小贴士： 不同MySQL版本里 SPACE_FLAGS 代表的属性可能有些差异，我们这里列举的是5.7.21版本的。不过大家现在不必深究它们的意思，因为我们一旦把这些概念展开，就需要非常大的篇幅，主要怕大家受不了。我们还是先挑重要的看，把主要的表空间结构了解完，这些 SPACE_FLAGS 里的属性的细节就暂时不深究了。</p>
</blockquote>
</li>
<li>
<p><code>List Base Node for SEG_INODES_FULL List</code>和<code>List Base Node for SEG_INODES_FREE List</code></p>
<p>每个段对应的<code>INODE Entry</code>结构会集中存放到一个类型为<code>INODE</code>的页中，如果表空间中的段特别多，则会有多个<code>INODE Entry</code>结构，可能一个页放不下，这些<code>INODE</code>类型的页会组成两种列表：</p>
<ul>
<li><code>SEG_INODES_FULL</code>链表，该链表中的<code>INODE</code>类型的页面都已经被<code>INODE Entry</code>结构填充满了，没空闲空间存放额外的<code>INODE Entry</code>了。</li>
<li><code>SEG_INODES_FREE</code>链表，该链表中的<code>INODE</code>类型的页面仍有空闲空间来存放<code>INODE Entry</code>结构。</li>
</ul>
<p>由于我们现在还没有详细唠叨<code>INODE</code>类型页，所以等会说过<code>INODE</code>类型的页之后再回过头来看着两个链表。</p>
</li>
</ul>
<h5 id="XDES-Entry部分">XDES Entry部分</h5>
<p>紧接着<code>File Space Header</code>部分的就是<code>XDES Entry</code>部分了，我们嘴上唠叨过无数次，却从没见过真身的<code>XDES Entry</code>就是在表空间的第一个页面中保存的。我们知道一个<code>XDES Entry</code>结构的大小是40字节，但是一个页面的大小有限，只能存放有限个<code>XDES Entry</code>结构，所以我们才把256个区划分成一组，在每组的第一个页面中存放256个<code>XDES Entry</code>结构。大家回看那个<code>FSP_HDR</code>类型页面的示意图，<code>XDES Entry 0</code>就对应着<code>extent 0</code>，<code>XDES Entry 1</code>就对应着<code>extent 1</code>… 依此类推，<code>XDES Entry255</code>就对应着<code>extent 255</code>。</p>
<p>因为每个区对应的<code>XDES Entry</code>结构的地址是固定的，所以我们访问这些结构就so easy啦，至于该结构的详细使用情况我们已经唠叨的够明白了，在这就不赘述了。</p>
<h4 id="XDES类型">XDES类型</h4>
<p>我们说过，每一个<code>XDES Entry</code>结构对应表空间的一个区，虽然一个<code>XDES Entry</code>结构只占用40字节，但你抵不住表空间的区的数量也多啊。在区的数量非常多时，一个单独的页可能就不够存放足够多的<code>XDES Entry</code>结构，所以我们把表空间的区分为了若干个组，每组开头的一个页面记录着本组内所有的区对应的<code>XDES Entry</code>结构。由于第一个组的第一个页面有些特殊，因为它也是整个表空间的第一个页面，所以除了记录本组中的所有区对应的<code>XDES Entry</code>结构以外，还记录着表空间的一些整体属性，这个页面的类型就是我们刚刚说完的<code>FSP_HDR</code>类型，整个表空间里只有一个这个类型的页面。除去第一个分组以外，之后的每个分组的第一个页面只需要记录本组内所有的区对应的<code>XDES Entry</code>结构即可，不需要再记录表空间的属性了，为了和<code>FSP_HDR</code>类型做区别，我们把之后每个分组的第一个页面的类型定义为<code>XDES</code>，它的结构和<code>FSP_HDR</code>类型是非常相似的：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f475c0ec2a~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cs3vmoii1h971aje1iveack1l109.png-149.5kB">
<p>与<code>FSP_HDR</code>类型的页面对比，除了少了<code>File Space Header</code>部分之外，也就是除了少了记录表空间整体属性的部分之外，其余的部分是一样一样的。由于我们上边唠叨的已经够仔细了，对于<code>XDES</code>类型的页面也就不重复唠叨了哈。</p>
<h4 id="IBUF-BITMAP类型">IBUF_BITMAP类型</h4>
<p>对比前边介绍表空间的图，每个分组的第二个页面的类型都是<code>IBUF_BITMAP</code>，这种类型的页里边记录了一些有关<code>Change Buffer</code>的东东，由于这个<code>Change Buffer</code>里又包含了贼多的概念，考虑到大家在一章中接受这么多新概念有点呼吸不适，怕大家心脏病犯了所以就把<code>Change Buffer</code>的相关知识放到后边的章节中，大家稍安勿躁哈。</p>
<h4 id="INODE类型">INODE类型</h4>
<p>再次对比前边介绍表空间的图，第一个分组的第三个页面的类型是<code>INODE</code>。我们前边说过设计<code>InnoDB</code>的大叔为每个索引定义了两个段，而且为某些特殊功能定义了些特殊的段。为了方便管理，他们又为每个段设计了一个<code>INODE Entry</code>结构，这个结构中记录了关于这个段的相关属性。而我们这会儿要介绍的这个<code>INODE</code>类型的页就是为了存储<code>INODE Entry</code>结构而存在的。好了，废话少说，直接看图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16ef3a8df380813e~tplv-t2oaga2asx-watermark.awebp" class="" title="img">
<p>从图中可以看出，一个<code>INODE</code>类型的页面是由这几部分构成的：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>File Header</code></td>
<td>文件头部</td>
<td><code>38</code>字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td><code>List Node for INODE Page List</code></td>
<td>通用链表节点</td>
<td><code>12</code>字节</td>
<td>存储上一个INODE页面和下一个INODE页面的指针</td>
</tr>
<tr>
<td><code>INODE Entry</code></td>
<td>段描述信息</td>
<td><code>16320</code>字节</td>
<td></td>
</tr>
<tr>
<td><code>Empty Space</code></td>
<td>尚未使用空间</td>
<td><code>6</code>字节</td>
<td>用于页结构的填充，没啥实际意义</td>
</tr>
<tr>
<td><code>File Trailer</code></td>
<td>文件尾部</td>
<td><code>8</code>字节</td>
<td>校验页是否完整</td>
</tr>
</tbody>
</table>
<p>除了<code>File Header</code>、<code>Empty Space</code>、<code>File Trailer</code>这几个老朋友外，我们重点关注<code>List Node for INODE Page List</code>和<code>INODE Entry</code>这两个部分。</p>
<p>首先看<code>INODE Entry</code>部分，我们前边已经详细介绍过这个结构的组成了，主要包括对应的段内零散页面的地址以及附属于该段的<code>FREE</code>、<code>NOT_FULL</code>和<code>FULL</code>链表的基节点。每个<code>INODE Entry</code>结构占用192字节，一个页面里可以存储<code>85</code>个这样的结构。</p>
<p>重点看一下<code>List Node for INODE Page List</code>这个玩意儿，因为一个表空间中可能存在超过85个段，所以可能一个<code>INODE</code>类型的页面不足以存储所有的段对应的<code>INODE Entry</code>结构，所以就需要额外的<code>INODE</code>类型的页面来存储这些结构。还是为了方便管理这些<code>INODE</code>类型的页面，设计<code>InnoDB</code>的大叔们将这些<code>INODE</code>类型的页面串联成两个不同的链表：</p>
<ul>
<li><code>SEG_INODES_FULL</code>链表：该链表中的<code>INODE</code>类型的页面中已经没有空闲空间来存储额外的<code>INODE Entry</code>结构了。</li>
<li><code>SEG_INODES_FREE</code>链表：该链表中的<code>INODE</code>类型的页面中还有空闲空间来存储额外的<code>INODE Entry</code>结构了。</li>
</ul>
<p>想必大家已经认出这两个链表了，我们前边提到过这两个链表的基节点就存储在<code>File Space Header</code>里边，也就是说这两个链表的基节点的位置是固定的，所以我们可以很轻松的访问到这两个链表。以后每当我们新创建一个段（创建索引时就会创建段）时，都会创建一个<code>INODE Entry</code>结构与之对应，存储<code>INODE Entry</code>的大致过程就是这样的：</p>
<ul>
<li>先看看<code>SEG_INODES_FREE</code>链表是否为空，如果不为空，直接从该链表中获取一个节点，也就相当于获取到一个仍有空闲空间的<code>INODE</code>类型的页面，然后把该<code>INODE Entry</code>结构放到该页面中。当该页面中无剩余空间时，就把该页放到<code>SEG_INODES_FULL</code>链表中。</li>
<li>如果<code>SEG_INODES_FREE</code>链表为空，则需要从表空间的<code>FREE_FRAG</code>链表中申请一个页面，修改该页面的类型为<code>INODE</code>，把该页面放到<code>SEG_INODES_FREE</code>链表中，与此同时把该<code>INODE Entry</code>结构放入该页面。</li>
</ul>
<h3 id="Segment-Header-结构的运用">Segment Header 结构的运用</h3>
<p>我们知道一个索引会产生两个段，分别是叶子节点段和非叶子节点段，而每个段都会对应一个<code>INODE Entry</code>结构，那我们怎么知道某个段对应哪个<code>INODE Entry</code>结构呢？所以得找个地方记下来这个对应关系。希望你还记得我们在唠叨数据页，也就是<code>INDEX</code>类型的页时有一个<code>Page Header</code>部分，当然我不能指望你记住，所以把<code>Page Header</code>部分再抄一遍给你看：</p>
<p><strong>Page Header部分</strong>（为突出重点，省略了好多属性）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td><code>PAGE_BTR_SEG_LEAF</code></td>
<td><code>10</code>字节</td>
<td>B+树叶子段的头部信息，仅在B+树的根页定义</td>
</tr>
<tr>
<td><code>PAGE_BTR_SEG_TOP</code></td>
<td><code>10</code>字节</td>
<td>B+树非叶子段的头部信息，仅在B+树的根页定义</td>
</tr>
</tbody>
</table>
<p>其中的<code>PAGE_BTR_SEG_LEAF</code>和<code>PAGE_BTR_SEG_TOP</code>都占用10个字节，它们其实对应一个叫<code>Segment Header</code>的结构，该结构图示如下：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f48c4472a3~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d6a74gu41fuqcqm1htri771d1k16.png-65.1kB">
<p>各个部分的具体释义如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用字节数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Space ID of the INODE Entry</code></td>
<td><code>4</code></td>
<td>INODE Entry结构所在的表空间ID</td>
</tr>
<tr>
<td><code>Page Number of the INODE Entry</code></td>
<td><code>4</code></td>
<td>INODE Entry结构所在的页面页号</td>
</tr>
<tr>
<td><code>Byte Offset of the INODE Ent</code></td>
<td><code>2</code></td>
<td>INODE Entry结构在该页面中的偏移量</td>
</tr>
</tbody>
</table>
<p>这样子就很清晰了，<code>PAGE_BTR_SEG_LEAF</code>记录着叶子节点段对应的<code>INODE Entry</code>结构的地址是哪个表空间的哪个页面的哪个偏移量，<code>PAGE_BTR_SEG_TOP</code>记录着非叶子节点段对应的<code>INODE Entry</code>结构的地址是哪个表空间的哪个页面的哪个偏移量。这样子索引和其对应的段的关系就建立起来了。不过需要注意的一点是，因为一个索引只对应两个段，所以只需要在索引的根页面中记录这两个结构即可。</p>
<h3 id="真实表空间对应的文件大小">真实表空间对应的文件大小</h3>
<p>等会儿等会儿，上边的这些概念已经压的快喘不过气了。不过独立表空间有那么大么？我到数据目录里看了，一个新建的表对应的<code>.ibd</code>文件只占用了96K，才6个页面大小，上边的内容该不是扯犊子吧？</p>
<p>哈，一开始表空间占用的空间自然是很小，因为表里边都没有数据嘛！不过别忘了这些<code>.ibd</code>文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p>
<h2 id="系统表空间">系统表空间</h2>
<p>了解完了独立表空间的基本结构，系统表空间的结构也就好理解多了，系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，所以会比独立表空间多出一些记录这些信息的页面。因为这个系统表空间最牛逼，相当于是表空间之首，所以它的<code>表空间 ID</code>（Space ID）是<code>0</code>。</p>
<h3 id="系统表空间的整体结构">系统表空间的整体结构</h3>
<p>系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面，如图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f4911220d8~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1csbied27ohe1rgg32gquulplm.png-147.4kB">
<p>可以看到，系统表空间和独立表空间的前三个页面（页号分别为<code>0</code>、<code>1</code>、<code>2</code>，类型分别是<code>FSP_HDR</code>、<code>IBUF_BITMAP</code>、<code>INODE</code>）的类型是一致的，只是页号为<code>3</code>～<code>7</code>的页面是系统表空间特有的，我们来看一下这些多出来的页面都是干啥使的：</p>
<table>
<thead>
<tr>
<th>页号</th>
<th>页面类型</th>
<th>英文描述</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>3</code></td>
<td><code>SYS</code></td>
<td>Insert Buffer Header</td>
<td>存储Insert Buffer的头部信息</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>INDEX</code></td>
<td>Insert Buffer Root</td>
<td>存储Insert Buffer的根页面</td>
</tr>
<tr>
<td><code>5</code></td>
<td><code>TRX_SYS</code></td>
<td>Transction System</td>
<td>事务系统的相关信息</td>
</tr>
<tr>
<td><code>6</code></td>
<td><code>SYS</code></td>
<td>First Rollback Segment</td>
<td>第一个回滚段的页面</td>
</tr>
<tr>
<td><code>7</code></td>
<td><code>SYS</code></td>
<td>Data Dictionary Header</td>
<td>数据字典头部信息</td>
</tr>
</tbody>
</table>
<p>除了这几个记录系统属性的页面之外，系统表空间的<code>extent 1</code>和<code>extent 2</code>这两个区，也就是页号从<code>64</code>~<code>191</code>这128个页面被称为<code>Doublewrite buffer</code>，也就是双写缓冲区。不过上述的大部分知识都涉及到了事务和多版本控制的问题，这些问题我们会放在后边的章节集中唠叨，现在讲述太影响用户体验，所以现在我们只唠叨一下有关InnoDB数据字典的知识，其余的概念在后边再看。</p>
<h4 id="InnoDB数据字典">InnoDB数据字典</h4>
<p>我们平时使用<code>INSERT</code>语句向表中插入的那些记录称之为用户数据，MySQL只是作为一个软件来为我们来保管这些数据，提供方便的增删改查接口而已。但是每当我们向一个表中插入一条记录的时候，MySQL先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的<code>B+</code>树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：</p>
<ul>
<li>某个表属于哪个表空间，表里边有多少列</li>
<li>表对应的每一个列的类型是什么</li>
<li>该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面</li>
<li>该表有哪些外键，外键对应哪个表的哪些列</li>
<li>某个表空间对应文件系统上文件路径是什么</li>
<li>balabala … 还有好多，不一一列举了</li>
</ul>
<p>上述这些数据并不是我们使用<code>INSERT</code>语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为<code>元数据</code>。InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些<code>元数据</code>：</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SYS_TABLES</code></td>
<td>整个InnoDB存储引擎中所有的表的信息</td>
</tr>
<tr>
<td><code>SYS_COLUMNS</code></td>
<td>整个InnoDB存储引擎中所有的列的信息</td>
</tr>
<tr>
<td><code>SYS_INDEXES</code></td>
<td>整个InnoDB存储引擎中所有的索引的信息</td>
</tr>
<tr>
<td><code>SYS_FIELDS</code></td>
<td>整个InnoDB存储引擎中所有的索引对应的列的信息</td>
</tr>
<tr>
<td><code>SYS_FOREIGN</code></td>
<td>整个InnoDB存储引擎中所有的外键的信息</td>
</tr>
<tr>
<td><code>SYS_FOREIGN_COLS</code></td>
<td>整个InnoDB存储引擎中所有的外键对应列的信息</td>
</tr>
<tr>
<td><code>SYS_TABLESPACES</code></td>
<td>整个InnoDB存储引擎中所有的表空间信息</td>
</tr>
<tr>
<td><code>SYS_DATAFILES</code></td>
<td>整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息</td>
</tr>
<tr>
<td><code>SYS_VIRTUAL</code></td>
<td>整个InnoDB存储引擎中所有的虚拟生成列的信息</td>
</tr>
</tbody>
</table>
<p>这些系统表也被称为<code>数据字典</code>，它们都是以<code>B+</code>树的形式保存在系统表空间的某些页面中，其中<code>SYS_TABLES</code>、<code>SYS_COLUMNS</code>、<code>SYS_INDEXES</code>、<code>SYS_FIELDS</code>这四个表尤其重要，称之为基本系统表（basic system tables），我们先看看这4个表的结构：</p>
<h5 id="SYS-TABLES表">SYS_TABLES表</h5>
<p><strong>SYS_TABLES表的列</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME</code></td>
<td>表的名称</td>
</tr>
<tr>
<td><code>ID</code></td>
<td>InnoDB存储引擎中每个表都有一个唯一的ID</td>
</tr>
<tr>
<td><code>N_COLS</code></td>
<td>该表拥有列的个数</td>
</tr>
<tr>
<td><code>TYPE</code></td>
<td>表的类型，记录了一些文件格式、行格式、压缩等信息</td>
</tr>
<tr>
<td><code>MIX_ID</code></td>
<td>已过时，忽略</td>
</tr>
<tr>
<td><code>MIX_LEN</code></td>
<td>表的一些额外的属性</td>
</tr>
<tr>
<td><code>CLUSTER_ID</code></td>
<td>未使用，忽略</td>
</tr>
<tr>
<td><code>SPACE</code></td>
<td>该表所属表空间的ID</td>
</tr>
</tbody>
</table>
<p>这个<code>SYS_TABLES</code>表有两个索引：</p>
<ul>
<li>以<code>NAME</code>列为主键的聚簇索引</li>
<li>以<code>ID</code>列建立的二级索引</li>
</ul>
<h5 id="SYS-COLUMNS表">SYS_COLUMNS表</h5>
<p><strong>SYS_COLUMNS表的列</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TABLE_ID</code></td>
<td>该列所属表对应的ID</td>
</tr>
<tr>
<td><code>POS</code></td>
<td>该列在表中是第几列</td>
</tr>
<tr>
<td><code>NAME</code></td>
<td>该列的名称</td>
</tr>
<tr>
<td><code>MTYPE</code></td>
<td>main data type，主数据类型，就是那堆INT、CHAR、VARCHAR、FLOAT、DOUBLE之类的东东</td>
</tr>
<tr>
<td><code>PRTYPE</code></td>
<td>precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许NULL值，是否允许负数啥的</td>
</tr>
<tr>
<td><code>LEN</code></td>
<td>该列最多占用存储空间的字节数</td>
</tr>
<tr>
<td><code>PREC</code></td>
<td>该列的精度，不过这列貌似都没有使用，默认值都是0</td>
</tr>
</tbody>
</table>
<p>这个<code>SYS_COLUMNS</code>表只有一个聚集索引：</p>
<ul>
<li>以<code>(TABLE_ID, POS)</code>列为主键的聚簇索引</li>
</ul>
<h5 id="SYS-INDEXES表">SYS_INDEXES表</h5>
<p><strong>SYS_INDEXES表的列</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TABLE_ID</code></td>
<td>该索引所属表对应的ID</td>
</tr>
<tr>
<td><code>ID</code></td>
<td>InnoDB存储引擎中每个索引都有一个唯一的ID</td>
</tr>
<tr>
<td><code>NAME</code></td>
<td>该索引的名称</td>
</tr>
<tr>
<td><code>N_FIELDS</code></td>
<td>该索引包含列的个数</td>
</tr>
<tr>
<td><code>TYPE</code></td>
<td>该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td>
</tr>
<tr>
<td><code>SPACE</code></td>
<td>该索引根页面所在的表空间ID</td>
</tr>
<tr>
<td><code>PAGE_NO</code></td>
<td>该索引根页面所在的页面号</td>
</tr>
<tr>
<td><code>MERGE_THRESHOLD</code></td>
<td>如果页面中的记录被删除到某个比例，就把该页面和相邻页面合并，这个值就是这个比例</td>
</tr>
</tbody>
</table>
<p>这个<code>SYS_INDEXES</code>表只有一个聚集索引：</p>
<ul>
<li>以<code>(TABLE_ID, ID)</code>列为主键的聚簇索引</li>
</ul>
<h5 id="SYS-FIELDS表">SYS_FIELDS表</h5>
<p><strong>SYS_FIELDS表的列</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>INDEX_ID</code></td>
<td>该索引列所属的索引的ID</td>
</tr>
<tr>
<td><code>POS</code></td>
<td>该索引列在某个索引中是第几列</td>
</tr>
<tr>
<td><code>COL_NAME</code></td>
<td>该索引列的名称</td>
</tr>
</tbody>
</table>
<p>这个<code>SYS_FIELDS</code>表只有一个聚集索引：</p>
<ul>
<li>以<code>(INDEX_ID, POS)</code>列为主键的聚簇索引</li>
</ul>
<h5 id="Data-Dictionary-Header页面">Data Dictionary Header页面</h5>
<p>只要有了上述4个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。比方说我们想看看<code>SYS_TABLESPACES</code>这个系统表里存储了哪些表空间以及表空间对应的属性，那就可以：</p>
<ul>
<li>到<code>SYS_TABLES</code>表中根据表名定位到具体的记录，就可以获取到<code>SYS_TABLESPACES</code>表的<code>TABLE_ID</code></li>
<li>使用这个<code>TABLE_ID</code>到<code>SYS_COLUMNS</code>表中就可以获取到属于该表的所有列的信息。</li>
<li>使用这个<code>TABLE_ID</code>还可以到<code>SYS_INDEXES</code>表中获取所有的索引的信息，索引的信息中包括对应的<code>INDEX_ID</code>，还记录着该索引对应的<code>B+</code>数根页面是哪个表空间的哪个页面。</li>
<li>使用<code>INDEX_ID</code>就可以到<code>SYS_FIELDS</code>表中获取所有索引列的信息。</li>
</ul>
<p>也就是说这4个表是表中之表，那这4个表的元数据去哪里获取呢？没法搞了，只能把这4个表的元数据，就是它们有哪些列、哪些索引等信息硬编码到代码中，然后设计<code>InnoDB</code>的大叔又拿出一个固定的页面来记录这4个表的聚簇索引和二级索引对应的<code>B+树</code>位置，这个页面就是页号为<code>7</code>的页面，类型为<code>SYS</code>，记录了<code>Data Dictionary Header</code>，也就是数据字典的头部信息。除了这4个表的5个索引的根页面信息外，这个页号为<code>7</code>的页面还记录了整个InnoDB存储引擎的一些全局属性，说话太啰嗦，直接看这个页面的示意图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16efe1e5a01aeac9~tplv-t2oaga2asx-watermark.awebp" class="" title="img">
<p>可以看到这个页面由下边几个部分组成：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>File Header</code></td>
<td>文件头部</td>
<td><code>38</code>字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td><code>Data Dictionary Header</code></td>
<td>数据字典头部信息</td>
<td><code>56</code>字节</td>
<td>记录一些基本系统表的根页面位置以及InnoDB存储引擎的一些全局信息</td>
</tr>
<tr>
<td><code>Segment Header</code></td>
<td>段头部信息</td>
<td><code>10</code>字节</td>
<td>记录本页面所在段对应的INODE Entry位置信息</td>
</tr>
<tr>
<td><code>Empty Space</code></td>
<td>尚未使用空间</td>
<td><code>16272</code>字节</td>
<td>用于页结构的填充，没啥实际意义</td>
</tr>
<tr>
<td><code>File Trailer</code></td>
<td>文件尾部</td>
<td><code>8</code>字节</td>
<td>校验页是否完整</td>
</tr>
</tbody>
</table>
<p>可以看到这个页面里竟然有<code>Segment Header</code>部分，意味着设计InnoDB的大叔把这些有关数据字典的信息当成一个段来分配存储空间，我们就姑且称之为<code>数据字典段</code>吧。由于目前我们需要记录的数据字典信息非常少（可以看到<code>Data Dictionary Header</code>部分仅占用了56字节），所以该段只有一个碎片页，也就是页号为<code>7</code>的这个页。</p>
<p>接下来我们需要细细唠叨一下<code>Data Dictionary Header</code>部分的各个字段：</p>
<ul>
<li><code>Max Row ID</code>：我们说过如果我们不显式的为表定义主键，而且表中也没有<code>UNIQUE</code>索引，那么<code>InnoDB</code>存储引擎会默认为我们生成一个名为<code>row_id</code>的列作为主键。因为它是主键，所以每条记录的<code>row_id</code>列的值不能重复。原则上只要一个表中的<code>row_id</code>列不重复就可以了，也就是说表a和表b拥有一样的<code>row_id</code>列也没啥关系，不过设计InnoDB的大叔只提供了这个<code>Max Row ID</code>字段，不论哪个拥有<code>row_id</code>列的表插入一条记录时，该记录的<code>row_id</code>列的值就是<code>Max Row ID</code>对应的值，然后再把<code>Max Row ID</code>对应的值加1，也就是说这个<code>Max Row ID</code>是全局共享的。</li>
<li><code>Max Table ID</code>：InnoDB存储引擎中的所有的表都对应一个唯一的ID，每次新建一个表时，就会把本字段的值作为该表的ID，然后自增本字段的值。</li>
<li><code>Max Index ID</code>：InnoDB存储引擎中的所有的索引都对应一个唯一的ID，每次新建一个索引时，就会把本字段的值作为该索引的ID，然后自增本字段的值。</li>
<li><code>Max Space ID</code>：InnoDB存储引擎中的所有的表空间都对应一个唯一的ID，每次新建一个表空间时，就会把本字段的值作为该表空间的ID，然后自增本字段的值。</li>
<li><code>Mix ID Low(Unused)</code>：这个字段没啥用，跳过。</li>
<li><code>Root of SYS_TABLES clust index</code>：本字段代表<code>SYS_TABLES</code>表聚簇索引的根页面的页号。</li>
<li><code>Root of SYS_TABLE_IDS sec index</code>：本字段代表<code>SYS_TABLES</code>表为<code>ID</code>列建立的二级索引的根页面的页号。</li>
<li><code>Root of SYS_COLUMNS clust index</code>：本字段代表<code>SYS_COLUMNS</code>表聚簇索引的根页面的页号。</li>
<li><code>Root of SYS_INDEXES clust index</code>本字段代表<code>SYS_INDEXES</code>表聚簇索引的根页面的页号。</li>
<li><code>Root of SYS_FIELDS clust index</code>：本字段代表<code>SYS_FIELDS</code>表聚簇索引的根页面的页号。</li>
<li><code>Unused</code>：这4个字节没用，跳过。</li>
</ul>
<p>以上就是页号为<code>7</code>的页面的全部内容，初次看可能会懵逼（因为有点儿绕），大家多瞅几次。</p>
<h5 id="information-schema系统数据库">information_schema系统数据库</h5>
<p>需要注意一点的是，用户是不能直接访问<code>InnoDB</code>的这些内部系统表的，除非你直接去解析系统表空间对应文件系统上的文件。不过设计InnoDB的大叔考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库<code>information_schema</code>中提供了一些以<code>innodb_sys</code>开头的表：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; USE information_schema;<br>Database changed<br><br>mysql&gt; SHOW TABLES LIKE &#x27;innodb_sys%&#x27;;<br>+--------------------------------------------+<br>|<span class="hljs-string"> Tables_in_information_schema (innodb_sys%) </span>|<br>+--------------------------------------------+<br>|<span class="hljs-string"> INNODB_SYS_DATAFILES                       </span>|<br>|<span class="hljs-string"> INNODB_SYS_VIRTUAL                         </span>|<br>|<span class="hljs-string"> INNODB_SYS_INDEXES                         </span>|<br>|<span class="hljs-string"> INNODB_SYS_TABLES                          </span>|<br>|<span class="hljs-string"> INNODB_SYS_FIELDS                          </span>|<br>|<span class="hljs-string"> INNODB_SYS_TABLESPACES                     </span>|<br>|<span class="hljs-string"> INNODB_SYS_FOREIGN_COLS                    </span>|<br>|<span class="hljs-string"> INNODB_SYS_COLUMNS                         </span>|<br>|<span class="hljs-string"> INNODB_SYS_FOREIGN                         </span>|<br>|<span class="hljs-string"> INNODB_SYS_TABLESTATS                      </span>|<br>+--------------------------------------------+<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>在<code>information_schema</code>数据库中的这些以<code>INNODB_SYS</code>开头的表并不是真正的内部系统表（内部系统表就是我们上边唠叨的以<code>SYS</code>开头的那些表），而是在存储引擎启动时读取这些以<code>SYS</code>开头的系统表，然后填充到这些以<code>INNODB_SYS</code>开头的表中。以<code>INNODB_SYS</code>开头的表和以<code>SYS</code>开头的表中的字段并不完全一样，但供大家参考已经足矣。这些表太多了，我就不唠叨了，大家自个儿动手试着查一查这些表中的数据吧哈～</p>
<h3 id="总结图">总结图</h3>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f4a99c9a08~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d9ppsbelendcbb13hghhn18pe9.png-3564.2kB">
<h1>10.单表访问方法</h1>
<p>对于我们这些<code>MySQL</code>的使用者来说，<code>MySQL</code>其实就是一个软件，平时用的最多的就是查询功能。DBA时不时丢过来一些慢查询语句让优化，我们如果连查询是怎么执行的都不清楚还优化个毛线，所以是时候掌握真正的技术了。我们在第一章的时候就曾说过，<code>MySQL Server</code>有一个称为<code>查询优化器</code>的模块，一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的<code>执行计划</code>，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。不过查询优化这个主题有点儿大，在学会跑之前还得先学会走，所以本章先来瞅瞅<code>MySQL</code>怎么执行单表查询（就是<code>FROM</code>子句后边只有一个表，最简单的那种查询～）。不过需要强调的一点是，在学习本章前务必看过前边关于记录结构、数据页结构以及索引的部分，如果你不能保证这些东西已经完全掌握，那么本章不适合你。</p>
<p>为了故事的顺利发展，我们先得有个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> single_table (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    key1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key2 <span class="hljs-type">INT</span>,<br>    key3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    common_field <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    KEY idx_key1 (key1),<br>    <span class="hljs-keyword">UNIQUE</span> KEY idx_key2 (key2),<br>    KEY idx_key3 (key3),<br>    KEY idx_key_part(key_part1, key_part2, key_part3)<br>) Engine<span class="hljs-operator">=</span>InnoDB CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure>
<p>我们为这个<code>single_table</code>表建立了1个聚簇索引和4个二级索引，分别是：</p>
<ul>
<li>为<code>id</code>列建立的聚簇索引。</li>
<li>为<code>key1</code>列建立的<code>idx_key1</code>二级索引。</li>
<li>为<code>key2</code>列建立的<code>idx_key2</code>二级索引，而且该索引是唯一二级索引。</li>
<li>为<code>key3</code>列建立的<code>idx_key3</code>二级索引。</li>
<li>为<code>key_part1</code>、<code>key_part2</code>、<code>key_part3</code>列建立的<code>idx_key_part</code>二级索引，这也是一个联合索引。</li>
</ul>
<p>然后我们需要为这个表插入10000行记录，除<code>id</code>列外其余的列都插入随机值就好了，具体的插入语句我就不写了，自己写个程序插入吧（id列是自增主键列，不需要我们手动插入）。</p>
<h2 id="访问方法（access-method）的概念">访问方法（access method）的概念</h2>
<p>想必各位都用过高德地图来查找到某个地方的路线吧（此处没有为高德地图打广告的意思，他们没给我钱，大家用百度地图也可以啊），如果我们搜西安钟楼到大雁塔之间的路线的话，地图软件会给出n种路线供我们选择，如果我们实在闲的没事儿干并且足够有钱的话，还可以用南辕北辙的方式绕地球一圈到达目的地。也就是说，不论采用哪一种方式，我们最终的目标就是到达大雁塔这个地方。回到<code>MySQL</code>中来，我们平时所写的那些查询语句本质上只是一种声明式的语法，只是告诉<code>MySQL</code>我们要获取的数据符合哪些规则，至于<code>MySQL</code>背地里是怎么把查询结果搞出来的那是<code>MySQL</code>自己的事儿。对于单个表的查询来说，设计MySQL的大叔把查询的执行方式大致分为下边两种：</p>
<ul>
<li>
<p>使用全表扫描进行查询</p>
<p>这种执行方式很好理解，就是把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。不管是啥查询都可以使用这种方式执行，当然，这种也是最笨的执行方式。</p>
</li>
<li>
<p>使用索引进行查询</p>
<p>因为直接使用全表扫描的方式执行查询要遍历好多记录，所以代价可能太大了。如果查询语句中的搜索条件可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。使用索引来执行查询的方式五花八门，又可以细分为许多种类：</p>
<ul>
<li>针对主键或唯一二级索引的等值查询</li>
<li>针对普通二级索引的等值查询</li>
<li>针对索引列的范围查询</li>
<li>直接扫描整个索引</li>
</ul>
</li>
</ul>
<p>设计<code>MySQL</code>的大叔把<code>MySQL</code>执行查询语句的方式称之为<code>访问方法</code>或者<code>访问类型</code>。同一个查询语句可能可以使用多种不同的访问方法来执行，虽然最后的查询结果都是一样的，但是执行的时间可能差老鼻子远了，就像是从钟楼到大雁塔，你可以坐火箭去，也可以坐飞机去，当然也可以坐乌龟去。下边细细道来各种<code>访问方法</code>的具体内容。</p>
<h2 id="const">const</h2>
<p>有的时候我们可以通过主键列来定位一条记录，比方说这个查询：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">1438</span>;<br></code></pre></td></tr></table></figure>
<p><code>MySQL</code>会直接利用主键值在聚簇索引中定位对应的用户记录，就像这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843dec61b4e~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctendl4319v659s1dfoj6lssl16.png-36.4kB">
<p>原谅我把聚簇索引对应的复杂的<code>B+</code>树结构搞了一个极度精简版，为了突出重点，我们忽略掉了<code>页</code>的结构，直接把所有的叶子节点的记录都放在一起展示，而且记录中只展示我们关心的索引列，对于<code>single_table</code>表的聚簇索引来说，展示的就是<code>id</code>列。我们想突出的重点就是：<code>B+</code>树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的<code>B+</code>树叶子节点中的记录就是按照<code>id</code>列排序的。<code>B+</code>树本来就是一个矮矮的大胖子，所以这样根据主键值定位一条记录的速度贼快。类似的，我们根据唯一二级索引列来定位一条记录的速度也是贼快的，比如下边这个查询：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 = <span class="hljs-number">3841</span>;<br></code></pre></td></tr></table></figure>
<p>这个查询的执行过程的示意图就是这样：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843e05c8e33~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cthurrlpbhlotsjru1dsjrrl30.png-110.2kB">
<p>可以看到这个查询的执行分两步，第一步先从<code>idx_key2</code>对应的<code>B+</code>树索引中根据<code>key2</code>列与常数的等值比较条件定位到一条二级索引记录，然后再根据该记录的<code>id</code>值到聚簇索引中获取到完整的用户记录。</p>
<p>设计<code>MySQL</code>的大叔认为通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像坐火箭一样快的，所以他们把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：**<code>const</code>，意思是常数级别的，代价是可以忽略不计的。**不过这种<code>const</code>访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个<code>const</code>访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。</p>
<p>对于唯一二级索引来说，查询该列为<code>NULL</code>值的情况比较特殊，比如这样：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>
<p>因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用<code>const</code>访问方法来执行（至于是什么访问方法我们下边马上说）。</p>
<h2 id="ref">ref</h2>
<p>有时候我们对某个普通的二级索引列与常数进行等值比较，比如这样：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>对于这个查询，我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到对应记录的<code>id</code>值，然后再回表到聚簇索引中查找完整的用户记录。**由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。**如果匹配的记录较少，则回表的代价还是比较低的，所以<code>MySQL</code>可能选择使用索引而不是全表扫描的方式来执行查询。设计<code>MySQL</code>的大叔就把这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为：<code>ref</code>。我们看一下采用<code>ref</code>访问方法执行查询的图示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843e5e227f1~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctf14vso11cdclsmc6ac8pru9h.png-109.5kB">
<p>从图示中可以看出，对于普通的二级索引来说，通过索引列进行等值比较后可能匹配到多条连续的记录，而不是像主键或者唯一二级索引那样最多只能匹配1条记录，所以这种<code>ref</code>访问方法比<code>const</code>差了那么一丢丢，但是在二级索引等值比较时匹配的记录数较少时的效率还是很高的（如果匹配的二级索引记录太多那么回表的成本就太大了），跟坐高铁差不多。不过需要注意下边两种情况：</p>
<ul>
<li>
<p>二级索引列值为<code>NULL</code>的情况</p>
<p>不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含<code>NULL</code>值的数量并不限制，所以我们采用<code>key IS NULL</code>这种形式的搜索条件最多只能使用<code>ref</code>的访问方法，而不是<code>const</code>的访问方法。</p>
</li>
<li>
<p>对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用<code>ref</code>的访问方法，比方说下边这几个查询：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key_part1 = <span class="hljs-string">&#x27;god like&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key_part1 = <span class="hljs-string">&#x27;god like&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;legendary&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key_part1 = <span class="hljs-string">&#x27;god like&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;legendary&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;penta kill&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为<code>ref</code>了，比方说这样：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key_part1 = <span class="hljs-string">&#x27;god like&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 &gt; <span class="hljs-string">&#x27;legendary&#x27;</span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ref-or-null">ref_or_null</h2>
<p>有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为<code>NULL</code>的记录也找出来，就像下边这个查询：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">OR</span> key1 <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>
<p>当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为<code>ref_or_null</code>，这个<code>ref_or_null</code>访问方法的执行过程如下：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843e8927bee~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctf21uu8113m1ajm1rcitgf5eeco.png-122.5kB">
<p>可以看到，上边的查询相当于先分别从<code>idx_key1</code>索引对应的<code>B+</code>树中找出<code>key1 IS NULL</code>和<code>key1 = 'abc'</code>的两个连续的记录范围，然后根据这些二级索引记录中的<code>id</code>值再回表查找完整的用户记录。</p>
<h2 id="range">range</h2>
<p>我们之前介绍的几种访问方法都是在对索引列与某一个常数进行等值比较的时候才可能使用到（<code>ref_or_null</code>比较奇特，还计算了值为<code>NULL</code>的情况），但是有时候我们面对的搜索条件更复杂，比如下边这个查询：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table WHERE key<span class="hljs-number">2</span> IN (<span class="hljs-number">1438</span>, <span class="hljs-number">6328</span>) OR (key<span class="hljs-number">2</span> &gt;= <span class="hljs-number">38</span> AND key<span class="hljs-number">2</span> &lt;= <span class="hljs-number">79</span>);<br></code></pre></td></tr></table></figure>
<p>我们当然还可以使用全表扫描的方式来执行这个查询，不过也可以使用<code>二级索引 + 回表</code>的方式执行，如果采用<code>二级索引 + 回表</code>的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是索引列需要匹配某个或某些范围的值，在本查询中<code>key2</code>列的值只要匹配下列3个范围中的任何一个就算是匹配成功了：</p>
<ul>
<li><code>key2</code>的值是<code>1438</code></li>
<li><code>key2</code>的值是<code>6328</code></li>
<li><code>key2</code>的值在<code>38</code>和<code>79</code>之间。</li>
</ul>
<p>设计<code>MySQL</code>的大叔把这种利用索引进行范围匹配的访问方法称之为：<code>range</code>。</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">小贴士：<br><br>此处所说的使用索引进行范围匹配中的 `索引` 可以是聚簇索引，也可以是二级索引。<br></code></pre></td></tr></table></figure>
<p>如果把这几个所谓的<code>key2</code>列的值需要满足的<code>范围</code>在数轴上体现出来的话，那应该是这个样子：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843e91231c9~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cth9mkf41li1dad1tnd6dm5139.png-9.2kB">
<p>也就是从数学的角度看，每一个所谓的范围都是数轴上的一个<code>区间</code>，3个范围也就对应着3个区间：</p>
<ul>
<li>范围1：<code>key2 = 1438</code></li>
<li>范围2：<code>key2 = 6328</code></li>
<li>范围3：<code>key2 ∈ [38, 79]</code>，注意这里是闭区间。</li>
</ul>
<p>我们可以把那种索引列等值匹配的情况称之为<code>单点区间</code>，上边所说的<code>范围1</code>和<code>范围2</code>都可以被称为单点区间，像<code>范围3</code>这种的我们可以称为连续范围区间。</p>
<h2 id="index">index</h2>
<p>看下边这个查询：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> key_part<span class="hljs-number">1</span>, key_part<span class="hljs-number">2</span>, key_part<span class="hljs-number">3</span> FROM single_table WHERE key_part<span class="hljs-number">2</span> = &#x27;abc&#x27;;<br></code></pre></td></tr></table></figure>
<p>由于<code>key_part2</code>并不是联合索引<code>idx_key_part</code>最左索引列，所以我们无法使用<code>ref</code>或者<code>range</code>访问方法来执行这个语句。但是这个查询符合下边这两个条件：</p>
<ul>
<li>它的查询列表只有3个列：<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>，而索引<code>idx_key_part</code>又包含这三个列。</li>
<li>搜索条件中只有<code>key_part2</code>列。这个列也包含在索引<code>idx_key_part</code>中。</li>
</ul>
<p>也就是说我们可以直接通过遍历<code>idx_key_part</code>索引的叶子节点的记录来比较<code>key_part2 = 'abc'</code>这个条件是否成立，把匹配成功的二级索引记录的<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多，设计<code>MySQL</code>的大叔就把这种采用遍历二级索引记录的执行方式称之为：<code>index</code>。</p>
<h2 id="all">all</h2>
<p>最直接的查询执行方式就是我们已经提了无数遍的全表扫描，对于<code>InnoDB</code>表来说也就是直接扫描聚簇索引，设计<code>MySQL</code>的大叔把这种使用全表扫描执行查询的方式称之为：<code>all</code>。</p>
<h2 id="注意事项-2">注意事项</h2>
<h3 id="重温-二级索引-回表">重温 二级索引 + 回表</h3>
<p>一般情况下只能利用单个二级索引执行查询，比方说下边的这个查询：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">AND</span> key2 &gt; <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure>
<p>查询优化器会识别到这个查询中的两个搜索条件：</p>
<ul>
<li><code>key1 = 'abc'</code></li>
<li><code>key2 &gt; 1000</code></li>
</ul>
<p>优化器一般会根据<code>single_table</code>表的统计数据来判断到底使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询（关于如何比较的细节我们后边的章节中会唠叨）。然后将从该二级索引中查询到的结果经过回表得到完整的用户记录后再根据其余的<code>WHERE</code>条件过滤记录。一般来说，等值查找比范围查找需要扫描的行数更少（也就是<code>ref</code>的访问方法一般比<code>range</code>好，但这也不总是一定的，也可能采用<code>ref</code>访问方法的那个索引列的值为特定值的行数特别多），所以这里假设优化器决定使用<code>idx_key1</code>索引进行查询，那么整个查询过程可以分为两个步骤：</p>
<ul>
<li>步骤1：使用二级索引定位记录的阶段，也就是根据条件<code>key1 = 'abc'</code>从<code>idx_key1</code>索引代表的<code>B+</code>树中找到对应的二级索引记录。</li>
<li>步骤2：回表阶段，也就是根据上一步骤中找到的记录的主键值进行<code>回表</code>操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件<code>key2 &gt; 1000</code>到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户。</li>
</ul>
<p>这里需要特别提醒大家的一点是，<strong>因为二级索引的节点中的记录只包含索引列和主键，所以在步骤1中使用<code>idx_key1</code>索引进行查询时只会用到与<code>key1</code>列有关的搜索条件，其余条件，比如<code>key2 &gt; 1000</code>这个条件在步骤1中是用不到的，只有在步骤2完成回表操作后才能继续针对完整的用户记录中继续过滤。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>需要注意的是，我们说一般情况下执行一个查询只会用到单个二级索引，不过还是有特殊情况的，我们后边会详细唠叨的。<br></code></pre></td></tr></table></figure>
<h3 id="明确range访问方法使用的范围区间">明确range访问方法使用的范围区间</h3>
<p>其实对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>区间</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引，具体原因我们在前边的章节中唠叨过了，这里就不赘述了。<br><br>IN操作符的效果和若干个等值匹配操作符`=`之间用`OR`连接起来是一样的，也就是说会产生多个单点区间，比如下边这两个语句的效果是一样的：<br><br>SELECT * FROM single_table WHERE key2 IN (1438, 6328);<br>    <br>SELECT * FROM single_table WHERE key2 = 1438 OR key2 = 6328;<br></code></pre></td></tr></table></figure>
<p>不过在日常的工作中，一个查询的<code>WHERE</code>子句可能有很多个小的搜索条件，这些搜索条件需要使用<code>AND</code>或者<code>OR</code>操作符连接起来，虽然大家都知道这两个操作符的作用，但我还是要再说一遍：</p>
<ul>
<li><code>cond1 AND cond2</code> ：只有当<code>cond1</code>和<code>cond2</code>都为<code>TRUE</code>时整个表达式才为<code>TRUE</code>。</li>
<li><code>cond1 OR cond2</code>：只要<code>cond1</code>或者<code>cond2</code>中有一个为<code>TRUE</code>整个表达式就为<code>TRUE</code>。</li>
</ul>
<p>当我们想使用<code>range</code>访问方法来执行一个查询语句时，重点就是找出该查询可用的索引以及这些索引对应的范围区间。下边分两种情况看一下怎么从由<code>AND</code>或<code>OR</code>组成的复杂搜索条件中提取出正确的范围区间。</p>
<h4 id="所有搜索条件都可以使用某个索引的情况">所有搜索条件都可以使用某个索引的情况</h4>
<p>有时候每个搜索条件都可以使用到某个索引，比如下边这个查询语句：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table WHERE key<span class="hljs-number">2</span> &gt; <span class="hljs-number">100</span> AND key<span class="hljs-number">2</span> &gt; <span class="hljs-number">200</span>;<br></code></pre></td></tr></table></figure>
<p>这个查询中的搜索条件都可以使用到<code>key2</code>，也就是说每个搜索条件都对应着一个<code>idx_key2</code>的范围区间。这两个小的搜索条件使用<code>AND</code>连接起来，也就是要取两个范围区间的交集，在我们使用<code>range</code>访问方法执行查询时，使用的<code>idx_key2</code>索引的范围区间的确定过程就如下图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843e0fb74ac~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctia5p09rqss4413qq16gdbbj3q.png-44kB">
<p><code>key2 &gt; 100</code>和<code>key2 &gt; 200</code>交集当然就是<code>key2 &gt; 200</code>了，也就是说上边这个查询使用<code>idx_key2</code>的范围区间就是<code>(200, +∞)</code>。这东西小学都学过吧，再不济初中肯定都学过。我们再看一下使用<code>OR</code>将多个搜索条件连接在一起的情况：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table WHERE key<span class="hljs-number">2</span> &gt; <span class="hljs-number">100</span> OR key<span class="hljs-number">2</span> &gt; <span class="hljs-number">200</span>;<br></code></pre></td></tr></table></figure>
<p><code>OR</code>意味着需要取各个范围区间的并集，所以上边这个查询在我们使用<code>range</code>访问方法执行查询时，使用的<code>idx_key2</code>索引的范围区间的确定过程就如下图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b8448ea4909c~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctia94i617ihr5ncku4ed1gg247.png-49.1kB">
<p>也就是说上边这个查询使用<code>idx_key2</code>的范围区间就是<code>(100， +∞)</code>。</p>
<h4 id="有的搜索条件无法使用索引的情况">有的搜索条件无法使用索引的情况</h4>
<p>比如下边这个查询：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> common_field = <span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>请注意，这个查询语句中能利用的索引只有<code>idx_key2</code>一个，而<code>idx_key2</code>这个二级索引的记录中又不包含<code>common_field</code>这个字段，所以在使用二级索引<code>idx_key2</code>定位记录的阶段用不到<code>common_field = 'abc'</code>这个条件，这个条件是在回表获取了完整的用户记录后才使用的，而<code>范围区间</code>是为了到索引中取记录中提出的概念，所以在确定<code>范围区间</code>的时候不需要考虑<code>common_field = 'abc'</code>这个条件，我们在为某个索引确定范围区间的时候只需要把用不到相关索引的搜索条件替换为<code>TRUE</code>就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>之所以把用不到索引的搜索条件替换为TRUE，是因为我们不打算使用这些条件进行在该索引上进行过滤，所以不管索引的记录满不满足这些条件，我们都把它们选取出来，待到之后回表的时候再使用它们过滤。<br></code></pre></td></tr></table></figure>
<p>我们把上边的查询中用不到<code>idx_key2</code>的搜索条件替换后就是这样：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> <span class="hljs-literal">TRUE</span>;<br></code></pre></td></tr></table></figure>
<p>化简之后就是这样：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure>
<p>也就是说最上边那个查询使用<code>idx_key2</code>的范围区间就是：<code>(100, +∞)</code>。</p>
<p>再来看一下使用<code>OR</code>的情况：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">OR</span> common_field = <span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>同理，我们把使用不到<code>idx_key2</code>索引的搜索条件替换为<code>TRUE</code>：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">OR</span> <span class="hljs-literal">TRUE</span>;<br></code></pre></td></tr></table></figure>
<p>接着化简：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> <span class="hljs-literal">TRUE</span>;<br></code></pre></td></tr></table></figure>
<p>额，这也就说说明如果我们强制使用<code>idx_key2</code>执行查询的话，对应的范围区间就是<code>(-∞, +∞)</code>，也就是需要将全部二级索引的记录进行回表，这个代价肯定比直接全表扫描都大了。也就是说一个使用到索引的搜索条件和没有使用该索引的搜索条件使用<code>OR</code>连接起来后是无法使用该索引的。</p>
<h4 id="复杂搜索条件下找出范围匹配的区间">复杂搜索条件下找出范围匹配的区间</h4>
<p>有的查询的搜索条件可能特别复杂，光是找出范围匹配的各个区间就挺烦的，比方说下边这个：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> <br>        (key1 &gt; <span class="hljs-string">&#x27;xyz&#x27;</span> <span class="hljs-keyword">AND</span> key2 = <span class="hljs-number">748</span> ) <span class="hljs-keyword">OR</span><br>        (key1 &lt; <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">AND</span> key1 &gt; <span class="hljs-string">&#x27;lmn&#x27;</span>) <span class="hljs-keyword">OR</span><br>        (key1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%suf&#x27;</span> <span class="hljs-keyword">AND</span> key1 &gt; <span class="hljs-string">&#x27;zzz&#x27;</span> <span class="hljs-keyword">AND</span> (key2 &lt; <span class="hljs-number">8000</span> <span class="hljs-keyword">OR</span> common_field = <span class="hljs-string">&#x27;abc&#x27;</span>)) ;<br></code></pre></td></tr></table></figure>
<p>我滴个神，这个搜索条件真是绝了，不过大家不要被复杂的表象迷住了双眼，按着下边这个套路分析一下：</p>
<ul>
<li>
<p>首先查看<code>WHERE</code>子句中的搜索条件都涉及到了哪些列，哪些列可能使用到索引。</p>
<p>这个查询的搜索条件涉及到了<code>key1</code>、<code>key2</code>、<code>common_field</code>这3个列，然后<code>key1</code>列有普通的二级索引<code>idx_key1</code>，<code>key2</code>列有唯一二级索引<code>idx_key2</code>。</p>
</li>
<li>
<p>对于那些可能用到的索引，分析它们的范围区间。</p>
<ul>
<li>
<p>假设我们使用<code>idx_key1</code>执行查询</p>
<ul>
<li>
<p>我们需要把那些用不到该索引的搜索条件暂时移除掉，移除方法也简单，直接把它们替换为<code>TRUE</code>就好了。上边的查询中除了有关<code>key2</code>和<code>common_field</code>列不能使用到<code>idx_key1</code>索引外，<code>key1 LIKE '%suf'</code>也使用不到索引，所以把这些搜索条件替换为<code>TRUE</code>之后的样子就是这样：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">(key1 &gt; <span class="hljs-symbol">&#x27;xyz</span>&#x27; <span class="hljs-keyword">AND</span> <span class="hljs-literal">TRUE</span> ) <span class="hljs-keyword">OR</span><br>(key1 &lt; <span class="hljs-symbol">&#x27;abc</span>&#x27; <span class="hljs-keyword">AND</span> key1 &gt; <span class="hljs-symbol">&#x27;lmn</span>&#x27;) <span class="hljs-keyword">OR</span><br>(<span class="hljs-literal">TRUE</span> <span class="hljs-keyword">AND</span> key1 &gt; <span class="hljs-symbol">&#x27;zzz</span>&#x27; <span class="hljs-keyword">AND</span> (<span class="hljs-literal">TRUE</span> <span class="hljs-keyword">OR</span> <span class="hljs-literal">TRUE</span>))<br></code></pre></td></tr></table></figure>
<p>化简一下上边的搜索条件就是下边这样：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">key1</span> &gt; &#x27;xyz&#x27;) OR<br>(<span class="hljs-name">key1</span> &lt; &#x27;abc&#x27; AND key1 &gt; &#x27;lmn&#x27;) OR<br>(<span class="hljs-name">key1</span> &gt; &#x27;zzz&#x27;)<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>替换掉永远为<code>TRUE</code>或<code>FALSE</code>的条件</p>
<p>因为符合<code>key1 &lt; 'abc' AND key1 &gt; 'lmn'</code>永远为<code>FALSE</code>，所以上边的搜索条件可以被写成这样：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">key1</span> &gt; &#x27;xyz&#x27;) OR (<span class="hljs-name">key1</span> &gt; &#x27;zzz&#x27;)<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>继续化简区间</p>
<p><code>key1 &gt; 'xyz'</code>和<code>key1 &gt; 'zzz'</code>之间使用<code>OR</code>操作符连接起来的，意味着要取并集，所以最终的结果化简的到的区间就是：<code>key1 &gt; xyz</code>。也就是说：上边那个有一坨搜索条件的查询语句如果使用 idx_key1 索引执行查询的话，需要把满足<code>key1 &gt; xyz</code>的二级索引记录都取出来，然后拿着这些记录的id再进行回表，得到完整的用户记录之后再使用其他的搜索条件进行过滤。</p>
</li>
</ul>
</li>
<li>
<p>假设我们使用<code>idx_key2</code>执行查询</p>
<ul>
<li>
<p>我们需要把那些用不到该索引的搜索条件暂时使用<code>TRUE</code>条件替换掉，其中有关<code>key1</code>和<code>common_field</code>的搜索条件都需要被替换掉，替换结果就是：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(TRUE <span class="hljs-keyword">AND </span>key2 = <span class="hljs-number">748</span> ) <span class="hljs-keyword">OR</span><br><span class="hljs-keyword"></span>(TRUE <span class="hljs-keyword">AND </span>TRUE) <span class="hljs-keyword">OR</span><br><span class="hljs-keyword"></span>(TRUE <span class="hljs-keyword">AND </span>TRUE <span class="hljs-keyword">AND </span>(key2 &lt; <span class="hljs-number">8000</span> <span class="hljs-keyword">OR </span>TRUE))<br></code></pre></td></tr></table></figure>
<p>哎呀呀，<code>key2 &lt; 8000 OR TRUE</code>的结果肯定是<code>TRUE</code>呀，也就是说化简之后的搜索条件成这样了：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">key2</span> = <span class="hljs-number">748</span> OR <span class="hljs-literal">TRUE</span><br></code></pre></td></tr></table></figure>
<p>这个化简之后的结果就更简单了：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-literal">TRUE</span><br></code></pre></td></tr></table></figure>
<p>这个结果也就意味着如果我们要使用<code>idx_key2</code>索引执行查询语句的话，需要扫描<code>idx_key2</code>二级索引的所有记录，然后再回表，这不是得不偿失么，所以这种情况下不会使用<code>idx_key2</code>索引的。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="索引合并">索引合并</h3>
<p>我们前边说过<code>MySQL</code>在一般情况下执行一个查询时最多只会用到单个二级索引，但不是还有特殊情况么，在这些特殊情况下也可能在一个查询中使用到多个二级索引，设计<code>MySQL</code>的大叔把这种使用到多个索引来完成一次查询的执行方法称之为：<code>index merge</code>，具体的索引合并算法有下边三种。</p>
<h4 id="Intersection合并">Intersection合并</h4>
<p><code>Intersection</code>翻译过来的意思是<code>交集</code>。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下边这个查询：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key3 = <span class="hljs-string">&#x27;b&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>假设这个查询使用<code>Intersection</code>合并的方式执行的话，那这个过程就是这样的：</p>
<ul>
<li>从<code>idx_key1</code>二级索引对应的<code>B+</code>树中取出<code>key1 = 'a'</code>的相关记录。</li>
<li>从<code>idx_key3</code>二级索引对应的<code>B+</code>树中取出<code>key3 = 'b'</code>的相关记录。</li>
<li>二级索引的记录都是由<code>索引列 + 主键</code>构成的，所以我们可以计算出这两个结果集中<code>id</code>值的交集。</li>
<li>按照上一步生成的<code>id</code>值列表进行回表操作，也就是从聚簇索引中把指定<code>id</code>值的完整用户记录取出来，返回给用户。</li>
</ul>
<p>这里有同学会思考：为啥不直接使用<code>idx_key1</code>或者<code>idx_key3</code>只根据某个搜索条件去读取一个二级索引，然后回表后再过滤另外一个搜索条件呢？这里要分析一下两种查询执行方式之间需要的成本代价。</p>
<p>只读取一个二级索引的成本：</p>
<ul>
<li>按照某个搜索条件读取一个二级索引</li>
<li>根据从该二级索引得到的主键值进行回表操作，然后再过滤其他的搜索条件</li>
</ul>
<p>读取多个二级索引之后取交集成本：</p>
<ul>
<li>按照不同的搜索条件分别读取不同的二级索引</li>
<li>将从多个二级索引得到的主键值取交集，然后进行回表操作</li>
</ul>
<p>虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是<code>顺序I/O</code>，而回表操作是<code>随机I/O</code>，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为<code>回表</code>而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。</p>
<p><code>MySQL</code>在某些特定的情况下才可能会使用到<code>Intersection</code>索引合并：</p>
<ul>
<li>
<p>情况一：<strong>二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。</strong></p>
<p>比方说下边这个查询可能用到<code>idx_key1</code>和<code>idx_key_part</code>这两个二级索引进行<code>Intersection</code>索引合并的操作：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;c&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>而下边这两个查询就不能进行<code>Intersection</code>索引合并：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 &gt; <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;c&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>第一个查询是因为对<code>key1</code>进行了范围匹配，第二个查询是因为联合索引<code>idx_key_part</code>中的<code>key_part2</code>和<code>key_part3</code>列并没有出现在搜索条件中，所以这两个查询不能进行<code>Intersection</code>索引合并。</p>
</li>
<li>
<p>情况二：<strong>主键列可以是范围匹配</strong></p>
<p>比方说下边这个查询可能用到主键和<code>idx_key1</code>进行<code>Intersection</code>索引合并的操作：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> id &gt; <span class="hljs-number">100</span> <span class="hljs-built_in">AND</span> key1 = <span class="hljs-comment">&#x27;a&#x27;;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>为啥呢？凭啥呀？突然冒出这么两个规定让大家一脸懵逼，下边我们慢慢品一品这里头的玄机。这话还得从<code>InnoDB</code>的索引结构说起，你要是记不清麻烦再回头看看。对于<code>InnoDB</code>的二级索引来说，记录先是按照索引列进行排序，如果该二级索引是一个联合索引，那么会按照联合索引中的各个列依次排序。而二级索引的用户记录是由<code>索引列 + 主键</code>构成的，二级索引列的值相同的记录可能会有好多条，这些索引列的值相同的记录又是按照<code>主键</code>的值进行排序的。所以重点来了，之所以在二级索引列都是等值匹配的情况下才可能使用<code>Intersection</code>索引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。</p>
<p>so？还是没看懂根据二级索引查询出的结果集是按照主键值排序的对使用<code>Intersection</code>索引合并有啥好处？小伙子，别忘了<code>Intersection</code>索引合并会把从多个二级索引中查询出的主键值求交集，如果从各个二级索引中查询的到的结果集本身就是已经按照主键排好序的，那么求交集的过程就很easy啦。假设某个查询使用<code>Intersection</code>索引合并的方式从<code>idx_key1</code>和<code>idx_key2</code>这两个二级索引中获取到的主键值分别是：</p>
<ul>
<li>从<code>idx_key1</code>中获取到已经排好序的主键值：1、3、5</li>
<li>从<code>idx_key2</code>中获取到已经排好序的主键值：2、3、4</li>
</ul>
<p>那么求交集的过程就是这样：逐个取出这两个结果集中最小的主键值，如果两个值相等，则加入最后的交集结果中，否则丢弃当前较小的主键值，再取该丢弃的主键值所在结果集的后一个主键值来比较，直到某个结果集中的主键值用完了，如果还是觉得不太明白那继续往下看：</p>
<ul>
<li>先取出这两个结果集中较小的主键值做比较，因为<code>1 &lt; 2</code>，所以把<code>idx_key1</code>的结果集的主键值<code>1</code>丢弃，取出后边的<code>3</code>来比较。</li>
<li>因为<code>3 &gt; 2</code>，所以把<code>idx_key2</code>的结果集的主键值<code>2</code>丢弃，取出后边的<code>3</code>来比较。</li>
<li>因为<code>3 = 3</code>，所以把<code>3</code>加入到最后的交集结果中，继续两个结果集后边的主键值来比较。</li>
<li>后边的主键值也不相等，所以最后的交集结果中只包含主键值<code>3</code>。</li>
</ul>
<p>别看我们写的啰嗦，这个过程其实可快了，时间复杂度是<code>O(n)</code>，但是如果从各个二级索引中查询出的结果集并不是按照主键排序的话，那就要先把结果集中的主键值排序完再来做上边的那个过程，就比较耗时了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>按照有序的主键值去回表取记录有个专有名词儿，叫：Rowid Ordered Retrieval，简称ROR，以后大家在某些地方见到这个名词儿就眼熟了。<br></code></pre></td></tr></table></figure>
<p>另外，不仅是多个二级索引之间可以采用<code>Intersection</code>索引合并，索引合并也可以有聚簇索引参加，也就是我们上边写的<code>情况二</code>：在搜索条件中有主键的范围匹配的情况下也可以使用<code>Intersection</code>索引合并索引合并。为啥主键这就可以范围匹配了？还是得回到应用场景里，比如看下边这个查询：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-comment">&#x27;a&#x27; AND id &gt; 100;</span><br></code></pre></td></tr></table></figure>
<p>假设这个查询可以采用<code>Intersection</code>索引合并，我们理所当然的以为这个查询会分别按照<code>id &gt; 100</code>这个条件从聚簇索引中获取一些记录，在通过<code>key1 = 'a'</code>这个条件从<code>idx_key1</code>二级索引中获取一些记录，然后再求交集，其实这样就把问题复杂化了，没必要从聚簇索引中获取一次记录。别忘了二级索引的记录中都带有主键值的，所以可以在从<code>idx_key1</code>中获取到的主键值上直接运用条件<code>id &gt; 100</code>过滤就行了，这样多简单。所以涉及主键的搜索条件只不过是为了从别的二级索引得到的结果集中过滤记录罢了，是不是等值匹配不重要。</p>
<p>当然，上边说的<code>情况一</code>和<code>情况二</code>只是发生<code>Intersection</code>索引合并的必要条件，不是充分条件。也就是说即使情况一、情况二成立，也不一定发生<code>Intersection</code>索引合并，这得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过<code>Intersection</code>索引合并后需要回表的记录数大大减少时才会使用<code>Intersection</code>索引合并。</p>
<h4 id="Union合并">Union合并</h4>
<p>我们在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是<code>OR</code>关系。有时候<code>OR</code>关系的不同搜索条件会使用到不同的索引，比方说这样：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">OR</span> key3 = <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>
<p><code>Intersection</code>是交集的意思，这适用于使用不同索引的搜索条件之间使用<code>AND</code>连接起来的情况；<code>Union</code>是并集的意思，适用于使用不同索引的搜索条件之间使用<code>OR</code>连接起来的情况。与<code>Intersection</code>索引合并类似，<code>MySQL</code>在某些特定的情况下才可能会使用到<code>Union</code>索引合并：</p>
<ul>
<li>
<p>情况一：<strong>二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。</strong></p>
<p>比方说下边这个查询可能用到<code>idx_key1</code>和<code>idx_key_part</code>这两个二级索引进行<code>Union</code>索引合并的操作：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">OR</span> ( key_part1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>而下边这两个查询就不能进行<code>Union</code>索引合并：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 &gt; <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">OR</span> (key_part1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;c&#x27;</span>);<br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">OR</span> key_part1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>第一个查询是因为对<code>key1</code>进行了范围匹配，第二个查询是因为联合索引<code>idx_key_part</code>中的<code>key_part2</code>和<code>key_part3</code>列并没有出现在搜索条件中，所以这两个查询不能进行<code>Union</code>索引合并。</p>
</li>
<li>
<p>情况二：<strong>主键列可以是范围匹配</strong></p>
</li>
<li>
<p>情况三：<strong>使用<code>Intersection</code>索引合并的搜索条件</strong></p>
<p>这种情况其实也挺好理解，就是搜索条件的某些部分使用<code>Intersection</code>索引合并的方式得到的主键集合和其他方式得到的主键集合取交集，比方说这个查询：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key_part1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;c&#x27;</span> <span class="hljs-keyword">OR</span> (key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key3 = <span class="hljs-string">&#x27;b&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>优化器可能采用这样的方式来执行这个查询：</p>
<ul>
<li>先按照搜索条件<code>key1 = 'a' AND key3 = 'b'</code>从索引<code>idx_key1</code>和<code>idx_key3</code>中使用<code>Intersection</code>索引合并的方式得到一个主键集合。</li>
<li>再按照搜索条件<code>key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c'</code>从联合索引<code>idx_key_part</code>中得到另一个主键集合。</li>
<li>采用<code>Union</code>索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户。</li>
</ul>
</li>
</ul>
<p>当然，查询条件符合了这些情况也不一定就会采用<code>Union</code>索引合并，也得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过<code>Union</code>索引合并后进行访问的代价比全表扫描更小时才会使用<code>Union</code>索引合并。</p>
<h4 id="Sort-Union合并">Sort-Union合并</h4>
<p><code>Union</code>索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下边这个查询就无法使用到<code>Union</code>索引合并：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 &lt; <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">OR</span> key3 &gt; <span class="hljs-string">&#x27;z&#x27;</span><br></code></pre></td></tr></table></figure>
<p>这是因为根据<code>key1 &lt; 'a'</code>从<code>idx_key1</code>索引中获取的二级索引记录的主键值不是排好序的，根据<code>key3 &gt; 'z'</code>从<code>idx_key3</code>索引中获取的二级索引记录的主键值也不是排好序的，但是<code>key1 &lt; 'a'</code>和<code>key3 &gt; 'z'</code>这两个条件又特别让我们动心，所以我们可以这样：</p>
<ul>
<li>先根据<code>key1 &lt; 'a'</code>条件从<code>idx_key1</code>二级索引中获取记录，并按照记录的主键值进行排序</li>
<li>再根据<code>key3 &gt; 'z'</code>条件从<code>idx_key3</code>二级索引中获取记录，并按照记录的主键值进行排序</li>
<li>因为上述的两个二级索引主键值都是排好序的，剩下的操作和<code>Union</code>索引合并方式就一样了。</li>
</ul>
<p>我们把上述这种先按照二级索引记录的主键值进行排序，之后按照<code>Union</code>索引合并方式执行的方式称之为<code>Sort-Union</code>索引合并，很显然，这种<code>Sort-Union</code>索引合并比单纯的<code>Union</code>索引合并多了一步对二级索引记录的主键值排序的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>为啥有Sort-Union索引合并，就没有Sort-Intersection索引合并么？是的，的确没有Sort-Intersection索引合并这么一说，<br><br>Sort-Union的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高<br><br>而Intersection索引合并的适用场景是单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，合并后可以明显降低回表开销，但是如果加入Sort-Intersection后，就需要为大量的二级索引记录按照主键值进行排序，这个成本可能比回表查询都高了，所以也就没有引入Sort-Intersection这个玩意儿。<br></code></pre></td></tr></table></figure>
<h4 id="索引合并注意事项">索引合并注意事项</h4>
<h4 id="联合索引替代Intersection索引合并">联合索引替代Intersection索引合并</h4>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key3 = <span class="hljs-string">&#x27;b&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>这个查询之所以可能使用<code>Intersection</code>索引合并的方式执行，还不是因为<code>idx_key1</code>和<code>idx_key3</code>是两个单独的<code>B+</code>树索引，你要是把这两个列搞一个联合索引，那直接使用这个联合索引就把事情搞定了，何必用啥索引合并呢，就像这样：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ALTER</span> TABLE single_table drop index idx_key<span class="hljs-number">1</span>, idx_key<span class="hljs-number">3</span>, add index idx_key<span class="hljs-number">1</span>_key<span class="hljs-number">3</span>(key<span class="hljs-number">1</span>, key<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>
<p>这样我们把没用的<code>idx_key1</code>、<code>idx_key3</code>都干掉，再添加一个联合索引<code>idx_key1_key3</code>，使用这个联合索引进行查询简直是又快又好，既不用多读一棵<code>B+</code>树，也不用合并结果，何乐而不为？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>不过小心有单独对key3列进行查询的业务场景，这样子不得不再把key3列的单独索引给加上。<br></code></pre></td></tr></table></figure>
<h1>11.连接的原理</h1>
<p>搞数据库一个避不开的概念就是<code>Join</code>，翻译成中文就是<code>连接</code>。相信很多小伙伴在初学连接的时候有些一脸懵逼，理解了连接的语义之后又可能不明白各个表中的记录到底是怎么连起来的，以至于在使用的时候常常陷入下边两种误区：</p>
<ul>
<li>误区一：业务至上，管他三七二十一，再复杂的查询也用在一个连接语句中搞定。</li>
<li>误区二：敬而远之，上次 DBA 那给报过来的慢查询就是因为使用了连接导致的，以后再也不敢用了。</li>
</ul>
<p>所以本章就来扒一扒连接的原理。考虑到一部分小伙伴可能忘了连接是个啥或者压根儿就不知道，为了节省他们百度或者看其他书的宝贵时间以及为了我的书凑字数，我们先来介绍一下 MySQL 中支持的一些连接语法。</p>
<h2 id="连接简介">连接简介</h2>
<h3 id="连接的本质">连接的本质</h3>
<p>为了故事的顺利发展，我们先建立两个简单的表并给它们填充一点数据：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; CREATE TABLE t<span class="hljs-number">1</span> (m<span class="hljs-number">1</span> int, n<span class="hljs-number">1</span> char(<span class="hljs-number">1</span>));<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">02</span> sec)<br><br><span class="hljs-attribute">mysql</span>&gt; CREATE TABLE t<span class="hljs-number">2</span> (m<span class="hljs-number">2</span> int, n<span class="hljs-number">2</span> char(<span class="hljs-number">1</span>));<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">02</span> sec)<br><br><span class="hljs-attribute">mysql</span>&gt; INSERT INTO t<span class="hljs-number">1</span> VALUES(<span class="hljs-number">1</span>, &#x27;a&#x27;), (<span class="hljs-number">2</span>, &#x27;b&#x27;), (<span class="hljs-number">3</span>, &#x27;c&#x27;);<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">3</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">3</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br><span class="hljs-attribute">mysql</span>&gt; INSERT INTO t<span class="hljs-number">2</span> VALUES(<span class="hljs-number">2</span>, &#x27;b&#x27;), (<span class="hljs-number">3</span>, &#x27;c&#x27;), (<span class="hljs-number">4</span>, &#x27;d&#x27;);<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">3</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">3</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>我们成功建立了<code>t1</code>、<code>t2</code>两个表，这两个表都有两个列，一个是<code>INT</code>类型的，一个是<code>CHAR(1)</code>类型的，填充好数据的两个表长这样：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t1;</span><br><span class="hljs-section">+------+------+</span><br><span class="hljs-section">| m1   | n1   |</span><br><span class="hljs-section">+------+------+</span><br>|    1 | a    |<br>|    2 | b    |<br><span class="hljs-section">|    3 | c    |</span><br><span class="hljs-section">+------+------+</span><br>3 rows in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM t2;</span><br><span class="hljs-section">+------+------+</span><br><span class="hljs-section">| m2   | n2   |</span><br><span class="hljs-section">+------+------+</span><br>|    2 | b    |<br>|    3 | c    |<br><span class="hljs-section">|    4 | d    |</span><br><span class="hljs-section">+------+------+</span><br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p><code>连接</code>的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把<code>t1</code>和<code>t2</code>两个表连接起来的过程如下图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3feccc29~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cql4ae7flug1itskat1ojgi7g3m.png-67.4kB">
<p>这个过程看起来就是把<code>t1</code>表的记录和<code>t2</code>的记录连起来组成新的更大的记录，所以这个查询过程称之为连接查询。连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为<code>笛卡尔积</code>。因为表<code>t1</code>中有3条记录，表<code>t2</code>中也有3条记录，所以这两个表连接之后的笛卡尔积就有<code>3×3=9</code>行记录。在<code>MySQL</code>中，连接查询的语法也很随意，只要在<code>FROM</code>语句后边跟多个表名就好了，比如我们把<code>t1</code>表和<code>t2</code>表连接起来的查询语句可以写成这样：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SELECT <span class="hljs-symbol">*</span> FROM t1, t2;<br>+------+------+------+------+<br>|<span class="hljs-string"> m1   </span>|<span class="hljs-string"> n1   </span>|<span class="hljs-string"> m2   </span>|<span class="hljs-string"> n2   </span>|<br>+------+------+------+------+<br>|<span class="hljs-string">    1 </span>|<span class="hljs-string"> a    </span>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<br>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<br>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<br>|<span class="hljs-string">    1 </span>|<span class="hljs-string"> a    </span>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<br>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<br>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<br>|<span class="hljs-string">    1 </span>|<span class="hljs-string"> a    </span>|<span class="hljs-string">    4 </span>|<span class="hljs-string"> d    </span>|<br>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<span class="hljs-string">    4 </span>|<span class="hljs-string"> d    </span>|<br>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<span class="hljs-string">    4 </span>|<span class="hljs-string"> d    </span>|<br>+------+------+------+------+<br>9 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<h3 id="连接过程简介">连接过程简介</h3>
<p>如果我们乐意，我们可以连接任意数量张表，但是如果没有任何限制条件的话，这些表连接起来产生的<code>笛卡尔积</code>可能是非常巨大的。比方说3个100行记录的表连接起来产生的<code>笛卡尔积</code>就有<code>100×100×100=1000000</code>行数据！所以在连接的时候过滤掉特定记录组合是有必要的，在连接查询中的过滤条件可以分成两种：</p>
<ul>
<li>
<p>涉及单表的条件</p>
<p>这种只涉及单表的过滤条件我们之前都提到过一万遍了，我们之前也一直称为<code>搜索条件</code>，比如<code>t1.m1 &gt; 1</code>是只针对<code>t1</code>表的过滤条件，<code>t2.n2 &lt; 'd'</code>是只针对<code>t2</code>表的过滤条件。</p>
</li>
<li>
<p>涉及两表的条件</p>
<p>这种过滤条件我们之前没见过，比如<code>t1.m1 = t2.m2</code>、<code>t1.n1 &gt; t2.n2</code>等，这些条件中涉及到了两个表，我们稍后会仔细分析这种过滤条件是如何使用的哈。</p>
</li>
</ul>
<p>下边我们就要看一下携带过滤条件的连接查询的大致执行过程了，比方说下边这个查询语句：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">1</span>, t<span class="hljs-number">2</span> WHERE t<span class="hljs-number">1</span>.m<span class="hljs-number">1</span> &gt; <span class="hljs-number">1</span> AND t<span class="hljs-number">1</span>.m<span class="hljs-number">1</span> = t<span class="hljs-number">2</span>.m<span class="hljs-number">2</span> AND t<span class="hljs-number">2</span>.n<span class="hljs-number">2</span> &lt; &#x27;d&#x27;;<br></code></pre></td></tr></table></figure>
<p>在这个查询中我们指明了这三个过滤条件：</p>
<ul>
<li><code>t1.m1 &gt; 1</code></li>
<li><code>t1.m1 = t2.m2</code></li>
<li><code>t2.n2 &lt; 'd'</code></li>
</ul>
<p>那么这个连接查询的大致执行过程如下：</p>
<ol>
<li>
<p>首先确定第一个需要查询的表，这个表称之为<code>驱动表</code>。怎样在单表中执行查询语句我们在前一章都唠叨过了，只需要选取代价最小的那种访问方法去执行单表查询语句就好了（就是说从const、ref、ref_or_null、range、index、all这些执行方法中选取代价最小的去执行查询）。此处假设使用<code>t1</code>作为驱动表，那么就需要到<code>t1</code>表中找满足<code>t1.m1 &gt; 1</code>的记录，因为表中的数据太少，我们也没在表上建立二级索引，所以此处查询<code>t1</code>表的访问方法就设定为<code>all</code>吧，也就是采用全表扫描的方式执行单表查询。关于如何提升连接查询的性能我们之后再说，现在先把基本概念捋清楚哈。所以查询过程就如下图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3dfab5ed~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctpnftbge08uf1ek61qor1fh14g.png-23.9kB">
<p>我们可以看到，<code>t1</code>表中符合<code>t1.m1 &gt; 1</code>的记录有两条。</p>
</li>
<li>
<p>针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到<code>t2</code>表中查找匹配的记录，所谓<code>匹配的记录</code>，指的是符合过滤条件的记录。因为是根据<code>t1</code>表中的记录去找<code>t2</code>表中的记录，所以<code>t2</code>表也可以被称之为<code>被驱动表</code>。上一步骤从驱动表中得到了2条记录，所以需要查询2次<code>t2</code>表。此时涉及两个表的列的过滤条件<code>t1.m1 = t2.m2</code>就派上用场了：</p>
<ul>
<li>当<code>t1.m1 = 2</code>时，过滤条件<code>t1.m1 = t2.m2</code>就相当于<code>t2.m2 = 2</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 2</code>、<code>t2.n2 &lt; 'd'</code>这两个过滤条件，然后到<code>t2</code>表中执行单表查询。</li>
<li>当<code>t1.m1 = 3</code>时，过滤条件<code>t1.m1 = t2.m2</code>就相当于<code>t2.m2 = 3</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 3</code>、<code>t2.n2 &lt; 'd'</code>这两个过滤条件，然后到<code>t2</code>表中执行单表查询。</li>
</ul>
<p>所以整个连接查询的执行过程就如下图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3a02660b~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctrsprar1bbh17lee79le63ls2m.png-49.6kB">
<p>也就是说整个连接查询最后的结果只有两条符合过滤条件的记录：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+------+</span>------<span class="hljs-code">+------+</span>------+<br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br>|    2 | b    |    2 | b    |<br><span class="hljs-section">|    3 | c    |    3 | c    |</span><br><span class="hljs-section">+------+------+------+------+</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>从上边两个步骤可以看出来，我们上边唠叨的这个两表连接查询共需要查询1次<code>t1</code>表，2次<code>t2</code>表。当然这是在特定的过滤条件下的结果，如果我们把<code>t1.m1 &gt; 1</code>这个条件去掉，那么从<code>t1</code>表中查出的记录就有3条，就需要查询3次<code>t2</code>表了。也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</p>
<h3 id="内连接和外连接">内连接和外连接</h3>
<p>为了大家更好理解后边内容，我们先创建两个有现实意义的表，</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student (<br>    number <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;学号&#x27;</span>,<br>    <span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    major <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;专业&#x27;</span>,<br>    <span class="hljs-keyword">PRIMARY KEY</span> (number)<br>) Engine=InnoDB CHARSET=utf8 <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;学生信息表&#x27;</span>;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> score (<br>    number <span class="hljs-type">INT</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;学号&#x27;</span>,<br>    subject <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;科目&#x27;</span>,<br>    score TINYINT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;成绩&#x27;</span>,<br>    <span class="hljs-keyword">PRIMARY KEY</span> (number, subject)<br>) Engine=InnoDB CHARSET=utf8 <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;学生成绩表&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>我们新建了一个学生信息表，一个学生成绩表，然后我们向上述两个表中插入一些数据，为节省篇幅，具体插入过程就不唠叨了，插入后两表中的数据如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM student;</span><br><span class="hljs-section">+----------+-----------+--------------------------+</span><br><span class="hljs-section">| number   | name      | major                    |</span><br><span class="hljs-section">+----------+-----------+--------------------------+</span><br>| 20180101 | 杜子腾    | 软件学院                 |<br>| 20180102 | 范统      | 计算机科学与工程         |<br><span class="hljs-section">| 20180103 | 史珍香    | 计算机科学与工程         |</span><br><span class="hljs-section">+----------+-----------+--------------------------+</span><br>3 rows in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM score;</span><br><span class="hljs-section">+----------+-----------------------------+-------+</span><br><span class="hljs-section">| number   | subject                     | score |</span><br><span class="hljs-section">+----------+-----------------------------+-------+</span><br>| 20180101 | 母猪的产后护理              |    78 |<br>| 20180101 | 论萨达姆的战争准备          |    88 |<br>| 20180102 | 论萨达姆的战争准备          |    98 |<br><span class="hljs-section">| 20180102 | 母猪的产后护理              |   100 |</span><br><span class="hljs-section">+----------+-----------------------------+-------+</span><br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>现在我们想把每个学生的考试成绩都查询出来就需要进表连接了（因为<code>score</code>中没有姓名信息，所以不能单纯只查询<code>score</code>表）。连接过程就是从<code>student</code>表中取出记录，在<code>score</code>表中查找<code>number</code>相同的成绩记录，所以过滤条件就是<code>student.number = socre.number</code>，整个查询语句就是这样：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SELECT <span class="hljs-symbol">*</span> FROM student, score WHERE student.number = score.number;<br>+----------+-----------+--------------------------+----------+-----------------------------+-------+<br>|<span class="hljs-string"> number   </span>|<span class="hljs-string"> name      </span>|<span class="hljs-string"> major                    </span>|<span class="hljs-string"> number   </span>|<span class="hljs-string"> subject                     </span>|<span class="hljs-string"> score </span>|<br>+----------+-----------+--------------------------+----------+-----------------------------+-------+<br>|<span class="hljs-string"> 20180101 </span>|<span class="hljs-string"> 杜子腾    </span>|<span class="hljs-string"> 软件学院                 </span>|<span class="hljs-string"> 20180101 </span>|<span class="hljs-string"> 母猪的产后护理              </span>|<span class="hljs-string">    78 </span>|<br>|<span class="hljs-string"> 20180101 </span>|<span class="hljs-string"> 杜子腾    </span>|<span class="hljs-string"> 软件学院                 </span>|<span class="hljs-string"> 20180101 </span>|<span class="hljs-string"> 论萨达姆的战争准备          </span>|<span class="hljs-string">    88 </span>|<br>|<span class="hljs-string"> 20180102 </span>|<span class="hljs-string"> 范统      </span>|<span class="hljs-string"> 计算机科学与工程         </span>|<span class="hljs-string"> 20180102 </span>|<span class="hljs-string"> 论萨达姆的战争准备          </span>|<span class="hljs-string">    98 </span>|<br>|<span class="hljs-string"> 20180102 </span>|<span class="hljs-string"> 范统      </span>|<span class="hljs-string"> 计算机科学与工程         </span>|<span class="hljs-string"> 20180102 </span>|<span class="hljs-string"> 母猪的产后护理              </span>|<span class="hljs-string">   100 </span>|<br>+----------+-----------+--------------------------+----------+-----------------------------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>字段有点多哦，我们少查询几个字段：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1, score AS s2 WHERE s1.number = s2.number;</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br><span class="hljs-section">| number   | name      | subject                     | score |</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br>| 20180101 | 杜子腾    | 母猪的产后护理              |    78 |<br>| 20180101 | 杜子腾    | 论萨达姆的战争准备          |    88 |<br>| 20180102 | 范统      | 论萨达姆的战争准备          |    98 |<br><span class="hljs-section">| 20180102 | 范统      | 母猪的产后护理              |   100 |</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>从上述查询结果中我们可以看到，各个同学对应的各科成绩就都被查出来了，可是有个问题，<code>史珍香</code>同学，也就是学号为<code>20180103</code>的同学因为某些原因没有参加考试，所以在<code>score</code>表中没有对应的成绩记录。那如果老师想查看所有同学的考试成绩，即使是缺考的同学也应该展示出来，但是到目前为止我们介绍的<code>连接查询</code>是无法完成这样的需求的。我们稍微思考一下这个需求，其本质是想：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。为了解决这个问题，就有了<code>内连接</code>和<code>外连接</code>的概念：</p>
<blockquote>
<p>外连接解决的问题是：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。</p>
</blockquote>
<ul>
<li>
<p>对于<code>内连接</code>的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的<code>内连接</code>。</p>
</li>
<li>
<p>对于<code>外连接</code>的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。</p>
<p>在<code>MySQL</code>中，根据选取驱动表的不同，外连接仍然可以细分为2种：</p>
<ul>
<li>
<p>左外连接</p>
<p>选取左侧的表为驱动表。</p>
</li>
<li>
<p>右外连接</p>
<p>选取右侧的表为驱动表。</p>
</li>
</ul>
</li>
</ul>
<p>可是这样仍然存在问题，即使对于外连接来说，有时候我们也并不想把驱动表的全部记录都加入到最后的结果集。这就犯难了，有时候匹配失败要加入结果集，有时候又不要加入结果集，这咋办，有点儿愁啊。。。噫，把过滤条件分为两种不就解决了这个问题了么，所以放在不同地方的过滤条件是有不同语义的：</p>
<ul>
<li>
<p><code>WHERE</code>子句中的过滤条件</p>
<p><code>WHERE</code>子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合<code>WHERE</code>子句中的过滤条件的记录都不会被加入最后的结果集。</p>
</li>
<li>
<p><code>ON</code>子句中的过滤条件</p>
<p>对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配<code>ON</code>子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用<code>NULL</code>值填充。</p>
<p>需要注意的是，这个<code>ON</code>子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把<code>ON</code>子句放到内连接中，<code>MySQL</code>会把它和<code>WHERE</code>子句一样对待，也就是说：内连接中的WHERE子句和ON子句是等价的。</p>
</li>
</ul>
<p>一般情况下，我们都把只涉及单表的过滤条件放到<code>WHERE</code>子句中，把涉及两表的过滤条件都放到<code>ON</code>子句中，我们也一般把放到<code>ON</code>子句中的过滤条件也称之为<code>连接条件</code>。</p>
<blockquote>
<p>小贴士： 左外连接和右外连接简称左连接和右连接，所以下边提到的左外连接和右外连接中的<code>外</code>字都用括号扩起来，以表示这个字儿可有可无。</p>
</blockquote>
<h4 id="左（外）连接的语法">左（外）连接的语法</h4>
<p>左（外）连接的语法还是挺简单的，比如我们要把<code>t1</code>表和<code>t2</code>表进行左外连接查询可以这么写：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> t2 <span class="hljs-keyword">ON</span> 连接条件 [<span class="hljs-keyword">WHERE</span> 普通过滤条件];<br></code></pre></td></tr></table></figure>
<p>其中中括号里的<code>OUTER</code>单词是可以省略的。对于<code>LEFT JOIN</code>类型的连接来说，我们把放在左边的表称之为外表或者驱动表，右边的表称之为内表或者被驱动表。所以上述例子中<code>t1</code>就是外表或者驱动表，<code>t2</code>就是内表或者被驱动表。需要注意的是，对于左（外）连接和右（外）连接来说，必须使用<code>ON</code>子句来指出连接条件。了解了左（外）连接的基本语法之后，再次回到我们上边那个现实问题中来，看看怎样写查询语句才能把所有的学生的成绩信息都查询出来，即使是缺考的考生也应该被放到结果集中：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1 LEFT JOIN score AS s2 ON s1.number = s2.number;</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br><span class="hljs-section">| number   | name      | subject                     | score |</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br>| 20180101 | 杜子腾    | 母猪的产后护理              |    78 |<br>| 20180101 | 杜子腾    | 论萨达姆的战争准备          |    88 |<br>| 20180102 | 范统      | 论萨达姆的战争准备          |    98 |<br>| 20180102 | 范统      | 母猪的产后护理              |   100 |<br><span class="hljs-section">| 20180103 | 史珍香    | NULL                        |  NULL |</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br>5 rows in set (0.04 sec)<br></code></pre></td></tr></table></figure>
<p>从结果集中可以看出来，虽然<code>史珍香</code>并没有对应的成绩记录，但是由于采用的是连接类型为左（外）连接，所以仍然把她放到了结果集中，只不过在对应的成绩记录的各列使用<code>NULL</code>值填充而已。</p>
<h4 id="右（外）连接的语法">右（外）连接的语法</h4>
<p>右（外）连接和左（外）连接的原理是一样一样的，语法也只是把<code>LEFT</code>换成<code>RIGHT</code>而已：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> t2 <span class="hljs-keyword">ON</span> 连接条件 [<span class="hljs-keyword">WHERE</span> 普通过滤条件];<br></code></pre></td></tr></table></figure>
<p>只不过驱动表是右边的表，被驱动表是左边的表，具体就不唠叨了。</p>
<h4 id="内连接的语法">内连接的语法</h4>
<p>内连接和外连接的根本区别就是在驱动表中的记录不符合<code>ON</code>子句中的连接条件时不会把该记录加入到最后的结果集，我们最开始唠叨的那些连接查询的类型都是内连接。不过之前仅仅提到了一种最简单的内连接语法，就是直接把需要连接的多个表都放到<code>FROM</code>子句后边。其实针对内连接，MySQL提供了好多不同的语法，我们以<code>t1</code>和<code>t2</code>表为例瞅瞅：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 [<span class="hljs-keyword">INNER</span> | <span class="hljs-keyword">CROSS</span>] <span class="hljs-keyword">JOIN</span> t2 [<span class="hljs-keyword">ON</span> 连接条件] [<span class="hljs-keyword">WHERE</span> 普通过滤条件];<br></code></pre></td></tr></table></figure>
<p>也就是说在<code>MySQL</code>中，下边这几种内连接的写法都是等价的：</p>
<ul>
<li>SELECT * FROM t1 JOIN t2;</li>
<li>SELECT * FROM t1 INNER JOIN t2;</li>
<li>SELECT * FROM t1 CROSS JOIN t2;</li>
</ul>
<p>上边的这些写法和直接把需要连接的表名放到<code>FROM</code>语句之后，用逗号<code>,</code>分隔开的写法是等价的：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">1</span>, t<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>
<p>现在我们虽然介绍了很多种<code>内连接</code>的书写方式，不过熟悉一种就好了，这里我们推荐<code>INNER JOIN</code>的形式书写内连接（因为<code>INNER JOIN</code>语义很明确嘛，可以和<code>LEFT JOIN</code>和<code>RIGHT JOIN</code>很轻松的区分开）。这里需要注意的是，由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句。</p>
<p>我们前边说过，连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。不论哪个表作为驱动表，两表连接产生的笛卡尔积肯定是一样的。而对于内连接来说，由于凡是不符合<code>ON</code>子句或<code>WHERE</code>子句中的条件的记录都会被过滤掉，其实也就相当于从两表连接的笛卡尔积中把不符合过滤条件的记录给踢出去，所以对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果。但是对于外连接来说，由于驱动表中的记录即使在被驱动表中找不到符合ON子句条件的记录时也要将其加入到结果集，所以此时驱动表和被驱动表的关系就很重要了，也就是说左外连接和右外连接的驱动表和被驱动表不能轻易互换。</p>
<h4 id="小结">小结</h4>
<p>上边说了很多，给大家的感觉不是很直观，我们直接把表<code>t1</code>和<code>t2</code>的三种连接方式写在一起，这样大家理解起来就很easy了：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br>|    2 | b    |    2 | b    |<br><span class="hljs-section">|    3 | c    |    3 | c    |</span><br><span class="hljs-section">+------+------+------+------+</span><br>2 rows in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br>|    2 | b    |    2 | b    |<br>|    3 | c    |    3 | c    |<br><span class="hljs-section">|    1 | a    | NULL | NULL |</span><br><span class="hljs-section">+------+------+------+------+</span><br>3 rows in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM t1 RIGHT JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br>|    2 | b    |    2 | b    |<br>|    3 | c    |    3 | c    |<br><span class="hljs-section">| NULL | NULL |    4 | d    |</span><br><span class="hljs-section">+------+------+------+------+</span><br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<h2 id="连接的原理">连接的原理</h2>
<p>上边贼啰嗦的介绍都只是为了唤醒大家对<code>连接</code>、<code>内连接</code>、<code>外连接</code>这些概念的记忆，这些基本概念是为了真正进入本章主题做的铺垫。真正的重点是MySQL采用了什么样的算法来进行表与表之间的连接，了解了这个之后，大家才能明白为啥有的连接查询运行的快如闪电，有的却慢如蜗牛。</p>
<h3 id="嵌套循环连接（Nested-Loop-Join）">嵌套循环连接（Nested-Loop Join）</h3>
<p>我们前边说过，对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数。对于内连接来说，选取哪个表为驱动表都没关系，而外连接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表。我们上边已经大致介绍过<code>t1</code>表和<code>t2</code>表执行内连接查询的大致过程，我们温习一下：</p>
<ul>
<li>步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。</li>
<li>步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。</li>
</ul>
<p>通用的两表连接过程如下图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3fa0f107~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctsr5ui2cdk1jduqafm7p1d3426.png-129.4kB">
<p>如果有3个表进行连接的话，那么<code>步骤2</code>中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上边过程，也就是<code>步骤2</code>中得到的结果集中的每一条记录都需要到<code>t3</code>表中找一找有没有匹配的记录，用伪代码表示一下这个过程就是这样：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> t1 &#123;   #此处表示遍历满足对t1单表查询结果集中的每一条记录<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> t2 &#123;   #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录<br>    <br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> t3 &#123;   #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">row</span> satisfies <span class="hljs-keyword">join</span> conditions, send <span class="hljs-keyword">to</span> client<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为<code>嵌套循环连接</code>（<code>Nested-Loop Join</code>），这是最简单，也是最笨拙的一种连接查询算法。</p>
<h3 id="使用索引加快连接速度">使用索引加快连接速度</h3>
<p>我们知道在<code>嵌套循环连接</code>的<code>步骤2</code>中可能需要访问多次被驱动表，如果访问被驱动表的方式都是全表扫描的话，妈呀，那得要扫描好多次呀～～～ 但是别忘了，查询<code>t2</code>表其实就相当于一次单表扫描，我们可以利用索引来加快查询速度哦。回顾一下最开始介绍的<code>t1</code>表和<code>t2</code>表进行内连接的例子：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">1</span>, t<span class="hljs-number">2</span> WHERE t<span class="hljs-number">1</span>.m<span class="hljs-number">1</span> &gt; <span class="hljs-number">1</span> AND t<span class="hljs-number">1</span>.m<span class="hljs-number">1</span> = t<span class="hljs-number">2</span>.m<span class="hljs-number">2</span> AND t<span class="hljs-number">2</span>.n<span class="hljs-number">2</span> &lt; &#x27;d&#x27;;<br></code></pre></td></tr></table></figure>
<p>我们使用的其实是<code>嵌套循环连接</code>算法执行的连接查询，再把上边那个查询执行过程表拉下来给大家看一下：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3a02660b~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctrsprar1bbh17lee79le63ls2m.png-49.6kB">
<p>查询驱动表<code>t1</code>后的结果集中有两条记录，<code>嵌套循环连接</code>算法需要对被驱动表查询2次：</p>
<ul>
<li>
<p>当<code>t1.m1 = 2</code>时，去查询一遍<code>t2</code>表，对<code>t2</code>表的查询语句相当于：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">2</span> WHERE t<span class="hljs-number">2</span>.m<span class="hljs-number">2</span> = <span class="hljs-number">2</span> AND t<span class="hljs-number">2</span>.n<span class="hljs-number">2</span> &lt; &#x27;d&#x27;;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>当<code>t1.m1 = 3</code>时，再去查询一遍<code>t2</code>表，此时对<code>t2</code>表的查询语句相当于：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">2</span> WHERE t<span class="hljs-number">2</span>.m<span class="hljs-number">2</span> = <span class="hljs-number">3</span> AND t<span class="hljs-number">2</span>.n<span class="hljs-number">2</span> &lt; &#x27;d&#x27;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，原来的<code>t1.m1 = t2.m2</code>这个涉及两个表的过滤条件在针对<code>t2</code>表做查询时关于<code>t1</code>表的条件就已经确定了，所以我们只需要单单优化对<code>t2</code>表的查询了，上述两个对<code>t2</code>表的查询语句中利用到的列是<code>m2</code>和<code>n2</code>列，我们可以：</p>
<ul>
<li>
<p>在<code>m2</code>列上建立索引，因为对<code>m2</code>列的条件是等值查找，比如<code>t2.m2 = 2</code>、<code>t2.m2 = 3</code>等，所以可能使用到<code>ref</code>的访问方法，假设使用<code>ref</code>的访问方法去执行对<code>t2</code>表的查询的话，需要回表之后再判断<code>t2.n2 &lt; d</code>这个条件是否成立。</p>
<p>这里有一个比较特殊的情况，就是假设<code>m2</code>列是<code>t2</code>表的主键或者唯一二级索引列，那么使用<code>t2.m2 = 常数值</code>这样的条件从<code>t2</code>表中查找记录的过程的代价就是常数级别的。我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为<code>const</code>，而设计<code>MySQL</code>的大叔把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为：<code>eq_ref</code>。</p>
</li>
<li>
<p>在<code>n2</code>列上建立索引，涉及到的条件是<code>t2.n2 &lt; 'd'</code>，可能用到<code>range</code>的访问方法，假设使用<code>range</code>的访问方法对<code>t2</code>表的查询的话，需要回表之后再判断在<code>m2</code>列上的条件是否成立。</p>
</li>
</ul>
<p>假设<code>m2</code>和<code>n2</code>列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对<code>t2</code>表的查询。当然，建立了索引不一定使用索引，只有在<code>二级索引 + 回表</code>的代价比全表扫描的代价更低时才会使用索引。</p>
<p>另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部分，这种情况下即使不能使用<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>或者<code>range</code>这些访问方法执行对被驱动表的查询的话，也可以使用索引扫描，也就是<code>index</code>的访问方法来查询被驱动表。所以我们建议在真实工作中最好不要使用<code>*</code>作为查询列表，最好把真实用到的列作为查询列表。</p>
<h3 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）">基于块的嵌套循环连接（Block Nested-Loop Join）</h3>
<p>**扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。**现实生活中的表可不像<code>t1</code>、<code>t2</code>这种只有3条记录，成千上万条记录都是少的，几百万、几千万甚至几亿条记录的表到处都是。内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前边记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前边的记录从内存中释放掉。我们前边又说过，采用<code>嵌套循环连接</code>算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个<code>I/O</code>代价就非常大了，所以我们得想办法：<strong>尽量减少访问被驱动表的次数</strong>。</p>
<p>当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。所以我们可不可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。所以设计<code>MySQL</code>的大叔提出了一个<code>join buffer</code>的概念，<code>join buffer</code>就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个<code>join buffer</code>中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和<code>join buffer</code>中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的<code>I/O</code>代价。使用<code>join buffer</code>的过程如下图所示：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3e5fa2f6~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctuhe3t71ahd10gn19917fo1nft4g.png-57.7kB">
<p>最好的情况是<code>join buffer</code>足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。设计<code>MySQL</code>的大叔把这种加入了<code>join buffer</code>的嵌套循环连接算法称之为<code>基于块的嵌套连接</code>（Block Nested-Loop Join）算法。</p>
<p>这个<code>join buffer</code>的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为<code>262144字节</code>（也就是<code>256KB</code>），最小可以设置为<code>128字节</code>。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大<code>join_buffer_size</code>的值来对连接查询进行优化。</p>
<p>另外需要注意的是，驱动表的记录并不是所有列都会被放到<code>join buffer</code>中，只有查询列表中的列和过滤条件中的列才会被放到<code>join buffer</code>中，所以再次提醒我们，最好不要把<code>*</code>作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在<code>join buffer</code>中放置更多的记录呢哈。</p>
<h1>12.基于成本的优化</h1>
<h2 id="什么是成本">什么是成本</h2>
<p>我们之前老说<code>MySQL</code>执行一个查询可以有不同的执行方案，它会选择其中成本最低，或者说代价最低的那种方案去真正的执行查询。不过我们之前对<code>成本</code>的描述是非常模糊的，其实在<code>MySQL</code>中一条查询语句的执行成本是由下边这两个方面组成的：</p>
<ul>
<li>
<p><code>I/O</code>成本</p>
<p>我们的表经常使用的<code>MyISAM</code>、<code>InnoDB</code>存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为<code>I/O</code>成本。</p>
</li>
<li>
<p><code>CPU</code>成本</p>
<p>读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为<code>CPU</code>成本。</p>
</li>
</ul>
<p>对于<code>InnoDB</code>存储引擎来说，页是磁盘和内存之间交互的基本单位，设计<code>MySQL</code>的大叔规定读取一个页面花费的成本默认是<code>1.0</code>，读取以及检测一条记录是否符合搜索条件的成本默认是<code>0.2</code>。<code>1.0</code>、<code>0.2</code>这些数字称之为<code>成本常数</code>，这两个成本常数我们最常用到，其余的成本常数我们后边再说哈。</p>
<blockquote>
<p>小贴士： 需要注意的是，不管读取记录时需不需要检测是否满足搜索条件，其成本都算是0.2。</p>
</blockquote>
<h2 id="单表查询的成本">单表查询的成本</h2>
<h3 id="准备工作-2">准备工作</h3>
<p>为了故事的顺利发展，我们还得把之前用到的<code>single_table</code>表搬来，怕大家忘了这个表长啥样，再给大家抄一遍：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> single_table (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    key1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key2 <span class="hljs-type">INT</span>,<br>    key3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    common_field <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    KEY idx_key1 (key1),<br>    <span class="hljs-keyword">UNIQUE</span> KEY idx_key2 (key2),<br>    KEY idx_key3 (key3),<br>    KEY idx_key_part(key_part1, key_part2, key_part3)<br>) Engine<span class="hljs-operator">=</span>InnoDB CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure>
<p>还是假设这个表里边儿有10000条记录，除<code>id</code>列外其余的列都插入随机值。下边正式开始我们的表演。</p>
<h3 id="基于成本的优化步骤">基于成本的优化步骤</h3>
<p>在一条单表查询语句真正执行之前，<code>MySQL</code>的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的<code>执行计划</code>，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：</p>
<ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那一个</li>
</ol>
<p>下边我们就以一个实例来分析一下这些步骤，单表查询语句如下：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> <br>    key1 <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-keyword">AND</span> <br>    key2 &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">AND</span> key2 &lt; <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span> <br>    key3 &gt; key2 <span class="hljs-keyword">AND</span> <br>    key_part1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%hello%&#x27;</span> <span class="hljs-keyword">AND</span><br>    common_field = <span class="hljs-string">&#x27;123&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>乍看上去有点儿复杂哦，我们一步一步分析一下。</p>
<h4 id="1-根据搜索条件，找出所有可能使用的索引">1. 根据搜索条件，找出所有可能使用的索引</h4>
<p>我们前边说过，对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>范围区间</code>（<code>LIKE</code>匹配字符串前缀也行），也就是说这些搜索条件都可能使用到索引，设计<code>MySQL</code>的大叔把一个查询中可能使用到的索引称之为<code>possible keys</code>。</p>
<p>我们分析一下上边查询中涉及到的几个搜索条件：</p>
<ul>
<li><code>key1 IN ('a', 'b', 'c')</code>，这个搜索条件可以使用二级索引<code>idx_key1</code>。</li>
<li><code>key2 &gt; 10 AND key2 &lt; 1000</code>，这个搜索条件可以使用二级索引<code>idx_key2</code>。</li>
<li><code>key3 &gt; key2</code>，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。</li>
<li><code>key_part1 LIKE '%hello%'</code>，<code>key_part1</code>通过<code>LIKE</code>操作符和以通配符开头的字符串做比较，不可以适用索引。</li>
<li><code>common_field = '123'</code>，由于该列上压根儿没有索引，所以不会用到索引。</li>
</ul>
<p>综上所述，上边的查询语句可能用到的索引，也就是<code>possible keys</code>只有<code>idx_key1</code>和<code>idx_key2</code>。</p>
<h4 id="2-计算全表扫描的代价">2. 计算全表扫描的代价</h4>
<p>对于<code>InnoDB</code>存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。由于查询成本=<code>I/O</code>成本+<code>CPU</code>成本，所以计算全表扫描的代价需要两个信息：</p>
<ul>
<li>聚簇索引占用的页面数</li>
<li>该表中的记录数</li>
</ul>
<p>这两个信息从哪来呢？设计<code>MySQL</code>的大叔为每个表维护了一系列的<code>统计信息</code>，关于这些统计信息是如何收集起来的我们放在本章后边详细唠叨，现在看看怎么查看这些统计信息哈。设计<code>MySQL</code>的大叔给我们提供了<code>SHOW TABLE STATUS</code>语句来查看表的统计信息，如果要看指定的某个表的统计信息，在该语句后加对应的<code>LIKE</code>语句就好了，比方说我们要查看<code>single_table</code>这个表的统计信息可以这么写：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">mysql&gt;</span> <span class="hljs-string">USE</span> <span class="hljs-string">xiaohaizi;</span><br><span class="hljs-string">Database</span> <span class="hljs-string">changed</span><br><br><span class="hljs-string">mysql&gt;</span> <span class="hljs-string">SHOW</span> <span class="hljs-string">TABLE</span> <span class="hljs-string">STATUS</span> <span class="hljs-string">LIKE</span> <span class="hljs-string">&#x27;single_table&#x27;</span><span class="hljs-string">\G</span><br><span class="hljs-string">***************************</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">row</span> <span class="hljs-string">***************************</span><br>           <span class="hljs-attr">Name:</span> <span class="hljs-string">single_table</span><br>         <span class="hljs-attr">Engine:</span> <span class="hljs-string">InnoDB</span><br>        <span class="hljs-attr">Version:</span> <span class="hljs-number">10</span><br>     <span class="hljs-attr">Row_format:</span> <span class="hljs-string">Dynamic</span><br>           <span class="hljs-attr">Rows:</span> <span class="hljs-number">9693</span><br> <span class="hljs-attr">Avg_row_length:</span> <span class="hljs-number">163</span><br>    <span class="hljs-attr">Data_length:</span> <span class="hljs-number">1589248</span><br><span class="hljs-attr">Max_data_length:</span> <span class="hljs-number">0</span><br>   <span class="hljs-attr">Index_length:</span> <span class="hljs-number">2752512</span><br>      <span class="hljs-attr">Data_free:</span> <span class="hljs-number">4194304</span><br> <span class="hljs-attr">Auto_increment:</span> <span class="hljs-number">10001</span><br>    <span class="hljs-attr">Create_time:</span> <span class="hljs-number">2018-12-10 13:37:23</span><br>    <span class="hljs-attr">Update_time:</span> <span class="hljs-number">2018-12-10 13:38:03</span><br>     <span class="hljs-attr">Check_time:</span> <span class="hljs-literal">NULL</span><br>      <span class="hljs-attr">Collation:</span> <span class="hljs-string">utf8_general_ci</span><br>       <span class="hljs-attr">Checksum:</span> <span class="hljs-literal">NULL</span><br> <span class="hljs-attr">Create_options:</span><br>        <span class="hljs-attr">Comment:</span><br><span class="hljs-number">1</span> <span class="hljs-string">row</span> <span class="hljs-string">in</span> <span class="hljs-string">set</span> <span class="hljs-string">(0.01</span> <span class="hljs-string">sec)</span><br></code></pre></td></tr></table></figure>
<p>虽然出现了很多统计选项，但我们目前只关心两个：</p>
<ul>
<li>
<p><code>Rows</code></p>
<p>本选项表示表中的记录条数**。对于使用<code>MyISAM</code>存储引擎的表来说，该值是准确的，对于使用<code>InnoDB</code>存储引擎的表来说，该值是一个估计值。**从查询结果我们也可以看出来，由于我们的<code>single_table</code>表是使用<code>InnoDB</code>存储引擎的，所以虽然实际上表中有10000条记录，但是<code>SHOW TABLE STATUS</code>	显示的<code>Rows</code>值只有9693条记录。</p>
</li>
<li>
<p><code>Data_length</code></p>
<p>本选项表示表占用的存储空间字节数。使用<code>MyISAM</code>存储引擎的表来说，该值就是数据文件的大小，对于使用<code>InnoDB</code>存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">Data_length</span> = 聚簇索引的页面数量 x 每个页面的大小<br></code></pre></td></tr></table></figure>
<p>我们的<code>single_table</code>使用默认<code>16KB</code>的页面大小，而上边查询结果显示<code>Data_length</code>的值是<code>1589248</code>，所以我们可以反向来推导出<code>聚簇索引的页面数量</code>：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">聚簇索引的页面数量 =<span class="hljs-number"> 1589248 </span>÷<span class="hljs-number"> 16 </span>÷<span class="hljs-number"> 1024 </span>= 97<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>我们现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值，所以就可以计算全表扫描成本了，但是设计<code>MySQL</code>的大叔在真实计算成本时会进行一些<code>微调</code>，这些微调的值是直接硬编码到代码里的，由于没有注释，我也不知道这些微调值是个啥子意思，但是由于这些微调的值十分的小，并不影响我们分析，所以我们也没有必要在这些微调值上纠结了。现在可以看一下全表扫描成本的计算过程：</p>
<ul>
<li>
<p><code>I/O</code>成本</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">97 </span>x <span class="hljs-number">1.0</span> + <span class="hljs-number">1.1</span> = <span class="hljs-number">98.1</span><br></code></pre></td></tr></table></figure>
<p><code>97</code>指的是聚簇索引占用的页面数，<code>1.0</code>指的是加载一个页面的成本常数，后边的<code>1.1</code>是一个微调值，我们不用在意。</p>
</li>
<li>
<p><code>CPU</code>成本：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9693 </span>x <span class="hljs-number">0.2</span> + <span class="hljs-number">1.0</span> = <span class="hljs-number">1939.6</span><br></code></pre></td></tr></table></figure>
<p><code>9693</code>指的是统计数据中表的记录数，对于<code>InnoDB</code>存储引擎来说是一个估计值，<code>0.2</code>指的是访问一条记录所需的成本常数，后边的<code>1.0</code>是一个微调值，我们不用在意。</p>
</li>
<li>
<p>总成本：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">98</span>.<span class="hljs-number">1</span> + <span class="hljs-number">1939</span>.<span class="hljs-number">6</span> = <span class="hljs-number">2037</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>综上所述，对于<code>single_table</code>的全表扫描所需的总成本就是<code>2037.7</code>。</p>
<blockquote>
<p>小贴士： 我们前边说过表中的记录其实都存储在聚簇索引对应B+树的叶子节点中，所以只要我们通过根节点获得了最左边的叶子节点，就可以沿着叶子节点组成的双向链表把所有记录都查看一遍。也就是说全表扫描这个过程其实有的B+树内节点是不需要访问的，但是设计MySQL的大叔们在计算全表扫描成本时直接使用聚簇索引占用的页面数作为计算I/O成本的依据，是不区分内节点和叶子节点的，有点儿简单暴力，大家注意一下就好了。</p>
</blockquote>
<h4 id="3-计算使用不同索引执行查询的代价">3. 计算使用不同索引执行查询的代价</h4>
<p>从第1步分析我们得到，上述查询可能使用到<code>idx_key1</code>和<code>idx_key2</code>这两个索引，我们需要分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能使用到索引合并。这里需要提一点的是，<code>MySQL</code>查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本，所以我们也先分析<code>idx_key2</code>的成本，然后再看使用<code>idx_key1</code>的成本。</p>
<h5 id="使用idx-key2执行查询的成本分析">使用idx_key2执行查询的成本分析</h5>
<p><code>idx_key2</code>对应的搜索条件是：<code>key2 &gt; 10 AND key2 &lt; 1000</code>，也就是说对应的范围区间就是：<code>(10, 1000)</code>，使用<code>idx_key2</code>搜索的示意图就是这样子：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16998b505d671d4e~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d6cb8nolj1714dimrf1iu64l99.png-124.3kB">
<p>对于使用<code>二级索引 + 回表</code>方式的查询，设计<code>MySQL</code>的大叔计算这种查询的成本依赖两个方面的数据：</p>
<ul>
<li>
<p>范围区间数量</p>
<p>不论某个范围区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的<code>I/O</code>成本和读取一个页面是相同的。本例中使用<code>idx_key2</code>的范围区间只有一个：<code>(10, 1000)</code>，所以相当于访问这个范围区间的二级索引付出的<code>I/O</code>成本就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>x <span class="hljs-number">1.0</span> = <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>需要回表的记录数</p>
<p>优化器需要计算二级索引的某个范围区间到底包含多少条记录，对于本例来说就是要计算<code>idx_key2</code>在<code>(10, 1000)</code>这个范围区间中包含多少二级索引记录，计算过程是这样的：</p>
<ul>
<li>
<p>步骤1：先根据<code>key2 &gt; 10</code>这个条件访问一下<code>idx_key2</code>对应的<code>B+</code>树索引，找到满足<code>key2 &gt; 10</code>这个条件的第一条记录，我们把这条记录称之为<code>区间最左记录</code>。我们前头说过在<code>B+</code>数树中定位一条记录的过程是贼快的，是常数级别的，所以这个过程的性能消耗是可以忽略不计的。</p>
</li>
<li>
<p>步骤2：然后再根据<code>key2 &lt; 1000</code>这个条件继续从<code>idx_key2</code>对应的<code>B+</code>树索引中找出最后一条满足这个条件的记录，我们把这条记录称之为<code>区间最右记录</code>，这个过程的性能消耗也可以忽略不计的。</p>
</li>
<li>
<p>步骤3：如果<code>区间最左记录</code>和<code>区间最右记录</code>相隔不太远（在<code>MySQL 5.7.21</code>这个版本里，只要相隔不大于10个页面即可），那就可以精确统计出满足<code>key2 &gt; 10 AND key2 &lt; 1000</code>条件的二级索引记录条数。否则只沿着<code>区间最左记录</code>向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就可以了。那么问题又来了，怎么估计<code>区间最左记录</code>和<code>区间最右记录</code>之间有多少个页面呢？解决这个问题还得回到<code>B+</code>树索引的结构中来：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16998b505d7a278a~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cubndfil1i02ddfas1j3brq9m.png-85.3kB">
<p>如图，我们假设<code>区间最左记录</code>在<code>页b</code>中，<code>区间最右记录</code>在<code>页c</code>中，那么我们想计算<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就相当于计算<code>页b</code>和<code>页c</code>之间有多少页面，而每一条<code>目录项记录</code>都对应一个数据页，所以计算<code>页b</code>和<code>页c</code>之间有多少页面就相当于计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录。在一个页面中统计两条记录之间有几条记录的成本就贼小了。</p>
<p>不过还有问题，如果<code>页b</code>和<code>页c</code>之间的页面实在太多，以至于<code>页b</code>和<code>页c</code>对应的目录项记录都不在一个页面中该咋办？继续递归啊，也就是再统计<code>页b</code>和<code>页c</code>对应的目录项记录所在页之间有多少个页面。之前我们说过一个<code>B+</code>树有4层高已经很了不得了，所以这个统计过程也不是很耗费性能。</p>
</li>
</ul>
<p>知道了如何统计二级索引某个范围区间的记录数之后，就需要回到现实问题中来，根据上述算法测得<code>idx_key2</code>在区间<code>(10, 1000)</code>之间大约有<code>95</code>条记录。读取这<code>95</code>条二级索引记录需要付出的<code>CPU</code>成本就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">95 </span>x <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span> = <span class="hljs-number">19.01</span><br></code></pre></td></tr></table></figure>
<p>其中<code>95</code>是需要读取的二级索引记录条数，<code>0.2</code>是读取一条记录成本常数，<code>0.01</code>是微调。</p>
<p>在通过二级索引获取到记录之后，还需要干两件事儿：</p>
<ul>
<li>
<p>根据这些记录里的主键值到聚簇索引中做回表操作</p>
<p>这里需要大家使劲儿睁大自己滴溜溜的大眼睛仔细瞧，设计<code>MySQL</code>的大叔评估回表操作的<code>I/O</code>成本依旧很豪放，他们认为每次回表操作都相当于访问一个页面，也就是说二级索引范围区间有多少记录，就需要进行多少次回表操作，也就是需要进行多少次页面<code>I/O</code>。我们上边统计了使用<code>idx_key2</code>二级索引执行查询时，预计有<code>95</code>条二级索引记录需要进行回表操作，所以回表操作带来的<code>I/O</code>成本就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">95 </span>x <span class="hljs-number">1.0</span> = <span class="hljs-number">95.0</span><br></code></pre></td></tr></table></figure>
<p>其中<code>95</code>是预计的二级索引记录数，<code>1.0</code>是一个页面的<code>I/O</code>成本常数。</p>
</li>
<li>
<p>回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立</p>
<p>回表操作的本质就是通过二级索引记录的主键值到聚簇索引中找到完整的用户记录，然后再检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立。因为我们通过范围区间获取到二级索引记录共<code>95</code>条，也就对应着聚簇索引中<code>95</code>条完整的用户记录，读取并检测这些完整的用户记录是否符合其余的搜索条件的<code>CPU</code>成本如下：</p>
<p>设计<code>MySQL</code>的大叔只计算这个查找过程所需的<code>I/O</code>成本，也就是我们上一步骤中得到的<code>95.0</code>，在内存中的定位完整用户记录的过程的成本是忽略不计的。在定位到这些完整的用户记录后，需要检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立，这个比较过程花费的<code>CPU</code>成本就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">95 </span>x <span class="hljs-number">0.2</span> = <span class="hljs-number">19.0</span><br></code></pre></td></tr></table></figure>
<p>其中<code>95</code>是待检测记录的条数，<code>0.2</code>是检测一条记录是否符合给定的搜索条件的成本常数。</p>
</li>
</ul>
</li>
</ul>
<p>所以本例中使用<code>idx_key2</code>执行查询的成本就如下所示：</p>
<ul>
<li>
<p><code>I/O</code>成本：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">0</span> + <span class="hljs-number">95</span> x <span class="hljs-number">1</span>.<span class="hljs-number">0</span> = <span class="hljs-number">96</span>.<span class="hljs-number">0</span> (范围区间的数量 + 预估的二级索引记录条数)<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>CPU</code>成本：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">95 </span>x <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span> + <span class="hljs-number">95</span> x <span class="hljs-number">0.2</span> = <span class="hljs-number">38.01</span> （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>综上所述，使用<code>idx_key2</code>执行查询的总成本就是：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">96</span>.<span class="hljs-number">0</span> + <span class="hljs-number">38</span>.<span class="hljs-number">01</span> = <span class="hljs-number">134</span>.<span class="hljs-number">01</span><br></code></pre></td></tr></table></figure>
<h5 id="使用idx-key1执行查询的成本分析">使用idx_key1执行查询的成本分析</h5>
<p><code>idx_key1</code>对应的搜索条件是：<code>key1 IN ('a', 'b', 'c')</code>，也就是说相当于3个单点区间：</p>
<ul>
<li><code>['a', 'a']</code></li>
<li><code>['b', 'b']</code></li>
<li><code>['c', 'c']</code></li>
</ul>
<p>使用<code>idx_key1</code>搜索的示意图就是这样子：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16998b505eab86e6~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cubvsars1i0rvdc11b3118th9830.png-124.1kB">
<p>与使用<code>idx_key2</code>的情况类似，我们也需要计算使用<code>idx_key1</code>时需要访问的范围区间数量以及需要回表的记录数：</p>
<ul>
<li>
<p>范围区间数量</p>
<p>使用<code>idx_key1</code>执行查询时很显然有3个单点区间，所以访问这3个范围区间的二级索引付出的I/O成本就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span>x <span class="hljs-number">1.0</span> = <span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>需要回表的记录数</p>
<p>由于使用<code>idx_key1</code>时有3个单点区间，所以每个单点区间都需要查找一遍对应的二级索引记录数：</p>
<ul>
<li>
<p>查找单点区间<code>['a', 'a']</code>对应的二级索引记录数</p>
<p>计算单点区间对应的二级索引记录数和计算连续范围区间对应的二级索引记录数是一样的，都是先计算<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算它们之间的记录数，具体算法上边都唠叨过了，就不赘述了。最后计算得到单点区间<code>['a', 'a']</code>对应的二级索引记录数是：<code>35</code>。</p>
</li>
<li>
<p>查找单点区间<code>['b', 'b']</code>对应的二级索引记录数</p>
<p>与上同理，计算得到本单点区间对应的记录数是：<code>44</code>。</p>
</li>
<li>
<p>查找单点区间<code>['c', 'c']</code>对应的二级索引记录数</p>
<p>与上同理，计算得到本单点区间对应的记录数是：<code>39</code>。</p>
</li>
</ul>
<p>所以，这三个单点区间总共需要回表的记录数就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">35 </span>+ <span class="hljs-number">44</span> + <span class="hljs-number">39</span> = <span class="hljs-number">118</span><br></code></pre></td></tr></table></figure>
<p>读取这些二级索引记录的<code>CPU</code>成本就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">118 </span>x <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span> = <span class="hljs-number">23.61</span><br></code></pre></td></tr></table></figure>
<p>得到总共需要回表的记录数之后，就要考虑：</p>
<ul>
<li>
<p>根据这些记录里的主键值到聚簇索引中做回表操作</p>
<p>所需的<code>I/O</code>成本就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">118 </span>x <span class="hljs-number">1.0</span> = <span class="hljs-number">118.0</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>回表操作后得到的完整用户记录，然后再比较其他搜索条件是否成立</p>
<p>此步骤对应的<code>CPU</code>成本就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">118 </span>x <span class="hljs-number">0.2</span> = <span class="hljs-number">23.6</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>所以本例中使用<code>idx_key1</code>执行查询的成本就如下所示：</p>
<ul>
<li>
<p><code>I/O</code>成本：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>.<span class="hljs-number">0</span> + <span class="hljs-number">118</span> x <span class="hljs-number">1</span>.<span class="hljs-number">0</span> = <span class="hljs-number">121</span>.<span class="hljs-number">0</span> (范围区间的数量 + 预估的二级索引记录条数)<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>CPU</code>成本：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">118 </span>x <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span> + <span class="hljs-number">118</span> x <span class="hljs-number">0.2</span> = <span class="hljs-number">47.21</span> （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>综上所述，使用<code>idx_key1</code>执行查询的总成本就是：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">121</span>.<span class="hljs-number">0</span> + <span class="hljs-number">47</span>.<span class="hljs-number">21</span> = <span class="hljs-number">168</span>.<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure>
<h5 id="是否有可能使用索引合并（Index-Merge）">是否有可能使用索引合并（Index Merge）</h5>
<p>本例中有关<code>key1</code>和<code>key2</code>的搜索条件是使用<code>AND</code>连接起来的，而对于<code>idx_key1</code>和<code>idx_key2</code>都是范围查询，也就是说查找到的二级索引记录并不是按照主键值进行排序的，并不满足使用<code>Intersection</code>索引合并的条件，所以并不会使用索引合并。</p>
<blockquote>
<p>小贴士： MySQL查询优化器计算索引合并成本的算法也比较麻烦，所以我们这也就不展开唠叨了。</p>
</blockquote>
<h4 id="4-对比各种执行方案的代价，找出成本最低的那一个">4. 对比各种执行方案的代价，找出成本最低的那一个</h4>
<p>下边把执行本例中的查询的各种可执行方案以及它们对应的成本列出来：</p>
<ul>
<li>全表扫描的成本：<code>2037.7</code></li>
<li>使用<code>idx_key2</code>的成本：<code>134.01</code></li>
<li>使用<code>idx_key1</code>的成本：<code>168.21</code></li>
</ul>
<p>很显然，使用<code>idx_key2</code>的成本最低，所以当然选择<code>idx_key2</code>来执行查询喽。</p>
<blockquote>
<p>小贴士： 考虑到大家的阅读体验，为了最大限度的减少大家在理解优化器工作原理的过程中遇到的懵逼情况，这里对优化器在单表查询中对比各种执行方案的代价的方式稍稍的做了简化，不过毕竟大部分同学不需要去看MySQL的源码，把大致的精神传递正确就好了哈。</p>
</blockquote>
<h3 id="基于索引统计数据的成本计算">基于索引统计数据的成本计算</h3>
<p>有时候使用索引执行查询时会有许多单点区间，比如使用<code>IN</code>语句就很容易产生非常多的单点区间，比如下边这个查询（下边查询语句中的<code>...</code>表示还有很多参数）：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> * FROM single_table <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;aa1&#x27;</span>, <span class="hljs-string">&#x27;aa2&#x27;</span>, <span class="hljs-string">&#x27;aa3&#x27;</span>, <span class="hljs-params">...</span> , <span class="hljs-string">&#x27;zzz&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>很显然，这个查询可能使用到的索引就是<code>idx_key1</code>，由于这个索引并不是唯一二级索引，所以并不能确定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算。计算方式我们上边已经介绍过了，就是先获取索引对应的<code>B+</code>树的<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。设计<code>MySQL</code>的大叔把这种通过直接访问索引对应的<code>B+</code>树来计算某个范围区间对应的索引记录条数的方式称之为<code>index dive</code>。</p>
<blockquote>
<p>小贴士： dive直译为中文的意思是跳水、俯冲的意思，原谅我的英文水平捉急，我实在不知道怎么翻译 index dive，索引跳水？索引俯冲？好像都不太合适，所以压根儿就不翻译了。不过大家要意会index dive就是直接利用索引对应的B+树来计算某个范围区间对应的记录条数。</p>
</blockquote>
<p>有零星几个单点区间的话，使用<code>index dive</code>的方式去计算这些单点区间对应的记录数也不是什么问题，可是你架不住有的孩子憋足了劲往<code>IN</code>语句里塞东西呀，我就见过有的同学写的<code>IN</code>语句里有20000个参数的🤣🤣，这就意味着<code>MySQL</code>的查询优化器为了计算这些单点区间对应的索引记录条数，要进行20000次<code>index dive</code>操作，这性能损耗可就大了，搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。设计<code>MySQL</code>的大叔们多聪明啊，他们当然考虑到了这种情况，所以提供了一个系统变量<code>eq_range_index_dive_limit</code>，我们看一下在<code>MySQL 5.7.21</code>中这个系统变量的默认值：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;%dive%&#x27;;</span><br><span class="hljs-section">+---------------------------+-------+</span><br><span class="hljs-section">| Variable_name             | Value |</span><br><span class="hljs-section">+---------------------------+-------+</span><br><span class="hljs-section">| eq_range_index_dive_limit | 200   |</span><br><span class="hljs-section">+---------------------------+-------+</span><br>1 row in set (0.08 sec)<br></code></pre></td></tr></table></figure>
<p>也就是说如果我们的<code>IN</code>语句中的参数个数小于200个的话，将使用<code>index dive</code>的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话，可就不能使用<code>index dive</code>了，要使用所谓的索引统计数据来进行估算。怎么个估算法？继续往下看。</p>
<p>像会为每个表维护一份统计数据一样，<code>MySQL</code>也会为表中的每一个索引维护一份统计数据，查看某个表中索引的统计数据可以使用<code>SHOW INDEX FROM 表名</code>的语法，比如我们查看一下<code>single_table</code>的各个索引的统计数据可以这么写：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW INDEX FROM single_table; <span class="hljs-comment"># 在最后+ \G 表示换行</span><br>+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+<br>|<span class="hljs-string"> Table        </span>|<span class="hljs-string"> Non_unique </span>|<span class="hljs-string"> Key_name     </span>|<span class="hljs-string"> Seq_in_index </span>|<span class="hljs-string"> Column_name </span>|<span class="hljs-string"> Collation </span>|<span class="hljs-string"> Cardinality </span>|<span class="hljs-string"> Sub_part </span>|<span class="hljs-string"> Packed </span>|<span class="hljs-string"> Null </span>|<span class="hljs-string"> Index_type </span>|<span class="hljs-string"> Comment </span>|<span class="hljs-string"> Index_comment </span>|<br>+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          0 </span>|<span class="hljs-string"> PRIMARY      </span>|<span class="hljs-string">            1 </span>|<span class="hljs-string"> id          </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">       9693  </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          0 </span>|<span class="hljs-string"> idx_key2     </span>|<span class="hljs-string">            1 </span>|<span class="hljs-string"> key2        </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">       9693  </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          1 </span>|<span class="hljs-string"> idx_key1     </span>|<span class="hljs-string">            1 </span>|<span class="hljs-string"> key1        </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">        968 </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          1 </span>|<span class="hljs-string"> idx_key3     </span>|<span class="hljs-string">            1 </span>|<span class="hljs-string"> key3        </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">        799 </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          1 </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string">            1 </span>|<span class="hljs-string"> key_part1   </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">        9673 </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          1 </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string">            2 </span>|<span class="hljs-string"> key_part2   </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">        9999 </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          1 </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string">            3 </span>|<span class="hljs-string"> key_part3   </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">       10000 </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+<br>7 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure>
<p>哇唔，竟然有这么多属性，不过好在这些属性都不难理解，我们就都介绍一遍吧：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Table</code></td>
<td>索引所属表的名称。</td>
</tr>
<tr>
<td><code>Non_unique</code></td>
<td>索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为<code>0</code>，普通二级索引该列值为<code>1</code>。</td>
</tr>
<tr>
<td><code>Key_name</code></td>
<td>索引的名称。</td>
</tr>
<tr>
<td><code>Seq_in_index</code></td>
<td>索引列在索引中的位置，从1开始计数。比如对于联合索引<code>idx_key_part</code>，来说，<code>key_part1</code>、<code>key_part2</code>和<code>key_part3</code>对应的位置分别是1、2、3。</td>
</tr>
<tr>
<td><code>Column_name</code></td>
<td>索引列的名称。</td>
</tr>
<tr>
<td><code>Collation</code></td>
<td>索引列中的值是按照何种排序方式存放的，值为<code>A</code>时代表升序存放，为<code>NULL</code>时代表降序存放。</td>
</tr>
<tr>
<td><code>Cardinality</code></td>
<td>索引列中不重复值的数量。后边我们会重点看这个属性的。</td>
</tr>
<tr>
<td><code>Sub_part</code></td>
<td>对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前<code>n</code>个字符或字节建立索引，这个属性表示的就是那个<code>n</code>值。如果对完整的列建立索引的话，该属性的值就是<code>NULL</code>。</td>
</tr>
<tr>
<td><code>Packed</code></td>
<td>索引列如何被压缩，<code>NULL</code>值表示未被压缩。这个属性我们暂时不了解，可以先忽略掉。</td>
</tr>
<tr>
<td><code>Null</code></td>
<td>该索引列是否允许存储<code>NULL</code>值。</td>
</tr>
<tr>
<td><code>Index_type</code></td>
<td>使用索引的类型，我们最常见的就是<code>BTREE</code>，其实也就是<code>B+</code>树索引。</td>
</tr>
<tr>
<td><code>Comment</code></td>
<td>索引列注释信息。</td>
</tr>
<tr>
<td><code>Index_comment</code></td>
<td>索引注释信息。</td>
</tr>
</tbody>
</table>
<p>上述属性除了<code>Packed</code>大家可能看不懂以外，应该没有啥看不懂的了，如果有的话肯定是大家看前边文章的时候跳过了啥东西。其实我们现在最在意的是<code>Cardinality</code>属性，<code>Cardinality</code>直译过来就是<code>基数</code>的意思，表示索引列中不重复值的个数。比如对于一个一万行记录的表来说，某个索引列的<code>Cardinality</code>属性是<code>10000</code>，那意味着该列中没有重复的值，如果<code>Cardinality</code>属性是<code>1</code>的话，就意味着该列的值全部是重复的。不过需要注意的是，对于InnoDB存储引擎来说，使用SHOW INDEX语句展示出来的某个索引列的Cardinality属性是一个估计值，并不是精确的。关于这个<code>Cardinality</code>属性的值是如何被计算出来的我们后边再说，先看看它有什么用途。</p>
<p>前边说道，当<code>IN</code>语句中的参数个数大于或等于系统变量<code>eq_range_index_dive_limit</code>的值的话，就不会使用<code>index dive</code>的方式计算各个单点区间对应的索引记录条数，而是使用索引统计数据，这里所指的<code>索引统计数据</code>指的是这两个值：</p>
<ul>
<li>
<p>使用<code>SHOW TABLE STATUS</code>展示出的<code>Rows</code>值，也就是一个表中有多少条记录。</p>
<p>这个统计数据我们在前边唠叨全表扫描成本的时候说过很多遍了，就不赘述了。</p>
</li>
<li>
<p>使用<code>SHOW INDEX</code>语句展示出的<code>Cardinality</code>属性。</p>
<p>结合上一个<code>Rows</code>统计数据，我们可以针对索引列，计算出平均一个值重复多少次。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">一个值的重复次数 ≈ <span class="hljs-keyword">Rows</span> ÷ <span class="hljs-keyword">Cardinality</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>以<code>single_table</code>表的<code>idx_key1</code>索引为例，它的<code>Rows</code>值是<code>9693</code>，它对应索引列<code>key1</code>的<code>Cardinality</code>值是<code>968</code>，所以我们可以计算<code>key1</code>列平均单个值的重复次数就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9693 </span>÷ <span class="hljs-number">968</span> ≈ <span class="hljs-number">10</span>（条）<br></code></pre></td></tr></table></figure>
<p>此时再看上边那条查询语句：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> * FROM single_table <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;aa1&#x27;</span>, <span class="hljs-string">&#x27;aa2&#x27;</span>, <span class="hljs-string">&#x27;aa3&#x27;</span>, <span class="hljs-params">...</span> , <span class="hljs-string">&#x27;zzz&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>假设<code>IN</code>语句中有20000个参数的话，就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了，每个参数大约对应<code>10</code>条记录，所以总共需要回表的记录数就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">20000 </span>x <span class="hljs-number">10</span> = <span class="hljs-number">200000</span><br></code></pre></td></tr></table></figure>
<p>使用统计数据来计算单点区间对应的索引记录条数可比<code>index dive</code>的方式简单多了，但是它的致命弱点就是：不精确！。使用统计数据算出来的查询成本与实际所需的成本可能相差非常大。</p>
<blockquote>
<p>小贴士： 大家需要注意一下，在MySQL 5.7.3以及之前的版本中，eq_range_index_dive_limit的默认值为10，之后的版本默认值为200。所以如果大家采用的是5.7.3以及之前的版本的话，很容易采用索引统计数据而不是index dive的方式来计算查询成本。当你的查询中使用到了IN查询，但是却实际没有用到索引，就应该考虑一下是不是由于 eq_range_index_dive_limit 值太小导致的。</p>
</blockquote>
<h2 id="连接查询的成本">连接查询的成本</h2>
<h3 id="准备工作-3">准备工作</h3>
<p>连接查询至少是要有两个表的，只有一个<code>single_table</code>表是不够的，所以为了故事的顺利发展，我们直接构造一个和<code>single_table</code>表一模一样的<code>single_table2</code>表。为了简便起见，我们把<code>single_table</code>表称为<code>s1</code>表，把<code>single_table2</code>表称为<code>s2</code>表。</p>
<h3 id="Condition-filtering介绍">Condition filtering介绍</h3>
<p>我们前边说过，<code>MySQL</code>中连接查询采用的是<strong>嵌套循环连接算法</strong>，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：</p>
<ul>
<li>单次查询驱动表的成本</li>
<li>多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）</li>
</ul>
<p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code>（英文名：<code>fanout</code>）。很显然驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值，有的时候扇出值的计算是很容易的，比如下边这两个查询：</p>
<ul>
<li>
<p>查询一：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">AS</span> s1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> single_table2 <span class="hljs-keyword">AS</span> s2;<br></code></pre></td></tr></table></figure>
<p>假设使用<code>s1</code>表作为驱动表，很显然对驱动表的单表查询只能使用全表扫描的方式执行，驱动表的扇出值也很明确，那就是驱动表中有多少记录，扇出值就是多少。我们前边说过，统计数据中<code>s1</code>表的记录行数是<code>9693</code>，也就是说优化器就直接会把<code>9693</code>当作在<code>s1</code>表的扇出值。</p>
</li>
<li>
<p>查询二：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table AS s<span class="hljs-number">1</span> INNER JOIN single_table<span class="hljs-number">2</span> AS s<span class="hljs-number">2</span> <br><span class="hljs-attribute">WHERE</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &gt;<span class="hljs-number">10</span> AND s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &lt; <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure>
<p>仍然假设<code>s1</code>表是驱动表的话，很显然对驱动表的单表查询可以使用<code>idx_key2</code>索引执行查询。此时<code>idx_key2</code>的范围区间<code>(10, 1000)</code>中有多少条记录，那么扇出值就是多少。我们前边计算过，满足<code>idx_key2</code>的范围区间<code>(10, 1000)</code>的记录数是95条，也就是说本查询中优化器会把<code>95</code>当作驱动表<code>s1</code>的扇出值。</p>
</li>
</ul>
<p>事情当然不会总是一帆风顺的，要不然剧情就太平淡了。有的时候扇出值的计算就变得很棘手，比方说下边几个查询：</p>
<ul>
<li>
<p>查询三：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">AS</span> s1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> single_table2 <span class="hljs-keyword">AS</span> s2 <br>    <span class="hljs-keyword">WHERE</span> s1.common_field &gt; <span class="hljs-string">&#x27;xyz&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>本查询和<code>查询一</code>类似，只不过对于驱动表<code>s1</code>多了一个<code>common_field &gt; 'xyz'</code>的搜索条件。查询优化器又不会真正的去执行查询，所以它只能<code>猜</code>这<code>9693</code>记录里有多少条记录满足<code>common_field &gt; 'xyz'</code>条件。</p>
</li>
<li>
<p>查询四：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table AS s<span class="hljs-number">1</span> INNER JOIN single_table<span class="hljs-number">2</span> AS s<span class="hljs-number">2</span> <br>    <span class="hljs-attribute">WHERE</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &gt; <span class="hljs-number">10</span> AND s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &lt; <span class="hljs-number">1000</span> AND<br>          <span class="hljs-attribute">s1</span>.common_field &gt; &#x27;xyz&#x27;;<br></code></pre></td></tr></table></figure>
<p>本查询和<code>查询二</code>类似，只不过对于驱动表<code>s1</code>也多了一个<code>common_field &gt; 'xyz'</code>的搜索条件。不过因为本查询可以使用<code>idx_key2</code>索引，所以只需要从符合二级索引范围区间的记录中猜有多少条记录符合<code>common_field &gt; 'xyz'</code>条件，也就是只需要猜在<code>95</code>条记录中有多少符合<code>common_field &gt; 'xyz'</code>条件。</p>
</li>
<li>
<p>查询五：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">AS</span> s1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> single_table2 <span class="hljs-keyword">AS</span> s2 <br>    <span class="hljs-keyword">WHERE</span> s1.key2 &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">AND</span> s1.key2 &lt; <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span><br>          s1.key1 <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-keyword">AND</span><br>          s1.common_field &gt; <span class="hljs-string">&#x27;xyz&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>本查询和<code>查询二</code>类似，不过在驱动表<code>s1</code>选取<code>idx_key2</code>索引执行查询后，优化器需要从符合二级索引范围区间的记录中猜有多少条记录符合下边两个条件：</p>
<ul>
<li><code>key1 IN ('a', 'b', 'c')</code></li>
<li><code>common_field &gt; 'xyz'</code></li>
</ul>
<p>也就是优化器需要猜在<code>95</code>条记录中有多少符合上述两个条件的。</p>
</li>
</ul>
<p>说了这么多，其实就是想表达在这两种情况下计算驱动表扇出值时需要靠<code>猜</code>：</p>
<ul>
<li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。</li>
<li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li>
</ul>
<p>设计<code>MySQL</code>的大叔把这个<code>猜</code>的过程称之为<code>condition filtering</code>。当然，这个过程可能会使用到索引，也可能使用到统计数据，也可能就是设计<code>MySQL</code>的大叔单纯的瞎猜，整个评估过程挺复杂的，再仔细的唠叨一遍可能引起大家的生理不适，所以我们就跳过了哈。</p>
<blockquote>
<p>小贴士： 在MySQL 5.7之前的版本中，查询优化器在计算驱动表扇出时，<strong>如果是使用全表扫描的话，就直接使用表中记录的数量作为扇出值，如果使用索引的话，就直接使用满足范围条件的索引记录条数作为扇出值</strong>。在MySQL 5.7中，设计MySQL的大叔引入了这个condition filtering的功能，就是还要猜一猜剩余的那些搜索条件能把驱动表中的记录再过滤多少条，其实本质上就是为了让成本估算更精确。 我们所说的纯粹瞎猜其实是很不严谨的，设计MySQL的大叔们称之为启发式规则（heuristic），大家有兴趣的可以再深入了解一下哈。</p>
</blockquote>
<h3 id="两表连接的成本分析">两表连接的成本分析</h3>
<p>连接查询的成本计算公式是这样的：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">连接查询总成本 </span>=<span class="hljs-string"> 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</span><br></code></pre></td></tr></table></figure>
<p>对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：</p>
<ul>
<li>分别为驱动表和被驱动表选择成本最低的访问方法。</li>
</ul>
<p>可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：</p>
<ul>
<li>不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。</li>
<li>然后分别为驱动表和被驱动表选择成本最低的访问方法。</li>
</ul>
<p>很显然，计算内连接查询成本的方式更麻烦一些，下边我们就以内连接为例来看看如何计算出最优的连接查询方案。</p>
<blockquote>
<p>小贴士： 左（外）连接和右（外）连接查询在某些特殊情况下可以被优化为内连接查询，我们在之后的章节中会仔细唠叨的，稍安勿躁。</p>
</blockquote>
<p>比如对于下边这个查询来说：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table AS s<span class="hljs-number">1</span> INNER JOIN single_table<span class="hljs-number">2</span> AS s<span class="hljs-number">2</span> <br>    <span class="hljs-attribute">ON</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">1</span> = s<span class="hljs-number">2</span>.common_field <br>    <span class="hljs-attribute">WHERE</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &gt; <span class="hljs-number">10</span> AND s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &lt; <span class="hljs-number">1000</span> AND <br>          <span class="hljs-attribute">s2</span>.key<span class="hljs-number">2</span> &gt; <span class="hljs-number">1000</span> AND s<span class="hljs-number">2</span>.key<span class="hljs-number">2</span> &lt; <span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure>
<p>可以选择的连接顺序有两种：</p>
<ul>
<li><code>s1</code>连接<code>s2</code>，也就是<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表。</li>
<li><code>s2</code>连接<code>s1</code>，也就是<code>s2</code>作为驱动表，<code>s1</code>作为被驱动表。</li>
</ul>
<p>查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。我们分别来看一下（定性的分析一下，不像分析单表查询那样定量的分析了）：</p>
<ul>
<li>
<p>使用<code>s1</code>作为驱动表的情况</p>
<ul>
<li>
<p>分析对于驱动表的成本最低的执行方案</p>
<p>首先看一下涉及<code>s1</code>表单表的搜索条件有哪些：</p>
<ul>
<li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 1000</code></li>
</ul>
<p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，这个过程我们上边都唠叨过了，很显然使用<code>idx_key2</code>执行查询的成本更低些。</p>
</li>
<li>
<p>然后分析对于被驱动表的成本最低的执行方案</p>
<p>此时涉及被驱动表<code>s2</code>的搜索条件就是：</p>
<ul>
<li><code>s2.common_field = 常数</code>（这是因为对驱动表<code>s1</code>结果集中的每一条记录，都需要进行一次被驱动表<code>s2</code>的访问，此时那些涉及两表的条件现在相当于只涉及被驱动表<code>s2</code>了。）</li>
<li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li>
</ul>
<p>很显然，第一个条件由于<code>common_field</code>没有用到索引，所以并没有什么卵用，此时访问<code>s2</code>表时可用的方案也是全表扫描和使用<code>idx_key2</code>两种，假设使用<code>idx_key2</code>的成本更小。</p>
</li>
</ul>
<p>所以此时使用<code>s1</code>作为驱动表时的总成本就是（暂时不考虑使用<code>join buffer</code>对成本的影响）：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用idx_key2访问<span class="hljs-built_in">s1</span>的成本 + <span class="hljs-built_in">s1</span>的扇出 × 使用idx_key2访问<span class="hljs-built_in">s2</span>的成本<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>使用<code>s2</code>作为驱动表的情况</p>
<ul>
<li>
<p>分析对于驱动表的成本最低的执行方案</p>
<p>首先看一下涉及<code>s2</code>表单表的搜索条件有哪些：</p>
<ul>
<li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li>
</ul>
<p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，假设使用<code>idx_key2</code>执行查询的成本更低些。</p>
</li>
<li>
<p>然后分析对于被驱动表的成本最低的执行方案</p>
<p>此时涉及被驱动表<code>s1</code>的搜索条件就是：</p>
<ul>
<li><code>s1.key1 = 常数</code></li>
<li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 2000</code></li>
</ul>
<p>这时就很有趣了，使用<code>idx_key1</code>可以进行<code>ref</code>方式的访问，使用<code>idx_key2</code>可以使用<code>range</code>方式的访问。这是优化器需要从全表扫描、使用<code>idx_key1</code>、使用<code>idx_key2</code>这几个方案里选出一个成本最低的方案。这里有个问题啊，因为<code>idx_key2</code>的范围区间是确定的：<code>(10, 1000)</code>，怎么计算使用<code>idx_key2</code>的成本我们上边已经说过了，可是在没有真正执行查询前，<code>s1.key1 = 常数</code>中的<code>常数</code>值我们是不知道的，怎么衡量使用<code>idx_key1</code>执行查询的成本呢？其实很简单，直接使用索引统计数据就好了（就是索引列平均一个值重复多少次）。一般情况下，<code>ref</code>的访问方式要比<code>range</code>成本更低，这里假设使用<code>idx_key1</code>进行对<code>s1</code>的访问。</p>
</li>
</ul>
<p>所以此时使用<code>s2</code>作为驱动表时的总成本就是：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用idx_key2访问<span class="hljs-built_in">s2</span>的成本 + <span class="hljs-built_in">s2</span>的扇出 × 使用idx_key1访问<span class="hljs-built_in">s1</span>的成本<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>最后优化器会比较这两种方式的最优访问成本，选取那个成本更低的连接顺序去真正的执行查询。从上边的计算过程也可以看出来，连接查询成本占大头的其实是<code>驱动表扇出数 x 单次访问被驱动表的成本</code>，所以我们的优化重点其实是下边这两个部分：</p>
<ul>
<li>
<p>尽量减少驱动表的扇出</p>
</li>
<li>
<p>对被驱动表的访问成本尽量低</p>
<p>这一点对于我们实际书写连接查询语句时十分有用，我们需要尽量在被驱动表的连接列上建立索引，这样就可以使用<code>ref</code>访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降到更低了。</p>
</li>
</ul>
<h3 id="多表连接的成本分析">多表连接的成本分析</h3>
<p>首先要考虑一下多表连接时可能产生出多少种连接顺序：</p>
<ul>
<li>
<p>对于两表连接，比如表A和表B连接</p>
<p>只有 AB、BA这两种连接顺序。其实相当于<code>2 × 1 = 2</code>种连接顺序。</p>
</li>
<li>
<p>对于三表连接，比如表A、表B、表C进行连接</p>
<p>有ABC、ACB、BAC、BCA、CAB、CBA这么6种连接顺序。其实相当于<code>3 × 2 × 1 = 6</code>种连接顺序。</p>
</li>
<li>
<p>对于四表连接的话，则会有<code>4 × 3 × 2 × 1 = 24</code>种连接顺序。</p>
</li>
<li>
<p>对于<code>n</code>表连接的话，则有 <code>n × (n-1) × (n-2) × ··· × 1</code>种连接顺序，就是n的阶乘种连接顺序，也就是<code>n!</code>。</p>
</li>
</ul>
<p>有<code>n</code>个表进行连接，<code>MySQL</code>查询优化器要每一种连接顺序的成本都计算一遍么？那可是<code>n!</code>种连接顺序呀。其实真的是要都算一遍，不过设计<code>MySQL</code>的大叔们想了很多办法减少计算非常多种连接顺序的成本的方法：</p>
<ul>
<li>
<p>提前结束某种顺序的成本评估</p>
<p><code>MySQL</code>在计算各种链接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就压根儿不对该连接顺序继续往下分析了。比方说A、B、C三个表进行连接，已经得到连接顺序<code>ABC</code>是当前的最小连接成本，比方说<code>10.0</code>，在计算连接顺序<code>BCA</code>时，发现<code>B</code>和<code>C</code>的连接成本就已经大于<code>10.0</code>时，就不再继续往后分析<code>BCA</code>这个连接顺序的成本了。</p>
</li>
<li>
<p>系统变量<code>optimizer_search_depth</code></p>
<p>为了防止无穷无尽的分析各种连接顺序的成本，设计<code>MySQL</code>的大叔们提出了<code>optimizer_search_depth</code>系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与<code>optimizer_search_depth</code>值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间。</p>
</li>
<li>
<p>根据某些规则压根儿就不考虑某些连接顺序</p>
<p>即使是有上边两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以设计<code>MySQL</code>的大叔干脆提出了一些所谓的<code>启发式规则</code>（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。他们提供了一个系统变量<code>optimizer_prune_level</code>来控制到底是不是用这些启发式规则。</p>
</li>
</ul>
<h2 id="调节成本常数">调节成本常数</h2>
<p>我们前边已经介绍了两个<code>成本常数</code>：</p>
<ul>
<li>读取一个页面花费的成本默认是<code>1.0</code></li>
<li>检测一条记录是否符合搜索条件的成本默认是<code>0.2</code></li>
</ul>
<p>其实除了这两个成本常数，<code>MySQL</code>还支持好多呢，它们被存储到了<code>mysql</code>数据库（这是一个系统数据库，我们之前介绍过）的两个表中：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW TABLES FROM mysql LIKE &#x27;%cost%&#x27;;</span><br><span class="hljs-section">+--------------------------+</span><br><span class="hljs-section">| Tables_in_mysql (%cost%) |</span><br><span class="hljs-section">+--------------------------+</span><br>| engine<span class="hljs-emphasis">_cost              |</span><br><span class="hljs-emphasis">| server_</span>cost              |<br><span class="hljs-code">+--------------------------+</span><br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>我们在第一章中就说过，一条语句的执行其实是分为两层的：</p>
<ul>
<li><code>server</code>层</li>
<li>存储引擎层</li>
</ul>
<p>在<code>server</code>层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在<code>server</code>层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的<code>成本常数</code>就存储在了<code>server_cost</code>表中，而依赖于存储引擎的一些操作对应的<code>成本常数</code>就存储在了<code>engine_cost</code>表中。</p>
<h3 id="mysql-server-cost表">mysql.server_cost表</h3>
<p><code>server_cost</code>表中在<code>server</code>层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SELECT <span class="hljs-symbol">*</span> FROM mysql.server_cost;<br>+------------------------------+------------+---------------------+---------+<br>|<span class="hljs-string"> cost_name                    </span>|<span class="hljs-string"> cost_value </span>|<span class="hljs-string"> last_update         </span>|<span class="hljs-string"> comment </span>|<br>+------------------------------+------------+---------------------+---------+<br>|<span class="hljs-string"> disk_temptable_create_cost   </span>|<span class="hljs-string">       NULL </span>|<span class="hljs-string"> 2018-01-20 12:03:21 </span>|<span class="hljs-string"> NULL    </span>|<br>|<span class="hljs-string"> disk_temptable_row_cost      </span>|<span class="hljs-string">       NULL </span>|<span class="hljs-string"> 2018-01-20 12:03:21 </span>|<span class="hljs-string"> NULL    </span>|<br>|<span class="hljs-string"> key_compare_cost             </span>|<span class="hljs-string">       NULL </span>|<span class="hljs-string"> 2018-01-20 12:03:21 </span>|<span class="hljs-string"> NULL    </span>|<br>|<span class="hljs-string"> memory_temptable_create_cost </span>|<span class="hljs-string">       NULL </span>|<span class="hljs-string"> 2018-01-20 12:03:21 </span>|<span class="hljs-string"> NULL    </span>|<br>|<span class="hljs-string"> memory_temptable_row_cost    </span>|<span class="hljs-string">       NULL </span>|<span class="hljs-string"> 2018-01-20 12:03:21 </span>|<span class="hljs-string"> NULL    </span>|<br>|<span class="hljs-string"> row_evaluate_cost            </span>|<span class="hljs-string">       NULL </span>|<span class="hljs-string"> 2018-01-20 12:03:21 </span>|<span class="hljs-string"> NULL    </span>|<br>+------------------------------+------------+---------------------+---------+<br>6 rows in set (0.05 sec)<br></code></pre></td></tr></table></figure>
<p>我们先看一下<code>server_cost</code>各个列都分别是什么意思：</p>
<ul>
<li>
<p><code>cost_name</code></p>
<p>表示成本常数的名称。</p>
</li>
<li>
<p><code>cost_value</code></p>
<p>表示成本常数对应的值。如果该列的值为<code>NULL</code>的话，意味着对应的成本常数会采用默认值。</p>
</li>
<li>
<p><code>last_update</code></p>
<p>表示最后更新记录的时间。</p>
</li>
<li>
<p><code>comment</code></p>
<p>注释。</p>
</li>
</ul>
<p>从<code>server_cost</code>中的内容可以看出来，目前在<code>server</code>层的一些操作对应的<code>成本常数</code>有以下几种：</p>
<table>
<thead>
<tr>
<th>成本常数名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>disk_temptable_create_cost</code></td>
<td><code>40.0</code></td>
<td>创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td>
</tr>
<tr>
<td><code>disk_temptable_row_cost</code></td>
<td><code>1.0</code></td>
<td>向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td>
</tr>
<tr>
<td><code>key_compare_cost</code></td>
<td><code>0.1</code></td>
<td>两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升<code>filesort</code>的成本，让优化器可能更倾向于使用索引完成排序而不是<code>filesort</code>。</td>
</tr>
<tr>
<td><code>memory_temptable_create_cost</code></td>
<td><code>2.0</code></td>
<td>创建基于内存的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td>
</tr>
<tr>
<td><code>memory_temptable_row_cost</code></td>
<td><code>0.2</code></td>
<td>向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td>
</tr>
<tr>
<td><code>row_evaluate_cost</code></td>
<td><code>0.2</code></td>
<td>这个就是我们之前一直使用的检测一条记录是否符合搜索条件的成本，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>小贴士： MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询（比如对于DISTINCT查询可以建一个带有UNIQUE索引的临时表，直接把需要去重的记录插入到这个临时表中，插入完成之后的记录就是结果集了）。在数据量大的情况下可能创建基于磁盘的临时表，也就是为该临时表使用MyISAM、InnoDB等存储引擎，在数据量不大时可能创建基于内存的临时表，也就是使用Memory存储引擎。关于更多临时表的细节我们并不打算展开唠叨，因为展开可能又需要好几万字了，大家知道创建临时表和对这个临时表进行写入和读取的操作代价还是很高的就行了。</p>
</blockquote>
<p>这些成本常数在<code>server_cost</code>中的初始值都是<code>NULL</code>，意味着优化器会使用它们的默认值来计算某个操作的成本，如果我们想修改某个成本常数的值的话，需要做两个步骤：</p>
<ul>
<li>
<p>对我们感兴趣的成本常数做更新操作</p>
<p>比方说我们想把检测一条记录是否符合搜索条件的成本增大到<code>0.4</code>，那么就可以这样写更新语句：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">UPDATE mysql.server_cost <br>    <span class="hljs-keyword">SET</span> cost_value <span class="hljs-comment">= 0.4</span><br>    WHERE <span class="hljs-comment">cost_name =</span> <span class="hljs-comment">&#x27;row_evaluate_cost&#x27;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>让系统重新加载这个表的值。</p>
<p>使用下边语句即可：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FLUSH OPTIMIZER_COSTS<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>当然，在你修改完某个成本常数后想把它们再改回默认值的话，可以直接把<code>cost_value</code>的值设置为<code>NULL</code>，再使用<code>FLUSH OPTIMIZER_COSTS</code>语句让系统重新加载它就好了。</p>
<h3 id="mysql-engine-cost表">mysql.engine_cost表</h3>
<p><code>engine_cost表</code>表中在存储引擎层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM mysql.engine_cost;</span><br><span class="hljs-section">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="hljs-section">| engine_name | device_type | cost_name              | cost_value | last_update         | comment |</span><br><span class="hljs-section">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br>| default     |           0 | io<span class="hljs-emphasis">_block_read_cost     |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="hljs-emphasis">| default     |           0 | memory_block_read_</span>cost |       NULL | 2018-01-20 12:03:21 | NULL    |<br><span class="hljs-code">+-------------+</span>-------------<span class="hljs-code">+------------------------+</span>------------<span class="hljs-code">+---------------------+</span>---------+<br>2 rows in set (0.05 sec)<br></code></pre></td></tr></table></figure>
<p>与<code>server_cost</code>相比，<code>engine_cost</code>多了两个列：</p>
<ul>
<li>
<p><code>engine_name</code>列</p>
<p>指成本常数适用的存储引擎名称。如果该值为<code>default</code>，意味着对应的成本常数适用于所有的存储引擎。</p>
</li>
<li>
<p><code>device_type</code>列</p>
<p>指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，不过在<code>MySQL 5.7.21</code>这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是<code>0</code>。</p>
</li>
</ul>
<p>我们从<code>engine_cost</code>表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：</p>
<table>
<thead>
<tr>
<th>成本常数名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>io_block_read_cost</code></td>
<td><code>1.0</code></td>
<td>从磁盘上读取一个块对应的成本。请注意我使用的是<code>块</code>，而不是<code>页</code>这个词儿。对于<code>InnoDB</code>存储引擎来说，一个<code>页</code>就是一个块，不过对于<code>MyISAM</code>存储引擎来说，默认是以<code>4096</code>字节作为一个块的。增大这个值会加重<code>I/O</code>成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。</td>
</tr>
<tr>
<td><code>memory_block_read_cost</code></td>
<td><code>1.0</code></td>
<td>与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本。</td>
</tr>
</tbody>
</table>
<p>大家看完这两个成本常数的默认值是不是有些疑惑，怎么从内存中和从磁盘上读取一个块的默认成本是一样的，脑子瓦特了？这主要是因为在<code>MySQL</code>目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上，所以设计<code>MySQL</code>的大叔们很粗暴的认为不管这个块有没有加载到内存中，使用的成本都是<code>1.0</code>，不过随着<code>MySQL</code>的发展，等到可以准确预测哪些块在磁盘上，那些块在内存中的那一天，这两个成本常数的默认值可能会改一改吧。</p>
<blockquote>
<p>在MySQL8.0+版本中，<code>io_block_read_cost</code>的默认值仍为1，<code>memory_block_read_cost</code>默认值为0.25</p>
</blockquote>
<p>与更新<code>server_cost</code>表中的记录一样，我们也可以通过更新<code>engine_cost</code>表中的记录来更改关于存储引擎的成本常数，我们也可以通过为<code>engine_cost</code>表插入新记录的方式来添加只针对某种存储引擎的成本常数：</p>
<ul>
<li>
<p>插入针对某个存储引擎的成本常数</p>
<p>比如我们想增大<code>InnoDB</code>存储引擎页面<code>I/O</code>的成本，书写正常的插入语句即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> mysql.engine_cost<br>    <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;InnoDB&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;io_block_read_cost&#x27;</span>, <span class="hljs-number">2.0</span>,<br>    <span class="hljs-built_in">CURRENT_TIMESTAMP</span>, <span class="hljs-string">&#x27;increase Innodb I/O cost&#x27;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>让系统重新加载这个表的值。</p>
<p>使用下边语句即可：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FLUSH OPTIMIZER_COSTS<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h1>13.InnoDB 统计数据是如何收集的</h1>
<p>我们前边唠叨查询成本的时候经常用到一些统计数据，比如通过<code>SHOW TABLE STATUS</code>可以看到关于表的统计数据，通过<code>SHOW INDEX</code>可以看到关于索引的统计数据，那么这些统计数据是怎么来的呢？它们是以什么方式收集的呢？本章将聚焦于<code>InnoDB</code>存储引擎的统计数据收集策略，看完本章大家就会明白为啥前边老说<code>InnoDB</code>的统计信息是不精确的估计值了（言下之意就是我们不打算介绍<code>MyISAM</code>存储引擎统计数据的收集和存储方式，有想了解的同学自己个儿看看文档哈）。</p>
<h2 id="两种不同的统计数据存储方式">两种不同的统计数据存储方式</h2>
<p><code>InnoDB</code>提供了两种存储统计数据的方式：</p>
<ul>
<li>
<p>永久性的统计数据</p>
<p>这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。</p>
</li>
<li>
<p>非永久性的统计数据</p>
<p>这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据。</p>
</li>
</ul>
<p>设计<code>MySQL</code>的大叔们给我们提供了系统变量<code>innodb_stats_persistent</code>来控制到底采用哪种方式去存储统计数据。在<code>MySQL 5.6.6</code>之前，<code>innodb_stats_persistent</code>的值默认是<code>OFF</code>，也就是说<code>InnoDB</code>的统计数据默认是存储到内存的，之后的版本中<code>innodb_stats_persistent</code>的值默认是<code>ON</code>，也就是统计数据默认被存储到磁盘中。</p>
<p>不过<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，也就是说我们可以把某些表的统计数据（以及该表的索引统计数据）存储在磁盘上，把另一些表的统计数据存储在内存中。怎么做到的呢？我们可以在创建和修改表的时候通过指定<code>STATS_PERSISTENT</code>属性来指明该表的统计数据存储方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (...) Engine<span class="hljs-operator">=</span>InnoDB, STATS_PERSISTENT <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 Engine<span class="hljs-operator">=</span>InnoDB, STATS_PERSISTENT <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<p>当<code>STATS_PERSISTENT=1</code>时，表明我们想把该表的统计数据永久的存储到磁盘上，当<code>STATS_PERSISTENT=0</code>时，表明我们想把该表的统计数据临时的存储到内存中。如果我们在创建表时未指定<code>STATS_PERSISTENT</code>属性，那默认采用系统变量<code>innodb_stats_persistent</code>的值作为该属性的值。</p>
<h2 id="基于磁盘的永久性统计数据">基于磁盘的永久性统计数据</h2>
<p>当我们选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW TABLES FROM mysql LIKE &#x27;innodb%&#x27;;</span><br><span class="hljs-section">+---------------------------+</span><br><span class="hljs-section">| Tables_in_mysql (innodb%) |</span><br><span class="hljs-section">+---------------------------+</span><br>| innodb<span class="hljs-emphasis">_index_stats        |</span><br><span class="hljs-emphasis">| innodb_table_</span>stats        |<br><span class="hljs-code">+---------------------------+</span><br>2 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure>
<p>可以看到，这两个表都位于<code>mysql</code>系统数据库下边，其中：</p>
<ul>
<li><code>innodb_table_stats</code>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li>
<li><code>innodb_index_stats</code>存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li>
</ul>
<p>我们下边的任务就是看一下这两个表里边都有什么以及表里的数据是如何生成的。</p>
<h3 id="innodb-table-stats">innodb_table_stats</h3>
<p>直接看一下这个<code>innodb_table_stats</code>表中的各个列都是干嘛的：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>database_name</code></td>
<td>数据库名</td>
</tr>
<tr>
<td><code>table_name</code></td>
<td>表名</td>
</tr>
<tr>
<td><code>last_update</code></td>
<td>本条记录最后更新时间</td>
</tr>
<tr>
<td><code>n_rows</code></td>
<td>表中记录的条数</td>
</tr>
<tr>
<td><code>clustered_index_size</code></td>
<td>表的聚簇索引占用的页面数量</td>
</tr>
<tr>
<td><code>sum_of_other_index_sizes</code></td>
<td>表的其他索引占用的页面数量</td>
</tr>
</tbody>
</table>
<p>注意这个表的主键是<code>(database_name,table_name)</code>，也就是innodb_table_stats表的每条记录代表着一个表的统计信息。我们直接看一下这个表里的内容：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SELECT <span class="hljs-symbol">*</span> FROM mysql.innodb_table_stats;<br>+---------------+---------------+---------------------+--------+----------------------+--------------------------+<br>|<span class="hljs-string"> database_name </span>|<span class="hljs-string"> table_name    </span>|<span class="hljs-string"> last_update         </span>|<span class="hljs-string"> n_rows </span>|<span class="hljs-string"> clustered_index_size </span>|<span class="hljs-string"> sum_of_other_index_sizes </span>|<br>+---------------+---------------+---------------------+--------+----------------------+--------------------------+<br>|<span class="hljs-string"> mysql         </span>|<span class="hljs-string"> gtid_executed </span>|<span class="hljs-string"> 2018-07-10 23:51:36 </span>|<span class="hljs-string">      0 </span>|<span class="hljs-string">                    1 </span>|<span class="hljs-string">                        0 </span>|<br>|<span class="hljs-string"> sys           </span>|<span class="hljs-string"> sys_config    </span>|<span class="hljs-string"> 2018-07-10 23:51:38 </span>|<span class="hljs-string">      5 </span>|<span class="hljs-string">                    1 </span>|<span class="hljs-string">                        0 </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table  </span>|<span class="hljs-string"> 2018-12-10 17:03:13 </span>|<span class="hljs-string">   9693 </span>|<span class="hljs-string">                   97 </span>|<span class="hljs-string">                      175 </span>|<br>+---------------+---------------+---------------------+--------+----------------------+--------------------------+<br>3 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure>
<p>可以看到我们熟悉的<code>single_table</code>表的统计信息就对应着<code>mysql.innodb_table_stats</code>的第三条记录。几个重要统计信息项的值如下：</p>
<ul>
<li><code>n_rows</code>的值是<code>9693</code>，表明<code>single_table</code>表中大约有<code>9693</code>条记录，注意这个数据是估计值。</li>
<li><code>clustered_index_size</code>的值是<code>97</code>，表明<code>single_table</code>表的聚簇索引占用97个页面，这个值是也是一个估计值。</li>
<li><code>sum_of_other_index_sizes</code>的值是<code>175</code>，表明<code>single_table</code>表的其他索引一共占用175个页面，这个值是也是一个估计值。</li>
</ul>
<h4 id="n-rows统计项的收集">n_rows统计项的收集</h4>
<p>为啥老强调<code>n_rows</code>这个统计项的值是估计值呢？现在就来揭晓答案。<code>InnoDB</code>统计一个表中有多少行记录的套路是这样的：</p>
<ul>
<li>
<p>按照一定算法（并不是纯粹随机的）选取几个叶子节点页面，计算每个页面中主键值记录数量，然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的<code>n_rows</code>值。</p>
<blockquote>
<p>小贴士： 真实的计算过程比这个稍微复杂一些，不过大致上就是这样的啦～</p>
</blockquote>
<p>可以看出来这个<code>n_rows</code>值精确与否取决于统计时采样的页面数量，设计<code>MySQL</code>的大叔很贴心的为我们准备了一个名为<code>innodb_stats_persistent_sample_pages</code>的系统变量来控制使用永久性的统计数据时，计算统计数据时采样的页面数量。该值设置的越大，统计出的<code>n_rows</code>值越精确，但是统计耗时也就最久；该值设置的越小，统计出的<code>n_rows</code>值越不精确，但是统计耗时特别少。所以在实际使用是需要我们去权衡利弊，该系统变量的默认值是<code>20</code>。</p>
<p>我们前边说过，不过<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，我们也可以单独设置某个表的采样页面的数量，设置方式就是在创建或修改表的时候通过指定<code>STATS_SAMPLE_PAGES</code>属性来指明该表的统计数据存储方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (...) Engine<span class="hljs-operator">=</span>InnoDB, STATS_SAMPLE_PAGES <span class="hljs-operator">=</span> 具体的采样页面数量;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 Engine<span class="hljs-operator">=</span>InnoDB, STATS_SAMPLE_PAGES <span class="hljs-operator">=</span> 具体的采样页面数量;<br></code></pre></td></tr></table></figure>
<p>如果我们在创建表的语句中并没有指定<code>STATS_SAMPLE_PAGES</code>属性的话，将默认使用系统变量<code>innodb_stats_persistent_sample_pages</code>的值作为该属性的值。</p>
</li>
</ul>
<h4 id="clustered-index-size和sum-of-other-index-sizes统计项的收集">clustered_index_size和sum_of_other_index_sizes统计项的收集</h4>
<p>统计这两个数据需要大量用到我们之前唠叨的<code>InnoDB</code>表空间的知识，如果大家压根儿没有看那一章，那下边的计算过程大家还是不要看了（看也看不懂）；如果看过了，那大家就会发现<code>InnoDB</code>表空间的知识真是有用啊啊啊！！！</p>
<p>这两个统计项的收集过程如下：</p>
<ul>
<li>
<p>从数据字典里找到表的各个索引对应的根页面位置。</p>
<p>系统表<code>SYS_INDEXES</code>里存储了各个索引对应的根页面信息。</p>
</li>
<li>
<p>从根页面的<code>Page Header</code>里找到叶子节点段和非叶子节点段对应的<code>Segment Header</code>。</p>
<p>在每个索引的根页面的<code>Page Header</code>部分都有两个字段：</p>
<ul>
<li><code>PAGE_BTR_SEG_LEAF</code>：表示B+树叶子段的<code>Segment Header</code>信息。</li>
<li><code>PAGE_BTR_SEG_TOP</code>：表示B+树非叶子段的<code>Segment Header</code>信息。</li>
</ul>
</li>
<li>
<p>从叶子节点段和非叶子节点段的<code>Segment Header</code>中找到这两个段对应的<code>INODE Entry</code>结构。</p>
<p>这个是<code>Segment Header</code>结构：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e94d5b165a91f~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cum7dbc812843ac192pfik1raep.png-107.3kB">
</li>
<li>
<p>从对应的<code>INODE Entry</code>结构中可以找到该段对应所有零散的页面地址以及<code>FREE</code>、<code>NOT_FULL</code>、<code>FULL</code>链表的基节点。</p>
<p>这个是<code>INODE Entry</code>结构：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e94d5b1e44524~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cum7f49h1beg5uccbq197n1g1b16.png-173.9kB">
</li>
<li>
<p>直接统计零散的页面有多少个，然后从那三个链表的<code>List Length</code>字段中读出该段占用的区的大小，每个区占用<code>64</code>个页，所以就可以统计出整个段占用的页面。</p>
<p>这个是链表基节点的示意图：</p>
<img src="/dajiangdahe.github.io/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e94d5b17c24e3~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cum7hkiihikm4b88j10461plc1j.png-129.9kB">
</li>
<li>
<p>分别计算聚簇索引的叶子结点段和非叶子节点段占用的页面数，它们的和就是<code>clustered_index_size</code>的值，按照同样的套路把其余索引占用的页面数都算出来，加起来之后就是<code>sum_of_other_index_sizes</code>的值。</p>
</li>
</ul>
<p>这里需要大家注意一个问题，我们说一个段的数据在非常多时（超过32个页面），会以<code>区</code>为单位来申请空间，这里头的问题是以区为单位申请空间中有一些页可能并没有使用，但是在统计<code>clustered_index_size</code>和<code>sum_of_other_index_sizes</code>时都把它们算进去了，所以说聚簇索引和其他的索引占用的页面数可能比这两个值要小一些。</p>
<h3 id="innodb-index-stats">innodb_index_stats</h3>
<p>直接看一下这个<code>innodb_index_stats</code>表中的各个列都是干嘛的：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>database_name</code></td>
<td>数据库名</td>
</tr>
<tr>
<td><code>table_name</code></td>
<td>表名</td>
</tr>
<tr>
<td><code>index_name</code></td>
<td>索引名</td>
</tr>
<tr>
<td><code>last_update</code></td>
<td>本条记录最后更新时间</td>
</tr>
<tr>
<td><code>stat_name</code></td>
<td>统计项的名称</td>
</tr>
<tr>
<td><code>stat_value</code></td>
<td>对应的统计项的值</td>
</tr>
<tr>
<td><code>sample_size</code></td>
<td>为生成统计数据而采样的页面数量</td>
</tr>
<tr>
<td><code>stat_description</code></td>
<td>对应的统计项的描述</td>
</tr>
</tbody>
</table>
<p>注意这个表的主键是<code>(database_name,table_name,index_name,stat_name)</code>，其中的<code>stat_name</code>是指统计项的名称，也就是说innodb_index_stats表的每条记录代表着一个索引的一个统计项。可能这会大家有些懵逼这个统计项到底指什么，别着急，我们直接看一下关于<code>single_table</code>表的索引统计数据都有些什么：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SELECT <span class="hljs-symbol">*</span> FROM mysql.innodb_index_stats WHERE table_name = &#x27;single_table&#x27;;<br>+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+<br>|<span class="hljs-string"> database_name </span>|<span class="hljs-string"> table_name   </span>|<span class="hljs-string"> index_name   </span>|<span class="hljs-string"> last_update         </span>|<span class="hljs-string"> stat_name    </span>|<span class="hljs-string"> stat_value </span>|<span class="hljs-string"> sample_size </span>|<span class="hljs-string"> stat_description                  </span>|<br>+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> PRIMARY      </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_diff_pfx01 </span>|<span class="hljs-string">       9693 </span>|<span class="hljs-string">          20 </span>|<span class="hljs-string"> id                                </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> PRIMARY      </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_leaf_pages </span>|<span class="hljs-string">         91 </span>|<span class="hljs-string">        NULL </span>|<span class="hljs-string"> Number of leaf pages in the index </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> PRIMARY      </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> size         </span>|<span class="hljs-string">         97 </span>|<span class="hljs-string">        NULL </span>|<span class="hljs-string"> Number of pages in the index      </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key1     </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_diff_pfx01 </span>|<span class="hljs-string">        968 </span>|<span class="hljs-string">          28 </span>|<span class="hljs-string"> key1                              </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key1     </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_diff_pfx02 </span>|<span class="hljs-string">      10000 </span>|<span class="hljs-string">          28 </span>|<span class="hljs-string"> key1,id                           </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key1     </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_leaf_pages </span>|<span class="hljs-string">         28 </span>|<span class="hljs-string">        NULL </span>|<span class="hljs-string"> Number of leaf pages in the index </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key1     </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> size         </span>|<span class="hljs-string">         29 </span>|<span class="hljs-string">        NULL </span>|<span class="hljs-string"> Number of pages in the index      </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key2     </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_diff_pfx01 </span>|<span class="hljs-string">      10000 </span>|<span class="hljs-string">          16 </span>|<span class="hljs-string"> key2                              </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key2     </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_leaf_pages </span>|<span class="hljs-string">         16 </span>|<span class="hljs-string">        NULL </span>|<span class="hljs-string"> Number of leaf pages in the index </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key2     </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> size         </span>|<span class="hljs-string">         17 </span>|<span class="hljs-string">        NULL </span>|<span class="hljs-string"> Number of pages in the index      </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key3     </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_diff_pfx01 </span>|<span class="hljs-string">        799 </span>|<span class="hljs-string">          31 </span>|<span class="hljs-string"> key3                              </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key3     </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_diff_pfx02 </span>|<span class="hljs-string">      10000 </span>|<span class="hljs-string">          31 </span>|<span class="hljs-string"> key3,id                           </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key3     </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_leaf_pages </span>|<span class="hljs-string">         31 </span>|<span class="hljs-string">        NULL </span>|<span class="hljs-string"> Number of leaf pages in the index </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key3     </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> size         </span>|<span class="hljs-string">         32 </span>|<span class="hljs-string">        NULL </span>|<span class="hljs-string"> Number of pages in the index      </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_diff_pfx01 </span>|<span class="hljs-string">       9673 </span>|<span class="hljs-string">          64 </span>|<span class="hljs-string"> key_part1                         </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_diff_pfx02 </span>|<span class="hljs-string">       9999 </span>|<span class="hljs-string">          64 </span>|<span class="hljs-string"> key_part1,key_part2               </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_diff_pfx03 </span>|<span class="hljs-string">      10000 </span>|<span class="hljs-string">          64 </span>|<span class="hljs-string"> key_part1,key_part2,key_part3     </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_diff_pfx04 </span>|<span class="hljs-string">      10000 </span>|<span class="hljs-string">          64 </span>|<span class="hljs-string"> key_part1,key_part2,key_part3,id  </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> n_leaf_pages </span>|<span class="hljs-string">         64 </span>|<span class="hljs-string">        NULL </span>|<span class="hljs-string"> Number of leaf pages in the index </span>|<br>|<span class="hljs-string"> xiaohaizi     </span>|<span class="hljs-string"> single_table </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string"> 2018-12-14 14:24:46 </span>|<span class="hljs-string"> size         </span>|<span class="hljs-string">         97 </span>|<span class="hljs-string">        NULL </span>|<span class="hljs-string"> Number of pages in the index      </span>|<br>+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+<br>20 rows in set (0.03 sec)<br></code></pre></td></tr></table></figure>
<p>这个结果有点儿多，正确查看这个结果的方式是这样的：</p>
<ul>
<li>
<p>先查看<code>index_name</code>列，这个列说明该记录是哪个索引的统计信息，从结果中我们可以看出来，<code>PRIMARY</code>索引（也就是主键）占了3条记录，<code>idx_key_part</code>索引占了6条记录。</p>
</li>
<li>
<p>针对<code>index_name</code>列相同的记录，<code>stat_name</code>表示针对该索引的统计项名称，<code>stat_value</code>展示的是该索引在该统计项上的值，<code>stat_description</code>指的是来描述该统计项的含义的。我们来具体看一下一个索引都有哪些统计项：</p>
<ul>
<li>
<p><code>n_leaf_pages</code>：表示该索引的叶子节点占用多少页面。</p>
</li>
<li>
<p><code>size</code>：表示该索引共占用多少页面。</p>
</li>
<li>
<p><code>n_diff_pfx**NN**</code>：表示对应的索引列不重复的值有多少。其中的<code>NN</code>长得有点儿怪呀，啥意思呢？</p>
<p>其实<code>NN</code>可以被替换为<code>01</code>、<code>02</code>、<code>03</code>… 这样的数字。比如对于<code>idx_key_part</code>来说：</p>
<ul>
<li><code>n_diff_pfx01</code>表示的是统计<code>key_part1</code>这单单一个列不重复的值有多少。</li>
<li><code>n_diff_pfx02</code>表示的是统计<code>key_part1、key_part2</code>这两个列组合起来不重复的值有多少。</li>
<li><code>n_diff_pfx03</code>表示的是统计<code>key_part1、key_part2、key_part3</code>这三个列组合起来不重复的值有多少。</li>
<li><code>n_diff_pfx04</code>表示的是统计<code>key_part1、key_part2、key_part3、id</code>这四个列组合起来不重复的值有多少。</li>
</ul>
<blockquote>
<p>小贴士： 这里需要注意的是，对于普通的二级索引，并不能保证它的索引列值是唯一的，比如对于idx_key1来说，key1列就可能有很多值重复的记录。此时只有在索引列上加上主键值才可以区分两条索引列值都一样的二级索引记录。对于主键和唯一二级索引则没有这个问题，它们本身就可以保证索引列值的不重复，所以也不需要再统计一遍在索引列后加上主键值的不重复值有多少。比如上边的idx_key1有n_diff_pfx01、n_diff_pfx02两个统计项，而idx_key2却只有n_diff_pfx01一个统计项。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>在计算某些索引列中包含多少不重复值时，需要对一些叶子节点页面进行采样，<code>sample_size</code>列就表明了采样的页面数量是多少。</p>
<blockquote>
<p>小贴士： 对于有多个列的联合索引来说，采样的页面数量是：innodb_stats_persistent_sample_pages × 索引列的个数。当需要采样的页面数量大于该索引的叶子节点数量的话，就直接采用全表扫描来统计索引列的不重复值数量了。所以大家可以在查询结果中看到不同索引对应的size列的值可能是不同的。</p>
</blockquote>
</li>
</ul>
<h3 id="定期更新统计数据">定期更新统计数据</h3>
<p>随着我们不断的对表进行增删改操作，表中的数据也一直在变化，<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表里的统计数据是不是也应该跟着变一变了？当然要变了，不变的话<code>MySQL</code>查询优化器计算的成本可就差老鼻子远了。设计<code>MySQL</code>的大叔提供了如下两种更新统计数据的方式：</p>
<ul>
<li>
<p>开启<code>innodb_stats_auto_recalc</code>。</p>
<p>系统变量<code>innodb_stats_auto_recalc</code>决定着服务器是否自动重新计算统计数据，它的默认值是<code>ON</code>，也就是该功能默认是开启的。每个表都维护了一个变量，该变量记录着对该表进行增删改的记录条数，如果发生变动的记录数量超过了表大小的<code>10%</code>，并且自动重新计算统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表。不过自动重新计算统计数据的过程是异步发生的，也就是即使表中变动的记录数超过了<code>10%</code>，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。</p>
<p>再一次强调，<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，我们也可以单独为某个表设置是否自动重新计算统计数的属性，设置方式就是在创建或修改表的时候通过指定<code>STATS_AUTO_RECALC</code>属性来指明该表的统计数据存储方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (...) Engine<span class="hljs-operator">=</span>InnoDB, STATS_AUTO_RECALC <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 Engine<span class="hljs-operator">=</span>InnoDB, STATS_AUTO_RECALC <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<p>当<code>STATS_AUTO_RECALC=1</code>时，表明我们想让该表自动重新计算统计数据，当<code>STATS_AUTO_RECALC=0</code>时，表明不想让该表自动重新计算统计数据。如果我们在创建表时未指定<code>STATS_AUTO_RECALC</code>属性，那默认采用系统变量<code>innodb_stats_auto_recalc</code>的值作为该属性的值。</p>
</li>
<li>
<p>手动调用<code>ANALYZE TABLE</code>语句来更新统计信息</p>
<p>如果<code>innodb_stats_auto_recalc</code>系统变量的值为<code>OFF</code>的话，我们也可以手动调用<code>ANALYZE TABLE</code>语句来重新计算统计数据，比如我们可以这样更新关于<code>single_table</code>表的统计数据：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; ANALYZE TABLE single_table;</span><br><span class="hljs-section">+------------------------+---------+----------+----------+</span><br><span class="hljs-section">| Table                  | Op      | Msg_type | Msg_text |</span><br><span class="hljs-section">+------------------------+---------+----------+----------+</span><br><span class="hljs-section">| xiaohaizi.single_table | analyze | status   | OK       |</span><br><span class="hljs-section">+------------------------+---------+----------+----------+</span><br>1 row in set (0.08 sec)<br></code></pre></td></tr></table></figure>
<p>需要注意的是，ANALYZE TABLE语句会立即重新计算统计数据，也就是这个过程是同步的，在表中索引多或者采样页面特别多时这个过程可能会特别慢，请不要没事儿就运行一下<code>ANALYZE TABLE</code>语句，最好在业务不是很繁忙的时候再运行。</p>
</li>
</ul>
<h3 id="手动更新innodb-table-stats和innodb-index-stats表">手动更新innodb_table_stats和innodb_index_stats表</h3>
<p>其实<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表就相当于一个普通的表一样，我们能对它们做增删改查操作。这也就意味着我们可以手动更新某个表或者索引的统计数据。比如说我们想把<code>single_table</code>表关于行数的统计数据更改一下可以这么做：</p>
<ul>
<li>
<p>步骤一：更新<code>innodb_table_stats</code>表。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">UPDATE</span> innodb_table_stats <br>    <span class="hljs-keyword">SET</span> n_rows = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">table_name</span> = <span class="hljs-string">&#x27;single_table&#x27;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>步骤二：让<code>MySQL</code>查询优化器重新加载我们更改过的数据。</p>
<p>更新完<code>innodb_table_stats</code>只是单纯的修改了一个表的数据，需要让<code>MySQL</code>查询优化器重新加载我们更改过的数据，运行下边的命令就可以了：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FLUSH TABLE single_table<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>之后我们使用<code>SHOW TABLE STATUS</code>语句查看表的统计数据时就看到<code>Rows</code>行变为了<code>1</code>。</p>
<h2 id="基于内存的非永久性统计数据">基于内存的非永久性统计数据</h2>
<p>当我们把系统变量<code>innodb_stats_persistent</code>的值设置为<code>OFF</code>时，之后创建的表的统计数据默认就都是非永久性的了，或者我们直接在创建表或修改表时设置<code>STATS_PERSISTENT</code>属性的值为<code>0</code>，那么该表的统计数据就是非永久性的了。</p>
<p>与永久性的统计数据不同，非永久性的统计数据采样的页面数量是由<code>innodb_stats_transient_sample_pages</code>控制的，这个系统变量的默认值是<code>8</code>。</p>
<p>另外，由于非永久性的统计数据经常更新，所以导致<code>MySQL</code>查询优化器计算查询成本的时候依赖的是经常变化的统计数据，也就会生成经常变化的执行计划，这个可能让大家有些懵逼。不过最近的<code>MySQL</code>版本都不咋用这种基于内存的非永久性统计数据了，所以我们也就不深入唠叨它了。</p>
<h2 id="innodb-stats-method的使用">innodb_stats_method的使用</h2>
<p>我们知道<code>索引列不重复的值的数量</code>这个统计数据对于<code>MySQL</code>查询优化器十分重要，因为通过它可以计算出在索引列中平均一个值重复多少行，它的应用场景主要有两个：</p>
<ul>
<li>
<p>单表查询中单点区间太多，比方说这样：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">key</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;xx1&#x27;</span>, <span class="hljs-string">&#x27;xx2&#x27;</span>, ..., <span class="hljs-string">&#x27;xxn&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>当<code>IN</code>里的参数数量过多时，采用<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量就太耗费性能了，所以直接依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。</p>
</li>
<li>
<p>连接查询时，如果有涉及两个表的等值匹配连接条件，该连接条件对应的被驱动表中的列又拥有索引时，则可以使用<code>ref</code>访问方法来对被驱动表进行查询，比方说这样：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">JOIN</span> t2 <span class="hljs-keyword">ON</span> t1.column = t2.<span class="hljs-keyword">key</span> <span class="hljs-keyword">WHERE</span> ...;<br></code></pre></td></tr></table></figure>
<p>在真正执行对<code>t2</code>表的查询前，<code>t1.comumn</code>的值是不确定的，所以我们也不能通过<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量，所以也只能依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。</p>
</li>
</ul>
<p>在统计索引列不重复的值的数量时，有一个比较烦的问题就是索引列中出现<code>NULL</code>值怎么办，比方说某个索引列的内容是这样：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+------+</span><br><span class="hljs-section">| col  |</span><br><span class="hljs-section">+------+</span><br>|    1 |<br>|    2 |<br>| NULL |<br><span class="hljs-section">| NULL |</span><br><span class="hljs-section">+------+</span><br></code></pre></td></tr></table></figure>
<p>此时计算这个<code>col</code>列中不重复的值的数量就有下边的分歧：</p>
<ul>
<li>
<p>有的人认为<code>NULL</code>值代表一个未确定的值，所以设计<code>MySQL</code>的大叔才认为任何和<code>NULL</code>值做比较的表达式的值都为<code>NULL</code>，就是这样：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT 1 = NULL;</span><br><span class="hljs-section">+----------+</span><br><span class="hljs-section">| 1 = NULL |</span><br><span class="hljs-section">+----------+</span><br><span class="hljs-section">|     NULL |</span><br><span class="hljs-section">+----------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT 1 != NULL;</span><br><span class="hljs-section">+-----------+</span><br><span class="hljs-section">| 1 != NULL |</span><br><span class="hljs-section">+-----------+</span><br><span class="hljs-section">|      NULL |</span><br><span class="hljs-section">+-----------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT NULL = NULL;</span><br><span class="hljs-section">+-------------+</span><br><span class="hljs-section">| NULL = NULL |</span><br><span class="hljs-section">+-------------+</span><br><span class="hljs-section">|        NULL |</span><br><span class="hljs-section">+-------------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT NULL != NULL;</span><br><span class="hljs-section">+--------------+</span><br><span class="hljs-section">| NULL != NULL |</span><br><span class="hljs-section">+--------------+</span><br><span class="hljs-section">|         NULL |</span><br><span class="hljs-section">+--------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>
<p>所以每一个<code>NULL</code>值都是独一无二的，也就是说统计索引列不重复的值的数量时，应该把<code>NULL</code>值当作一个独立的值，所以<code>col</code>列的不重复的值的数量就是：<code>4</code>（分别是1、2、NULL、NULL这四个值）。</p>
</li>
<li>
<p>有的人认为其实<code>NULL</code>值在业务上就是代表没有，所有的<code>NULL</code>值代表的意义是一样的，所以<code>col</code>列不重复的值的数量就是：<code>3</code>（分别是1、2、NULL这三个值）。</p>
</li>
<li>
<p>有的人认为这<code>NULL</code>完全没有意义嘛，所以在统计索引列不重复的值的数量时压根儿不能把它们算进来，所以<code>col</code>列不重复的值的数量就是：<code>2</code>（分别是1、2这两个值）。</p>
</li>
</ul>
<p>设计<code>MySQL</code>的大叔蛮贴心的，他们提供了一个名为<code>innodb_stats_method</code>的系统变量，相当于在计算某个索引列不重复值的数量时如何对待<code>NULL</code>值这个锅甩给了用户，这个系统变量有三个候选值：</p>
<ul>
<li>
<p><code>nulls_equal</code>：认为所有<code>NULL</code>值都是相等的。这个值也是<code>innodb_stats_method</code>的默认值。</p>
<p>如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别多，所以倾向于不使用索引进行访问。</p>
</li>
<li>
<p><code>nulls_unequal</code>：认为所有<code>NULL</code>值都是不相等的。</p>
<p>如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别少，所以倾向于使用索引进行访问。</p>
</li>
<li>
<p><code>nulls_ignored</code>：直接把<code>NULL</code>值忽略掉。</p>
</li>
</ul>
<p>反正这个锅是甩给用户了，当你选定了<code>innodb_stats_method</code>值之后，优化器即使选择了不是最优的执行计划，那也跟设计<code>MySQL</code>的大叔们没关系了哈～ 当然对于用户的我们来说，最好不在索引列中存放NULL值才是正解。</p>
<h2 id="总结-5">总结</h2>
<ul>
<li><code>InnoDB</code>以表为单位来收集统计数据，这些统计数据可以是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据。</li>
<li><code>innodb_stats_persistent</code>控制着使用永久性统计数据还是非永久性统计数据；<code>innodb_stats_persistent_sample_pages</code>控制着永久性统计数据的采样页面数量；<code>innodb_stats_transient_sample_pages</code>控制着非永久性统计数据的采样页面数量；<code>innodb_stats_auto_recalc</code>控制着是否自动重新计算统计数据。</li>
<li>我们可以针对某个具体的表，在创建和修改表时通过指定<code>STATS_PERSISTENT</code>、<code>STATS_AUTO_RECALC</code>、<code>STATS_SAMPLE_PAGES</code>的值来控制相关统计数据属性。</li>
<li><code>innodb_stats_method</code>决定着在统计某个索引列不重复值的数量时如何对待<code>NULL</code>值。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/dajiangdahe/categories/Mysql/">Mysql</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/dajiangdahe/tags/Mysql/">Mysql</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/dajiangdahe/2021/12/10/Linux%E5%BC%80%E6%9C%BA%E6%9C%8D%E5%8A%A1%E8%87%AA%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux开机服务自启动问题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/dajiangdahe/2021/11/20/%E3%80%90%E6%95%A3%E6%96%87%E3%80%91God%20ghost%20ghosts/">
                        <span class="hidden-mobile">God ghost ghosts</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP证123456号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/dajiangdahe/img/police_beian.png" alt="police-icon"/>
            
            <span>京公网安备12345678号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/dajiangdahe/js/events.js" ></script>
<script  src="/dajiangdahe/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/dajiangdahe/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/dajiangdahe/js/boot.js" ></script>


</body>
</html>
