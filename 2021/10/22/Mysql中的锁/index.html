

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/dajiangdahe/img/favicon.png">
  <link rel="icon" href="/dajiangdahe/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Hello,here is kengkeng&#39;s blog.">
  <meta name="author" content="kengkeng">
  <meta name="keywords" content="">
  
  <title>Mysql中的锁 - kengkeng&#39;s life</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/dajiangdahe/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/dajiangdahe/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"kengkengya.github.io","root":"/dajiangdahe/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/dajiangdahe/js/utils.js" ></script>
  <script  src="/dajiangdahe/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/dajiangdahe/">&nbsp;<strong>kengkeng's life</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/dajiangdahe/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Mysql中的锁">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      kengkeng
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-22 15:21" pubdate>
        2021年10月22日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      113
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Mysql中的锁</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：6 个月前
                
              </p>
            
            <div class="markdown-body">
              <h1>Mysql中的锁</h1>
<p><strong>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。</strong></p>
<h2 id="1-全局锁">1.全局锁</h2>
<p>全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure>
<p>当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p>**全局锁的典型使用场景是，做全库逻辑备份。**也就是把整库每个表都select出来存成文本</p>
<p>但是让整个库都只读，可能出现以下问题：</p>
<ul>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆</li>
<li>果在从库上备份，那么在备份期间从库不能执行主库同步过来的binlog，会导致主从延迟<br>
在可重复读隔离级别下开启一个事务能够拿到一致性视图</li>
</ul>
<p>官方自带的逻辑备份工具是<strong>mysqldump</strong>。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。single-transaction只适用于所有的表使用事务引擎的库。</p>
<p><strong>1.既然要全库只读，为什么不使用set global readonly=true的方式？</strong></p>
<ul>
<li>在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此修改global变量的方式影响面更大</li>
<li>在异常处理机制上有差异。如果执行Flush tables with read lock命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高</li>
</ul>
<h2 id="2-表级锁">2.表级锁</h2>
<p><strong>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL）</strong></p>
<p>表锁的语法是lock tables … read/write。可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象</p>
<p>如果在某个线程A中执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">lock tables t1 read,t2 wirte;<br></code></pre></td></tr></table></figure>
<p>这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许</p>
<p>另一类表级的锁是MDL。MDL不需要显式使用，在访问一个表的时候会被自动加上。**MDL的作用是，保证读写的正确性。**如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做了变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定不行</p>
<p>在MySQL5.5版本引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p>
<ul>
<li><strong>读锁之间不互斥，因此可以有多个线程同时对一张表增删改查</strong></li>
<li><strong>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行</strong></li>
</ul>
<p>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，需要特别小心，以免对线上服务造成影响。</p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/201906051620443.png" class="" title="在这里插入图片描述">
<p>session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。之后sesession C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。</p>
<p><strong>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放</strong></p>
<p><strong>1.如果安全地给小表加字段？</strong></p>
<p>首先要解决长事务，事务不提交，就会一直占着DML锁。在MySQL的information_schema库的innodb_trx表中，可以查到当前执行的事务。如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务</p>
<p><strong>2.如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而又不得不加个字段，该怎么做？</strong></p>
<p>在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后再通过重试命令重复这个过程。</p>
<h2 id="3-行级锁">3.行级锁</h2>
<p>MySQL的行锁是在引擎层由各个引擎自己实现的。但不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁</p>
<p>行锁就是针对数据表中行记录的锁。比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。</p>
<h3 id="1、两阶段锁协议">1、两阶段锁协议</h3>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162055774.png" class="" title="在这里插入图片描述">
<p>事务A持有的两个记录的行锁都是在commit的时候才释放的，事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。</p>
<p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议</strong></p>
<p><strong>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</strong></p>
<p>【<strong>示例</strong>】</p>
<p>假设要实现一个电影票在线交易业务，顾客A要在影院B购买电影票。业务需要涉及到以下操作：</p>
<p>1.从顾客A账户余额中扣除电影票价</p>
<p>2.给影院B的账户余额增加这张电影票价</p>
<p>3.记录一条交易日志</p>
<p>为了保证交易的原子性，要把这三个操作放在一个事务中。如何安排这三个语句在事务中的顺序呢？</p>
<p>如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。根据两阶段锁协议，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p>
<h3 id="2、死锁和死锁检测">2、死锁和死锁检测</h3>
<p><strong>在并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁</strong>。</p>
<p><strong>【死锁的条件】：</strong></p>
<ul>
<li>
<p>互斥条件：简单的说就是进程抢夺的资源必须是临界资源，一段时间内，该资源只能同时被一个进程所占有。</p>
</li>
<li>
<p>请求和保持条件：当一个进程持有了一个（或者更多）资源，申请另外的资源的时候发现申请的资源被其他进程所持有，当前进程阻塞，但不会是放自己所持有的资源。</p>
</li>
<li>
<p>不可抢占条件：进程已经获得的资源在未使用完毕的情况下不可被其他进程所抢占。</p>
</li>
<li>
<p>循环等待条件：存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源。</p>
</li>
</ul>
<p><strong>【预防死锁】：</strong></p>
<ol>
<li>
<p>破坏请求和保持条件：</p>
<p>1.所有进程在开始运行之前，必须一次性获得所有资源，如果无法获得完全，释放已经获得的资源，等待；</p>
<p>2.所有进程在开始运行之前，只获得初始运行所需要的资源，然后在运行过程中不断请求新的资源，同时释放自己已经用完的资源。</p>
</li>
</ol>
<p>2.破坏不可抢占条件：</p>
<p>​		1.只要当一个进程申请一个资源，然而却申请不到的时候，必须释放已经申请到的所有资源。</p>
<p>3.破坏循环等待条件：</p>
<p>​		1.设立一个规则，让进程获取资源的时候按照一定的顺序依次申请，不能违背这个顺序的规则。必须按照顺序申请和释放，想要申请后面的资源必须先把该资源之前的资源全部申请，想要申请前面的资源必须先把该资源之后的资源。</p>
<p>4.破坏互斥条件：</p>
<p>​		没法破坏，是资源本身的性质所引起的。</p>
<p><strong>【死锁避免】：</strong></p>
<p>1.有序资源分配法：</p>
<p>​	这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1,、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。</p>
<p>​	采用有序资源分配法：R1的编号为1，R2的编号为2,；PA：申请次序应是：R1，R2；PB：申请次序应是：R1，R2；这样就破坏了环路条件，避免了死锁的发生。</p>
<p>2.银行家算法：</p>
<p>​	该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可以很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。</p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162105380.png" class="" title="在这里插入图片描述">
<p>事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<p>一种策略是，<strong>直接进入等待，直到超时</strong>。这个超时时间可以通过参数innodb_lock_wait_timeout来设置<br>
另一种策略是，<strong>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务</strong>，让其他事务得以继续执行。将参数<strong>innodb_deadlock_detect设置为on</strong>，表示开启这个逻辑。</p>
<p>在InnoDB中，<strong>innodb_lock_wait_timeout的默认值是50s</strong>，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的</p>
<p>正常情况下还是要采用主动死锁检查策略，而且innodb_deadlock_detect的默认值本身就是on。主动死锁监测在发生死锁的时候，是能够快速发现并进行处理的，但是它有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁</p>
<p>如果所有事务都要更新同一行的场景，每个新来的被堵住的线程都要判断会不会由于自己的加入导致死锁，这是一个时间复杂度是O(n)的操作。</p>
<p>【<strong>示例</strong>】</p>
<p><strong>怎么解决由这种热点行更新导致的性能问题？</strong></p>
<p>1.如果确保这个业务一定不会出现死锁，可以临时把死锁检测关掉</p>
<p>2.控制并发度</p>
<p>3.将一行改成逻辑上的多行来减少锁冲突。以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成员原来的1/10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p>
<h1>Mysql中的锁</h1>
<p>根据锁的设计思想，MySQL里面的锁大致分为乐观锁和悲观锁。</p>
<h2 id="1、乐观锁和悲观锁的澄清">1、乐观锁和悲观锁的澄清</h2>
<ul>
<li>无论是悲观锁还是乐观锁，他们本质上不是数据库中具体的锁概念，而是我们定义出来，用来描述两种类别的锁的思想。所以有了设计的分类，我们就可以通过这个分类去对数据库中具体的锁进行分门别类；</li>
<li>不过数据库中的乐观锁更倾向叫乐观并发控制（OCC），悲观锁叫悲观并发控制（PCC），还有区别于乐观悲观锁的一种控制叫MVCC，多版本并发控制</li>
<li>也不要把乐观锁和悲观锁与数据库中的行锁，表锁，排他锁，共享锁混为一谈，他们并不是一个维度的东西；前者是一个锁思想，可以将后者根据是否进行趋近于乐观或悲观锁的思想进行分类</li>
<li>乐观锁和悲观锁的概念不仅仅存在于数据库领域，可以说存在线程安全，存在并发的场景几乎都有乐观锁和悲观锁的适用场景，比如Java中也有乐观锁和悲观锁思想的具体实现；但不同领域的乐观和悲观锁的具体实现都不尽相同，要解决的问题也可能有所不一样</li>
</ul>
<h2 id="1、悲观锁">1、悲观锁</h2>
<h3 id="【概念】">【概念】</h3>
<p>在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法; <strong>悲观锁指的是采用一种持悲观消极的态度，默认数据被外界访问时，必然会产生冲突，所以在数据处理的整个过程中都采用加锁的状态，保证同一时间，只有一个线程可以访问到数据，实现数据的排他性</strong>；通常，数据库的悲观锁是利用数据库本身提供的锁机制去实现的.</p>
<p>数据库的悲观并发控制可以解决<strong>读-写冲突和写-写冲突</strong>,指在用<strong>加锁的方式</strong>去解决</p>
<hr>
<h3 id="【实现】">【实现】</h3>
<p><strong>通常情况下，数据库的悲观锁就是利用数据库本身提供的锁去实现的</strong></p>
<ul>
<li>外界要访问某条数据，那它就要首先向数据库申请该数据的锁(某种锁)</li>
<li>如果获得成功，那它就可以操作该数据，在它操作期间，其他客户端就无法再操作该数据了</li>
<li>如果获得失败，则代表同一时间已有其他客户端获得了该锁，那就必须等待其他客户端释放锁</li>
</ul>
<p>当然数据库提供了非常多的锁，每种数据库提供的锁也不尽然相同，所以具体情况就要看是什么锁了,比如行锁，表锁等。</p>
<h3 id="【优缺点】">【优缺点】</h3>
<p>**优点：**适合在写多读少的并发环境中使用，虽然无法维持非常高的性能，但是在乐观锁无法提更好的性能前提下，可以做到数据的安全性<br>
**缺点：**加锁会增加系统开销，虽然能保证数据的安全，但数据处理吞吐量低，不适合在读书写少的场合下使用。</p>
<h2 id="2、乐观锁">2、乐观锁</h2>
<h3 id="【概念】-2">【概念】</h3>
<p>在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法；乐观锁（ Optimistic Locking ） 是相对悲观锁而言，<strong>乐观锁是假设认为即使在并发环境中，外界对数据的操作一般是不会造成冲突，所以并不会去加锁(所以乐观锁不是一把锁)，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测</strong>，如果发现冲突了，则让返回冲突信息，让用户决定如何去做下一步，比如说重试，直至成功为止；数据库的乐观锁，并不是利用数据库本身的锁去实现的，可能是利用某种实现逻辑去实现做到乐观锁的思想</p>
<p>数据库的乐观并发控制要解决的是数据库并发场景下的<strong>写-写冲突</strong>，指在用<strong>无锁的方式</strong>去解决</p>
<hr>
<h3 id="【CAS思想】">【CAS思想】</h3>
<p>其实数据库乐观锁的具体实现几乎就跟Java中乐观锁采用的CAS算法思想是一致，所以我们可以从CAS算法中学习到数据库乐观锁的设计：</p>
<p>CAS指令全称为Compare and Swap，它是系统的指令集，<strong>整个CAS操作是一个原子操作，是不可分割的</strong>。从具体的描述上，我们可以这么看CAS操作：</p>
<hr>
<p><strong>CAS指令需要3个操作数，分别是内存位置V，旧的预期值A,和新值B。CAS指令执行时，当我们读取的内置位置V的现值等于旧预期值A时，处理器才会将新值B去更新内置位置V的值。否则它就不执行更新，但无论是否更新V的值，都会返回V的旧值。</strong></p>
<p>我们通俗的放到代码层次上去理解i = 2; i++，就是说：</p>
<ul>
<li>首先线程1从内存位置V中读取到了值，保存并作为旧预期值A. (v = 2 ,a = 2)</li>
<li>然后在因为i要进行++操作，系统会比较内存位置V的现值跟旧预期值A进行比较，既V =? A。</li>
<li>如果相等，B = i++ = 3 ，新值B就会对内存位置V进行更新，所以内存位置V的值就变成了B的值，3</li>
<li>如果不相等，则说明有其他的线程修改过了内存位置V的值，比如线程2在线程1修改i的值前就更新了i的值。，所以线程1会更新变量i失败。但线程不会挂起，而是返回失败状态，等待调用线程决定是否重试或其他操作。(通常会重试直到成功)</li>
</ul>
<h3 id="【实现】-2">【实现】</h3>
<p><strong>通常乐观锁的实现有两种，但它们的内在都是CAS思想的设计：</strong></p>
<ul>
<li><strong>方式一：</strong> 使用数据版本（<code>version</code>）实现</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">这是乐观锁最常用的一种实现方式。什么是数据版本呢？就是在表中增添一个字段作为该记录的版本标识，比如叫version，每次对该记录的写操作都会让 version<span class="hljs-operator">+</span> <span class="hljs-number">1</span>。<br><br>所以当我们读取了数据(包括version)，做出更新，要提交的时候，就会拿取得的version去跟数据库中的version比较是否一致，如果一致则代表这个时间段，并没有其他的线程的也修改过这个数据，给予更新，同时version <span class="hljs-operator">+</span> <span class="hljs-number">1</span>；如果不一致，则代表在这个时间段，该记录以及被其他线程修改过了， 认为是过期数据，返回冲突信息，让用户决定下一步动作，比如重试（重新读取最新数据，再过更新）<br>update <span class="hljs-keyword">table</span> <span class="hljs-keyword">set</span> num <span class="hljs-operator">=</span> num <span class="hljs-operator">+</span> <span class="hljs-number">1</span> , version <span class="hljs-operator">=</span> version <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> version <span class="hljs-operator">=</span> #&#123;version&#125; <span class="hljs-keyword">and</span> id <span class="hljs-operator">=</span> #&#123;id&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>方式二：</strong> 使用时间戳(<code>timestamp</code>)实现</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">表中增加一个字段，名称无所谓，比如叫update_time, 字段类型使用时间戳（<span class="hljs-type">timestamp</span>）<br><br>原理和方式一一致，也是在更新提交的时检查当前数据库中数据的时间戳和自己更新前取到的时间戳是否一致，如果一致则代表此刻没有冲突，可以提交更新，同时时间戳更新为当前时间，否则就是该时间段有其他线程也更新提交过，返回冲突信息，等待用户下一步动作。<br>update <span class="hljs-keyword">table</span> <span class="hljs-keyword">set</span> num <span class="hljs-operator">=</span> num <span class="hljs-operator">+</span> <span class="hljs-number">1</span> ,update_time <span class="hljs-operator">=</span> unix_timestamp(now()) <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> #&#123;id&#125; <span class="hljs-keyword">and</span> update_time <span class="hljs-operator">=</span> #&#123;updateTime&#125;<br><br></code></pre></td></tr></table></figure>
<p>但是我们要注意的是，要实现乐观锁的思想的同时，我们必须要要保证CAS多个操作的原子性，即<strong>获取数据库数据的版本</strong>，<strong>拿数据库的数据版本与之前拿到的版本的比较</strong>，以及<strong>更新数据</strong>等这几个操作的执行必须是连贯执行，具有复合操作的原子性；所以如果是数据库的SQL,那么我们就要保证<strong>多个SQL操作处于同一个事务中</strong>。</p>
<h3 id="【优缺点】-2">【优缺点】</h3>
<p>**优点：**在读多写少的并发场景下，可以避免数据库加锁的开销，提高Dao层的响应性能。其实很多情况下，我们orm工具都有带有乐观锁的实现，所以这些方法不一定需要我们人为的去实现</p>
<p>**缺点：**在写多读少的并发场景下，即在写操作竞争激烈的情况下，会导致CAS多次重试，冲突频率过高，导致开销比悲观锁更高。</p>
<h1>Mysql锁的底层算法</h1>
<h2 id="1、记录锁">1、记录锁</h2>
<p>​	记录锁是锁住记录，锁住索引记录，而不是真正的数据记录</p>
<ul>
<li>锁是非主键索引，会在索引记录上加锁后，在去主键索引上加锁</li>
<li>表上没有索引，会在隐藏的主键索引上加锁</li>
<li>如果要锁的列没有索引，进行全表记录加锁</li>
</ul>
<h2 id="2、间隙锁">2、间隙锁</h2>
<p>当我们用<strong>范围条件</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB（可重复读、串行化级别下才有效）会给符合条件的已有数据的索引项加锁；对于<strong>键值在条件范围内但并不存在的记录</strong>，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162243301.png" class="" title="在这里插入图片描述">
<p>当执行<code>select * from t where d=5 for update</code>的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p>
<p><strong>跟间隙锁存在冲突关系的是往这个间隙中插入一个记录这个操作。间隙锁之间不存在冲突关系</strong></p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162258745.png" class="" title="在这里插入图片描述">
<p>这里sessionB并不会被堵住。因为表t里面并没有c=7会这个记录，因此sessionA加的是间隙锁(5,10)。而sessionB也是在这个间隙加的间隙锁。它们用共同的目标，保护这个间隙，不允许插入值。但它们之间是不冲突的。</p>
<p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是(-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。因为+∞是开区间，在实现上，InnoDB给每个索引加了一个不存在的最大值supremum，这样才符合都是前开后闭区间。</p>
<p>间隙锁和next-key lock的引入，解决了幻读的问题，但同时也带来了一些困扰。</p>
<p><strong>间隙锁导致的死锁：</strong></p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162307738.png" class="" title="在这里插入图片描述">
<p>1.sessionA执行select … for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10)</p>
<p>2.sessionB执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突</p>
<p>3.sessionB试图插入一行(9,9,9)，被sessionA的间隙锁挡住了，只好进入等待</p>
<p>4.sessionA试图插入一行(9,9,9)，被sessionB的间隙锁挡住了</p>
<p>两个session进入互相等待状态，形成了死锁，间隙锁的引入可能会导致同样的语句锁住更大的范围，这其实是影响并发度的。在读提交隔离级别下，不存在间隙锁。</p>
<h2 id="3、the-next-key-lock">3、the next-key lock</h2>
<p>该锁是记录锁加gap锁，在RR隔离级别下，对行的扫描、锁定都是使用这种锁。如果查询中包含唯一索引，就会只适用记录锁。因为唯一索引能确定记录行数，其他索引不能确定行数，有可能在其他事务中添加这个索引的数据导致幻读。</p>
<h3 id="1、next-key-lock加锁规则">1、next-key lock加锁规则</h3>
<ul>
<li>原则1：加锁的基本单位是next-key lock，next-key lock是<strong>前开后闭区间</strong></li>
<li>原则2：查找过程中<strong>访问到的对象</strong>才会加锁</li>
<li>优化1：索引上的<strong>等值查询，给唯一索引加锁的时候，next-key lock退化为行锁</strong></li>
<li>优化2：索引上的<strong>等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁</strong></li>
<li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止</li>
</ul>
<hr>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">这个规则只限于<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MySQL5</span>.</span></span>x系列&lt;=<span class="hljs-number">5.7</span>.<span class="hljs-number">24</span>，<span class="hljs-number">8.0</span>系列&lt;=<span class="hljs-number">8.0</span>.<span class="hljs-number">13</span><br></code></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `c` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `d` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<br>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>),(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>),(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">25</span>,<span class="hljs-number">25</span>,<span class="hljs-number">25</span>);<br><br></code></pre></td></tr></table></figure>
<h3 id="2、案例一：等值查询间隙锁">2、案例一：等值查询间隙锁</h3>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162316586.png" class="" title="在这里插入图片描述">
<p>1.由于表t中没有id=7的记录，根据原则1，加锁单位是next-key lock，sessionA加锁范围就是(5,10]</p>
<p>2.根据优化2，这是一个等值查询(id=7)，而id=10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)</p>
<p>所以，sessionB要往这个间隙里面插入id=8的记录会被锁住，但是sessionC修改id=10这行是可以的</p>
<hr>
<h3 id="3、案例二：非唯一索引等值锁">3、案例二：非唯一索引等值锁</h3>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162326725.png" class="" title="在这里插入图片描述">
<p>1.根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock</p>
<p>2.c是普通索引，因此访问c=5这一条记录是不能马上停下来的，需要向右遍历，查到c=10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock</p>
<p>3.根据优化2，等值判断，向右遍历，最后一个值不满足c=5这个等值条件，因此退化成间隙锁(5,10)</p>
<p>4.根据原则2，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有任何锁，这就是为什么sessionB的update语句可以执行完成</p>
<p>锁是加在索引上的，在这个例子中，lock in share mode只锁覆盖索引，但是如果是for update，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁，这样的话sessionB的update语句会被阻塞住。如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段</p>
<h3 id="4、案例三：主键索引范围锁">4、案例三：主键索引范围锁</h3>
<p>1.开始执行的时候，要找到第一个id=10的行，因此本该是next-key lock(5,10]。根据优化1，主键id上的等值条件，退化成行锁，只加了id=10这一行的行锁</p>
<p>2.范围查询就往后继续找，找到id=15这一行停下来，因此需要加next-key lock(10,15]</p>
<p>所以，sessionA这时候锁的范围就是主键索引上，行锁id=10和next-key lock(10,15]</p>
<h3 id="5、案例四：非唯一索引范围锁">5、案例四：非唯一索引范围锁</h3>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162335984.png" class="" title="在这里插入图片描述">
<p>这次sessionA用字段c来判断，加锁规则跟案例三唯一的不同是：在第一次用c=10定位记录的时候，索引c上加上(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，因此最终sessionA加的锁是索引c上的(5,10]和(10,15]这两个next-key lock</p>
<h3 id="6、案例五：唯一索引范围锁bug">6、案例五：唯一索引范围锁bug</h3>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162344192.png" class="" title="在这里插入图片描述">
<p>sessionA是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id=15这一行就应该停止了</p>
<p>但是实现上，InnoDB会扫描到第一个不满足条件的行为止，也就是id=20。而且由于这是个范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上</p>
<p>所以，sessionB要更新id=20这一行是会被锁住的。同样地，sessionC要插入id=16的一行，也会被锁住</p>
<h3 id="7、案例六：非唯一索引上存在等值的例子">7、案例六：非唯一索引上存在等值的例子</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">30</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure>
<p>​		新插入的这一行c=10，现在表里有两个c=10的行。虽然有两个c=10，但是它们的主键值id是不同的，因此这两个c=10的记录之间也是有间隙的.</p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162401642.png" class="" title="在这里插入图片描述">
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162410516.png" class="" title="在这里插入图片描述">
<p>sessionA在遍历的时候，先访问第一个c=10的记录。根据原则1，这里加的是(c=5,id=5)到(c=10,id=10)这个next-key lock。然后sessionA向右查找，直到碰到(c=15,id=15)这一行，循环才结束。根据优化2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成(c=10,id=10)到(c=15,id=15)的间隙锁</p>
<p>也就是说，这个delete语句在索引c上的加锁范围，就是下图中蓝色区域覆盖的部分，这个蓝色区域左右两边都是虚线，表示开区间.</p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162418283.png" class="" title="在这里插入图片描述">
<h3 id="8、案例七：limit语句加锁">8、案例七：limit语句加锁</h3>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/2019060516242975.png" class="" title="在这里插入图片描述">
<p>加了limit 2的限制，因此在遍历到(c=10,id=30)这一行之后，满足条件的语句已经有两条，循环就结束了。因此，索引c上的加锁范围就变成了从(c=5,id=5)到(c=10,id=30)这个前开后闭区间，如下图所示：</p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162438271.png" class="" title="在这里插入图片描述">
<p>再删除数据的时候尽量加limit，这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围</p>
<h3 id="9、案例八：一个死锁的例子">9、案例八：一个死锁的例子</h3>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162446585.png" class="" title="在这里插入图片描述">
<p>1.sessionA启动事务后执行查询语句加lock in share mode，在索引c上加了next-key lock(5,10]和间隙锁(10,15)</p>
<p>2.sessionB的update语句也要在索引c上加next-key lock(5,10]，进入锁等待</p>
<p>3.然后sessionA要再插入(8,8,8)这一行，被sessionB的间隙锁锁住。由于出现了死锁，InnoDB让sessionB回滚</p>
<p>sessionB的加next-key lock(5,10]操作，实际上分成了两步，先是加(5,10)间隙锁，加锁成功；然后加c=10的行锁，这时候才被锁住的.</p>
<h3 id="10、不等号条件里的等值查询">10、不等号条件里的等值查询</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> id<span class="hljs-operator">&gt;</span><span class="hljs-number">9</span> <span class="hljs-keyword">and</span> id<span class="hljs-operator">&lt;</span><span class="hljs-number">12</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span> <span class="hljs-keyword">for</span> update;<br><br></code></pre></td></tr></table></figure>
<p>利用上面的加锁规则，这个语句的加锁范围是主键索引上的(0,5]、(5,10]和(10,15)。加锁单位是next-key lock，这里用到了优化2，即索引上的等值查询，向右遍历的时候id=15不满足条件，所以next-key lock退化为了间隙锁(10,15)</p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162454802.png" class="" title="在这里插入图片描述">
<p>1.首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到第一个id&lt;12的值</p>
<p>2.这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id=12的这个值，只是最终没找到，但找到了(10,15)这个间隙</p>
<p>3.然后根据order by id desc，再向左遍历，在遍历过程中，就不是等值查询了，会扫描到id=5这一行，所以会加一个next-key lock (0,5]</p>
<p>在执行过程中，通过树搜索的方式定位记录的时候，用的是等值查询的方法</p>
<h3 id="11、等值查询的过程">11、等值查询的过程</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> c <span class="hljs-keyword">in</span>(<span class="hljs-number">5</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>) lock <span class="hljs-keyword">in</span> share mode;<br><br></code></pre></td></tr></table></figure>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/2019060516250347.png" class="" title="在这里插入图片描述">
<p>这条in语句使用了索引c并且rows=3，说明这三个值都是通过B+树搜索定位的</p>
<p><strong>在查找c=5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c=5，就要向右遍历，找到c=10确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。执行c=10会这个逻辑的时候，加锁的范围是(5,10]和(10,15)，执行c=20这个逻辑的时候，加锁的范围是(15,20]和(20,25)</strong></p>
<p>这条语句在索引c上加的三个记录锁的顺序是：先加c=5的记录锁，再加c=10的记录锁，最后加c=20的记录锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> c <span class="hljs-keyword">in</span>(<span class="hljs-number">5</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c <span class="hljs-keyword">desc</span> <span class="hljs-keyword">for</span> update;<br><br></code></pre></td></tr></table></figure>
<p>由于语句里面是order by c desc，这三个记录锁的加锁顺序是先锁c=20，然后c=10，最后是c=5。这两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，就可能出现死锁。</p>
<h3 id="12、insert语句的锁为什么这么多？">12、insert语句的锁为什么这么多？</h3>
<h4 id="1、insert-…-select语句">1、insert … select语句</h4>
<p>表t和t2的表结构、初始化数据语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `c` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `d` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `c` (`c`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-number">4</span>,<span class="hljs-number">4</span>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t2 <span class="hljs-keyword">like</span> t;<br><br></code></pre></td></tr></table></figure>
<p><strong>在可重复读隔离级别下，binlog_format=statement时执行下面这个语句时，需要对表t的所有行和间隙加锁</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t2(c,d) <span class="hljs-keyword">select</span> c,d <span class="hljs-keyword">from</span> t;<br><br></code></pre></td></tr></table></figure>
<h4 id="2、insert循环写入">2、insert循环写入</h4>
<p>要往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t2(c,d)  (<span class="hljs-keyword">select</span> c<span class="hljs-operator">+</span><span class="hljs-number">1</span>, d <span class="hljs-keyword">from</span> t force index(c) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1</span>);<br><br></code></pre></td></tr></table></figure>
<p>这个语句的加锁范围，就是表t索引c上的(3,4]和(4,supermum]这两个next-key lock，以及主键索引上id=4这一行</p>
<p>执行流程是从表t中按照索引c倒序吗，扫描第一行，拿到结果写入到表t2中，因此整条语句的扫描行数是1</p>
<p>但如果要把这一行的数据插入到表t中的话:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t(c,d)  (<span class="hljs-keyword">select</span> c<span class="hljs-operator">+</span><span class="hljs-number">1</span>, d <span class="hljs-keyword">from</span> t force index(c) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1</span>);<br><br></code></pre></td></tr></table></figure>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162511513.png" class="" title="在这里插入图片描述">
<p>explain结果中的Extra字段中Using temporary字段，表示这个语句用到了临时表</p>
<p>执行流程如下：</p>
<p>1.创建临时表，表里有两个字段c和d</p>
<p>2.按照索引c扫描表t，依次取c=4、3、2、1，然后回表，读到c和d的值写入临时表</p>
<p>3.由于语义里面有limit 1，所以只取了临时表的第一行，再插入到表t中</p>
<p>这个语句会导致在表t上做全表扫描，并且会给索引c上的所有间隙都加上共享的next-key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据</p>
<p>需要临时表是因为这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符.</p>
<h4 id="3、insert唯一键冲突">3、insert唯一键冲突</h4>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162520967.png" class="" title="在这里插入图片描述">
<p>sessionA执行的insert语句，发生唯一键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁，sessionA持有索引c上的(5,10]共享next-key lock（读锁）</p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162531598.png" class="" title="在这里插入图片描述">
<p>在sessionA执行rollback语句回滚的时候，sessionC几乎同时发现死锁并返回</p>
<p>1.在T1时刻，启动sessionA，并执行insert语句，此时在索引c的c=5上加了记录锁。这个索引是唯一索引，因此退化为记录锁</p>
<p>2.在T2时刻，sessionA回滚。这时候，sessionB和sessionC都试图继续执行插入操作，都要加上写锁。两个session都要等待对方的行锁，所以就出现了死锁</p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162540324.png" class="" title="在这里插入图片描述">
<h4 id="4、insert-into-…-on-duplicate-key-update">4、insert into … on duplicate key update</h4>
<p>上面这个例子是主键冲突后直接报错，如果改写成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>) <span class="hljs-keyword">on</span> duplicate key update d<span class="hljs-operator">=</span><span class="hljs-number">100</span>; <br><br></code></pre></td></tr></table></figure>
<p>就会给索引c上(5,10]加一个排他的next-key lock（写锁）</p>
<p>insert into … on duplicate key update的语义逻辑是，插入一行数据，如果碰到唯一键约束，就继续执行后面的更新语句。如果有多个列违反了唯一性索引，就会按照索引的顺序，修改跟第一个索引冲突的行</p>
<p>表t里面已经有了(1,1,1)和(2,2,2)这两行，执行这个语句效果如下：</p>
<img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/2019060516255097.png" class="" title="在这里插入图片描述">
<p>主键id是先判断的，MySQL认为这个语句跟id=2这一行冲突，所以修改的是id=2的行</p>
<p><strong>思考题：</strong><br>
1、如果要删除一个表里面的前10000行数据，有以下三种方法可以做到：</p>
<ul>
<li>第一种，直接执行delete from T limit 10000;</li>
<li>第二种，在一个连接中循环执行20次delete from T limit 500；</li>
<li>第三种，在20个连接中同时执行delete from T limit 500；<br>
选择哪一种方式比较好？</li>
</ul>
<p><strong>参考答案：</strong></p>
<ul>
<li>
<p>第一种方式，单个语句占用时间长，锁的时间也比较长，而且大事务还会导致主从延迟</p>
</li>
<li>
<p>第三种方式，会人为造成锁冲突</p>
</li>
<li>
<p>第二种方式相对较好</p>
</li>
</ul>
<hr>
<h1>MyISAM和MySQL的锁的对比总结</h1>
<p><strong>对于ＭyISAM的表锁，主要有以下几点</strong></p>
<p>（１）共享读锁（S）之间是兼容的，但共享读锁（S）和排他写锁（X）之间，以及排他写锁之间（X）是互斥的，也就是说读和写是串行的。</p>
<p>（２）在一定条件下，ＭyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表和插入的锁争用问题。</p>
<p>（３）ＭyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIPORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。</p>
<p>（４）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，ＭyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</p>
<p><strong>对于InnoDB表，主要有以下几点</strong></p>
<p>（１）InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。</p>
<p>（２）InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。</p>
<p>（３）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。</p>
<p>（４）ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。</p>
<p>（５）锁冲突甚至死锁很难完全避免。</p>
<p><strong>在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</strong></p>
<ul>
<li>尽量使用较低的隔离级别</li>
<li>精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。</li>
<li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li>
<li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li>
<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。</li>
<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li>
<li>不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。</li>
<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/dajiangdahe/categories/Mysql/">Mysql</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/dajiangdahe/tags/Mysql/">Mysql</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/dajiangdahe/2021/10/22/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Mysql主从复制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97/">
                        <span class="hidden-mobile">Mysql中的日志</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP证123456号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/dajiangdahe/img/police_beian.png" alt="police-icon"/>
            
            <span>京公网安备12345678号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/dajiangdahe/js/events.js" ></script>
<script  src="/dajiangdahe/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/dajiangdahe/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/dajiangdahe/js/boot.js" ></script>


</body>
</html>
