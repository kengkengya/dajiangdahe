

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/dajiangdahe/img/favicon.png">
  <link rel="icon" href="/dajiangdahe/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Hello,here is kengkeng&#39;s blog.">
  <meta name="author" content="kengkeng">
  <meta name="keywords" content="">
  
  <title>JavaInterview-01 - kengkeng&#39;s life</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/dajiangdahe/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/dajiangdahe/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"kengkengya.github.io","root":"/dajiangdahe/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/dajiangdahe/js/utils.js" ></script>
  <script  src="/dajiangdahe/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/dajiangdahe/">&nbsp;<strong>kengkeng's life</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/dajiangdahe/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JavaInterview-01">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      kengkeng
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-22 15:21" pubdate>
        2021年10月22日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      105
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JavaInterview-01</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2 年前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="初心">初心</h2>
<p>在本篇文章开始之前，我想先来回答一个问题：我为什么要写这样一篇关于面试的文章？原因有三个：第一，我想为每一个为梦想时刻准备着的“有心人”，尽一份自己的力量，提供一份高度精华的 java 面试清单；第二，目前市面上的面试题不是答案不准确就是内容覆盖面太窄，所以提供一份经典而又准确的面试题是非常有必要的；第三，本文会对部分面试题提供详细解读和代码案例，让读者知其然并知其所以然，从而学到更多的知识。</p>
<p>或许这份面试题还不足以囊括所有 java 问题，但有了它，我相信你一定不会“败”的很惨，因为有了它，足以应对目前市面上绝大部分的 java 面试了，因为这篇文章不论是从深度还是广度上来讲，都已经囊括了非常多的知识点了。</p>
<p>凡事预则立，不预则废。能读到这里的人，我相信都是这个世界上的“有心人”，还是那句老话：上天不负有心人！我相信你的每一步努力，都会收获意想不到的回报。</p>
<h2 id="适宜阅读人群">适宜阅读人群</h2>
<ul>
<li>准备跳槽的初/中/高级 Java 程序员</li>
<li>想要查漏补缺的人</li>
<li>想要不断完善和扩充自己 Java 技术栈的人</li>
<li>Java 面试官</li>
</ul>
<h2 id="阅读建议">阅读建议</h2>
<p>本文会按技能模块划分文章段落，每个模块里的内容，从易到难依次进行排序，各模块之间不存在互相关联的关系，读者可选择文章顺序阅读或者跳跃式阅读。</p>
<h2 id="正文">正文</h2>
<p>本文分为十九个模块，分别是： <strong>Java 基础、容器、多线程、反射、对象拷贝、Java Web 模块、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、Mybatis、RabbitMQ、Kafka、Zookeeper、MySql、Redis、JVM</strong> ，如下图所示：</p>
<p><img src="http://icdn.apigo.cn/gitchat/java-intervier-gitchat-path.png" alt=""></p>
<p>共包含 208 道面试题，本文的宗旨是为读者朋友们整理一份详实而又权威的面试清单，下面一起进入主题吧。</p>
<h3 id="一、Java-基础">一、Java 基础</h3>
<h4 id="1-JDK-和-JRE-有什么区别？">1.JDK 和 JRE 有什么区别？</h4>
<ul>
<li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li>
<li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li>
</ul>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p>
<h4 id="2-和-equals-的区别是什么？">2.== 和 equals 的区别是什么？</h4>
<p><strong>== 解读</strong></p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是引用是否相同；</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String x = <span class="hljs-string">&quot;string&quot;</span>;<br>String y = <span class="hljs-string">&quot;string&quot;</span>;<br>String z = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;string&quot;</span>);<br>System.out.println(x==y); <span class="hljs-comment">// true</span><br>System.out.println(x==z); <span class="hljs-comment">// false</span><br>System.out.println(x.equals(y)); <span class="hljs-comment">// true</span><br>System.out.println(x.equals(z)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p><strong>equals 解读</strong></p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br>Cat c1 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;王磊&quot;</span>);<br>Cat c2 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;王磊&quot;</span>);<br>System.out.println(c1.equals(c2)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;老王&quot;</span>);<br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;老王&quot;</span>);<br>System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>        String anotherString = (String)anObject;<br>        <span class="hljs-keyword">int</span> n = value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>            <span class="hljs-keyword">char</span> v1[] = value;<br>            <span class="hljs-keyword">char</span> v2[] = anotherString.value;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p><strong>总结</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h4 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？">3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h4>
<p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String str1 = <span class="hljs-string">&quot;通话&quot;</span>;<br>String str2 = <span class="hljs-string">&quot;重地&quot;</span>;<br>System.out.println(String.format(<span class="hljs-string">&quot;str1：%d | str2：%d&quot;</span>,  str1.hashCode(),str2.hashCode()));<br>System.out.println(str1.equals(str2));<br></code></pre></td></tr></table></figure>
<p>执行的结果：</p>
<p>str1：1179395 | str2：1179395</p>
<p>false</p>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h4 id="4-final-在-java-中有什么作用？">4.final 在 java 中有什么作用？</h4>
<ul>
<li>final 修饰的类叫最终类，该类不能被继承。</li>
<li>final 修饰的方法不能被重写。</li>
<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li>
</ul>
<h4 id="5-java-中的-Math-round-1-5-等于多少？">5.java 中的 Math.round(-1.5) 等于多少？</h4>
<p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<h4 id="6-String-属于基础的数据类型吗？">6.String 属于基础的数据类型吗？</h4>
<p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p>
<h4 id="7-java-中操作字符串都有哪些类？它们之间有什么区别？">7.java 中操作字符串都有哪些类？它们之间有什么区别？</h4>
<p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<h4 id="8-String-str-i-与-String-str-new-String-“i”-一样吗？">8.String str=&quot;i&quot;与 String str=new String(“i”)一样吗？</h4>
<p>不一样，因为内存的分配方式不一样。String str=&quot;i&quot;的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h4 id="9-如何将字符串反转？">9.如何将字符串反转？</h4>
<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringBuffer reverse</span><br>StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();<br>stringBuffer.append(<span class="hljs-string">&quot;abcdefg&quot;</span>);<br>System.out.println(stringBuffer.reverse()); <span class="hljs-comment">// gfedcba</span><br><span class="hljs-comment">// StringBuilder reverse</span><br>StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>stringBuilder.append(<span class="hljs-string">&quot;abcdefg&quot;</span>);<br>System.out.println(stringBuilder.reverse()); <span class="hljs-comment">// gfedcba</span><br></code></pre></td></tr></table></figure>
<h4 id="10-String-类的常用方法都有那些？">10.String 类的常用方法都有那些？</h4>
<ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h4 id="11-抽象类必须要有抽象方法吗？">11.抽象类必须要有抽象方法吗？</h4>
<p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHi</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hi~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h4 id="12-普通类和抽象类有哪些区别？">12.普通类和抽象类有哪些区别？</h4>
<ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<h4 id="13-抽象类能使用-final-修饰吗？">13.抽象类能使用 final 修饰吗？</h4>
<p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p>
<p><img src="http://icdn.apigo.cn/gitchat/java-intervier002.png" alt="final定义抽象类"></p>
<h4 id="14-接口和抽象类有什么区别？">14.接口和抽象类有什么区别？</h4>
<ul>
<li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有。</li>
<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>
</ul>
<h4 id="15-java-中-IO-流分为几种？">15.java 中 IO 流分为几种？</h4>
<p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h4 id="16-BIO、NIO、AIO-有什么区别？">16.BIO、NIO、AIO 有什么区别？</h4>
<ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：New IO（或 Non Blocking IO）同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<h4 id="17-Files的常用方法都有哪些？">17.Files的常用方法都有哪些？</h4>
<ul>
<li>Files.exists()：检测文件路径是否存在。</li>
<li>Files.createFile()：创建文件。</li>
<li>Files.createDirectory()：创建文件夹。</li>
<li>Files.delete()：删除一个文件或目录。</li>
<li>Files.copy()：复制文件。</li>
<li>Files.move()：移动文件。</li>
<li>Files.size()：查看文件个数。</li>
<li>Files.read()：读取文件。</li>
<li>Files.write()：写入文件。</li>
</ul>
<h3 id="二、容器">二、容器</h3>
<h4 id="18-java-容器都有哪些？">18.java 容器都有哪些？</h4>
<p>java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<ul>
<li>Collection
<ul>
<li>List
<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector
<ul>
<li>Stack</li>
</ul>
</li>
</ul>
</li>
<li>Set
<ul>
<li>HashSet
<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
<li>Map
<ul>
<li>HashMap
<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li>TreeMap</li>
<li>ConcurrentHashMap</li>
<li>Hashtable</li>
</ul>
</li>
</ul>
<h4 id="19-Collection-和-Collections-有什么区别？">19.Collection 和 Collections 有什么区别？</h4>
<ul>
<li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li>
<li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections.sort(list)。</li>
</ul>
<h4 id="20-List、Set、Map-之间的区别是什么？">20.List、Set、Map 之间的区别是什么？</h4>
<p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>
<p>三者之间的区别，如下表：</p>
<p><img src="http://icdn.apigo.cn/gitchat/listmapset.png" alt="list/set/map区别图"></p>
<h4 id="21-HashMap-和-Hashtable-有什么区别？">21.HashMap 和 Hashtable 有什么区别？</h4>
<ul>
<li>存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。</li>
<li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li>
<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>
<li>HashMap 的默认初始容量为 16，Hashtable 为 11。</li>
<li>HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。</li>
<li>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</li>
<li>HashMap 去掉了 Hashtable 中的 contains 方法。</li>
<li>HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。</li>
</ul>
<h4 id="22-如何决定使用-HashMap-还是-TreeMap？">22.如何决定使用 HashMap 还是 TreeMap？</h4>
<p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>
<h4 id="23-说一下-HashMap-的实现原理？">23.说一下 HashMap 的实现原理？</h4>
<p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key.hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<p>==HashMap的链表上数据节点超过8时，就会转换为红黑树。==</p>
<ol>
<li>
<p>补充：</p>
<ol>
<li>头结点是HashMap&lt;K,V&gt; table表上索引位置的节点</li>
<li>红黑树的根节点不一定是索引位置的头结点，HashMap通过moveRootToFont来维护头结点的位置。</li>
<li>转换为红黑树之后，链表的结构还存在，通过next属性来维持，红黑树上的任何操作都会顺带维护链表结构。</li>
<li>在红黑树上，叶子结点也可能是next节点，两种结构互不影响。</li>
<li>源码中，在进行红黑树的查找时，会利用以下两种规则：
<ol>
<li>如果目标节点的 hash 值小于 p 节点的 hash 值，则向 p 节点的左边遍历；否则向 p 节点的右边遍历。</li>
<li>如果目标节点的 key 值小于 p 节点的 key 值，则向 p 节点的左边遍历；否则向 p 节点的右边遍历。（左节点 &lt; 根节点 &lt; 右节点）</li>
</ol>
</li>
</ol>
</li>
<li>
<p>默认容量：16</p>
</li>
<li>
<p>默认负载因子：0.75</p>
</li>
<li>
<p>链表节点转换的红黑树的阈值：8</p>
</li>
<li>
<p>红黑树转链表的阈值：6</p>
</li>
<li>
<p>转红黑树的时候，table的长度阈值：64</p>
</li>
<li>
<p><strong>get方法</strong></p>
<ol>
<li>对table进行校验：table不为空&amp;&amp;table长度大于0&amp;&amp;索引位置的节点不为空</li>
<li>然后检查first节点是目标入参，是返回，不是执行3。</li>
<li>通过next遍历first下的链表
<ol>
<li>如果是红黑树，则调用红黑树的查找目标节点的方法getTreeNode()</li>
<li>不是则遍历链表，找到节点key和入参key相等的值，返回value</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>put方法</strong></p>
<ol>
<li>校验table是否为空&amp;&amp;长度==0，如果是调用resize()进行初始化。
<ol>
<li>通过Hash值计算索引位置，将该索引位置的头结点赋值给P，如果为空，则在此新增节点。</li>
</ol>
</li>
<li>若table不为空，判断p的key的hash值是否一样，如果相等，则将p赋值给e节点</li>
<li>判断p节点是不是TreeNode，如果是调用红黑树的putTreeVal方法查找目标节点</li>
<li>否则，是普通链表节点（使用bincount计数）
<ol>
<li>如果p的next为空，则新增一个节点插入尾部。
<ol>
<li>如果bincount的值超过8个，则调用treeifyBin将链表节点转换为红黑树节点</li>
</ol>
</li>
<li>如果e节点存在hash值和key值都与传入的相同，则e节点即为目标节点。p指向e。</li>
</ol>
</li>
<li>如果e的节点不为空，则代表目标节点存在，使用value覆盖该节点的value，并返回oldValue。</li>
<li>如果插入节点后节点数超过阈值，则调用resize方法进行扩容</li>
</ol>
</li>
<li>
<p><strong>扩容</strong>resize方法</p>
<ol>
<li>
<p>如果old表的容量不为0</p>
<ol>
<li>判断old表的容量是否超过最大容量，如果超过最大阈值设置为Interger.MAX_VALUE，并直接返回old表。此时oldCap*2比Integer.MAX_VALUE大，因此无法进行重新分布，只是单纯的将阈值扩容到最大。</li>
<li>==将newCap赋值为oldCap的2倍，如果newCap&lt;最大容量并且oldCap&gt;=16，则将新阈值设置为原来的两倍==</li>
</ol>
</li>
<li>
<p>如果old表的容量为0，阈值&gt;0，是因为初始容量被放入阈值，则将新表的容量设置为old表的阈值</p>
</li>
<li>
<p>如果old表的容量为0，阈值&gt;=0，这种情况是没有穿初始容量的new方法创建的空表，将阈值和容量设置为默认值。</p>
</li>
<li>
<p>如果新表的阈值为空，则通过新的容量*负载因子获得阈值。</p>
</li>
<li>
<p>将当前阈值设置成新计算出来的新的阈值，定义新表，容量为刚计算出来的新容量，将table设置为新定义的表。</p>
</li>
<li>
<p>扩容后，节点重 hash 为什么只可能分布在 “原索引位置” 与 “原索引 + oldCap 位置“。（针对于普通的链表节点）</p>
</li>
</ol>
</li>
</ol>
<h4 id="24-说一下-HashSet-的实现原理？">24.说一下 HashSet 的实现原理？</h4>
<p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<h4 id="25-ArrayList-和-LinkedList-的区别是什么？">25.ArrayList 和 LinkedList 的区别是什么？</h4>
<ul>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
</ul>
<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<h4 id="26-如何实现数组和-List-之间的转换？">26.如何实现数组和 List 之间的转换？</h4>
<ul>
<li>数组转 List：使用 Arrays.asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// list to array</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;王磊&quot;</span>);<br>list.add(<span class="hljs-string">&quot;的博客&quot;</span>);<br>list.toArray();<br><span class="hljs-comment">// array to list</span><br>String[] array = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;王磊&quot;</span>,<span class="hljs-string">&quot;的博客&quot;</span>&#125;;<br>Arrays.asList(array);<br></code></pre></td></tr></table></figure>
<h4 id="27-ArrayList-和-Vector-的区别是什么？">27.ArrayList 和 Vector 的区别是什么？</h4>
<ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
<h4 id="28-Array-和-ArrayList-有何区别？">28.Array 和 ArrayList 有何区别？</h4>
<ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<h4 id="29-在-Queue-中-poll-和-remove-有什么区别？">29.在 Queue 中 poll()和 remove()有什么区别？</h4>
<ul>
<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>
<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>queue.offer(<span class="hljs-string">&quot;string&quot;</span>); <span class="hljs-comment">// add</span><br>System.out.println(queue.poll());<br>System.out.println(queue.remove());<br>System.out.println(queue.size());<br></code></pre></td></tr></table></figure>
<h4 id="30-哪些集合类是线程安全的？">30.哪些集合类是线程安全的？</h4>
<p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 jdk 1.5 之后随着 java.util.concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>
<h4 id="31-迭代器-Iterator-是什么？">31.迭代器 Iterator 是什么？</h4>
<p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<h4 id="32-Iterator-怎么使用？有什么特点？">32.Iterator 怎么使用？有什么特点？</h4>
<p>Iterator 使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Iterator&lt;String&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>  String obj = it.next();<br>  System.out.println(obj);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h4 id="33-Iterator-和-ListIterator-有什么区别？">33.Iterator 和 ListIterator 有什么区别？</h4>
<ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>
<li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
<h4 id="34-怎么确保一个集合不能被修改？">34.怎么确保一个集合不能被修改？</h4>
<p>可以使用 Collections.unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 java.lang.UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;x&quot;</span>);<br>Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);<br>clist.add(<span class="hljs-string">&quot;y&quot;</span>); <span class="hljs-comment">// 运行时此行报错</span><br>System.out.println(list.size());<br></code></pre></td></tr></table></figure>
<h3 id="三、多线程">三、多线程</h3>
<h4 id="35-并行和并发有什么区别？">35.并行和并发有什么区别？</h4>
<ul>
<li>并行：多个处理器或多核处理器同时处理多个任务。</li>
<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li>
</ul>
<p>如下图：</p>
<p><img src="http://icdn.apigo.cn/gitchat/gitchat208-010.png" alt=""></p>
<p>并发 = 两个队列和一台咖啡机。</p>
<p>并行 = 两个队列和两台咖啡机。</p>
<h4 id="36-线程和进程的区别？">36.线程和进程的区别？</h4>
<p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>
<h4 id="37-守护线程是什么？">37.守护线程是什么？</h4>
<p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 java 中垃圾回收线程就是特殊的守护线程。</p>
<h4 id="38-创建线程有哪几种方式？">38.创建线程有哪几种方式？</h4>
<p>创建线程有四种方式：</p>
<ul>
<li>继承 Thread 重写 run 方法；</li>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口。</li>
<li>使用线程池ThreadPoolExecutor。</li>
</ul>
<h4 id="39-说一下-runnable-和-callable-有什么区别？">39.说一下 runnable 和 callable 有什么区别？</h4>
<p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p>
<p>FutureTask类：</p>
<ol>
<li>
<p>​	一个可取消的异步计算。FutureTask提供了对Future的基本实现。可以调用一个方法去开始或者取消一个计算，并可以查询和返回一个计算结果。</p>
</li>
<li>
<p>FutureTask还实现了Runnable接口，所以FutureTash的实例对象可以交给Thread或者Excutor执行。也可以自己调用futureTash.run()：分为三个状态：</p>
<ol>
<li>
<p>未启动</p>
</li>
<li>
<p>已启动</p>
</li>
<li>
<p>已完成</p>
<p><img src="https://img-blog.csdnimg.cn/20190530214704456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0ODQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li></li>
</ol>
</li>
</ol>
<h4 id="40-线程有哪些状态？">40.线程有哪些状态？</h4>
<p>线程的状态：new Runnable Running  Blocked Dead</p>
<ul>
<li>
<p>NEW 尚未启动</p>
</li>
<li>
<p>RUNNABLE 可运行/就绪状态，等待分配CPU时间片</p>
</li>
<li>
<p>Running  获取CPU时间片，正在运行</p>
</li>
<li>
<p>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</p>
<ul>
<li>线程通过调用sleep方法进入睡眠状态；</li>
<li>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；、</li>
<li>线程试图得到一个锁，而该锁正被其他线程持有；</li>
<li>线程在等待某个触发条件；</li>
</ul>
</li>
<li>
<p>Dead ：线程结束（判断线程是否活着用 isAlive（）方法）</p>
<ul>
<li>run方法正常退出而自然死亡；</li>
<li>一个未捕获的异常终止了run方法而使线程猝死；</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201228162648820.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="41-sleep-和-wait-有什么区别？">41.sleep() 和 wait() 有什么区别？</h4>
<ul>
<li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li>
<li>释放锁：sleep() 不释放锁；wait() 释放锁。</li>
<li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。而且使用wait的线程会进入Wait Set集中。</li>
</ul>
<h4 id="42-notify-和-notifyAll-有什么区别？">42.notify()和 notifyAll()有什么区别？</h4>
<p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。其中等待池就是 JVM 维护的 Wait Set集合</p>
<h4 id="43-线程的-run-和-start-有什么区别？">43.线程的 run()和 start()有什么区别？</h4>
<p>start()方法用于启动线程，run()方法用于执行线程的运行时代码。run() 可以重复调用，而 start()只能调用一次。</p>
<h4 id="44-创建线程池有哪几种方式？">44.创建线程池有哪几种方式？</h4>
<p>线程池创建有七种方式，最核心的是最后一种：</p>
<ul>
<li>new SingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li>
<li>new CachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li>
<li>new FixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li>
<li>new SingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li>
<li>new ScheduledThreadPool(int corePoolSize)：和new SingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li>
<li>new WorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li>
<li>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</li>
</ul>
<h4 id="45-线程池都有哪些状态？">45.线程池都有哪些状态？</h4>
<ul>
<li>
<p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</p>
</li>
<li>
<p>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</p>
</li>
<li>
<p>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</p>
</li>
<li>
<p>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</p>
</li>
<li>
<p>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p>
<p><img src="https://img-blog.csdnimg.cn/20201228162704883.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="46-线程池中-submit-和-execute-方法有什么区别？">46.线程池中 submit()和 execute()方法有什么区别？</h4>
<ul>
<li>
<p>execute()：只能执行 Runnable 类型的任务。</p>
</li>
<li>
<p>submit()：可以执行 Runnable 和 Callable 类型的任务。</p>
</li>
<li>
<p>方法所在的类不同：<br>
<code>execute</code> 方法：<code>java.util.concurrent.Executor</code>;<br>
<code>submit</code>方法：<code>java.util.concurrent.ExecutorService</code></p>
</li>
<li>
<p>所需要的参数不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">execute : java.util.concurrent.Executor#execute(java.lang.Runnable)<br>submit: java.util.concurrent.ExecutorService#submit(java.lang.Runnable, T),<br>               java.util.concurrent.ExecutorService#submit(java.lang.Runnable)<br>               java.util.concurrent.ExecutorService#submit(java.util.concurrent.Callable&lt;T&gt;)<br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p>
<h4 id="47-在-java-程序中怎么保证多线程的运行安全？">47.在 java 程序中怎么保证多线程的运行安全？</h4>
<ul>
<li>方法一：使用安全类，比如 java.util.concurrent 下的类。</li>
<li>方法二：使用自动锁 synchronized。</li>
<li>方法三：使用手动锁 Lock。</li>
</ul>
<p>手动锁 java 示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;获得锁&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>    lock.unlock();<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="48-多线程中-synchronized-锁升级的原理是什么？">48.多线程中 synchronized 锁升级的原理是什么？</h4>
<p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h4 id="49-什么是死锁？">49.什么是死锁？</h4>
<p>当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<ol>
<li><strong>死锁产生的原因</strong>：
<ol>
<li>系统资源的竞争：多个进程使用一个资源造成的僵局，例如打印机。</li>
<li>进程推进顺序的非法：请求和释放资源的顺序问题</li>
<li>死锁产生的必要条件：只要一个条件不满足，就不会产生死锁。
<ol>
<li>互斥条件：同一时间内只允许一个线程使用。</li>
<li>不剥夺条件：线程在获取资源还没使用完毕，不能被其他线程占有，必须由此线程自己释放</li>
<li>请求和保持条件：线程已经保持了至少一个资源，但是又请求了新的资源请求，此时请求资源进程等待，保持的资源不释放</li>
<li>循环等待条件：请求资源的线程构成一个请求资源链{p1,p2…pn}，后一个线程必须依赖于前一个线程。</li>
</ol>
</li>
</ol>
</li>
<li><strong>JVM对锁的维护</strong>：
<ol>
<li>JVM在底层维护了两个“队列”，一个是Entry Set（入口集），一个Wait Set（等待集）</li>
<li>首先每一个对象都有唯一一个内部的monitor（内部锁），Entry Set存储所有的等待获取资源的资源，Wait Set存储执行了objectX.wait（）的线程。</li>
<li>假设ABC三个线程，B线程获取了资源，线程AC进入Entry Set，等待请求资源（此时处于BLOCKED状态），当B释放资源，Entry Set队列里随机一个线程出列与其他获取的线程来争夺线程（处于RUNNABLE），抢占成功就真正离开Entry Set，否则，再回到Entry Set。</li>
<li>如果有个线程执行了objectX.wait（）方法，则进入Wait Set队列，当其他线程执行了objectX.notify()/notifyAll()方法，Wait Set中的线程才会离开队列，共同去抢占资源，如果被唤醒的线程抢夺了资源，则会离开队列，否则，再次回到Wait Set中</li>
</ol>
</li>
</ol>
<h4 id="50-怎么防止死锁？">50.怎么防止死锁？</h4>
<ul>
<li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。 （设置加锁时长）</li>
<li>尽量使用 java.util.concurrent 并发类代替自己手写锁。</li>
<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>
<li>加锁顺序。</li>
<li>死锁检测。并且给线程设置优先级。</li>
</ul>
<h4 id="51-ThreadLocal-是什么？有哪些使用场景？">51.ThreadLocal 是什么？有哪些使用场景？</h4>
<p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>
<h4 id="52-说一下-synchronized-底层实现原理？">52.说一下 synchronized 底层实现原理？</h4>
<p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 java 6 的时候，java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能</p>
<p>==补充1：i++等操作不具备原子性，它分为读取，计算，赋值三个步骤，可能在步骤还没完成就被赋值	了。==</p>
<p>==synchronized 过程：当线程获取锁的时候，monitor+1，如果重复进入，则继续+1，如果失去锁，则monitor=0。通过指令monittorenter和monitorexit来操作。==</p>
<p>==synchronized 锁膨胀：无锁状态、偏向锁、轻量级锁、重量级锁，此过程不可逆。==</p>
<p>==偏向锁：减少同一线程获取锁的代价，大多数情况下，锁不存在多线程竞争，总是由统一线程多次获得。==</p>
<p>==轻量级锁：当存在第二个线程申请同一个锁时，偏向锁就会立即升级为轻量级锁，这里是申请锁，而不是竞争锁，可以一前一后的交替执行代码块。==</p>
<p>==重量级锁：当多个线程同时竞争一个锁时，就会升级成重量级锁，一般追求吞吐量、同步块、或者同步方法较长的场景下。==</p>
<p>==锁消除：jvm扫描上下文，去除不存在竞争的锁==</p>
<p>==锁粗化：jvm扫描上下文，通过扩大枷锁的范围，避免反复加锁和释放锁==</p>
<p>==自旋锁：在共享数据的状态持续过短的情况下，切换线程不值得，就通过让线程执行循环等待锁的释放的方式来进行优化，得到锁就进入临界区，否则就挂起。缺点：如果一直得不到锁，就会带来大量性能开销==</p>
<p>==自适应自旋锁：它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。==</p>
<h4 id="53-synchronized-和-volatile-的区别是什么？">53.synchronized 和 volatile 的区别是什么？</h4>
<ul>
<li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
</ul>
<p>==volatile 定义：volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略（可见性、有序性、原子性）==</p>
<p>==作用：保证了不同线程对这个变量进行修改时，新值对其他线程来说是立马可见的。 只能保证对变量的单次读/写操作的原子性。能够禁止进行指令重排序==</p>
<h4 id="54-synchronized-和-Lock-有什么区别？">54.synchronized 和 Lock 有什么区别？</h4>
<ul>
<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
</ul>
<h4 id="55-synchronized-和-ReentrantLock-区别是什么？">55.synchronized 和 ReentrantLock 区别是什么？</h4>
<p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 java 6 中对 synchronized 进行了非常多的改进。</p>
<p>主要区别如下：</p>
<ul>
<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>
<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>
<li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li>
<li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ul>
<p>==AbstractQueuedSynchronizer(AQS)：是一个构建锁和相关同步器的框架，它依赖于FIFO的等待队列实现。ReentrantLock就是基于AQS构建的。AQS维护了一个FIFO的队列，记录等待的线程，上锁和释放锁就是线程进队or出队的过程；获取不到锁，就进入队列进行等待，被唤醒就出队列。==</p>
<h4 id="56-说一下-atomic-的原理？">56.说一下 atomic 的原理？</h4>
<p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>==Atomic的作用：方面程序员在多线程的环境下，进行无锁编程==</p>
<p>==CAS：比较和替换技术，将预期值与当前变量的值进行比较，如果相等就用新值替换，否则就不操作。注意：CAS的操作中的再面对ABA问题时，不能保证这个值是否被修改过，可以给自己增加一个版本号，每次修改变量时，版本自增，比较的时候比较值与版本号==</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/dajiangdahe/categories/JavaInterview/">JavaInterview</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/dajiangdahe/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/dajiangdahe/2021/10/22/JavaInterview-02/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JavaInterview-02</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/dajiangdahe/2021/10/22/HR%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94%E7%AD%96%E7%95%A5/">
                        <span class="hidden-mobile">HR面试</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP证123456号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/dajiangdahe/img/police_beian.png" alt="police-icon"/>
            
            <span>京公网安备12345678号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/dajiangdahe/js/events.js" ></script>
<script  src="/dajiangdahe/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/dajiangdahe/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/dajiangdahe/js/boot.js" ></script>


</body>
</html>
