<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="Hello,here is kengkeng&#39;s blog." />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> kengkeng&#39;s life</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dajiangdahe.github.io/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/dajiangdahe.github.io/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/dajiangdahe.github.io/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/dajiangdahe.github.io/">kengkeng&#39;s life</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_1.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/vultr.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-JavaInterview-03"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/dajiangdahe.github.io/2021/10/22/JavaInterview-03/"
    >JavaInterview-03</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/dajiangdahe.github.io/2021/10/22/JavaInterview-03/" class="article-date">
  <time datetime="2021-10-22T07:21:44.862Z" itemprop="datePublished">2021-10-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/dajiangdahe.github.io/categories/JavaInterview/">JavaInterview</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="九、设计模式">九、设计模式</h3>
<h4 id="88-说一下你熟悉的设计模式？">88.说一下你熟悉的设计模式？</h4>
<ul>
<li>单例模式：保证被创建一次，节省系统开销。</li>
<li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li>
<li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li>
<li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li>
<li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li>
<li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li>
</ul>
<h4 id="89-简单工厂和抽象工厂有什么区别？">89.简单工厂和抽象工厂有什么区别？</h4>
<ul>
<li>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</li>
<li>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</li>
<li>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</li>
</ul>
<h3 id="十、Spring-Spring-MVC">十、Spring/Spring MVC</h3>
<h4 id="90-为什么要使用-spring？">90.为什么要使用 spring？</h4>
<ul>
<li>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</li>
<li>spring 提供了事务支持，使得事务操作变的更加方便。</li>
<li>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</li>
<li>更方便的框架集成，spring 可以很方便的集成其他框架，比如 mybatis、hibernate 等。</li>
<li>方便程序的测试，提供了对Junit4的支持。</li>
</ul>
<h4 id="91-解释一下什么是-aop？">91.解释一下什么是 aop？</h4>
<p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>
<p>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p>
<h4 id="92-解释一下什么是-ioc？">92.解释一下什么是 ioc？</h4>
<p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</p>
<p>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p>
<h4 id="93-spring-有哪些主要模块？">93.spring 有哪些主要模块？</h4>
<ul>
<li>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</li>
<li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li>
<li>spring dao：Data Access Object 提供了JDBC的抽象层。</li>
<li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li>
<li>spring web：提供了针对 web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 web 的 ApplicationContext。</li>
<li>spring web mvc：spring 中的 mvc 封装包提供了 web 应用的 Model-View-Controller（MVC）的实现。</li>
</ul>
<h4 id="94-spring-常用的注入方式有哪些？">94.spring 常用的注入方式有哪些？</h4>
<ul>
<li>setter 属性注入</li>
<li>构造方法注入</li>
<li>注解方式注入</li>
</ul>
<h4 id="95-spring-中的-bean-是线程安全的吗？">95.spring 中的 bean 是线程安全的吗？</h4>
<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<ul>
<li>有状态就是有数据存储功能。</li>
<li>无状态就是不会保存数据。</li>
</ul>
<h4 id="96-spring-支持几种-bean-的作用域？">96.spring 支持几种 bean 的作用域？</h4>
<p>spring 支持 5 种作用域，如下：</p>
<ul>
<li>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</li>
<li>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</li>
<li>Web 环境下的作用域：
<ul>
<li>request：每次 http 请求都会创建一个 bean；</li>
<li>session：同一个 http session 共享一个 bean 实例；</li>
<li>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong> 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<h4 id="97-spring-自动装配-bean-有哪些方式？">97.spring 自动装配 bean 有哪些方式？</h4>
<ul>
<li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li>
<li>byName：它根据 bean 的名称注入对象依赖项。</li>
<li>byType：它根据类型注入对象依赖项。</li>
<li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</li>
<li>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</li>
</ul>
<h4 id="98-spring-事务实现方式有哪些？">98.spring 事务实现方式有哪些？</h4>
<ul>
<li>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</li>
<li>编码方式：提供编码的形式管理和维护事务。</li>
</ul>
<h4 id="99-说一下-spring-的事务隔离？">99.说一下 spring 的事务隔离？</h4>
<p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
<p>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p>
<p>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），sql server 的默认级别；</p>
<p>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），mysql 的默认级别；</p>
<p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>
<p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h4 id="100-说一下-spring-mvc-运行流程？">100.说一下 spring mvc 运行流程？</h4>
<ul>
<li>spring mvc 先将请求发送给 DispatcherServlet。</li>
<li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li>
<li>DispatcherServlet 再把请求提交到对应的 Controller。</li>
<li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li>
<li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li>
<li>视图对象负责渲染返回给客户端。</li>
</ul>
<h4 id="101-spring-mvc-有哪些组件？">101.spring mvc 有哪些组件？</h4>
<ul>
<li>前置控制器 DispatcherServlet。</li>
<li>映射控制器 HandlerMapping。</li>
<li>处理器 Controller。</li>
<li>模型和视图 ModelAndView。</li>
<li>视图解析器 ViewResolver。</li>
</ul>
<h4 id="102-RequestMapping-的作用是什么？">102.@RequestMapping 的作用是什么？</h4>
<p>将 http 请求映射到相应的类/方法上。</p>
<h4 id="103-Autowired-的作用是什么？">103.@Autowired 的作用是什么？</h4>
<p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p>
<h3 id="十一、Spring-Boot-Spring-Cloud">十一、Spring Boot/Spring Cloud</h3>
<h4 id="104-什么是-spring-boot？">104.什么是 spring boot？</h4>
<p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p>
<h4 id="105-为什么要用-spring-boot？">105.为什么要用 spring boot？</h4>
<ul>
<li>配置简单</li>
<li>独立运行</li>
<li>自动装配</li>
<li>无代码生成和 xml 配置</li>
<li>提供应用监控</li>
<li>易上手</li>
<li>提升开发效率</li>
</ul>
<h4 id="106-spring-boot-核心配置文件是什么？">106.spring boot 核心配置文件是什么？</h4>
<p>spring boot 核心的两个配置文件：</p>
<ul>
<li>bootstrap (.yml 或者 .properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</li>
<li>application (.yml 或者 .properties)：用于 spring boot 项目的自动化配置。</li>
</ul>
<h4 id="107-spring-boot-配置文件有哪几种类型？它们有什么区别？">107.spring boot 配置文件有哪几种类型？它们有什么区别？</h4>
<p>配置文件有 .properties 格式和 .yml 格式，它们主要的区别是书法风格不同。</p>
<p>.properties 配置如下：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">spring</span>.rabbitmq.<span class="hljs-keyword">port</span>=5672<br><br></code></pre></td></tr></table></figure>
<p>.yml 配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">rabbitmq:</span><br>		<span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br><br></code></pre></td></tr></table></figure>
<p>.yml 格式不支持 @PropertySource 注解导入。</p>
<h4 id="108-spring-boot-有哪些方式可以实现热部署？">108.spring boot 有哪些方式可以实现热部署？</h4>
<ul>
<li>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring.devtools.restart.enabled 设置为 true；</li>
<li>使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</li>
</ul>
<h4 id="109-jpa-和-hibernate-有什么区别？">109.jpa 和 hibernate 有什么区别？</h4>
<p>jpa 全称 Java Persistence API，是 java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p>
<h4 id="110-什么是-spring-cloud？">110.什么是 spring cloud？</h4>
<p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p>
<h4 id="111-spring-cloud-断路器的作用是什么？">111.spring cloud 断路器的作用是什么？</h4>
<p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>
<h4 id="112-spring-cloud-的核心组件有哪些？">112.spring cloud 的核心组件有哪些？</h4>
<ul>
<li>Eureka：服务注册于发现。</li>
<li>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</li>
<li>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</li>
<li>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li>
<li>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</li>
</ul>
<h3 id="十二、Hibernate">十二、Hibernate</h3>
<h4 id="113-为什么要使用-hibernate？">113.为什么要使用 hibernate？</h4>
<ul>
<li>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。</li>
<li>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。</li>
<li>可以很方便的进行数据库的移植工作。</li>
<li>提供了缓存机制，是程序执行更改的高效。</li>
</ul>
<h4 id="114-什么是-ORM-框架？">114.什么是 ORM 框架？</h4>
<p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</p>
<p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p>
<h4 id="115-hibernate-中如何在控制台查看打印的-sql-语句？">115.hibernate 中如何在控制台查看打印的 sql 语句？</h4>
<p>在 Config 里面把 hibernate.show_sql 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p>
<h4 id="116-hibernate-有几种查询方式？">116.hibernate 有几种查询方式？</h4>
<p>三种：hql、原生 sql、条件查询 Criteria。</p>
<h4 id="117-hibernate-实体类可以被定义为-final-吗？">117.hibernate 实体类可以被定义为 final 吗？</h4>
<p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p>
<h4 id="118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？">118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h4>
<p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p>
<h4 id="119-hibernate-是如何工作的？">119.hibernate 是如何工作的？</h4>
<ul>
<li>读取并解析配置文件。</li>
<li>读取并解析映射文件，创建 SessionFactory。</li>
<li>打开 Session。</li>
<li>创建事务。</li>
<li>进行持久化操作。</li>
<li>提交事务。</li>
<li>关闭 Session。</li>
<li>关闭 SessionFactory。</li>
</ul>
<h4 id="120-get-和-load-的区别？">120.get()和 load()的区别？</h4>
<ul>
<li>数据查询时，没有 OID 指定的对象，get()返回 null；load()返回一个代理对象。</li>
<li>load()支持延迟加载；get()不支持延迟加载。</li>
</ul>
<h4 id="121-说一下-hibernate-的缓存机制？">121.说一下 hibernate 的缓存机制？</h4>
<p>hibernate 常用的缓存有一级缓存和二级缓存：</p>
<p>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</p>
<p>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p>
<h4 id="122-hibernate-对象有哪些状态？">122.hibernate 对象有哪些状态？</h4>
<ul>
<li>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</li>
<li>持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。</li>
<li>游离状态：Session 关闭之后对象就是游离状态。</li>
</ul>
<h4 id="123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？">123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h4>
<ul>
<li>getCurrentSession 会绑定当前线程，而 openSession 则不会。</li>
<li>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</li>
</ul>
<h4 id="124-hibernate-实体类必须要有无参构造函数吗？为什么？">124.hibernate 实体类必须要有无参构造函数吗？为什么？</h4>
<p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p>
<h3 id="十三、Mybatis">十三、Mybatis</h3>
<h4 id="125-mybatis-中-和-的区别是什么？">125.mybatis 中 #{}和 ${}的区别是什么？</h4>
<p>#{}是预编译处理，${}是字符替换。<br>
在使用 #{}时，mybatis 会将 sql 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 sql 注入，保证程序的运行安全。</p>
<h4 id="126-mybatis-有几种分页方式？">126.mybatis 有几种分页方式？</h4>
<p>分页方式：逻辑分页和物理分页。</p>
<p><strong>1).逻辑分页：</strong> 使用 mybatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p>
<p><strong>2).物理分页：</strong> 自己手写 sql 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p>
<h4 id="127-RowBounds-是一次性查询全部结果吗？为什么？">127.RowBounds 是一次性查询全部结果吗？为什么？</h4>
<p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 mybatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>
<p>Fetch Size 官方相关文档：<a target="_blank" rel="noopener" href="http://t.cn/EfSE2g3">http://t.cn/EfSE2g3</a></p>
<h4 id="128-mybatis-逻辑分页和物理分页的区别是什么？">128.mybatis 逻辑分页和物理分页的区别是什么？</h4>
<ul>
<li>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</li>
<li>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</li>
</ul>
<h4 id="129-mybatis-是否支持延迟加载？延迟加载的原理是什么？">129.mybatis 是否支持延迟加载？延迟加载的原理是什么？</h4>
<p>mybatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</p>
<p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a.getB().getName()，这个时候发现 a.getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 sql，先查询出来 B，然后再调用 a.setB(b)，而这时候再调用 a.getB().getName() 就有值了，这就是延迟加载的基本原理。</p>
<h4 id="130-说一下-mybatis-的一级缓存和二级缓存？">130.说一下 mybatis 的一级缓存和二级缓存？</h4>
<ul>
<li>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 sqlSession  一致的，有多个 sqlSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</li>
<li>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个sqlSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。</li>
</ul>
<p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<p>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h4 id="131-mybatis-和-hibernate-的区别有哪些？">131.mybatis 和 hibernate 的区别有哪些？</h4>
<ul>
<li>灵活性：mybatis 更加灵活，自己可以写 sql 语句，使用起来比较方便。</li>
<li>可移植性：mybatis 有很多自己写的 sql，因为每个数据库的 sql 可以不相同，所以可移植性比较差。</li>
<li>学习和使用门槛：mybatis 入门比较简单，使用门槛也更低。</li>
<li>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</li>
</ul>
<h4 id="132-mybatis-有哪些执行器（Executor）？">132.mybatis 有哪些执行器（Executor）？</h4>
<p>mybatis 有三种基本的Executor执行器：</p>
<ul>
<li>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</li>
<li>ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</li>
<li>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</li>
</ul>
<h4 id="133-mybatis-分页插件的实现原理是什么？">133.mybatis 分页插件的实现原理是什么？</h4>
<p>分页插件的基本原理是使用 mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h4 id="134-mybatis-如何编写一个自定义插件？">134.mybatis 如何编写一个自定义插件？</h4>
<p><strong>1).自定义插件实现原理</strong></p>
<p>mybatis 自定义插件针对 mybatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p>
<ul>
<li>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</li>
<li>StatementHandler：拦截 sql 语法构建的处理，它是 mybatis 直接和数据库执行 sql 脚本的对象，另外它也实现了 mybatis 的一级缓存；</li>
<li>ParameterHandler：拦截参数的处理；</li>
<li>ResultSetHandler：拦截结果集的处理。</li>
</ul>
<p><strong>2).自定义插件实现关键</strong></p>
<p>mybatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interceptor</span> </span>&#123;   <br>   <span class="hljs-function">Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable</span>;       <br>   <span class="hljs-function">Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span></span>;    <br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>setProperties 方法是在 mybatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</li>
<li>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin.wrap(target, this)；</li>
<li>intercept 方法就是要进行拦截的时候要执行的方法。</li>
</ul>
<p><strong>3).自定义插件实现示例</strong></p>
<p>官方插件实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(type = Executor.class, method = &quot;query&quot;,</span><br><span class="hljs-meta">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>     Object target = invocation.getTarget(); <span class="hljs-comment">//被代理对象</span><br>     Method method = invocation.getMethod(); <span class="hljs-comment">//代理方法</span><br>     Object[] args = invocation.getArgs(); <span class="hljs-comment">//方法参数</span><br>     <span class="hljs-comment">// do something ...... 方法拦截前执行代码块</span><br>     Object result = invocation.proceed();<br>     <span class="hljs-comment">// do something .......方法拦截后执行代码块</span><br>     <span class="hljs-keyword">return</span> result;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="十四、RabbitMQ">十四、RabbitMQ</h3>
<h4 id="135-rabbitmq-的使用场景有哪些？">135.rabbitmq 的使用场景有哪些？</h4>
<ul>
<li>抢购活动，削峰填谷，防止系统崩塌。</li>
<li>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。</li>
<li>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</li>
</ul>
<h4 id="136-rabbitmq-有哪些重要的角色？">136.rabbitmq 有哪些重要的角色？</h4>
<p>rabbitmq 中重要的角色有：生产者、消费者和代理：</p>
<ul>
<li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li>
<li>消费者：消息的接收方，用于处理数据和确认消息；</li>
<li>代理：就是 rabbitmq 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li>
</ul>
<h4 id="137-rabbitmq-有哪些重要的组件？">137.rabbitmq 有哪些重要的组件？</h4>
<ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li>
<li>Channel（信道）：消息推送使用的通道。</li>
<li>Exchange（交换器）：用于接受、分配消息。</li>
<li>Queue（队列）：用于存储生产者的消息。</li>
<li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li>
</ul>
<h4 id="138-rabbitmq-中-vhost-的作用是什么？">138.rabbitmq 中 vhost 的作用是什么？</h4>
<p>vhost：每个 rabbitmq 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的rabbitmq，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p>
<h4 id="139-rabbitmq-的消息是怎么发送的？">139.rabbitmq 的消息是怎么发送的？</h4>
<p>首先客户端必须连接到 rabbitmq 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 rabbitmq 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p>
<h4 id="140-rabbitmq-怎么保证消息的稳定性？">140.rabbitmq 怎么保证消息的稳定性？</h4>
<ul>
<li>提供了事务的功能。</li>
<li>通过将 channel 设置为 confirm（确认）模式。</li>
</ul>
<h4 id="141-rabbitmq-怎么避免消息丢失？">141.rabbitmq 怎么避免消息丢失？</h4>
<ul>
<li>把消息持久化磁盘，保证服务器重启消息不丢失。</li>
<li>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</li>
</ul>
<h4 id="142-要保证消息持久化成功的条件有哪些？">142.要保证消息持久化成功的条件有哪些？</h4>
<ul>
<li>声明队列必须设置持久化 durable 设置为 true.</li>
<li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li>
<li>消息已经到达持久化交换器。</li>
<li>消息已经到达持久化队列。</li>
</ul>
<p>以上四个条件都满足才能保证消息持久化成功。</p>
<h4 id="143-rabbitmq-持久化有什么缺点？">143.rabbitmq 持久化有什么缺点？</h4>
<p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p>
<h4 id="144-rabbitmq-有几种广播类型？">144.rabbitmq 有几种广播类型？</h4>
<ul>
<li>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</li>
<li>headers：与 direct 类似，只是性能很差，此类型几乎用不到。</li>
<li>fanout：分发模式，把消费分发给所有订阅者。</li>
<li>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</li>
</ul>
<h4 id="145-rabbitmq-怎么实现延迟消息队列？">145.rabbitmq 怎么实现延迟消息队列？</h4>
<p>延迟队列的实现有两种方式：</p>
<ul>
<li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li>
<li>使用 rabbitmq-delayed-message-exchange 插件实现延迟功能。</li>
</ul>
<h4 id="146-rabbitmq-集群有什么用？">146.rabbitmq 集群有什么用？</h4>
<p>集群主要有以下两个用途：</p>
<ul>
<li>高可用：某个服务器出现问题，整个 rabbitmq 还可以继续使用；</li>
<li>高容量：集群可以承载更多的消息量。</li>
</ul>
<h4 id="147-rabbitmq-节点的类型有哪些？">147.rabbitmq 节点的类型有哪些？</h4>
<ul>
<li>磁盘节点：消息会存储到磁盘。</li>
<li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li>
</ul>
<h4 id="148-rabbitmq-集群搭建需要注意哪些问题？">148.rabbitmq 集群搭建需要注意哪些问题？</h4>
<ul>
<li>各节点之间使用“–link”连接，此属性不能忽略。</li>
<li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li>
<li>整个集群中必须包含一个磁盘节点。</li>
</ul>
<h4 id="149-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？">149.rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</h4>
<p>不是，原因有以下两个：</p>
<ul>
<li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li>
<li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li>
</ul>
<h4 id="150-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？">150.rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h4>
<p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p>
<ul>
<li>不能创建队列</li>
<li>不能创建交换器</li>
<li>不能创建绑定</li>
<li>不能添加用户</li>
<li>不能更改权限</li>
<li>不能添加和删除集群节点</li>
</ul>
<p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p>
<h4 id="151-rabbitmq-对集群节点停止顺序有要求吗？">151.rabbitmq 对集群节点停止顺序有要求吗？</h4>
<p>rabbitmq 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/dajiangdahe.github.io/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-JavaInterview-02"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/dajiangdahe.github.io/2021/10/22/JavaInterview-02/"
    >JavaInterview-02</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/dajiangdahe.github.io/2021/10/22/JavaInterview-02/" class="article-date">
  <time datetime="2021-10-22T07:21:44.845Z" itemprop="datePublished">2021-10-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/dajiangdahe.github.io/categories/JavaInterview/">JavaInterview</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="四、反射">四、反射</h3>
<h4 id="57-什么是反射？">57.什么是反射？</h4>
<p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p>
<h4 id="58-什么是-java-序列化？什么情况下需要序列化？">58.什么是 java 序列化？什么情况下需要序列化？</h4>
<p>java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</p>
<p>以下情况需要使用 java 序列化：</p>
<ul>
<li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>
<li>想用套接字在网络上传送对象的时候；</li>
<li>想通过RMI（远程方法调用）传输对象的时候。</li>
</ul>
<h4 id="59-动态代理是什么？有哪些应用？">59.动态代理是什么？有哪些应用？</h4>
<p>在运行时提供了一系列的API来访问系统里面的对象和类的信息。</p>
<p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，java注解对象获取等。</p>
<p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合，入口是Proxy。</p>
<h4 id="60-怎么实现动态代理？">60.怎么实现动态代理？</h4>
<p>jdk 原生动态代理和 cglib 动态代理。jdk 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代理类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span></span>&#123;<br>    <span class="hljs-comment">//解决问题1：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxyInstance</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>        <span class="hljs-comment">//obj:被代理类</span><br>        <span class="hljs-comment">//解决问题2：当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法</span><br>        MyInvocationHandler handler = <span class="hljs-keyword">new</span> MyInvocationHandler();<br>        handler.bind(obj);<br><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),handler);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Object object;<span class="hljs-comment">//需要使用被代理类的对象进行赋值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(Object object)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.object = object;<br>    &#125;<br>    <span class="hljs-comment">//当我们通过代理类的对象时，调用方法a，就会跑到下面来调用invoke()。</span><br>    <span class="hljs-comment">//将被代理类要执行的方法a声明带invoke中</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">//代理类对象调用的方法，也是被代理类即将调用的方法。</span><br>        <span class="hljs-comment">//object:被代理类对象</span><br>        Object returnValue = method.invoke(object, args);<br>        <span class="hljs-comment">//上述方法的返回值就是作为当前类中的invoke（）值</span><br>        <span class="hljs-keyword">return</span> returnValue;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="五、对象拷贝">五、对象拷贝</h3>
<h4 id="61-为什么要使用克隆？">61.为什么要使用克隆？</h4>
<p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p>
<h4 id="62-如何实现对象克隆？">62.如何实现对象克隆？</h4>
<ul>
<li>实现 Cloneable 接口并重写 Object 类中的 clone()方法。</li>
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li>
</ul>
<h4 id="63-深拷贝和浅拷贝区别是什么？">63.深拷贝和浅拷贝区别是什么？</h4>
<ul>
<li>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</li>
<li>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</li>
</ul>
<h3 id="六、Java-Web">六、Java Web</h3>
<h4 id="64-jsp-和-servlet-有什么区别？">64.jsp 和 servlet 有什么区别？</h4>
<ol>
<li>Servlet是一种服务器端的Java程序，担当客户端请求与服务器端响应的中间层。Servlet由web服务器端进行加载。</li>
<li>JSP是一种动态页面设计，主要目的是将表示逻辑从Servlet中分离出来。</li>
</ol>
<p>jsp 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 jsp 最主要的不同点在于，servlet 的应用逻辑是在 java 文件中，并且完全从表示层中的 html 里分离开来，而 jsp 的情况是 java 和 html 可以组合成一个扩展名为 jsp 的文件。jsp代码经过web容器的编译就能变成JVM识别的java类。</p>
<ol>
<li>jsp 侧重于视图，servlet 主要用于控制逻辑</li>
<li>JSP中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</li>
</ol>
<h4 id="65-jsp-有哪些内置对象？作用分别是什么？">65.jsp 有哪些内置对象？作用分别是什么？</h4>
<p>jsp 有 9 大内置对象：</p>
<ul>
<li>HttpServletRequet类的Request对象：代表请求对象，主要用于接受客户端通过HTTP协议连接传输服务器端的数据；</li>
<li>HttpSevletResponse类的Response对象：代表响应对象，主要用于向客户端发送数据；</li>
<li>PageContext类的PageContext对象：管理网页属性，为jsp页面包装页面的上下文，管理对属于jsp的特殊可见部分中已经命名对象的访问，它的创建和初始化都是由容器来完成的；</li>
<li>HttpSession类的session对象：主要用来分别保存每个月的信息与请求关联的会话；会话状态的维持是web应用开发者必须面对的问题；</li>
<li>ServletContext类的application对象：主要用于保存用户信息，代码片段的运行环境；它是一个共享的内置对象，即一个容器中的多个用户共享一个application；</li>
<li>JspWriter类的out对象：主要用于向客户端输出数据，out的基类是jspWriter；</li>
<li>ServletConfig类的Config对象：代码片段配置对象，标识Servlet的配置；</li>
<li>Object类的Page对象：处理jsp页面，是object类的一个实例，指的是jsp实现类的实例；</li>
<li>Exception：处理jsp文件执行时发生的错误和异常，只有在错误页面里才使用，前提是在页面指令里要有isErrorPage=true。。</li>
</ul>
<h4 id="66-说一下-jsp-的-4-种作用域？">66.说一下 jsp 的 4 种作用域？</h4>
<ul>
<li>page：代表与一个页面相关的对象和属性。</li>
<li>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 web 组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</li>
<li>application：代表与整个 web 应用程序相关的对象和属性，它实质上是跨越整个 web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h4 id="67-session-和-cookie-有什么区别？">67.session 和 cookie 有什么区别？</h4>
<ul>
<li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</li>
<li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li>
<li>容量和个数限制：cookie 有容量限制&lt;=4KB，一个站点下的 cookie 最多存20个cookie。</li>
<li>存储的多样性：session 可以存储在 redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</li>
<li>有效期不同：开发可以通过设置cookie的属性，达到使cookie长期有效的效果。session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</li>
<li>跨域支持上不同：cookie支持跨域访问，session不支持跨域访问。</li>
</ul>
<h4 id="68-说一下-session-的工作原理？">68.说一下 session 的工作原理？</h4>
<p><img src="https://img-blog.csdnimg.cn/20200422094415521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2MTg0MDc1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>执行流程：</p>
<ol>
<li>第一次请求，请求头中没有jsessionid的cookie，当访问到对应的servlet资源时，执行到getSession()会创建HttpSession对象；进而响应时就将session的id作为cookie的value，响应到浏览器 Set-cookie:jsessionid=xxxx;</li>
<li>再一次请求时，http请求中就有一个cookie:jsessionid=xxxx信息，那么该servlet就可以通过getSession()获取到jsessionid在服务器内查找对应的session对象，有就使用，无就创建。</li>
</ol>
<p>生命周期：</p>
<p>​	一般都是默认30min，取决于tomcat中的web.xml文件里的设置</p>
<p>​	结束时机：</p>
<ul>
<li>浏览器关闭：销毁cookie中的jsessionid=xxx</li>
<li>session销毁：主动调用session.invalidate()方法后，立即将session对象销毁。</li>
</ul>
<h4 id="69-如果客户端禁止-cookie-能实现-session-还能用吗？">69.如果客户端禁止 cookie 能实现 session 还能用吗？</h4>
<p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p>
<h4 id="70-spring-mvc-和-struts-的区别是什么？">70.spring mvc 和 struts 的区别是什么？</h4>
<ul>
<li>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。</li>
<li>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</li>
<li>拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。</li>
<li>对 ajax 的支持：spring mvc 集成了ajax，所以 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</li>
</ul>
<h4 id="71-如何避免-sql-注入？">71.如何避免 sql 注入？</h4>
<ul>
<li>使用预处理 PreparedStatement。</li>
<li>使用正则表达式过滤掉字符中的特殊字符。</li>
</ul>
<h4 id="72-什么是-XSS-攻击，如何避免？">72.什么是 XSS 攻击，如何避免？</h4>
<p>XSS 攻击：即跨站脚本攻击，它是 web 程序中常见的漏洞。原理是攻击者往 web 页面里插入恶意的脚本代码（css 代码、javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p>
<p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p>
<h4 id="73-什么是-CSRF-攻击，如何避免？">73.什么是 CSRF 攻击，如何避免？</h4>
<p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p>
<p>防御手段：</p>
<ul>
<li>验证请求来源地址；</li>
<li>关键操作添加验证码；</li>
<li>在请求地址添加 token 并验证。</li>
</ul>
<h3 id="七、异常">七、异常</h3>
<h4 id="74-throw-和-throws-的区别？">74.throw 和 throws 的区别？</h4>
<ul>
<li>throw：是真实抛出一个异常。</li>
<li>throws：是声明可能会抛出一个异常。</li>
</ul>
<h4 id="75-final、finally、finalize-有什么区别？">75.final、finally、finalize 有什么区别？</h4>
<ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li>
<li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>
</ul>
<h4 id="76-try-catch-finally-中哪个部分可以省略？">76.try-catch-finally 中哪个部分可以省略？</h4>
<p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>
<h4 id="77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？">77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h4>
<p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>
<h4 id="78-常见的异常类有哪些？">78.常见的异常类有哪些？</h4>
<ul>
<li>NullPointerException 空指针异常</li>
<li>ClassNotFoundException 指定类不存在</li>
<li>NumberFormatException 字符串转换为数字异常</li>
<li>IndexOutOfBoundsException 数组下标越界异常</li>
<li>ClassCastException 数据类型转换异常</li>
<li>FileNotFoundException 文件未找到异常</li>
<li>NoSuchMethodException 方法不存在异常</li>
<li>IOException IO 异常</li>
<li>SocketException Socket 异常</li>
</ul>
<h3 id="八、网络">八、网络</h3>
<h4 id="79-http-响应码-301-和-302-代表的是什么？有什么区别？">79.http 响应码 301 和 302 代表的是什么？有什么区别？</h4>
<p>301：永久重定向。</p>
<p>302：暂时重定向。</p>
<p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p>
<h4 id="80-forward-和-redirect-的区别？">80.forward 和 redirect 的区别？</h4>
<p>forward 是转发 和 redirect 是重定向：</p>
<ul>
<li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li>
<li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li>
<li>效率：forward 比 redirect 效率高。</li>
</ul>
<h4 id="81-简述-tcp-和-udp的区别？">81.简述 tcp 和 udp的区别？</h4>
<p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>两者的区别大致如下：</p>
<ul>
<li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li>
<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>
<li>tcp 面向字节流，udp 面向报文；</li>
<li>tcp 数据传输慢，udp 数据传输快；</li>
</ul>
<ol>
<li>
<p><strong>TCP详解</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36629696/article/details/80740678">https://blog.csdn.net/sinat_36629696/article/details/80740678</a></p>
<p><img src="https://img-blog.csdn.net/20180620002403691?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Alt text"></p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">URG:</span> 标识紧急指针是否有效<br><span class="hljs-symbol">ACK:</span> 标识确认序号是否有效<br><span class="hljs-symbol">PSH:</span> 用来提示接收端应用程序立刻将数据从tcp缓冲区读走<br><span class="hljs-symbol">RST:</span> 要求重新建立连接. 我们把含有RST标识的报文称为复位报文段<br><span class="hljs-symbol">SYN:</span> 请求建立连接. 我们把含有SYN标识的报文称为同步报文段<br><span class="hljs-symbol">FIN:</span> 通知对端, 本端即将关闭. 我们把含有FIN标识的报文称为结束报文段<br></code></pre></td></tr></table></figure>
<p><img src="C:%5CUsers%5C13126%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210517141753451.png" alt="image-20210517141753451"><strong>三次握手过程原理</strong>：</p>
<ul>
<li>TCP服务器进程先创建传输控制块TCB, 时刻准备接受客户端进程的连接请求, 此时服务器就进入了 LISTEN（监听）状态</li>
<li>TCP客户端进程也是先创建传输控制块TCB, 然后向服务器发出连接请求报文，此时报文首部中的同步标志位SYN=1, 同时选择一个初始序列号 seq = x, 此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定, SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li>TCP服务器收到请求报文后, 如果同意连接, 则发出确认报文。确认报文中的 ACK=1, SYN=1, 确认序号是 x+1, 同时也要为自己初始化一个序列号 seq = y, 此时, TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据, 但是同样要消耗一个序号。</li>
<li>TCP客户端进程收到确认后还, 要向服务器给出确认。确认报文的ACK=1，确认序号是 y+1，自己的序列号是 x+1</li>
<li>此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ul>
<p><img src="C:%5CUsers%5C13126%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210517143200048.png" alt="image-20210517143200048"></p>
<p><strong>四次挥手过程原理</strong>：</p>
<p>数据传输完毕后，双方都可以释放连接.<br>
此时客户端和服务器都是处于ESTABLISHED状态，然后客户端主动断开连接，服务器被动断开连接.</p>
<ul>
<li>客户端进程发出连接释放报文，并且停止发送数据。<br>
释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li>服务器收到连接释放报文，发出确认报文，ACK=1，确认序号为 u+1，并且带上自己的序列号seq=v，此时服务端就进入了CLOSE-WAIT（关闭等待）状态。<br>
TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>
<li>客户端收到服务器的确认请求后，此时客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最终数据）</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，确认序号为v+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，确认序号为w+1，而自己的序列号是u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ul>
</li>
<li>
<p><strong>tcp在四次挥手时，为什么还要等待2*MSL秒呢？</strong></p>
<ol>
<li>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</li>
<li>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li>
<li>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li>
</ol>
</li>
<li>
<p><strong>tcp关闭连接为什么会比建立连接多一次呢？</strong></p>
<ol>
<li>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</li>
</ol>
</li>
<li>
<p><strong>如果已经建立了连接，但是客户端又发生了故障怎么办？</strong></p>
<ol>
<li>TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</li>
</ol>
</li>
<li>
<p><strong>拥塞控制</strong></p>
<ol>
<li>TCP引入慢启动机制，先发少量的数据探探路，摸清当前的网络拥堵情况以后，在按照多大的速度传输数据。</li>
<li>拥塞窗口：每接收到一次ACK应答，拥塞窗口大小+1</li>
<li>慢启动阈值：当拥塞窗口达到阈值的时候，改为线性增加的方式。当TCP启动的时候，慢启动阈值等于窗口最大值。在每次超时重发的时候，慢启动阈值会变为原来的一半，同时拥塞窗口置为1</li>
</ol>
</li>
</ol>
<h4 id="82-tcp-为什么要三次握手，两次不行吗？为什么？">82.tcp 为什么要三次握手，两次不行吗？为什么？</h4>
<p>​      主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的费。<br>
​     如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h4 id="83-tcp粘包产生的原因？">83.tcp粘包产生的原因？</h4>
<p>粘包：指的是应用层的数据包，指的是站在应用层的角度，看到了发来的一连串的字节数据，就不知道从哪个部分开始，到哪个部分结束是一个完整的应用数据包。此时数据没有了边界，就产生了粘包问题。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">对于定长的包<br><span class="hljs-bullet">- </span>保证每次都按固定大小读取即可<br>例如上面的Request结构, 是固定大小的, 那么就从缓冲区从头开始按sizeof(Request)依次读取即可<br><br>对于变长的包<br><span class="hljs-bullet">- </span>可以在数据包的头部, 约定一个数据包总长度的字段, 从而就知道了包的结束位置<br>还可以在包和包之间使用明确的分隔符来作为边界(应用层协议, 是程序员自己来定的, 只要保证分隔符不和正文冲突即可)<br></code></pre></td></tr></table></figure>
<p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p>
<ul>
<li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li>
<li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li>
</ul>
<h4 id="84-OSI-的七层模型都有哪些？">84.OSI 的七层模型都有哪些？</h4>
<ul>
<li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li>
<li>数据链路层：负责建立和管理节点间的链路。</li>
<li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li>
<li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li>
<li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li>
<li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li>
<li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li>
</ul>
<h4 id="85-get-和-post-请求有哪些区别？">85.get 和 post 请求有哪些区别？</h4>
<ul>
<li>在浏览器进行回退操作时,get请求是无害的,而post请求则会重新请求一次</li>
<li>get请求参数是连接在url后面的,而post请求参数是存放在requestbody内的</li>
<li>get请求因为浏览器对url长度有限制(不同浏览器长度限制不一样)对传参数量有限制,而post请求因为参数存放在requestbody内所以参数数量没有限制(事实上get请求也能在requestbody内携带参数,只不过不符合规定,有的浏览器能够获取到数据,而有的不能)</li>
<li>因为get请求参数暴露在url上,所以安全方面post比get更加安全</li>
<li>get请求浏览器会主动cache,post并不会,除非主动设置</li>
<li>get请求参数会保存在浏览器历史记录内,post请求并不会</li>
<li>get请求只能进行url编码,而post请求可以支持多种编码方式</li>
<li>get请求产生1个tcp数据包,post请求产生2个tcp数据包</li>
<li>==浏览器在发送get请求时会将header和data一起发送给服务器,服务器返回200状态码,而在发送post请求时,会先将header发送给服务器,服务器返回100,之后再将data发送给服务器,服务器返回200 OK==</li>
</ul>
<h4 id="86-如何实现跨域？">86.如何实现跨域？</h4>
<p>跨域：当浏览器执行脚本时会检查是否同源，只有同源的脚本才会执行，如果不同源即为跨域。</p>
<ul>
<li>
<p>这里的同源指访问的协议、域名、端口都相同。</p>
</li>
<li>
<p>同源策略是由 Netscape 提出的著名安全策略，是浏览器最核心、基本的安全功能，它限制了一个源中加载脚本与来自其他源中资源的交互方式。</p>
</li>
<li>
<p>Ajax 发起的跨域 HTTP 请求，结果被浏览器拦截，同时 Ajax 请求不能携带与本网站不同源的 Cookie。</p>
</li>
<li>
<script> <img> <iframe> <link> <video> <audio> 等带有 src 属性的标签可以从不同的域加载和执行资源
<script> <img> <iframe> <link> <video> <audio> 等带有 src 属性的标签可以从不同的域加载和执行资
</li>
</ul>
<p>实现跨域有以下几种方案：</p>
<ul>
<li>服务器端运行跨域 设置 CORS（Cross-Origin Resource Sharing）跨域资源共享 等于 *；
<ul>
<li>当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头 origin；</li>
<li>后端在接受到请求后确定响应后会在后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin；</li>
<li>浏览器判断响应中的 Access-Control-Allow-Origin 值是否和当前的地址相同，匹配成功后才继续响应处理，否则报错</li>
</ul>
</li>
<li>在单个接口使用注解 @CrossOrigin 运行跨域；</li>
<li>使用 jsonp 跨域；利用了scripts不受同源策略的限制</li>
</ul>
<h4 id="87-说一下-JSONP-实现原理？">87.说一下 JSONP 实现原理？</h4>
<p>jsonp：JSON with Padding，它是利用<script>标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p>
<h4 id="88-HTTP响应类型有哪几种？">88.HTTP响应类型有哪几种？</h4>
<ol>
<li>消息响应：100（继续）、101（切换协议）</li>
<li>成功响应：200（成功）</li>
<li>重定向：301（永久移动）表示所请求的URI资源路径已经改变,新的URL会在响应的<code>Location</code>:头字段里找到.）、302（临时移动）==http0.9==、307（临时重定向）、308（永久重定向） ==http1.1==，区别 307、308必须是两次相同请求访问。</li>
<li>客户端错误：400（错误请求）、401（未授权）、403（禁止访问）、404（请求资源找不到）、405（不允许使用此方法）、408（请求超时）</li>
<li>服务器端错误：500（内部服务器错误）、501（服务器不支持使用的方法，如put、delete）、502（网关错误）、503（服务不可用）</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/dajiangdahe.github.io/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-JavaInterview-01"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/dajiangdahe.github.io/2021/10/22/JavaInterview-01/"
    >JavaInterview-01</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/dajiangdahe.github.io/2021/10/22/JavaInterview-01/" class="article-date">
  <time datetime="2021-10-22T07:21:44.832Z" itemprop="datePublished">2021-10-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/dajiangdahe.github.io/categories/JavaInterview/">JavaInterview</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="初心">初心</h2>
<p>在本篇文章开始之前，我想先来回答一个问题：我为什么要写这样一篇关于面试的文章？原因有三个：第一，我想为每一个为梦想时刻准备着的“有心人”，尽一份自己的力量，提供一份高度精华的 java 面试清单；第二，目前市面上的面试题不是答案不准确就是内容覆盖面太窄，所以提供一份经典而又准确的面试题是非常有必要的；第三，本文会对部分面试题提供详细解读和代码案例，让读者知其然并知其所以然，从而学到更多的知识。</p>
<p>或许这份面试题还不足以囊括所有 java 问题，但有了它，我相信你一定不会“败”的很惨，因为有了它，足以应对目前市面上绝大部分的 java 面试了，因为这篇文章不论是从深度还是广度上来讲，都已经囊括了非常多的知识点了。</p>
<p>凡事预则立，不预则废。能读到这里的人，我相信都是这个世界上的“有心人”，还是那句老话：上天不负有心人！我相信你的每一步努力，都会收获意想不到的回报。</p>
<h2 id="适宜阅读人群">适宜阅读人群</h2>
<ul>
<li>准备跳槽的初/中/高级 Java 程序员</li>
<li>想要查漏补缺的人</li>
<li>想要不断完善和扩充自己 Java 技术栈的人</li>
<li>Java 面试官</li>
</ul>
<h2 id="阅读建议">阅读建议</h2>
<p>本文会按技能模块划分文章段落，每个模块里的内容，从易到难依次进行排序，各模块之间不存在互相关联的关系，读者可选择文章顺序阅读或者跳跃式阅读。</p>
<h2 id="正文">正文</h2>
<p>本文分为十九个模块，分别是： <strong>Java 基础、容器、多线程、反射、对象拷贝、Java Web 模块、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、Mybatis、RabbitMQ、Kafka、Zookeeper、MySql、Redis、JVM</strong> ，如下图所示：</p>
<p><img src="http://icdn.apigo.cn/gitchat/java-intervier-gitchat-path.png" alt=""></p>
<p>共包含 208 道面试题，本文的宗旨是为读者朋友们整理一份详实而又权威的面试清单，下面一起进入主题吧。</p>
<h3 id="一、Java-基础">一、Java 基础</h3>
<h4 id="1-JDK-和-JRE-有什么区别？">1.JDK 和 JRE 有什么区别？</h4>
<ul>
<li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li>
<li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li>
</ul>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p>
<h4 id="2-和-equals-的区别是什么？">2.== 和 equals 的区别是什么？</h4>
<p><strong>== 解读</strong></p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是引用是否相同；</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String x = <span class="hljs-string">&quot;string&quot;</span>;<br>String y = <span class="hljs-string">&quot;string&quot;</span>;<br>String z = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;string&quot;</span>);<br>System.out.println(x==y); <span class="hljs-comment">// true</span><br>System.out.println(x==z); <span class="hljs-comment">// false</span><br>System.out.println(x.equals(y)); <span class="hljs-comment">// true</span><br>System.out.println(x.equals(z)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p><strong>equals 解读</strong></p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br>Cat c1 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;王磊&quot;</span>);<br>Cat c2 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;王磊&quot;</span>);<br>System.out.println(c1.equals(c2)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;老王&quot;</span>);<br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;老王&quot;</span>);<br>System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>        String anotherString = (String)anObject;<br>        <span class="hljs-keyword">int</span> n = value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>            <span class="hljs-keyword">char</span> v1[] = value;<br>            <span class="hljs-keyword">char</span> v2[] = anotherString.value;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p><strong>总结</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h4 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？">3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h4>
<p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String str1 = <span class="hljs-string">&quot;通话&quot;</span>;<br>String str2 = <span class="hljs-string">&quot;重地&quot;</span>;<br>System.out.println(String.format(<span class="hljs-string">&quot;str1：%d | str2：%d&quot;</span>,  str1.hashCode(),str2.hashCode()));<br>System.out.println(str1.equals(str2));<br></code></pre></td></tr></table></figure>
<p>执行的结果：</p>
<p>str1：1179395 | str2：1179395</p>
<p>false</p>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h4 id="4-final-在-java-中有什么作用？">4.final 在 java 中有什么作用？</h4>
<ul>
<li>final 修饰的类叫最终类，该类不能被继承。</li>
<li>final 修饰的方法不能被重写。</li>
<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li>
</ul>
<h4 id="5-java-中的-Math-round-1-5-等于多少？">5.java 中的 Math.round(-1.5) 等于多少？</h4>
<p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<h4 id="6-String-属于基础的数据类型吗？">6.String 属于基础的数据类型吗？</h4>
<p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p>
<h4 id="7-java-中操作字符串都有哪些类？它们之间有什么区别？">7.java 中操作字符串都有哪些类？它们之间有什么区别？</h4>
<p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<h4 id="8-String-str-i-与-String-str-new-String-“i”-一样吗？">8.String str=&quot;i&quot;与 String str=new String(“i”)一样吗？</h4>
<p>不一样，因为内存的分配方式不一样。String str=&quot;i&quot;的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h4 id="9-如何将字符串反转？">9.如何将字符串反转？</h4>
<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringBuffer reverse</span><br>StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();<br>stringBuffer.append(<span class="hljs-string">&quot;abcdefg&quot;</span>);<br>System.out.println(stringBuffer.reverse()); <span class="hljs-comment">// gfedcba</span><br><span class="hljs-comment">// StringBuilder reverse</span><br>StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>stringBuilder.append(<span class="hljs-string">&quot;abcdefg&quot;</span>);<br>System.out.println(stringBuilder.reverse()); <span class="hljs-comment">// gfedcba</span><br></code></pre></td></tr></table></figure>
<h4 id="10-String-类的常用方法都有那些？">10.String 类的常用方法都有那些？</h4>
<ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h4 id="11-抽象类必须要有抽象方法吗？">11.抽象类必须要有抽象方法吗？</h4>
<p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHi</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hi~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h4 id="12-普通类和抽象类有哪些区别？">12.普通类和抽象类有哪些区别？</h4>
<ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<h4 id="13-抽象类能使用-final-修饰吗？">13.抽象类能使用 final 修饰吗？</h4>
<p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p>
<p><img src="http://icdn.apigo.cn/gitchat/java-intervier002.png" alt="final定义抽象类"></p>
<h4 id="14-接口和抽象类有什么区别？">14.接口和抽象类有什么区别？</h4>
<ul>
<li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有。</li>
<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>
</ul>
<h4 id="15-java-中-IO-流分为几种？">15.java 中 IO 流分为几种？</h4>
<p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h4 id="16-BIO、NIO、AIO-有什么区别？">16.BIO、NIO、AIO 有什么区别？</h4>
<ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：New IO（或 Non Blocking IO）同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<h4 id="17-Files的常用方法都有哪些？">17.Files的常用方法都有哪些？</h4>
<ul>
<li>Files.exists()：检测文件路径是否存在。</li>
<li>Files.createFile()：创建文件。</li>
<li>Files.createDirectory()：创建文件夹。</li>
<li>Files.delete()：删除一个文件或目录。</li>
<li>Files.copy()：复制文件。</li>
<li>Files.move()：移动文件。</li>
<li>Files.size()：查看文件个数。</li>
<li>Files.read()：读取文件。</li>
<li>Files.write()：写入文件。</li>
</ul>
<h3 id="二、容器">二、容器</h3>
<h4 id="18-java-容器都有哪些？">18.java 容器都有哪些？</h4>
<p>java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<ul>
<li>Collection
<ul>
<li>List
<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector
<ul>
<li>Stack</li>
</ul>
</li>
</ul>
</li>
<li>Set
<ul>
<li>HashSet
<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
<li>Map
<ul>
<li>HashMap
<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li>TreeMap</li>
<li>ConcurrentHashMap</li>
<li>Hashtable</li>
</ul>
</li>
</ul>
<h4 id="19-Collection-和-Collections-有什么区别？">19.Collection 和 Collections 有什么区别？</h4>
<ul>
<li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li>
<li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections.sort(list)。</li>
</ul>
<h4 id="20-List、Set、Map-之间的区别是什么？">20.List、Set、Map 之间的区别是什么？</h4>
<p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>
<p>三者之间的区别，如下表：</p>
<p><img src="http://icdn.apigo.cn/gitchat/listmapset.png" alt="list/set/map区别图"></p>
<h4 id="21-HashMap-和-Hashtable-有什么区别？">21.HashMap 和 Hashtable 有什么区别？</h4>
<ul>
<li>存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。</li>
<li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li>
<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>
<li>HashMap 的默认初始容量为 16，Hashtable 为 11。</li>
<li>HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。</li>
<li>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</li>
<li>HashMap 去掉了 Hashtable 中的 contains 方法。</li>
<li>HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。</li>
</ul>
<h4 id="22-如何决定使用-HashMap-还是-TreeMap？">22.如何决定使用 HashMap 还是 TreeMap？</h4>
<p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>
<h4 id="23-说一下-HashMap-的实现原理？">23.说一下 HashMap 的实现原理？</h4>
<p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key.hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<p>==HashMap的链表上数据节点超过8时，就会转换为红黑树。==</p>
<ol>
<li>
<p>补充：</p>
<ol>
<li>头结点是HashMap&lt;K,V&gt; table表上索引位置的节点</li>
<li>红黑树的根节点不一定是索引位置的头结点，HashMap通过moveRootToFont来维护头结点的位置。</li>
<li>转换为红黑树之后，链表的结构还存在，通过next属性来维持，红黑树上的任何操作都会顺带维护链表结构。</li>
<li>在红黑树上，叶子结点也可能是next节点，两种结构互不影响。</li>
<li>源码中，在进行红黑树的查找时，会利用以下两种规则：
<ol>
<li>如果目标节点的 hash 值小于 p 节点的 hash 值，则向 p 节点的左边遍历；否则向 p 节点的右边遍历。</li>
<li>如果目标节点的 key 值小于 p 节点的 key 值，则向 p 节点的左边遍历；否则向 p 节点的右边遍历。（左节点 &lt; 根节点 &lt; 右节点）</li>
</ol>
</li>
</ol>
</li>
<li>
<p>默认容量：16</p>
</li>
<li>
<p>默认负载因子：0.75</p>
</li>
<li>
<p>链表节点转换的红黑树的阈值：8</p>
</li>
<li>
<p>红黑树转链表的阈值：6</p>
</li>
<li>
<p>转红黑树的时候，table的长度阈值：64</p>
</li>
<li>
<p><strong>get方法</strong></p>
<ol>
<li>对table进行校验：table不为空&amp;&amp;table长度大于0&amp;&amp;索引位置的节点不为空</li>
<li>然后检查first节点是目标入参，是返回，不是执行3。</li>
<li>通过next遍历first下的链表
<ol>
<li>如果是红黑树，则调用红黑树的查找目标节点的方法getTreeNode()</li>
<li>不是则遍历链表，找到节点key和入参key相等的值，返回value</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>put方法</strong></p>
<ol>
<li>校验table是否为空&amp;&amp;长度==0，如果是调用resize()进行初始化。
<ol>
<li>通过Hash值计算索引位置，将该索引位置的头结点赋值给P，如果为空，则在此新增节点。</li>
</ol>
</li>
<li>若table不为空，判断p的key的hash值是否一样，如果相等，则将p赋值给e节点</li>
<li>判断p节点是不是TreeNode，如果是调用红黑树的putTreeVal方法查找目标节点</li>
<li>否则，是普通链表节点（使用bincount计数）
<ol>
<li>如果p的next为空，则新增一个节点插入尾部。
<ol>
<li>如果bincount的值超过8个，则调用treeifyBin将链表节点转换为红黑树节点</li>
</ol>
</li>
<li>如果e节点存在hash值和key值都与传入的相同，则e节点即为目标节点。p指向e。</li>
</ol>
</li>
<li>如果e的节点不为空，则代表目标节点存在，使用value覆盖该节点的value，并返回oldValue。</li>
<li>如果插入节点后节点数超过阈值，则调用resize方法进行扩容</li>
</ol>
</li>
<li>
<p><strong>扩容</strong>resize方法</p>
<ol>
<li>
<p>如果old表的容量不为0</p>
<ol>
<li>判断old表的容量是否超过最大容量，如果超过最大阈值设置为Interger.MAX_VALUE，并直接返回old表。此时oldCap*2比Integer.MAX_VALUE大，因此无法进行重新分布，只是单纯的将阈值扩容到最大。</li>
<li>==将newCap赋值为oldCap的2倍，如果newCap&lt;最大容量并且oldCap&gt;=16，则将新阈值设置为原来的两倍==</li>
</ol>
</li>
<li>
<p>如果old表的容量为0，阈值&gt;0，是因为初始容量被放入阈值，则将新表的容量设置为old表的阈值</p>
</li>
<li>
<p>如果old表的容量为0，阈值&gt;=0，这种情况是没有穿初始容量的new方法创建的空表，将阈值和容量设置为默认值。</p>
</li>
<li>
<p>如果新表的阈值为空，则通过新的容量*负载因子获得阈值。</p>
</li>
<li>
<p>将当前阈值设置成新计算出来的新的阈值，定义新表，容量为刚计算出来的新容量，将table设置为新定义的表。</p>
</li>
<li>
<p>扩容后，节点重 hash 为什么只可能分布在 “原索引位置” 与 “原索引 + oldCap 位置“。（针对于普通的链表节点）</p>
</li>
</ol>
</li>
</ol>
<h4 id="24-说一下-HashSet-的实现原理？">24.说一下 HashSet 的实现原理？</h4>
<p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<h4 id="25-ArrayList-和-LinkedList-的区别是什么？">25.ArrayList 和 LinkedList 的区别是什么？</h4>
<ul>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
</ul>
<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<h4 id="26-如何实现数组和-List-之间的转换？">26.如何实现数组和 List 之间的转换？</h4>
<ul>
<li>数组转 List：使用 Arrays.asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// list to array</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;王磊&quot;</span>);<br>list.add(<span class="hljs-string">&quot;的博客&quot;</span>);<br>list.toArray();<br><span class="hljs-comment">// array to list</span><br>String[] array = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;王磊&quot;</span>,<span class="hljs-string">&quot;的博客&quot;</span>&#125;;<br>Arrays.asList(array);<br></code></pre></td></tr></table></figure>
<h4 id="27-ArrayList-和-Vector-的区别是什么？">27.ArrayList 和 Vector 的区别是什么？</h4>
<ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
<h4 id="28-Array-和-ArrayList-有何区别？">28.Array 和 ArrayList 有何区别？</h4>
<ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<h4 id="29-在-Queue-中-poll-和-remove-有什么区别？">29.在 Queue 中 poll()和 remove()有什么区别？</h4>
<ul>
<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>
<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>queue.offer(<span class="hljs-string">&quot;string&quot;</span>); <span class="hljs-comment">// add</span><br>System.out.println(queue.poll());<br>System.out.println(queue.remove());<br>System.out.println(queue.size());<br></code></pre></td></tr></table></figure>
<h4 id="30-哪些集合类是线程安全的？">30.哪些集合类是线程安全的？</h4>
<p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 jdk 1.5 之后随着 java.util.concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>
<h4 id="31-迭代器-Iterator-是什么？">31.迭代器 Iterator 是什么？</h4>
<p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<h4 id="32-Iterator-怎么使用？有什么特点？">32.Iterator 怎么使用？有什么特点？</h4>
<p>Iterator 使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Iterator&lt;String&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>  String obj = it.next();<br>  System.out.println(obj);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h4 id="33-Iterator-和-ListIterator-有什么区别？">33.Iterator 和 ListIterator 有什么区别？</h4>
<ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>
<li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
<h4 id="34-怎么确保一个集合不能被修改？">34.怎么确保一个集合不能被修改？</h4>
<p>可以使用 Collections.unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 java.lang.UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;x&quot;</span>);<br>Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);<br>clist.add(<span class="hljs-string">&quot;y&quot;</span>); <span class="hljs-comment">// 运行时此行报错</span><br>System.out.println(list.size());<br></code></pre></td></tr></table></figure>
<h3 id="三、多线程">三、多线程</h3>
<h4 id="35-并行和并发有什么区别？">35.并行和并发有什么区别？</h4>
<ul>
<li>并行：多个处理器或多核处理器同时处理多个任务。</li>
<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li>
</ul>
<p>如下图：</p>
<p><img src="http://icdn.apigo.cn/gitchat/gitchat208-010.png" alt=""></p>
<p>并发 = 两个队列和一台咖啡机。</p>
<p>并行 = 两个队列和两台咖啡机。</p>
<h4 id="36-线程和进程的区别？">36.线程和进程的区别？</h4>
<p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>
<h4 id="37-守护线程是什么？">37.守护线程是什么？</h4>
<p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 java 中垃圾回收线程就是特殊的守护线程。</p>
<h4 id="38-创建线程有哪几种方式？">38.创建线程有哪几种方式？</h4>
<p>创建线程有四种方式：</p>
<ul>
<li>继承 Thread 重写 run 方法；</li>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口。</li>
<li>使用线程池ThreadPoolExecutor。</li>
</ul>
<h4 id="39-说一下-runnable-和-callable-有什么区别？">39.说一下 runnable 和 callable 有什么区别？</h4>
<p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p>
<p>FutureTask类：</p>
<ol>
<li>
<p>​	一个可取消的异步计算。FutureTask提供了对Future的基本实现。可以调用一个方法去开始或者取消一个计算，并可以查询和返回一个计算结果。</p>
</li>
<li>
<p>FutureTask还实现了Runnable接口，所以FutureTash的实例对象可以交给Thread或者Excutor执行。也可以自己调用futureTash.run()：分为三个状态：</p>
<ol>
<li>
<p>未启动</p>
</li>
<li>
<p>已启动</p>
</li>
<li>
<p>已完成</p>
<p><img src="https://img-blog.csdnimg.cn/20190530214704456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0ODQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li></li>
</ol>
</li>
</ol>
<h4 id="40-线程有哪些状态？">40.线程有哪些状态？</h4>
<p>线程的状态：new Runnable Running  Blocked Dead</p>
<ul>
<li>
<p>NEW 尚未启动</p>
</li>
<li>
<p>RUNNABLE 可运行/就绪状态，等待分配CPU时间片</p>
</li>
<li>
<p>Running  获取CPU时间片，正在运行</p>
</li>
<li>
<p>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</p>
<ul>
<li>线程通过调用sleep方法进入睡眠状态；</li>
<li>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；、</li>
<li>线程试图得到一个锁，而该锁正被其他线程持有；</li>
<li>线程在等待某个触发条件；</li>
</ul>
</li>
<li>
<p>Dead ：线程结束（判断线程是否活着用 isAlive（）方法）</p>
<ul>
<li>run方法正常退出而自然死亡；</li>
<li>一个未捕获的异常终止了run方法而使线程猝死；</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201228162648820.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="41-sleep-和-wait-有什么区别？">41.sleep() 和 wait() 有什么区别？</h4>
<ul>
<li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li>
<li>释放锁：sleep() 不释放锁；wait() 释放锁。</li>
<li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。而且使用wait的线程会进入Wait Set集中。</li>
</ul>
<h4 id="42-notify-和-notifyAll-有什么区别？">42.notify()和 notifyAll()有什么区别？</h4>
<p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。其中等待池就是 JVM 维护的 Wait Set集合</p>
<h4 id="43-线程的-run-和-start-有什么区别？">43.线程的 run()和 start()有什么区别？</h4>
<p>start()方法用于启动线程，run()方法用于执行线程的运行时代码。run() 可以重复调用，而 start()只能调用一次。</p>
<h4 id="44-创建线程池有哪几种方式？">44.创建线程池有哪几种方式？</h4>
<p>线程池创建有七种方式，最核心的是最后一种：</p>
<ul>
<li>new SingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li>
<li>new CachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li>
<li>new FixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li>
<li>new SingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li>
<li>new ScheduledThreadPool(int corePoolSize)：和new SingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li>
<li>new WorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li>
<li>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</li>
</ul>
<h4 id="45-线程池都有哪些状态？">45.线程池都有哪些状态？</h4>
<ul>
<li>
<p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</p>
</li>
<li>
<p>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</p>
</li>
<li>
<p>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</p>
</li>
<li>
<p>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</p>
</li>
<li>
<p>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p>
<p><img src="https://img-blog.csdnimg.cn/20201228162704883.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="46-线程池中-submit-和-execute-方法有什么区别？">46.线程池中 submit()和 execute()方法有什么区别？</h4>
<ul>
<li>
<p>execute()：只能执行 Runnable 类型的任务。</p>
</li>
<li>
<p>submit()：可以执行 Runnable 和 Callable 类型的任务。</p>
</li>
<li>
<p>方法所在的类不同：<br>
<code>execute</code> 方法：<code>java.util.concurrent.Executor</code>;<br>
<code>submit</code>方法：<code>java.util.concurrent.ExecutorService</code></p>
</li>
<li>
<p>所需要的参数不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">execute : java.util.concurrent.Executor#execute(java.lang.Runnable)<br>submit: java.util.concurrent.ExecutorService#submit(java.lang.Runnable, T),<br>               java.util.concurrent.ExecutorService#submit(java.lang.Runnable)<br>               java.util.concurrent.ExecutorService#submit(java.util.concurrent.Callable&lt;T&gt;)<br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p>
<h4 id="47-在-java-程序中怎么保证多线程的运行安全？">47.在 java 程序中怎么保证多线程的运行安全？</h4>
<ul>
<li>方法一：使用安全类，比如 java.util.concurrent 下的类。</li>
<li>方法二：使用自动锁 synchronized。</li>
<li>方法三：使用手动锁 Lock。</li>
</ul>
<p>手动锁 java 示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;获得锁&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>    lock.unlock();<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="48-多线程中-synchronized-锁升级的原理是什么？">48.多线程中 synchronized 锁升级的原理是什么？</h4>
<p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h4 id="49-什么是死锁？">49.什么是死锁？</h4>
<p>当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<ol>
<li><strong>死锁产生的原因</strong>：
<ol>
<li>系统资源的竞争：多个进程使用一个资源造成的僵局，例如打印机。</li>
<li>进程推进顺序的非法：请求和释放资源的顺序问题</li>
<li>死锁产生的必要条件：只要一个条件不满足，就不会产生死锁。
<ol>
<li>互斥条件：同一时间内只允许一个线程使用。</li>
<li>不剥夺条件：线程在获取资源还没使用完毕，不能被其他线程占有，必须由此线程自己释放</li>
<li>请求和保持条件：线程已经保持了至少一个资源，但是又请求了新的资源请求，此时请求资源进程等待，保持的资源不释放</li>
<li>循环等待条件：请求资源的线程构成一个请求资源链{p1,p2…pn}，后一个线程必须依赖于前一个线程。</li>
</ol>
</li>
</ol>
</li>
<li><strong>JVM对锁的维护</strong>：
<ol>
<li>JVM在底层维护了两个“队列”，一个是Entry Set（入口集），一个Wait Set（等待集）</li>
<li>首先每一个对象都有唯一一个内部的monitor（内部锁），Entry Set存储所有的等待获取资源的资源，Wait Set存储执行了objectX.wait（）的线程。</li>
<li>假设ABC三个线程，B线程获取了资源，线程AC进入Entry Set，等待请求资源（此时处于BLOCKED状态），当B释放资源，Entry Set队列里随机一个线程出列与其他获取的线程来争夺线程（处于RUNNABLE），抢占成功就真正离开Entry Set，否则，再回到Entry Set。</li>
<li>如果有个线程执行了objectX.wait（）方法，则进入Wait Set队列，当其他线程执行了objectX.notify()/notifyAll()方法，Wait Set中的线程才会离开队列，共同去抢占资源，如果被唤醒的线程抢夺了资源，则会离开队列，否则，再次回到Wait Set中</li>
</ol>
</li>
</ol>
<h4 id="50-怎么防止死锁？">50.怎么防止死锁？</h4>
<ul>
<li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。 （设置加锁时长）</li>
<li>尽量使用 java.util.concurrent 并发类代替自己手写锁。</li>
<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>
<li>加锁顺序。</li>
<li>死锁检测。并且给线程设置优先级。</li>
</ul>
<h4 id="51-ThreadLocal-是什么？有哪些使用场景？">51.ThreadLocal 是什么？有哪些使用场景？</h4>
<p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>
<h4 id="52-说一下-synchronized-底层实现原理？">52.说一下 synchronized 底层实现原理？</h4>
<p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 java 6 的时候，java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能</p>
<p>==补充1：i++等操作不具备原子性，它分为读取，计算，赋值三个步骤，可能在步骤还没完成就被赋值	了。==</p>
<p>==synchronized 过程：当线程获取锁的时候，monitor+1，如果重复进入，则继续+1，如果失去锁，则monitor=0。通过指令monittorenter和monitorexit来操作。==</p>
<p>==synchronized 锁膨胀：无锁状态、偏向锁、轻量级锁、重量级锁，此过程不可逆。==</p>
<p>==偏向锁：减少同一线程获取锁的代价，大多数情况下，锁不存在多线程竞争，总是由统一线程多次获得。==</p>
<p>==轻量级锁：当存在第二个线程申请同一个锁时，偏向锁就会立即升级为轻量级锁，这里是申请锁，而不是竞争锁，可以一前一后的交替执行代码块。==</p>
<p>==重量级锁：当多个线程同时竞争一个锁时，就会升级成重量级锁，一般追求吞吐量、同步块、或者同步方法较长的场景下。==</p>
<p>==锁消除：jvm扫描上下文，去除不存在竞争的锁==</p>
<p>==锁粗化：jvm扫描上下文，通过扩大枷锁的范围，避免反复加锁和释放锁==</p>
<p>==自旋锁：在共享数据的状态持续过短的情况下，切换线程不值得，就通过让线程执行循环等待锁的释放的方式来进行优化，得到锁就进入临界区，否则就挂起。缺点：如果一直得不到锁，就会带来大量性能开销==</p>
<p>==自适应自旋锁：它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。==</p>
<h4 id="53-synchronized-和-volatile-的区别是什么？">53.synchronized 和 volatile 的区别是什么？</h4>
<ul>
<li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
</ul>
<p>==volatile 定义：volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略（可见性、有序性、原子性）==</p>
<p>==作用：保证了不同线程对这个变量进行修改时，新值对其他线程来说是立马可见的。 只能保证对变量的单次读/写操作的原子性。能够禁止进行指令重排序==</p>
<h4 id="54-synchronized-和-Lock-有什么区别？">54.synchronized 和 Lock 有什么区别？</h4>
<ul>
<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
</ul>
<h4 id="55-synchronized-和-ReentrantLock-区别是什么？">55.synchronized 和 ReentrantLock 区别是什么？</h4>
<p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 java 6 中对 synchronized 进行了非常多的改进。</p>
<p>主要区别如下：</p>
<ul>
<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>
<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>
<li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li>
<li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ul>
<p>==AbstractQueuedSynchronizer(AQS)：是一个构建锁和相关同步器的框架，它依赖于FIFO的等待队列实现。ReentrantLock就是基于AQS构建的。AQS维护了一个FIFO的队列，记录等待的线程，上锁和释放锁就是线程进队or出队的过程；获取不到锁，就进入队列进行等待，被唤醒就出队列。==</p>
<h4 id="56-说一下-atomic-的原理？">56.说一下 atomic 的原理？</h4>
<p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>==Atomic的作用：方面程序员在多线程的环境下，进行无锁编程==</p>
<p>==CAS：比较和替换技术，将预期值与当前变量的值进行比较，如果相等就用新值替换，否则就不操作。注意：CAS的操作中的再面对ABA问题时，不能保证这个值是否被修改过，可以给自己增加一个版本号，每次修改变量时，版本自增，比较的时候比较值与版本号==</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/dajiangdahe.github.io/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-HR面试常见问题与回答策略"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/dajiangdahe.github.io/2021/10/22/HR%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94%E7%AD%96%E7%95%A5/"
    >HR面试</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/dajiangdahe.github.io/2021/10/22/HR%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94%E7%AD%96%E7%95%A5/" class="article-date">
  <time datetime="2021-10-22T07:21:44.795Z" itemprop="datePublished">2021-10-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/dajiangdahe.github.io/categories/JavaInterview/">JavaInterview</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1>1、你怎么看待本公司在行业内的地位。</h1>
<p>​	对公司的认知以及的行业认知。哪里的优势，哪里的缺点。</p>
<h1>2、你现在收到了几个offer了，来本公司的意愿有多大。</h1>
<p>求职意愿，基于个人未来规划。 根据规划面试了那些公司，拿到了哪些offer，但是我最最终目标的是xxx。 1.与求职意愿符合       2.在我的offer中，也是我的最优解。3、城市的选择，</p>
<h1>3、为什么选择杭州/北京，（有考虑定居的打算吗）</h1>
<p>1.有定居的打算。这是我第一份的工作，我可能要进行学校-社会的转换，这一转换和任我认知的发展是需要长时期的。因为先加强自己的技术栈，需要在这个岗位长期学习，我也愿意为了定居去努力，尽自己最大的可能去留下来。       2.让自己留下来的方法：           1.让自己值钱 — 技术           2.工资 — 生存。</p>
<h1>4、个人学习上有什么规划</h1>
<p>表达出成就感的事情，长期坚持的事情，抗压性。解决压力的办法。</p>
<h1>5、对实习有什么看法。</h1>
<h1>6、反问</h1>
<p>1.在面试结束时，赶紧补充这一句：我很看重我这次的交流，希望有更多的交流机会，我可以留您一个联系方式吗？</p>
<h1>7、期望薪资多少。</h1>
<p>​	1.行业平均之上/不能低于去年校招相同岗位工资</p>
<h1>8、你对什么行业/公司最感兴趣？</h1>
<p>智慧企业/城市、 金融科技、车联网</p>
<h1>9、你如果拿到我们的offer，但是最终没有来，你觉得什么原因导致的呢。</h1>
<p>首先，我能拿到offer，我肯定非常开心，我肯定也会去。如果我最终没有来，可能公司觉得我太菜了，收回offer了。</p>
<h1>10、你选择一个公司的标准是什么。</h1>
<p>1.企业文化</p>
<p>2.团队精神</p>
<p>3.是否是进步的积极的</p>
<p>4.付出和回报是否成正比</p>
<h1>11、你对加班怎么看</h1>
<ol>
<li>如果项目出现bug和紧急情况的话，我也会加班去完成这个事情。当然公司要求的每天任务还是要积极完成的，如果没完成，会要求主动加班去完成。       2. 减少无意义的加班，然后让自己有一定的时间去提升自己，形成一种工作-提升的良性循环。       3. 对每天工作进行一种复盘。</li>
</ol>
<h1>12、项目合作中如果你们产生了意见分歧怎么解决？</h1>
<p>1.过往真实故事。虚假的情节会容易被找到漏洞。</p>
<h1>13、你的领导和身边的同事和你相处不来怎么办。</h1>
<p>如果只对我不和的话，可能就是我问题，我回反思一下自己，会很坦陈的与大家进行一种沟通，改掉自己的毛病。     如果是领导问题的话，那是部门人心不齐吗，应该不会，毕竟一个部门有一个统一的目标。那可能也是管理方式不同，可以大家一起探讨一下。毕竟每个人都有优点和缺点，我们不能只看到别人的缺点，也需要看到别人的优点。</p>
<h1>14、自我介绍</h1>
<p>个人 相关信息，应聘什么岗位，面试xx的原因。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/dajiangdahe.github.io/tags/%E6%A0%A1%E6%8B%9B/" rel="tag">校招</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-hexo相关问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/dajiangdahe.github.io/2021/10/22/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"
    >关于hexo自动推送问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/dajiangdahe.github.io/2021/10/22/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2021-10-22T07:21:44.769Z" itemprop="datePublished">2021-10-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/dajiangdahe.github.io/categories/blog/">blog</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1>1.解决每次git时，都需要输入账号密码问题</h1>
<p>只需要在git bash 里执行此git命令，以后N次操作就不需要输入账号密码了。（第一次push的时候需要账号和密码）</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git config --<span class="hljs-keyword">global</span> credential.helper <span class="hljs-keyword">store</span><br></code></pre></td></tr></table></figure>
<h1>2.解决hexo自动推送博客到码云问题（方案一）</h1>
<p>1.在/{your blog}目录下新建一个文件，<a target="_blank" rel="noopener" href="http://xn--ss0ao17a.sh">部署.sh</a></p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure>
<p>2.文件内容如上图所示</p>
<p>​			hexo clean 是清除文件</p>
<p>​		    hexo g 是生成静态文件</p>
<p>​			hexo d 是部署到gitee</p>
<p>3.在码云 gitee pages 页面点击更新即可。（付费版可以自动更新）</p>
<h1>3.解决图片不显示问题</h1>
<p>1.需要安装推送图片插件</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">npm install hexo-asset-<span class="hljs-built_in">image</span> --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure>
<p>2.设置博客目录下_config.yml文件中的 post_asset_folder：选项是否为 true</p>
<p>3.设置Typora</p>
<img src="/dajiangdahe.github.io/2021/10/22/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20210913131129705.png" class="" title="image-20210913131129705">
<p>4.将下面的index.js中的代码替换node_modules\hexo-asset-image中的index.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> log = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;hexo-log&#x27;</span>)(&#123; <span class="hljs-string">&#x27;debug&#x27;</span>: <span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;slient&#x27;</span>: <span class="hljs-literal">false</span> &#125;);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * md文件返回 true</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>data </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ignore</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 好奇怪，试了一下, md返回true, 但却需要忽略 取反!</span><br>    <span class="hljs-keyword">var</span> source = data.source;<br>    <span class="hljs-keyword">var</span> ext = source.substring(source.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>)).toLowerCase();<br>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;md&#x27;</span>,].indexOf(ext) &gt; -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> reverseSource = data.source.split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">var</span> fileName = reverseSource.substring(<span class="hljs-number">3</span>, reverseSource.indexOf(<span class="hljs-string">&quot;/&quot;</span>)).split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">// ![example](postname/example.jpg)  --&gt;  &#123;% asset_img example.jpg example %&#125;</span><br>    <span class="hljs-keyword">var</span> regExp = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;!\\[(.*?)\\]\\(&quot;</span> + fileName + <span class="hljs-string">&#x27;/(.+?)\\)&#x27;</span>, <span class="hljs-string">&quot;g&quot;</span>);<br>    <span class="hljs-comment">// hexo g</span><br>    data.content = data.content.replace(regExp, <span class="hljs-string">&quot;&#123;% asset_img $2 $1 %&#125;&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>);<br><br>    <span class="hljs-comment">// log.info(`hexo-asset-img: filename: $&#123;fileName&#125;, title: $&#123;data.title.trim()&#125;`);</span><br>    <br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br>hexo.extend.filter.register(<span class="hljs-string">&#x27;before_post_render&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(!ignore(data))&#123;<br>        action(data)<br>    &#125;<br>&#125;, <span class="hljs-number">0</span>);<br><br></code></pre></td></tr></table></figure>
<p>5.测试</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/dajiangdahe.github.io/tags/blog/" rel="tag">blog</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-HashMap为什么默认扩容因子是0.75？"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/dajiangdahe.github.io/2021/10/22/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF0.75%EF%BC%9F/"
    >HashMap为什么默认扩容因子是0.75？</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/dajiangdahe.github.io/2021/10/22/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF0.75%EF%BC%9F/" class="article-date">
  <time datetime="2021-10-22T07:21:44.729Z" itemprop="datePublished">2021-10-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/dajiangdahe.github.io/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1>从泊松分布谈起HashMap</h1>
<p><strong>【二项分布】</strong></p>
<p>二项分布就是重复n次独立的伯努利试验。在每次试验中只有两种可能的结果，而且两种结果发生与否互相对立，并且相互独立，与其它各次试验结果无关，事件发生与否的概率p在每一次独立试验中都保持不变，则这一系列试验总称为n重伯努利实验，当试验次数为1时，二项分布服从0-1分布。</p>
<p>两个重点：</p>
<ul>
<li>每次试验独立：第n次试验不受n-1次试验的影响，也不影响n+1次试验；</li>
<li>结果有且只有两个，并且互相对立：要么成功，要么失败，成功的概率+失败的概率=1；</li>
</ul>
<p>至于二项分布图的绘制，也就是做n次试验，期望成功k次的概率分布。根据二项分布函数，你只需要知道试验总次数n、期望成功的次数k，以及每次试验成功的概率p，即可很快的求出成功k次的概率。</p>
<p>【<strong>泊松分布</strong>】</p>
<p>泊松分布： 是离散随机分布的一种，通常被使用在估算在 一段特定时间/空间内发生成功事件的数量的概率。</p>
<img src="/dajiangdahe.github.io/2021/10/22/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF0.75%EF%BC%9F/v2-7adb1965b4f92d6121d77687907583e1_720w.jpg" class="" title="img">
<p>【<strong>HashMap与泊松分布的关系</strong>】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs text">* Ideally, under random hashCodes, the frequency of<br>     * nodes in bins follows a Poisson distribution<br>     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a<br>     * parameter of about 0.5 on average for the default resizing<br>     * threshold of 0.75, although with a large variance because of<br>     * resizing granularity.<br>     *<br>     * 翻译：<br>     *     尽管因为调整粒度而产生较大的方差，但是理想的情况，在随机hashCodes下，桶中节点的频率遵循泊松分布。<br>     *     默认调整阈值为0.75的条件下，泊松分布中的概率参数λ=0.5。<br>     * 解释：<br>     *     k表示数量，这里指桶中节点的个数。<br>     *     λ表示事件的频率。这里λ=0.5，代表理想情况下，平均100个桶，50个数据，则1个桶有数据的概率是0.5。<br>     *     忽略方差，把λ代入。则求一个桶中出现k个节点的概率，公式为：<br>     <br>     <br>    private static String poisson(int k) &#123;<br>        //泊松分布 Java<br>        double value = Math.exp(-0.5) * Math.pow(0.5, k) / IntMath.factorial(k);<br>        //格式化参数，保留10位小数。<br>        return new BigDecimal(value+&quot;&quot;).setScale(10, ROUND_HALF_UP).toPlainString();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>【<strong>每个桶中出现1个节点的概率</strong>】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs text">public static void main(String[] args) &#123;<br>        System.out.println(&quot;1个桶中出现1个节点的概率:&quot; + poisson(1));<br>        System.out.println(&quot;1个桶中出现2个节点的概率:&quot; +poisson(2));<br>        System.out.println(&quot;1个桶中出现3个节点的概率:&quot; +poisson(3));<br>        System.out.println(&quot;1个桶中出现4个节点的概率:&quot; +poisson(4));<br>        System.out.println(&quot;1个桶中出现5个节点的概率:&quot; +poisson(5));<br>        System.out.println(&quot;1个桶中出现6个节点的概率:&quot; +poisson(6));<br>        System.out.println(&quot;1个桶中出现7个节点的概率:&quot; +poisson(7));<br>        System.out.println(&quot;1个桶中出现8个节点的概率:&quot; +poisson(8));//亿分之六<br>        System.out.println(&quot;1个桶中出现9个节点的概率:&quot; +poisson(9));<br>    &#125;<br><br>Console:<br>    1个桶中出现1个节点的概率:0.3032653299<br>    1个桶中出现2个节点的概率:0.0758163325<br>    1个桶中出现3个节点的概率:0.0126360554<br>    1个桶中出现4个节点的概率:0.0015795069<br>    1个桶中出现5个节点的概率:0.0001579507<br>    1个桶中出现6个节点的概率:0.0000131626<br>    1个桶中出现7个节点的概率:0.0000009402<br>    1个桶中出现8个节点的概率:0.0000000588//亿分之六<br>    1个桶中出现9个节点的概率:0.0000000033<br></code></pre></td></tr></table></figure>
<p>这一段乃至HashMap开头的一大段注释都没有解释load factory默认值是0.75的原因，而是说load factor的值会影响泊松分布PMF函数公式中的参数λ的值，例如load factor=0.75f时λ=0.5。按照泊松分布公式来看，期望放入bin中数据的数量k=8，e是一个无理常数，λ的值受load factor的值的影响（泊松分布是用来估算在 一段特定时间或空间内发生成功事件的数量的概率，即在长度为length的数组中hash地放入0.75*length数量的数据，数组中某一个下标放入k个数据的概率）。</p>
<img src="/dajiangdahe.github.io/2021/10/22/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF0.75%EF%BC%9F/20181013121844583" class="" title="img">
<p>java8及以上版本的HashMap中这段注释的解释：</p>
<ul>
<li>这一段注释的内容和目的都是为了解释在java8 HashMap中引入Tree Bin（也就是放入数据的每个数组bin从链表node转换为red-black tree node）的原因</li>
<li>原注释如上图划线部分：Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD).</li>
<li><strong>TreeNode</strong>虽然改善了链表增删改查的性能，<strong>但是其节点大小是链表节点的两倍</strong></li>
<li>虽然引入TreeNode但是不会轻易转变为TreeNode（如果存在大量转换那么资源代价比较大），<strong>根据泊松分布来看转变是小概率事件，性价比是值得的</strong></li>
<li>泊松分布是二项分布的极限形式，两个重点：<strong>事件独立</strong>、<strong>有且只有两个相互对立的结果</strong></li>
<li>泊松分布是指一段时间或空间中发生成功事件的数量的概率</li>
<li>对HashMap table[]中任意一个bin来说，存入一个数据，要么放入要么不放入，这个动作满足二项分布的两个重点概念</li>
<li>对于HashMap.table[].length的空间来说，放入0.75<em>length个数据，某一个bin中放入节点数量的概率情况如上图注释中给出的数据（表示数组某一个下标存放数据数量为0~8时的概率情况）</em>
<ul>
<li><strong>举个例子说明</strong>，HashMap默认的table[].length=16，在长度为16的HashMap中放入12（0.75*length）个数据，某一个bin中存放了8个节点的概率是0.00000006</li>
<li><strong>扩容一次</strong>，16*2=32，在长度为32的HashMap中放入24个数据，某一个bin中存放了8个节点的概率是0.00000006</li>
<li><strong>再扩容一次</strong>，32*2=64，在长度为64的HashMap中放入48个数据，某一个bin中存放了8个节点的概率是0.00000006</li>
<li><strong>所以，当某一个bin的节点大于等于8个的时候，就可以从链表node转换为treenode，其性价比是值得的。</strong></li>
</ul>
</li>
</ul>
<p><strong>【load factor=0.75f的真正原因】</strong></p>
<p>load factory=0.75的真正原因，在java7、8等中均有注释（这段注释在public class HashMap类定义之前，附注的注释即本文所讨论的注释是在HashMap类定义之后），如下图所示，负载因子太小了浪费空间并且会发生更多次数的resize，太大了哈希冲突增加会导致性能不好，所以0.75只是一个折中的选择，和泊松分布没有什么关系。</p>
<img src="/dajiangdahe.github.io/2021/10/22/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF0.75%EF%BC%9F/20181013121921758" class="" title="img"> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/dajiangdahe.github.io/tags/HashMap/" rel="tag">HashMap</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-EasyExcel插件的使用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/dajiangdahe.github.io/2021/10/22/EasyExcel%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"
    >EasyExcel插件在web下的使用</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/dajiangdahe.github.io/2021/10/22/EasyExcel%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2021-10-22T07:21:44.697Z" itemprop="datePublished">2021-10-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/dajiangdahe.github.io/categories/%E6%8F%92%E4%BB%B6/">插件</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1>1.EasyExcel插件</h1>
<p>EasyExcel是一个基于Java的简单、省内存的读写Excel的开源项目。在尽可能节约内存的情况下支持读写百M的Excel。</p>
<h1>2.EasyExcel web读</h1>
<h2 id="1-依赖">1.依赖</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>           &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;<br>           &lt;version&gt;<span class="hljs-number">2.1</span><span class="hljs-number">.6</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>
<h2 id="2-对应的execl表格">2.对应的execl表格</h2>
<img src="/dajiangdahe.github.io/2021/10/22/EasyExcel%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/image-20211007105045718.png" class="" title="image-20211007105045718">Ian
<h2 id="3-在bean层建立对应的vo类">3.在bean层建立对应的vo类</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraindataVo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer userId;<br><br>    <span class="hljs-keyword">private</span> String type;<br><br>    <span class="hljs-keyword">private</span> Date timeStamp;<br><br>    <span class="hljs-keyword">private</span> Double firstSub;<br><br>    <span class="hljs-keyword">private</span> Double secondSub;<br><br>    <span class="hljs-keyword">private</span> Double thirdSub;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过对应的vo类来匹配对应的excel进行excel的读取.</p>
<h2 id="4-controller层">4.controller层</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/importExcel&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;文件上传&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">importExcel</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> MultipartFile file)</span> </span>&#123;<br>       traindataService.importExcel(file);<br>       <span class="hljs-keyword">return</span> Result.ok();<br>   &#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-service层">5.service层</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导入文件</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">importExcel</span><span class="hljs-params">(MultipartFile file)</span></span>; <br><br><span class="hljs-comment">//插入数据到数据库</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Traindata results)</span></span>;<br></code></pre></td></tr></table></figure>
<h2 id="6-serviceImpl层">6.serviceImpl层</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 导入excel</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> file 文件</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">importExcel</span><span class="hljs-params">(MultipartFile file)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span>==file)&#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       InputStream in = <span class="hljs-keyword">null</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           in = <span class="hljs-keyword">new</span> BufferedInputStream(file.getInputStream());<br>           <span class="hljs-comment">//实例化实现了AnalysisEventListener接口的类</span><br>           <span class="hljs-comment">//打印信息</span><br>           LOGGER.info(in.toString());<br>           EasyExcel.read(in, TraindataVo.class, <span class="hljs-keyword">new</span> ExcelListener(traindataService)).sheet().doRead();<br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> traindata traindata</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Traindata traindata)</span> </span>&#123;<br>        baseMapper.insert(traindata);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-ExcelListener工具类">7.ExcelListener工具类</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> edu.bjut.visualization.utils.listeners;<br><br><span class="hljs-keyword">import</span> com.alibaba.excel.context.AnalysisContext;<br><span class="hljs-keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> edu.bjut.visualization.bean.Traindata;<br><span class="hljs-keyword">import</span> edu.bjut.visualization.bean.vo.TraindataVo;<br><span class="hljs-keyword">import</span> edu.bjut.visualization.service.ITraindataService;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">// 有个很重要的点 ExcelListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnalysisEventListener</span>&lt;<span class="hljs-title">TraindataVo</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//日志使用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ExcelListener.class);<br>    <span class="hljs-comment">//缓存的数据列表</span><br>    <span class="hljs-keyword">private</span> List&lt;TraindataVo&gt; datas = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">//每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BATCH_COUNT = <span class="hljs-number">3000</span>;<br>    <span class="hljs-keyword">private</span> ITraindataService traindataService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExcelListener</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">//如果使用了spring,则需要使用此构造器,每次创建Listener的时候需要把spring管理的类传进来</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExcelListener</span><span class="hljs-params">(ITraindataService traindataService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.traindataService = traindataService;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data    数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 上下文</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(TraindataVo data, AnalysisContext context)</span> </span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));<br>        <span class="hljs-comment">//数据存储到datas，供批量处理，或后续自己业务逻辑处理。</span><br>        datas.add(data);<br>        <span class="hljs-comment">//达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span><br>        <span class="hljs-keyword">if</span>(datas.size() &gt;= BATCH_COUNT)&#123;<br>            saveData();<br>            <span class="hljs-comment">// 存储完成清理datas</span><br>            datas.clear();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveData</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">//如果是大批量的数据,尽量别多次调用insert一次次插入,可以在mapper层写一个批量插入</span><br>        <span class="hljs-keyword">for</span>(TraindataVo results : datas)&#123;<br>            Traindata traindata = <span class="hljs-keyword">new</span> Traindata();<br>            traindata.setUserId(results.getUserId());<br>            traindata.setTimeStamp(<span class="hljs-keyword">new</span> java.sql.Timestamp(results.getTimeStamp().getTime()));<br>            traindata.setFirstSub(results.getFirstSub());<br>            traindata.setSecondSub(results.getSecondSub());<br>            traindata.setType(results.getType());<br>            traindata.setThirdSub(results.getThirdSub());<br>            LOGGER.info(<span class="hljs-string">&quot;traindata数据，开始存储数据库！&quot;</span>,  JSON.toJSONString(traindata));<br>            <span class="hljs-keyword">this</span>.traindataService.insert(traindata);<br>        &#125;<br>        LOGGER.info(<span class="hljs-string">&quot;存储数据库成功！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//所有数据解析完成了 都会来调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfterAllAnalysed</span><span class="hljs-params">(AnalysisContext context)</span> </span>&#123;<br>        <span class="hljs-comment">//这里也要保存数据,确保最后遗留的数据也存储到数据库</span><br>        saveData();<br>        LOGGER.info(<span class="hljs-string">&quot;所有数据解析完成！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>3.总结</h1>
<p>easyexcel是一个比较简单方便使用的插件,对于web读和web写基本上都只需要在监听类做一些配置即可.</p>
<p>官方文档地址https://www.yuque.com/easyexcel/doc/read</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/dajiangdahe.github.io/tags/EasyExcel/" rel="tag">EasyExcel</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/dajiangdahe.github.io/page/3/">上一页</a><a class="page-number" href="/dajiangdahe.github.io/">1</a><a class="page-number" href="/dajiangdahe.github.io/page/2/">2</a><a class="page-number" href="/dajiangdahe.github.io/page/3/">3</a><span class="page-number current">4</span>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> kengkeng
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/dajiangdahe.github.io/"><img src="/images/ayer-side.svg" alt="kengkeng&#39;s life"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/dajiangdahe.github.io/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/dajiangdahe.github.io/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/dajiangdahe.github.io/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/dajiangdahe.github.io/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/dajiangdahe.github.io/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/dajiangdahe.github.io/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/dajiangdahe.github.io/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/dajiangdahe.github.io/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/dajiangdahe.github.io/js/jquery-3.6.0.min.js"></script>
 
<script src="/dajiangdahe.github.io/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dajiangdahe.github.io/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/dajiangdahe.github.io/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/dajiangdahe.github.io/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>