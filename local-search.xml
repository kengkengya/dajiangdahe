<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第三方支付业务流程介绍</title>
    <link href="/dajiangdahe/2022/03/11/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D/"/>
    <url>/dajiangdahe/2022/03/11/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1>1.概述</h1><p>可能你在使用支付宝时，感觉蛮简单的，不外乎就是绑个卡，验一下支付密码，银行卡的资金就被扣掉了；但是背后涉及的技术架构其实蛮复杂的，比如从外部合作来说，就涉及到了银行，银联，网联，商户，用户，公安，电信运营商，安全防控公司，服务器运营商等等；如果从具体业务来说，大致分成入金类业务，出金类业务，清算对账类业务，差错处理类业务；因为支付业务涉及的方方面面很多，所以导致了技术架构蛮复杂的，所以本来试描绘一下支付系统的轮廓，能让人对第三方支付有一个全貌的大致了解。</p><h1>2.支付系统架构</h1><img src="/dajiangdahe/2022/03/11/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D/image-20220311221444793-7008090.png" class="" title="image-20220311221444793"><h2 id="2-1支付系统的整体介绍">2.1支付系统的整体介绍</h2><p>一般来说，支付系统从架构上来说，分为四层;<strong>分成网关层，核心层，产品层和运营支撑层；</strong></p><p><strong>网关层</strong>：网关一般是通过对银行，银联，网联，第三方支付的能力进行包装然后提供原子能力给上层系统调用；比如接入网联的快捷，网关，代付，清算对账，差错处理能力后，提供给其上层系统调用；另外网关一般还会维护路由系统(简单来说，路由就是帮一笔交易通过一定规则比较后，选择合适的道路到渠道侧)。</p><p>**核心层：**支付系统的核心模块，一般包括会员系统，风控系统，交易系统，收费系统，订单系统，清算系统，账务系统，签约系统，数据系统等；</p><p><strong>产品层：</strong> 通过对核心层提供的服务组合起来，大体来分，可以组合成入金类产品，比如组合成充值产品，转账产品等，还有出金类产品，比如提现产品，结算产品；然后通过接口，收银台，钱包，官网，内部运营后台等具体产品系统来提供服务；</p><p><strong>运营支撑层：</strong> 用来支持核心系统的服务， 包括运维监控系统、日志分析系统等。</p><p>简单来说，一笔交易进入第三方支付系统，首先会经过产品层，然后经过核心层，最后经过网关到达渠道侧，同时支付机构还可以通过运营支撑层对这笔交易进行监控维护；</p><p>比如用户买一个肾X，需要支付9998元，那么调用支付机构的服务后进入收银台，选择快捷支付，那么这个其实就是首先经过了产品层的收银台，然后产品层收银台的背后核心层也会参与本次交易，比如涉及到了会员系统，对该用户会进行校验，还涉及到风控系统，风控会对这笔交易进行判断，能否放行，还涉及到了签约系统，用户选择的银行卡是否进行了签约，还涉及到了收费系统，该笔交易手续费多少，还涉及到了订单和交易系统，为该交易生成订单，方便以后查询核对；如果交易完成后，还涉及到清算对账系统，该笔交易与渠道侧进行对账，商户侧对账，内部对账等，然后还会结算相应款项给商户；最后还会经过网关层，网关会为该笔交易选择合适的渠道进行资金转移，然后调用合适渠道的能力进行业务处理；同时支付机构可通过运营支撑，对该交易进行监测管理。</p><h2 id="2-2-网关层">2.2 网关层</h2><p>上文已经提到过，网关主要是封装各个渠道的差异，呈现统一的接口，然后提供给上层系统调用。同时路由一般也维护在网关层；这里重点介绍一下路由。</p><p><strong>简单来说，路由就是找合适的路</strong>。支付机构一般会对接很多渠道，比如直连渠道，间连网联，银联，还有其他第三方支付机构等，那么一笔交易来了，到底该走哪条路呢，这就是路由干的事。</p><p>路由一般分成<strong>人工路由，规则路由</strong>；人工路由指运营人员指定支付渠道和产品之间的映射关系，就是人工帮忙找路；规则路由就是按照业务要求设置各种路由规则，系统帮忙找路；</p><p>路由设计时，一般从以下方面进行考虑；费率，单笔费率，总额费率，阶梯费率等；营销策略，比如渠道侧提供优惠，单笔优惠金额，单笔折扣比例，补贴总额度，活动时间等；交易限额，日限，笔限等；渠道类型，代扣，快捷，网银，第三方支付等；银行卡类型，借贷记类型，对公对私等；服务质量，掉单率，网络延迟等；</p><h2 id="2-3-核心层">2.3 <strong>核心层</strong></h2><p><strong>一般包括会员系统，风控系统，交易系统，收费系统，订单系统，清算系统，账务系统，签约系统等；</strong></p><p>**交易系统：**交易系统是一种组合能力，比如一笔交易进来，交易系统可能会调用会员系统，风控系统，充值产品，订单系统，收费系统等等对该笔交易进行处理；</p><p>**会员系统：**包括对用户、商户的实名身份、银行卡、基本信息、协议的管理；</p><p>订单系统：对交易订单的管理，比如单笔顶单，多笔订单支付请求的处理，还有查询订单的处理等；</p><p><strong>收费系统</strong>：支付机构的盈利方式之一，一笔交易通过第三方支付完成，总得给点过路费吧；收费系统一般按照单笔定额，单笔比例，混合收费，包月年封顶收费等进行；</p><p>**签约系统：**如果通过银行卡进行快捷支付，签约是需要进行签约的，那么银行提供的签约能力，解约能力等都由签约系统提供；</p><p><strong>清算，账务系统</strong>指围绕财务会计而产生的后台资金核实、调度和管理的系统，包括会计核算： 提供会计科目、内部账务、试算平衡、日切、流水登记、核算和归档的功能。资金管理： 管理公司在各个支付渠道的头寸，在余额不足时进行打款，对第三方支付公司，还需要对备付金进行管理。清算分润：对于有分润需求的业务，还需要提供清分清算、对账处理功能。</p><p><strong>风控系统</strong>是支付系统必备的基础功能，所有的支付行为必须做风险评估并采取对应的措施；信用系统是在风控基础上发展的高级功能，京东的白条，蚂蚁花呗等，都是成功的案例。风控系统一般进行三种校验，交易放行，交易拦截，交易验证增强；</p><h2 id="2-4-产品层">2.4 产品层</h2><p>通过对核心层提供的服务组合起来，大体来分，可以组合成<strong>入金类产品，比如组合成充值产品，转账产品等，还有出金类产品，比如提现产品，结算产品；然后通过接口，收银台，钱包，官网，内部运营后台等具体产品系统来提供服务；</strong></p><p>入金类产品整体上来说，可以提供如下能力：</p><p><strong>(1) 快捷，代扣支付</strong></p><p>用户在完成绑卡之后，在支付的时候，不需要再输入卡或者身份信息，仅需要输入支付密码就可以完成支付。对于小额度的支付，甚至可以开通小额免密，直接完成支付。 这种支付方式不会打断用户的体验，是目前主要的在线支付方式。</p><p><strong>(2) 网银支付</strong></p><p>用户在支付的时候，需要跳转到银行网银页面来完成支付。在网银页面，需要输入用户的卡号和身份信息。这种支付方式会中断用户当前的体验，一般仅用于PC Web上的支付。 网银支付是封装银行提供的网银支付来实现。</p><p><strong>(3) 第三方支付</strong></p><p>使用微信、支付宝等第三方支付平台来完成支付。使用时，一般需要用户预先安装支付平台系统（手机上），注册并登录到第三方支付平台，并且已经在该平台上完成绑卡等操作。 由于微信、支付宝已经被大量使用，用户也产生对这些平台的信任，该类支付往往是电商公司的主要支付方式。</p><p><strong>(4) 账户支付</strong></p><p>也成为余额支付、零钱支付等。 指为用户建立本地账户， 支持充值，之后可以使用这个账户来完成支付。</p><p><strong>(5) 信用支付</strong></p><p>如京东的白条，蚂蚁花呗等，指使用信用账户进行透支，类似信用卡支付。</p><p>出金类产品整体来说，就是提供转账、结算等能力</p><h2 id="2-5-运营支撑层">2.5 运营支撑层</h2><p>支撑系统是一个公司提供给支付系统运行的基础设施。 主要包括如下子系统：</p><p><strong>运维监控：</strong> 支付系统在下运行过程中不可避免的会受到各种内部和外部的干扰，光纤被挖断、黑客攻击、数据库被误删、上线系统中有bug等等，运维人员必须在第一时间内对这些意外事件作出响应，又不能够一天24小时盯着。这就需要一个运维监控系统来协助完成。</p><p><strong>日志分析：</strong> 日志是支付系统统计分析、运维监控的重要依据。公司需要提供基础设施来支持日志统一收集和分析。</p><p><strong>短信平台：</strong> 短信在支付系统中有重要作用： 身份验证、安全登录、找回密码、以及报警监控，都需要短信的支持。</p><p><strong>安全机制：</strong> 安全是支付的生命线。 SSL、证书系统、防刷接口等，都是支付的必要设施。</p><p><strong>统计报表</strong>： 支付数据的可视化展示，是公司进行决策的基础。</p><p>远程连接管理、分布式计算、消息机制、全文检索、文件传输、数据存储、机器学习等，都是构建大型系统所必须的基础软件，这里不再一一详细介绍。</p><h1>3.  <strong>支付业务商户侧流程</strong></h1><p><strong>一般支付机构会通过接口，收银台，钱包，官网等具象产品为商户提供服务</strong>；那么商户侧使用支付机构的服务一般涉及到以下几方面。</p><ol><li>签约和解约</li></ol><p>在快捷支付、代扣等产品中，用户在使用前，需要先完成签约。商户侧负责收集用户银行卡的信息，然后调用支付机构的接口进行签约，可能支付机构会调用银行和银联的接口进行签约。签约后，后续的支付行为就使用签约号来进行，无需再输入个人信息。 和签约相对应，解约则是取消签约关系。</p><ol start="2"><li>支付</li></ol><p>支付是少不了的操作。支付前，商户需向支付机构下单，然后调用付款接口进行支付，一般提供快捷支付和网银支付能力；</p><ol start="3"><li>撤销和退款</li></ol><p>商户向支付机构下单或付款后，该笔订单由于一些原因，并不想真的执行，那么就可使用支付机构的能力进行撤销或退款；</p><ol start="4"><li>查询签约状态</li></ol><p>对于需要签约的交易，可以通过这个接口来查询签约状态。</p><ol start="5"><li>查询订单状态</li></ol><p>通过这个接口来查询订单状态以及退款的订单状态。</p><p>6 对账</p><p>通过FTP或者HTTP方式提供对账文件供商户侧对账。</p><h1>4. 支付业务中支付机构内部流程</h1><img src="/dajiangdahe/2022/03/11/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D/image-20220311222425835.png" class="" title="image-20220311222425835"><p><strong>一般会包括参数校验，支付路由，生成订单，风险评估，调用渠道服务，更新订单和发送消息这7步，对于一些比较复杂的服务，还会涉及到异步同通知处理的步骤。</strong></p><p><strong>1. 执行参数校验</strong></p><p>所有的支付操作，都需要对输入执行参数校验，避免接口受到攻击。</p><p>验证输入参数中各字段的有效性验证，比如用户ID,商户ID,价格，返回地址等参数。</p><p>验证账户状态。交易主体、交易对手等账户的状态是处于可交易的状态。</p><p>验证订单：如果涉及到预单，还需要验证订单号的有效性，订单状态是未支付。为了避免用户缓存某个URL地址，还需要校验下单时间和支付时间是否超过预定的间隔。</p><p>验证签名。签名也是为了防止支付接口被伪造。 一般签名是使用分发给商户的key来对输入参数拼接成的字符串做MD5 Hash或者RSA加密，然后作为一个参数随其他参数一起提交到服务器端。如支付网关设计所介绍，签名验证也可以在网关中统一完成。</p><p><strong>2. 根据支付路由寻找合适的支付服务</strong></p><p>根据用户选择的支付方式确定用来完成该操作的合适的支付渠道。用户指定的支付方式不一定是最终的执行支付的渠道。比如用户选择通过工行信用卡来执行支付，但是我们没有实现和工行的对接，而是可以通过第三方支付，比如支付宝、微信支付、易宝支付，或者银联来完成。那如何选择合适的支付渠道，就通过支付路由来实现。支付路由会综合考虑收费、渠道的可用性等因素来选择最优方案。</p><p><strong>3. 评估交易风险</strong></p><p>检查本次交易是否有风险。风控接口返回三种结果：阻断交易、增强验证和放行交易。</p><ol><li><p>阻断交易，说明该交易是高风险的，需要终止，不执行第5个步骤；</p></li><li><p>增强验证，说明该交易有一定的风险，需要确认下是不是用户本人在操作。这可以通过发送短信验证码或者其他可以验证用户身份的方式来做校验，验证通过后，可以继续执行该交易。</p></li><li><p>放行交易，即本次交易是安全的，可以继续往下走。</p></li></ol><p><strong>4. 生成交易订单</strong></p><p>将订单信息持久化到数据库中。</p><p><strong>5. 调用支付渠道提供的服务</strong></p><p>所有的支付服务都需要第三方通道来完成执行。一般银行渠道的调用比较简单，可以直接返回结果。一些第三方支付，支付宝，微信支付等，会通过异步接口来告知支付结果。</p><p><strong>6. 更新订单</strong></p><p>对于同步返回的结果，需要在主线程中更新订单的状态，标记是支付成功还是失败。对于异步返回的渠道，需要在异步程序中处理。</p><p><strong>7. 发送消息</strong></p><p>通过消息来通知相关系统关于订单的变更。风控，数据系统等，都需要依赖这数据做准实时计算。</p><p><strong>8. 异步通知</strong></p><p>如上述流程，其中涉及到调用远程接口，其延迟不可控。如果调用方一直阻塞等待，很容易超时。引入异步通知机制，可以让调用方在主线程中尽快返回，通过异步线程来得到支付结果。对于通过异步来获取支付结果的渠道接口，也需要对应的在异步通知中将结果返回给调用方。 异步通知需要调用方提供一个回调地址，一般以http或者https的方式。这就有技术风险，如果调用失败，还需要重试。而重试不能过于频繁，需要逐步拉大每一次重试的时间间隔。 在异步处理程序中，订单根据处理结果变更状态后，也要发消息通知相关系统。</p>]]></content>
    
    
    <categories>
      
      <category>支付体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>支付</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动物农场</title>
    <link href="/dajiangdahe/2022/01/05/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%91%E5%8A%A8%E7%89%A9%E5%86%9C%E5%9C%BA/"/>
    <url>/dajiangdahe/2022/01/05/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%91%E5%8A%A8%E7%89%A9%E5%86%9C%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1>动物农场（乔治奥威尔）</h1><h2 id="◆-第1章">◆ 第1章</h2><p>从1984看到动物农场发现，乔治写书的目的在于警醒人们，而没有提出切实可行的纲领或者理论。任何一场运动都需要有明确的纲领和理论，没有纲领和理论就如同一盘散沙。</p><blockquote><p>还有记住：在同人类作斗争的过程中，我们不要模仿他们。即使征服了他们，也决不沿用他们的恶习。是动物就决不住在房屋里，决不睡在床上，决不穿衣、喝酒、抽烟，决不接触钞票，从事交易。凡是人的习惯都是邪恶的。而且，千万要注意，任何动物都不能欺压自己的同类。不论是瘦弱的还是强壮的；不论是聪明的还是迟钝的，我们都是兄弟。任何动物都不得伤害其他动物。所有的动物一律平等。”</p></blockquote><h2 id="◆-第2章">◆ 第2章</h2><blockquote><p>“同志，”斯诺鲍说，“那些你如此钟爱的饰带全是奴隶的标记。你难道不明白自由比饰带更有价值吗？”</p></blockquote><p>旧的统治阶级被扫除，新的统治又登上了舞台，迄今为止如何实现人人物质极大丰富，精神极大自由的wczy动物们并没有一个完善的理论指导。</p><blockquote><p>接着，斯诺鲍（正是他才最擅长书写）用蹄子的双趾捏起一支刷子，涂掉了栅栏顶的木牌上的“曼纳农场”几个字，又在那上面写上“动物农场”。这就是农场以后的名字</p></blockquote><p>新的秩序和规则应该用来约束所有人，所谓王子犯法与庶民同罪，当法律和规则一旦对某些人失效的时候，这就产生了阶级分化。不受规则法律约束的人称为上层，受到法律规则约束但是有机会晋升为上层的人称为中层，余下皆下层。往复循环，当寡头政治被推到的时候，新的朝代或者统治阶级又站到了舞台上，旧有的不利于统治巩固集权的东西被扫进了垃圾堆。</p><blockquote><p>他们解释说，经过过去三个月的研讨，他们已经成功地把动物主义的原则简化为“七诫”，这“七诫”将要题写在墙上，它们将成为不可更改的法律，所有动物农场的动物都必须永远遵循它的规定生活。</p></blockquote><h2 id="◆-第3章">◆ 第3章</h2><p>“每个人觉悟非常高”是达到shzy的充要条件</p><blockquote><p>他们完成了收获，比琼斯那伙人过去干完活的时间提前了整整两天！更了不起的是，这是一个庄园里前所未有的大丰收。没有半点遗落；鸡和鸭子凭他们敏锐的眼光竟连非常细小的草梗草叶也没有放过。也没有一个动物偷吃哪怕一口牧草。</p></blockquote><blockquote><p>“你们不会把我们猪这样做看成是出于自私和特权吧？我希望你们不。实际上，我们中有许多猪根本不喜欢牛奶和苹果。我自己就很不喜欢。我们食用这些东西的唯一目的是要保护我们的健康。牛奶和苹果（这一点已经被科学所证明，同志们）包含的营养对猪的健康来说是绝对必需的。我们猪是脑力劳动者。农场的全部管理和组织工作都要依靠我们。我们夜以继日地为大家的幸福费尽心机。因此，这是为了你们，我们才喝牛奶，才吃苹果的。你们知道吧，万一我们猪失职了，那会发生什么事情呢？琼斯会卷土重来！是的，琼斯会卷土重来！真的，同志们！”</p></blockquote><h2 id="◆-第4章">◆ 第4章</h2><blockquote><p>他们说，传说那里的动物同类相食，互相用烧得通红的马蹄铁拷打折磨，还共同霸占他们中的雌性动物。弗雷德里克和皮尔金顿说，正是在这一点上，造反是悖于天理的。</p></blockquote><h2 id="◆-第5章">◆ 第5章</h2><p>合作社制度和按劳分配高下立现（战时状态除外）</p><blockquote><p>冬天快要到了，莫丽变得越来越难以管教。她每天早上干活总要迟到，而且总为自己开脱说她睡过头了，她还常常抱怨身体这里、那里说不出缘由地疼痛，虽然她的胃口好得惊人。她会找出种种借口逃避干活而跑到饮水池边，呆呆地站在那儿，凝视着她在水中的倒影。</p></blockquote><p>转：人与人之间的争斗很奇怪，一开始可能是正义与邪恶之争，发展到最后却会为争斗而争斗，凡是你支持的我都反对。一群人，一群掌握权势的人之间的争斗，发展到后来也会从政见不合变成你死我活。</p><blockquote><p>拿破仑自己无所贡献，却冷言冷语地说斯诺鲍的这些东西都是空想，绝不会成功，看起来他是在等待一个什么时机。这两口猪矛盾重重，争吵不休，但最为激烈的一次莫过于关于建立风车的争辩。</p></blockquote><h2 id="◆-第6章">◆ 第6章</h2><p>谁掌握过去，谁掌握未来！</p><blockquote><p>拿破仑从来没有真正反对过风车。相反，正是由他最初做的建议。那个斯诺鲍画在孵卵棚地板上的设计图，实际上是他早先从拿破仑的笔记中剽窃的。事实上，风车是拿破仑自己的创造。</p></blockquote><h2 id="◆-第7章">◆ 第7章</h2><blockquote><p>穆丽尔好不容易才拼读出来。 “它说，‘任何动物不得在铺被褥的床上睡觉’。”她终于念道。 克拉弗觉得太突兀了，她从不记得第四条诫律提到过被褥，可它既然就写在墙上，那它一定本来就是这样。</p></blockquote><h2 id="◆-第8章">◆ 第8章</h2><blockquote><p>只有鲍克瑟和克拉弗从不气馁。斯奎拉则时不时来一段关于什么劳动的乐趣以及劳工神圣之类的精彩演讲，但使其他动物受到鼓舞更大的，却来自鲍克瑟的踏实肯干和他总是挂在嘴边的口头禅：“我要更加努力工作。”</p></blockquote><h2 id="◆-第9章">◆ 第9章</h2><blockquote><p>当年他们为推翻人类而斗争，他们追求的目标可不是今天这样的景象。这些恐怖和屠杀的场面绝不是那天夜里老少校第一次鼓动他们造反时大家所向往的。对于未来，如果说她还曾有过什么构想，那就一定是构想了这样一个社会：在那里，没有饥饿和鞭子的折磨，一律平等，各尽其能，强者保护弱者，就像是在少校讲演的那天晚上，她曾经用前腿保护着那些最后才到的一群小鸭子一样。但现在她不明白，为什么他们现在竟处在一个不敢讲真话的世界里。当那些气势汹汹的狗到处咆哮的时候，当眼看着自己的同志在坦白了可怕的罪行后被撕成碎片而无可奈何的时候……</p></blockquote><h2 id="◆-第14章">◆ 第14章</h2><blockquote><p>还说他认识到事物过去没有，将来也不会有什么更好或更糟之分。因此他说，饥饿、艰难、失望的现实，是生活不可改变的规律。</p></blockquote><h2 id="◆-第15章">◆ 第15章</h2><blockquote><p>再次重申动物农场及其邻居之间已经建立的和应该建立的友好感情。在猪和人之间不存在，也不应该存在任何意义上的利害冲突。他们的奋斗目标和遇到的困难是一致的。劳工问题不是到处都相同嘛？</p></blockquote><blockquote><p>窗外的动物们从猪看到人，又从人看到猪，再从猪看到人；但他们已分不出谁是猪，谁是人了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>政治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka从入门到放弃</title>
    <link href="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <url>/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    
    <content type="html"><![CDATA[<h1>第 1章 Kafka 概述</h1><h2 id="1-1-定义">1.1 定义</h2><p><code>Kafka</code> 是一个分布式的基于发布/订阅模式的消息队列（<code>Message Queue</code>），主要应用于大数据实时处理领域。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/format,png-20220105165020501.png" class="" title="img"><p>一个典型的Kafka体系架构包括若干Producer（可以是服务器日志，业务数据，页面前端产生的page view等等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer (Group)，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在consumer group发生变化时进行rebalance。Producer使用push(推)模式将消息发布到broker，Consumer使用pull(拉)模式从broker订阅并消费消息。</p><h2 id="1-2-消息队列">1.2 消息队列</h2><h3 id="1-2-1-传统消息队列的应用场景">1.2.1 传统消息队列的应用场景</h3><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220104190400222.png" class="" title="image-20220104190400222"> <p><strong>使用消息队列的好处</strong></p><p>1） 解耦</p><p>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><p>2） 可恢复性</p><p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p><p>3） 缓冲</p><p>有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致 的情况。</p><p>4）灵活性   &amp;  峰值处理能力</p><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。 如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列 能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p><p>5）异步通信</p><p>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户 把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要 的时候再去处理它们。</p><h3 id="1-2-2-消息队列的两种模式">1.2.2  消息队列的两种模式</h3><p><strong>（1）点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）</strong></p><p>消息生产者生产消息发送到 <code>Queue</code> 中，然后消息消费者从 <code>Queue</code> 中取出并且消费消息。 消息被消费以后，<code>queue</code> 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。 <code>Queue</code> 支 持 存 在 多 个 消 费 者 ， 但 是 对 一 个 消 息 而 言 ， 只 会 有 一 个 消 费 者 可 以 消 费 。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220104190607741.png" class="" title="image-20220104190607741"><p><strong>（2）发布/订阅模式（一对多，消费者消费数据之后不会清除消息）</strong><br>消息生产者（发布）将消息发布到  <code>topic</code> 中，同时有多个消息消费者（订阅）消费该消 息。和点对点方式不同，发布到  <code>topic</code> 的消息会被所有订阅者消费。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220104190623124.png" class="" title="image-20220104190623124"><h2 id="1-3-Kafka-基础架构">1.3 Kafka 基础架构</h2><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220104190748143.png" class="" title="image-20220104190748143"><p>1）<strong><code>Producer</code></strong>  ：消息生产者，就是向  <code>kafka broker</code> 发消息的客户端；</p><p>2）<strong><code>Consumer</code></strong>  ：消息消费者，向  <code>kafka broker </code>取消息的客户端；</p><p>3）<code>**Consumer Group  （CG）**</code>：消费者组，由多个 <code>consumer</code> 组成。消费者组内每个消费者负 责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。所 有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</p><p>4）<strong><code>Broker</code></strong>  ：一台 <code>kafka</code> 服务器就是一个 <code>broker</code>。一个集群由多个 <code>broker</code> 组成。一个 <code>broker</code>可以容纳多个 <code>topic</code>。</p><p>5）<strong><code>Topic</code></strong>  ：可以理解为一个队列，生产者和消费者面向的都是一个  <code>topic</code>；</p><p>6）<strong><code>Partition</code></strong>：为了实现扩展性，一个非常大的 <code>topic</code> 可以分布到多个 <code>broker</code>（即服务器）上，一个 <code>topic</code> 可以分为多个  <code>partition</code>，每个 <code>partition</code> 是一个有序的队列；</p><p>7）<strong><code>Replica</code></strong>：副本，为保证集群中的某个节点发生故障时，该节点上的 <code>partition</code> 数据不丢失，且 <code>kafka</code> 仍然能够继续工作，<code>kafka</code> 提供了副本机制，一个 <code>topic</code> 的每个分区都有若干个副本， 一个 <code>leader</code> 和若干个 <code>follower</code>。</p><p>8）<strong><code>leader</code></strong>：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 <code>leader</code>。</p><p>9）<strong><code>follower</code></strong>：每个分区多个副本中的“从”，实时从 <code>leader</code> 中同步数据，保持和 <code>leader</code> 数据的同步。<code>leader</code> 发生故障时，某个  follower 会成为新的  <code>follower</code>。</p><h1>第  2 章    Kafka 快速入门</h1><h2 id="2-1-安装部署">2.1 安装部署</h2><p><a href="https://kengkengya.github.io/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">Zookeeper_kafka_kafka-Manager单机伪集群环境安装</a></p><h2 id="2-2-Kafka-命令行操作">2.2 Kafka 命令行操作</h2><ol><li><p>查看当前服务器里所有的<code>topics</code>:</p><figure class="highlight shell"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/kafka_2.13-2.8.1 # bin/kafka-topics.sh   --zookeeper 10.121.17.138:2181 --list<br></code></pre></td></tr></table></figure></li><li><p>创建<code>tpoic</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/kafka_2.13-2.8.1 # bin/kafka-topics.sh --create  --zookeeper 10.121.17.138:2181 --topic first --partitions 2 --replication-factor 2<br>Created topic first.<br></code></pre></td></tr></table></figure></li></ol><p>​选项说明：<br>​<code>--topic</code>  定义 <code>topic</code> 名</p><p>​<code>--replication-factor</code>    定义副本数</p><p><code>--partitions </code>   定义分区数</p><ol start="3"><li><p>删除<code>topic</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/kafka_2.13-2.8.1 # bin/kafka-topics.sh --delete  --zookeeper 10.121.17.138:2181 --topic first<br>Topic first is marked for deletion.<br>Note: This will have no impact if delete.topic.enable is not set to true.<br></code></pre></td></tr></table></figure></li><li><p>查看<code>topic</code>详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/kafka_2.13-2.8.1 # bin/kafka-topics.sh --describe  --zookeeper 10.121.17.138:2181 --topic first<br><br>Topic: firstTopicId: h7I5zqd-R7Sj3hd-P7q1gQPartitionCount: 2ReplicationFactor: 2Configs:<br>Topic: firstPartition: 0Leader: 1Replicas: 0,1Isr: 1,0<br>Topic: firstPartition: 1Leader: 2Replicas: 1,2Isr: 2,1<br></code></pre></td></tr></table></figure></li><li><p>发送消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/kafka-console-producer.sh --broker-list 10.121.17.138:9092 --topic first<br></code></pre></td></tr></table></figure></li><li><p>消费消息（必须先开启消息，再启动生产者）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">bin/kafka-console-consumer.sh  --zookeeper 10.121.17.138:2181 --topic first --from-beginning<br></code></pre></td></tr></table></figure><p><code>--from-beginning</code>：会把主题中以往所有的数据都读取出来</p></li><li><p>修改分区数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/kafka-topics.sh   --zookeeper 10.121.17.138:2181 --alter --topic first --partitions 6<br></code></pre></td></tr></table></figure></li></ol><h1>第  3 章    Kafka 架构深入</h1><h2 id="3-1-Kafka-工作流程及文件存储机制">3.1 Kafka 工作流程及文件存储机制</h2><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220105154350679.png" class="" title="image-20220105154350679"><p><code>Kafka</code> 中消息是以  <code>topic</code> 进行分类的，生产者生产消息，消费者消费消息，都是面向  <code>topic</code> 的。</p><p><code>topic</code> 是逻辑上的概念，而 <code>partition</code> 是物理上的概念，<strong>每个 <code>partition</code> 对应于一个 <code>log</code> 文 件，该 <code>log</code> 文件中存储的就是 <code>producer</code> 生产的数据</strong>。<code>Producer</code> 生产的数据会被不断追加到该 log 文件末端，且每条数据都有自己的 <code>offset</code>。消费者组中的每个消费者，都会实时记录自己 消费到了哪个 <code>offset</code>，以便出错恢复时，从上次的位置继续消费。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220105155713384.png" class="" title="image-20220105155713384"><p>由于生产者生产的消息会不断追加到 <code>log</code> 文件末尾，为防止 <code>log</code> 文件过大导致数据定位 效率低下，<strong>Kafka 采取了分片和索引机制</strong>，将每个 <code>partition</code> 分为多个 <code>segment</code>。每个 segment 对应两个文件——“<code>.index</code>”文件和“<code>.log</code>”文件。这些文件位于一个文件夹下，该文件夹的命名 规则为：<code>topic</code> 名称+分区序号。例如，first 这个 topic 有三个分区，则其对应的文件夹为<code> first- 0,first-1,first-2</code>。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">00000000000000000000</span>.<span class="hljs-built_in">index</span><br><span class="hljs-number">00000000000000000000</span>.<span class="hljs-built_in">log</span><br><span class="hljs-number">00000000000000170410</span>.<span class="hljs-built_in">index</span><br><span class="hljs-number">00000000000000170410</span>.<span class="hljs-built_in">log</span><br><span class="hljs-number">00000000000000239430</span>.<span class="hljs-built_in">index</span><br><span class="hljs-number">00000000000000239430</span>.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><code>index</code> 和  <code>log</code> 文件以当前  <code>segment</code> 的第一条消息的  <code>offset</code> 命名。下图为  <code>index</code> 文件和  <code>log</code> 文件的结构示意图。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220105160059914.png" class="" title="image-20220105160059914"><p>首先在<code>index</code>文件根据二分查找法查找索引（每一个offset都是一样大），找到<code>offset=3</code>的起始值。然后今后<code>log</code>文件进行查找。<code>**.index</code>文件存储大量的索引信息，<code>.log</code>文件存储大量的数据**，索引文件中的元数据指向对应数据文件中 <code>message</code> 的物理偏移地址。</p><h3 id="3-1-1-复制原理和同步方式">3.1.1 复制原理和同步方式</h3><p><code>Kafka</code>中<code>topic</code>的每个<code>partition</code>有一个预写式的日志文件，虽然<code>partition</code>可以继续细分为若干个<code>segment</code>文件，但是对于上层应用来说可以将<code>partition</code>看成最小的存储单元（一个有多个<code>segment</code>文件拼接的“巨型”文件），每个<code>partition</code>都由一些列有序的、不可变的消息组成，这些消息被连续的追加到<code>partition</code>中。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/format,png.png" class="" title="这里写图片描述"><p>上图中有两个新名词：<code>HW</code>和<code>LEO</code>。这里先介绍下<code>LEO</code>，<code>LogEndOffset``的缩写，表示每个</code>partition<code>的</code>log<code>最后一条</code>Message<code>的位置。</code>HW<code>HighWatermark</code>的缩写，是指<code>consumer</code>能够看到的此<code>partition</code>的位置，这个涉及到多副本的概念，这里先提及一下，下节再详表。</p><p>言归正传，为了提高消息的可靠性，<code>Kafka</code>每个<code>topic</code>的<code>partition</code>有N个副本（<code>replicas</code>），其中N(大于等于1)是<code>topic</code>的复制因子（<code>replica fator</code>）的个数。<code>Kafka</code>通过多副本机制实现故障自动转移，当Kafka<code>集群</code>中一个<code>broker</code>失效情况下仍然保证服务可用。在<code>Kafka</code>中发生复制时确保<code>partition</code>的日志能有序地写到其他节点上，N个<code>replicas</code>中，其中一个<code>replica</code>为<code>leader</code>，其他都为<code>follower</code>, <code>leader</code>处理<code>partition</code>的所有读写请求，与此同时，<code>follower</code>会被动定期地去复制<code>leader</code>上的数据。</p><p>如下图所示，<code>Kafka</code>集群中有4个<code>broker</code>, 某<code>topic</code>有3个<code>partition</code>,且复制因子即副本个数也为3：</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/format,png-20220105164106125.png" class="" title="这里写图片描述"><p><code>Kafka</code>提供了数据复制算法保证，如果<code>leader</code>发生故障或挂掉，一个新<code>leader</code>被选举并被接受客户端的消息成功写入。<code>Kafka</code>确保从同步副本列表中选举一个副本为<code>leader</code>，或者说<code>follower</code>追赶<code>leader</code>数据。<code>leader</code>负责维护和跟踪<code>ISR</code>(<code>In-Sync Replicas</code>的缩写，表示副本同步队列，具体可参考下节)中所有<code>follower</code>滞后的状态。当<code>producer</code>发送一条消息到<code>broker</code>后，<code>leader</code>写入消息并复制到所有<code>follower</code>。消息提交之后才被成功复制到所有的同步副本。消息复制延迟受最慢的<code>follower</code>限制，重要的是快速检测慢副本，如果<code>follower</code>“落后”太多或者失效，<code>leader</code>将会把它从<code>ISR</code>中删除。</p><p>另外每个<code>replica</code>都有<code>HW</code>,<code>leader</code>和<code>follower</code>各自负责更新自己的<code>HW</code>的状态。对于<code>leader</code>新写入的消息，<code>consumer</code>不能立刻消费，<code>leader</code>会等待该消息被所有ISR中的<code>replicas</code>同步后更新<code>HW</code>，此时消息才能被<code>consumer</code>消费。这样就保证了如果<code>leader</code>所在的<code>broker</code>失效，该消息仍然可以从新选举的<code>leader</code>中获取。对于来自内部<code>broker</code>的读取请求，没有<code>HW</code>的限制。</p><p>下图详细的说明了当<code>producer</code>生产消息至<code>broker</code>后，ISR以及HW和LEO的流转过程：</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/format,png-20220105164408305.png" class="" title="这里写图片描述"><p>由此可见，<code>Kafka</code>的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的<code>follower</code>都复制完，这条消息才会被<code>commit</code>，这种复制方式极大的影响了吞吐率。而异步复制方式下，<code>follower</code>异步的从<code>leader</code>复制数据，数据只要被<code>leader</code>写入<code>log</code>就被认为已经<code>commit</code>，这种情况下如果<code>follower</code>都还没有复制完，落后于<code>leader</code>时，突然<code>leader</code>宕机，则会丢失数据。而<code>Kafka</code>的这种使用<code>ISR</code>的方式则很好的均衡了确保数据不丢失以及吞吐率。</p><p><code>Kafka</code>的<code>ISR</code>的管理最终都会反馈到<code>Zookeeper</code>节点上。具体位置为：<code>/brokers/topics/[topic]/partitions/[partition]/state</code>。目前有两个地方会对这个<code>Zookeeper</code>的节点进行维护：</p><ul><li><p><code>Controller</code>来维护：<code>Kafka</code>集群中的其中一个<code>Broker</code>会被选举为<code>Controller</code>，主要负责<code>Partition</code>管理和副本状态管理，也会执行类似于重分配<code>partition</code>之类的管理任务。在符合某些特定条件下，<code>Controller</code>下的<code>LeaderSelector</code>会选举新的<code>leader</code>，<code>ISR</code>和新的<code>leader_epoch</code>及<code>controller_epoch</code>写入<code>Zookeeper</code>的相关节点中。同时发起<code>LeaderAndIsrRequest</code>通知所有的<code>replicas</code>。</p></li><li><p><code>leader</code>来维护：<code>leader</code>有单独的线程定期检测<code>ISR</code>中<code>follower</code>是否脱离<code>ISR</code>, 如果发现<code>ISR</code>变化，则会将新的<code>ISR</code>的信息返回到<code>Zookeeper</code>的相关节点中。</p></li></ul><h2 id="3-2-Kafka-生产者">3.2 Kafka 生产者</h2><h3 id="3-2-1-分区策略">3.2.1  分区策略</h3><p>1）分区的原因</p><p>​（1）<strong>方便在集群中扩展</strong>，每个 <code>Partition</code> 可以通过调整以适应它所在的机器，而一个  <code>topic</code>又可以有多个 <code>Partition</code> 组成，因此整个集群就可以适应任意大小的数据了；</p><p>​（2）<strong>可以提高并发</strong>，因为可以以 <code>Partition</code> 为单位读写了。</p><p>2）分区的原则</p><p>​我们需要将 <code>producer</code> 发送的数据封装成一个 <code>ProducerRecord</code> 对象。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220105160759755-1370080.png" class="" title="image-20220105160759755"><p>（1）指明   <code>partition</code>  的情况下，直接将指明的值直接作为   <code>partiton</code>  值；（权重）</p><p>（2）没有指明   <code>partition</code>  值但有   <code>key</code>  的情况下，将   <code>key</code>  的   <code>hash</code>  值与   <code>topic</code>  的   <code>partition</code> 数进行取余得到   partition  值；（hash）</p><p>（3）既没有 <code>partition</code>  值又没有 key  值的情况下，第一次调用时随机生成一个整数（后 面每次调用在这个整数上自增），将这个值与 <code>topic</code>  可用的 <code>partition</code>  总数取余得到 <code>partition</code> 值，也就是常说的 <code>round-robin</code>  算法。(轮询)</p><h3 id="3-2-2-数据可靠性保证">3.2.2  数据可靠性保证</h3><p>为保证 <code>producer</code> 发送的数据，能可靠的发送到指定的 <code>topic</code>，<code>topic</code> 的每个 <code>partition</code> 收到 <code>producer</code> 发送的数据后，都需要向 <code>producer</code> 发送 <code>ack</code>（<code>acknowledgement</code> 确认收到），如果 <code>producer</code> 收到 <code>ack</code>，就会进行下一轮的发送，否则重新发送数据。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220105161526377.png" class="" title="image-20220105161526377"><p><strong>1）副本数据同步策略</strong></p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>半数以上完成同步，就发 送  <code>ack</code></td><td>延迟低</td><td>选举新的 <code>leader</code> 时，容忍 n 台 节点的故障，需要 <code>2n+1</code> 个副 本</td></tr><tr><td>全部完成同步，才发送 <code>ack</code></td><td>选举新的 <code>leader</code> 时，容忍 n 台 节点的故障，需要 n+1 个副 本</td><td>延迟高</td></tr></tbody></table><p><code>Kafka</code> 选择了第二种方案，原因如下：</p><ol><li>同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1个副本，而 <code>Kafka</code> 的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。</li><li>虽然第二种方案的网络延迟会比较高，但网络延迟对  <code>Kafka</code> 的影响较小。</li></ol><blockquote><ul><li>半数以上方案的缺点解释：宕机的N个机器，它们可能是同步好数据的那部分，也可能是没有同步好的那部分。如果坏掉的是同步好的那部分，那我们只需要N+1个副本(多出来的这个副本是仅仅或者说专门用来备份的节点机器，懂我意思吧)，如果坏掉的不是同步好的那部分，本身没有同步的数据，而且还缺一份备份，所以需要2N+1</li><li>全部同步才发送<code>ack</code>的方案：因为是所有的<code>follower</code>都同步好了，参照上面的解释，我们就仅仅需要N+1个副本就好。</li></ul></blockquote><p><strong>2）ISR</strong></p><p>采用第二种方案之后，设想以下情景：<code>leader</code> 收到数据，所有 <code>follower</code> 都开始同步数据， 但有一个 <code>follower</code>，因为某种故障，迟迟不能与 <code>leader</code> 进行同步，那 <code>leader</code> 就要一直等下去， 直到它完成同步，才能发送 <code>ack</code>。这个问题怎么解决呢？</p><p><code>Leader</code> 维护了一个动态的 <code>in-sync replica set (ISR)</code>，意为和 <code>leader</code> 保持同步的 <code>follower</code> 集 合。当 <code>ISR</code> 中的 <code>follower</code> 完成数据的同步之后，<code>leader</code> 就会给 <code>follower</code> 发送 <code>ack</code>。如果 <code>follower</code> 长时间未 向 <code>leader</code> 同 步 数 据 ， 则 该 <code>follower</code> 将 被 踢 出<code> ISR</code> ， 该 时 间 阈 值 由<code>replica.lag.time.max.ms</code> 参数设定。<code>Leader</code> 发生故障之后，就会从  <code>ISR</code> 中选举新的  <code>leader</code>。</p><p>默认情况下<code>Kafka</code>的<code>replica</code>数量为1，即每个<code>partition</code>都有一个唯一的<code>leader</code>，为了确保消息的可靠性，通常应用中将其值(由<code>broker</code>的参数<code>offsets.topic.replication.factor</code>指定)大小设置为大于1，比如3。 所有的副本（<code>replicas</code>）统称为<code>Assigned Replicas</code>，即<code>AR</code>。<code>ISR</code>是<code>AR</code>中的一个子集，由<code>leader</code>维护<code>ISR</code>列表，<code>follower</code>从<code>leader</code>同步数据有一些延迟（包括延迟时间<code>replica.lag.time.max.ms</code>和延迟条数<code>replica.lag.max.messages</code>两个维度, 当前最新的版本<code>0.10.x</code>中只支持<code>replica.lag.time.max.ms</code>这个维度），任意一个超过阈值都会把<code>follower</code>剔除出<code>ISR</code>, 存入<code>OSR</code>（<code>Outof-Sync Replicas</code>）列表，新加入的<code>follower</code>也会先存放在<code>OSR</code>中。<code>AR=ISR+OSR</code>。</p><p><code>Kafka 0.9.0.0</code>版本后移除了<code>replica.lag.max.messages</code>参数，只保留了<code>replica.lag.time.max.ms</code>作为ISR中副本管理的参数。为什么这样做呢？</p><p><code>replica.lag.max.messages</code>表示当前某个副本落后<code>leader</code>的消息数量超过了这个参数的值，那么<code>leader</code>就会把<code>follower</code>从<code>ISR</code>中删除。假设设置<code>replica.lag.max.messages</code>=4，那么如果<code>producer</code>一次传送至<code>broker</code>的消息数量都小于4条时，因为在<code>leader</code>接受到<code>producer</code>发送的消息之后而<code>follower</code>副本开始拉取这些消息之前，<code>follower</code>落后<code>leader</code>的消息数不会超过4条消息，故此没有<code>follower</code>移出<code>ISR</code>，所以这时候<code>replica.lag.max.message</code>的设置似乎是合理的。但是<code>producer</code>发起瞬时高峰流量，<code>producer</code>一次发送的消息超过4条时，也就是超过<code>replica.lag.max.messages</code>，此时follower都会被认为是与<code>leader</code>副本不同步了，从而被踢出了<code>ISR</code>。但实际上这些<code>follower</code>都是存活状态的且没有性能问题。那么在之后追上<code>leader</code>,并被重新加入了<code>ISR</code>。于是就会出现它们不断地剔出<code>ISR</code>然后重新回归<code>ISR</code>，这无疑增加了无谓的性能损耗。而且这个参数是<code>broker</code>全局的。设置太大了，影响真正“落后”<code>follower</code>的移除；设置的太小了，导致<code>follower</code>的频繁进出。无法给定一个合适的<code>replica.lag.max.messages</code>的值，故此，新版本的<code>Kafka</code>移除了这个参数。</p><blockquote><p><code>ISR</code>包括<code>leader</code>和<code>follow</code></p></blockquote><p><strong>3）<code>ack</code> 应答机制</strong><br>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失， 所以没必要等 <code>ISR</code> 中的  <code>follower</code> 全部接收成功。所以  <code>Kafka</code> 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡， 选择以下的配置。</p><p>当<code>producer</code>向<code>leader</code>发送数据时，可以通过<code>request.required.acks</code>参数来设置数据可靠性的级别：</p><ul><li><strong>1</strong>（默认）：这意味着<code>producer</code>在<code>ISR</code>中的<code>leader</code>已成功收到数据并得到确认。如果<code>leader</code>宕机了，则会丢失数据。</li><li><strong>0</strong>：这意味着<code>producer</code>无需等待来自<code>broker</code>的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li><li><strong>-1</strong>：<code>producer</code>需要等待ISR中的所有<code>follower</code>都确认接收到数据后才算一次发送完成，可靠性最高。但是这样也不能保证数据不丢失，比如当<code>ISR</code>中只有<code>leader</code>时（前面<code>ISR</code>那一节讲到，<code>ISR</code>中的成员由于某些情况会增加也会减少，最少就只剩一个<code>leader</code>），这样就变成了<code>acks</code>=1的情况。</li></ul><p>如果要提高数据的可靠性，在设置<code>request.required.acks</code>=-1的同时，也要<code>min.insync.replicas</code>这个参数(可以在<code>broker</code>或者<code>topic</code>层面进行设置)的配合，这样才能发挥最大的功效。<code>min.insync.replicas</code>这个参数设定<code>ISR</code>中的最小副本数是多少，默认值为<code>1</code>，当且仅当<code>request.required.acks</code>参数设置为<code>-1</code>时，此参数才生效。如果ISR中的副本数少于<code>min.insync.replicas</code>配置的数量时，客户端会返回异常：<code>org.apache.kafka.common.errors.NotEnoughReplicasExceptoin</code>: <code>Messages are rejected since there are fewer in-sync replicas than required。</code></p><p>接下来对<code>acks</code>=1和-1的两种情况进行详细分析：</p><p><strong>1. request.required.acks=1</strong></p><p><code>producer</code>发送数据到<code>leader</code>，<code>leader</code>写本地日志成功，返回客户端成功；此时<code>ISR</code>中的副本还没有来得及拉取该消息，<code>leader</code>就宕机了，那么此次发送的消息就会丢失。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/format,png-1439968.png" class="" title="这里写图片描述"><ol start="2"><li><strong>request.required.acks=-1</strong></li></ol><p>同步（<code>Kafka</code>默认为同步，即<code>producer.type=sync</code>）的发送模式，<code>replication.factor&gt;=2</code>且<code>min.insync.replicas&gt;=2</code>的情况下，不会丢失数据。</p><p>有两种典型情况。<code>acks=-1</code>的情况下（如无特殊说明，以下<code>acks</code>都表示为参数<code>request.required.acks</code>），数据发送到<code>leader</code>, <code>ISR</code>的<code>follower</code>全部完成数据同步后，<code>leader</code>此时挂掉，那么会选举出新的<code>leader</code>，数据不会丢失。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/format,png-20220106113345033.png" class="" title="这里写图片描述"><p><code>acks</code>=-1的情况下，数据发送到<code>leader</code>后 ，部分<code>ISR</code>的副本同步，<code>leader</code>此时挂掉。比如<code>follower1</code>和<code>follower2</code>都有可能变成新的<code>leader</code>, <code>producer</code>端会得到返回异常，<code>producer</code>端会重新发送数据，数据可能会重复。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/format,png-20220106113413975.png" class="" title="这里写图片描述"><p>当然上图中如果在<code>leader crash</code>的时候，<code>follower2</code>还没有同步到任何数据，而且<code>follower2</code>被选举为新的<code>leader</code>的话，这样消息就不会重复。</p><blockquote><p>注：Kafka只处理fail/recover问题,不处理Byzantine问题。</p></blockquote><h3 id="3-2-3-关于HW的进一步探讨">3.2.3 关于HW的进一步探讨</h3><p>考虑上图（即<code>acks=-1</code>,部分<code>ISR</code>副本同步）中的另一种情况，如果在<code>Leader</code>挂掉的时候，<code>follower1</code>同步了消息4,5，<code>follower2</code>同步了消息4，与此同时<code>follower2</code>被选举为<code>leader</code>，那么此时<code>follower1</code>中的多出的消息5该做如何处理呢？</p><p>这里就需要<code>HW</code>的协同配合了。如前所述，一个<code>partition</code>中的<code>ISR</code>列表中，<code>leader</code>的<code>HW</code>是所有<code>ISR</code>列表里副本中最小的那个的<code>LEO</code>。类似于木桶原理，水位取决于最低那块短板。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/format,png-20220106113832317.png" class="" title="这里写图片描述"><p>如上图，某个<code>topic</code>的某<code>partition</code>有三个副本，分别为A、B、C。A作为<code>leader</code>肯定是<code>LEO</code>最高，B紧随其后，C机器由于配置比较低，网络比较差，故而同步最慢。这个时候A机器宕机，这时候如果B成为<code>leader</code>，假如没有<code>HW</code>，在A重新恢复之后会做同步(<code>makeFollower</code>)操作，在宕机时<code>log</code>文件之后直接做追加操作，而假如B的<code>LEO</code>已经达到了A的<code>LEO</code>，会产生数据不一致的情况，所以使用<code>HW</code>来避免这种情况。<br>A在做同步操作的时候，先将<code>log</code>文件截断到之前自己的<code>HW</code>的位置，即3，之后再从B中拉取消息进行同步。</p><p>如果失败的<code>follower</code>恢复过来，它首先将自己的<code>log</code>文件截断到上次<code>checkpointed</code>时刻的<code>HW</code>的位置，之后再从<code>leader</code>中同步消息。<code>leader</code>挂掉会重新选举，新的<code>leader</code>会发送“指令”让其余的<code>follower</code>截断至自身的<code>HW</code>的位置然后再拉取新的消息。</p><blockquote><p>当ISR中的个副本的LEO不一致时，如果此时leader挂掉，选举新的leader时并不是按照LEO的高低进行选举，而是按照ISR中的顺序选举。</p></blockquote><h3 id="3-2-4-消息传输保障">3.2.4 消息传输保障</h3><p>将服务器的 <code>ACK</code> 级别设置为-1，可以保证 <code>Producer</code> 到 <code>Server</code> 之间不会丢失数据，即 <code>At Least Once </code>语义。相对的，将服务器 <code>ACK</code> 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 <code>At Most Once</code> 语义。</p><p><code>At Least Once</code> 可以保证数据不丢失，但是不能保证数据不重复；相对的，<code>At Least Once</code> 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说 交易数据，下游数据消费者要求数据既不重复也不丢失，即 <code>Exactly Once</code> 语义。在 0.11 版 本以前的 <code>Kafka</code>，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局 去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。0.11 版本的 <code>Kafka</code>，引入了一项重大特性：幂等性。所谓的幂等性就是指 <code>Producer</code> 不论 向 <code>Server</code> 发送多少次重复数据，<code>Server</code> 端都只会持久化一条。幂等性结合 <code>At Least Once </code>语 义，就构成了 <code>Kafka</code> 的 <code>Exactly Once </code>语义。即：<br>$$<br>At Least Once + 幂等性   = Exactly Once<br>$$<br>要启用幂等性，只需要将 <code>Producer</code> 的参数中 <code>enable.idompotence </code>设置为 <code>true</code> 即可。<code>Kafka</code> 的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 <code>Producer</code> 在 初始化的时候会被分配一个 <code>PID</code>，发往同一 <code>Partition</code> 的消息会附带 <code>Sequence Number</code>。而 <code>Broker</code> 端会对<code>&lt;PID, Partition, SeqNumber&gt;</code>做缓存，当具有相同主键的消息提交时，<code>Broker</code> 只 会持久化一条。</p><p>但是 <code>PID</code> 重启就会变化，同时不同的 <code>Partition</code> 也具有不同主键，所以幂等性无法保证跨分区跨会话的 <code>Exactly Once</code>。</p><h3 id="3-2-5-消息去重">3.2.5 消息去重</h3><p>如上一节所述，<code>Kafka</code>在<code>producer</code>端和<code>consumer</code>端都会出现消息的重复，这就需要去重处理。</p><p><code>Kafka</code>文档中提及<code>GUID(Globally Unique Identifier)</code>的概念，通过客户端生成算法得到每个消息的<code>unique id</code>，同时可映射至<code>broker</code>上存储的地址，即通过<code>GUID</code>便可查询提取消息内容，也便于发送方的幂等性保证，需要在<code>broker</code>上提供此去重处理模块，目前版本尚不支持。</p><p>针对<code>GUID</code>, 如果从客户端的角度去重，那么需要引入集中式缓存，必然会增加依赖复杂度，另外缓存的大小难以界定。</p><p>不只是<code>Kafka</code>, 类似<code>RabbitMQ</code>以及<code>RocketMQ</code>这类商业级中间件也只保障<code>at least once</code>, 且也无法从自身去进行消息去重。所以我们建议业务方根据自身的业务特点进行去重，比如业务消息本身具备幂等性，或者借助<code>Redis</code>等其他产品进行去重处理。</p><h3 id="3-2-6-高可靠性配置">3.2.6 高可靠性配置</h3><p><code>Kafka</code>提供了很高的数据冗余弹性，对于需要数据高可靠性的场景，我们可以增加数据冗余备份数<code>（replication.factor）</code>，调高最小写入副本数的个数<code>（min.insync.replicas）</code>等等，但是这样会影响性能。反之，性能提高而可靠性则降低，用户需要自身业务特性在彼此之间做一些权衡性选择。</p><p>要保证数据写入到<code>Kafka</code>是安全的，高可靠的，需要如下的配置：</p><p><code>topic</code>的配置：<code>replication.factor&gt;=3</code>,即副本数至少是3个；<code>2&lt;=min.insync.replicas&lt;=replication.factor</code><br><code>broker</code>的配置：<code>leader</code>的选举条件<code>unclean.leader.election.enable=false</code><br><code>producer</code>的配置：<code>request.required.acks=-1(all)，producer.type=sync</code></p><h2 id="3-3-Kafka-消费者">3.3 Kafka 消费者</h2><h3 id="3-3-1-消费方式">3.3.1  消费方式</h3><p><code>consumer</code> 采用<code>  pull</code>（拉）模式从 <code>broker</code> 中读取数据。<code>push</code>（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由  <code>broker</code> 决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 <code>consumer</code> 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而  <code>pull</code> 模式则可以根据  <code>consumer</code> 的消费能力以适 当的速率消费消息。<code>pull</code> 模式不足之处是，如果 <code>kafka</code> 没有数据，消费者可能会陷入循环中，一直返回空数 据。针对这一点，<code>Kafka</code> 的消费者在消费数据时会传入一个时长参数 <code>timeout</code>，如果当前没有 数据可供消费，<code>consumer</code> 会等待一段时间之后再返回，这段时长即为 <code>timeout</code>。</p><h3 id="3-3-2-分区分配策略">3.3.2  分区分配策略</h3><p>一个  <code>consumer group</code> 中有多个 <code>consumer</code>，一个   <code>topic</code> 有多个 <code>partition</code>，所以必然会涉及 到 <code>partition</code> 的分配问题，即确定那个  <code>partition</code> 由哪个  <code>consumer</code> 来消费。<code>Kafka</code> 有两种分配策略，一是  <code>RoundRobin</code>，一是 <code>Range</code>。默认采用 <code>Range</code> 范围分区。 <code>Kafka</code>提供了消费者客户端参数 <code>partition.assignment.strategy</code> 用来设置消费者与订阅主题之间的分区分配策略。默认情况下，此参数的值为：<code>org.apache.kafka.clients.consumer.RangeAssignor</code>，即采用<code>RangeAssignor</code>分配策略。</p><p><strong>1）RoundRobin</strong></p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220106142144381.png" class="" title="image-20220106142144381"><p><code>RoundRobin</code> 轮询分区策略，是把所有的 <code>partition</code> 和所有的 <code>consumer</code> 都列出来，然后按照 <code>hascode</code> 进行排序，最后通过轮询算法来分配 <code>partition</code> 给到各个消费者。</p><p>轮询分区分为如下两种情况：①同一消费组内所有消费者订阅的消息都是相同的    ②同一消费者组内的消费者组订阅的消息不相同</p><p>①如果同一消费组内，所有的消费者订阅的消息都是相同的，那么 <code>RoundRobin</code> 策略的分区分配会是均匀的。</p><p>例如：同一消费者组中，有 3 个消费者C0、C1和C2，都订阅了 2 个主题 t0  和 t1，并且每个主题都有 3 个分区(p0、p1、p2)，那么所订阅的所以分区可以标识为<code>t0p0、t0p1、t0p2、t1p0、t1p1、t1p2</code>。最终分区分配结果如下：</p><table><thead><tr><th></th><th style="text-align:center">RoundRobin</th></tr></thead><tbody><tr><td>消费者C0</td><td style="text-align:center">消费 t0p0 、t1p0 分区</td></tr><tr><td>消费者C1</td><td style="text-align:center">消费 t0p1 、t1p1 分区</td></tr><tr><td>消费者C2</td><td style="text-align:center">消费 t0p2 、t1p2 分区</td></tr></tbody></table><p>②如果同一消费者组内，所订阅的消息是不相同的，那么在执行分区分配的时候，就不是完全的轮询分配，有可能会导致分区分配的不均匀。如果某个消费者没有订阅消费组内的某个 topic，那么在分配分区的时候，此消费者将不会分配到这个 <code>topic</code> 的任何分区。</p><p>例如：同一消费者组中，有3个消费者C0、C1和C2，他们共订阅了 3 个主题：t0、t1 和 t2，这 3 个主题分别有 1、2、3 个分区(即:t0有1个分区<code>(p0)</code>，t1有2个分区<code>(p0、p1)</code>，t2有3个分区<code>(p0、p1、p2))</code>，即整个消费者所订阅的所有分区可以标识为 <code>t0p0、t1p0、t1p1、t2p0、t2p1、t2p2</code>。具体而言，消费者C0订阅的是主题t0，消费者C1订阅的是主题t0和t1，消费者C2订阅的是主题t0、t1和t2，最终分区分配结果如下：</p><table><thead><tr><th></th><th style="text-align:center">RoundRobin</th></tr></thead><tbody><tr><td>消费者C0</td><td style="text-align:center">消费 t0p0</td></tr><tr><td>消费者C1</td><td style="text-align:center">消费 t1p0 分区</td></tr><tr><td>消费者C2</td><td style="text-align:center">消费 t1p1、t2p0、t2p1、t2p2 分区</td></tr></tbody></table><p><strong>RoundRobin轮询分区的弊端：</strong></p><blockquote><p>从如上实例，可以看到RoundRobin策略也并不是十分完美，这样分配其实并不是最优解，因为完全可以将分区 t1p1 分配给消费者 C1。</p><p>所以，如果想要使用RoundRobin 轮询分区策略，必须满足如下两个条件：</p><p>①每个消费者订阅的主题，必须是相同的</p><p>②每个主题的消费者实例都是相同的。(即：上面的第一种情况，才优先使用 RoundRobin 轮询分区策略)</p></blockquote><p><strong>2）Range</strong></p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220106142208609.png" class="" title="image-20220106142208609"><p><code>Range</code> 范围分区策略是对每个 <code>topic</code> 而言的。首先对同一个 <code>topic</code> 里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。假如现在有 10 个分区，3 个消费者，排序后的分区将会是0,1,2,3,4,5,6,7,8,9；消费者排序完之后将会是<code>C1-0,C2-0,C3-0</code>。通过 <strong><code>partitions</code>数/<code>consumer</code>数</strong> 来决定每个消费者应该消费几个分区。如果除不尽，那么前面几个消费者将会多消费 1 个分区。</p><blockquote><p>例如，10/3 = 3 余 1 ，除不尽，那么 消费者 C1-0 便会多消费 1 个分区，最终分区分配结果如下：</p></blockquote><table><thead><tr><th></th><th style="text-align:center">Range分区</th></tr></thead><tbody><tr><td>C1-0</td><td style="text-align:center">消费 0,1,2,3 分区</td></tr><tr><td>C2-0</td><td style="text-align:center">消费 4,5,6 分区</td></tr><tr><td>C3-0</td><td style="text-align:center">消费 7,8,9 分区(如果有11 个分区的话，C1-0 将消费0,1,2,3 分区，C2-0 将消费4,5,6,7分区  C3-0 将消费 8,9,10 分区)</td></tr></tbody></table><p><strong><code>Range</code> 范围分区的弊端：</strong></p><blockquote><p>如上，只是针对 1 个 <code>topic</code> 而言，<code>C1-0</code>消费者多消费<code>1</code>个分区影响不是很大。如果有 N 多个 <code>topic</code>，那么针对每个 <code>topic</code>，消费者<code>C1-0</code>都将多消费 1 个分区，<code>topic</code>越多，C1-0 消费的分区会比其他消费者明显多消费 N 个分区。这就是 <code>Range</code> 范围分区的一个很明显的弊端了.</p></blockquote><p><strong>2.什么时候触发分区分配策略</strong><br>当出现以下几种情况时，<code>Kafka</code> 会进行一次分区分配操作，即 <code>Kafka</code> 消费者端的 <code>Rebalance</code> 操作</p><p>① 同一个 <code>consumer</code> 消费者组<code>group.id</code>中，新增了消费者进来，会执行 <code>Rebalance</code> 操作</p><p>② 消费者离开当期所属的 <code>consumer group</code>组。比如 主动停机  或者  宕机</p><p>③ 分区数量发生变化时(即 <code>topic</code> 的分区数量发生变化时)</p><p>④ 消费者主动取消订阅</p><p><code>Kafka</code> 消费端的 <code>Rebalance</code> 机制，规定了一个<code>Consumer group</code>下的所有 <code>consumer</code> 如何达成一致来分配订阅 <code>topic</code> 的每一个分区。而具体如何执行分区策略，就是上面提到的 <code>Range</code> 范围分区 和 <code>RoundRobin</code> 轮询分区 两种内置的分区策略。</p><p><code>Kafka</code> 对于分区分配策略这块，也提供了可插拔式的实现方式，除了上面两种分区分配策略外，我们也可以创建满足自己使用的分区分配策略，即：<strong>自定义分区策略</strong></p><h3 id="3-3-3-offset-的维护">3.3.3 offset 的维护</h3><p>由于 <code>consumer</code> 在消费过程中可能会出现断电宕机等故障，<code>consumer</code> 恢复后，需要从故障前的位置的继续消费，所以 <code>consumer</code> 需要实时记录自己消费到了哪个 <code>offset</code>，以便故障恢 复后继续消费。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220106142242884.png" class="" title="image-20220106142242884"><p><code>Kafka 0.9</code> 版本之前，<code>consumer</code> 默认将  <code>offset</code> 保存在  <code>Zookeeper</code> 中，从  <code>0.9 </code>版本开始， <code>consumer</code> 默认将 <code>offset</code> 保存在 <code>Kafka</code> 一个内置的  <code>topic</code> 中，该 <code>topic</code> 为<code>__consumer_offsets</code>。</p><p>1）修改配置文件 consumer.properties</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">exclude.internal.topics</span>=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>2）读取 offset 0.11.0.0 之前版本:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">bin/kafka-console-consumer.sh   <span class="hljs-params">--topic</span>   __consumer_offsets   <span class="hljs-params">--hadoop102</span><span class="hljs-function">:2181</span> zookeeper <span class="hljs-params">--formatter</span> <span class="hljs-string">&quot;kafka.coordinator.GroupMetadataManager\$OffsetsMessageFormatter&quot;</span> <span class="hljs-params">--consumer</span>.config config/consumer.properties <span class="hljs-params">--from-beginning</span><br></code></pre></td></tr></table></figure><p>0.11.0.0 之后版本(含):</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">bin</span>/<span class="hljs-string">kafka-console-consumer</span>.<span class="hljs-string">sh</span>   <span class="hljs-built_in">--topic</span>   <span class="hljs-string">__consumer_offsets</span>   <span class="hljs-built_in">--hadoop102:2181</span> <span class="hljs-string">zookeeper</span> <br><span class="hljs-built_in">--formatter</span> <span class="hljs-string">&quot;kafka.coordinator.group.GroupMetadataManager\$OffsetsMessageForm atter&quot;</span>  <span class="hljs-built_in">--consumer.config</span>  <span class="hljs-string">config</span>/<span class="hljs-string">consumer</span>.<span class="hljs-string">properties</span> <span class="hljs-built_in">--from-</span> <span class="hljs-string">beginning</span><br></code></pre></td></tr></table></figure><h2 id="3-4-Leader选举">3.4 Leader选举</h2><p>一条消息只有被<code>ISR</code>中的所有<code>follower</code>都从<code>leader</code>复制过去才会被认为已提交。这样就避免了部分数据被写进了<code>leader</code>，还没来得及被任何<code>follower</code>复制就宕机了，而造成数据丢失。而对于<code>producer</code>而言，它可以选择是否等待消息<code>commit</code>，这可以通过<code>request.required.acks</code>来设置。这种机制确保了只要<code>ISR</code>中有一个或者以上的<code>follower</code>，一条被<code>commit</code>的消息就不会丢失。</p><p>有一个很重要的问题是当<code>leader</code>宕机了，怎样在<code>follower</code>中选举出新的<code>leader</code>，因为<code>follower</code>可能落后很多或者直接<code>crash</code>了，所以必须确保选择“最新”的<code>follower</code>作为新的<code>leader</code>。一个基本的原则就是，如果<code>leader</code>不在了，新的<code>leader</code>必须拥有原来的<code>leader commit</code>的所有消息。这就需要做一个折中，如果<code>leader</code>在一个消息被<code>commit</code>前等待更多的<code>follower</code>确认，那么在它挂掉之后就有更多的follower可以成为新的<code>leader</code>，但这也会造成吞吐率的下降。</p><p>一种非常常用的选举<code>leader</code>的方式是“少数服从多数”，<code>Kafka</code>并不是采用这种方式。这种模式下，如果我们有2f+1个副本，那么在<code>commit</code>之前必须保证有f+1个<code>replica</code>复制完消息，同时为了保证能正确选举出新的<code>leader</code>，失败的副本数不能超过f个。这种方式有个很大的优势，系统的延迟取决于最快的几台机器，也就是说比如副本数为3，那么延迟就取决于最快的那个<code>follower</code>而不是最慢的那个。“少数服从多数”的方式也有一些劣势，为了保证<code>leader</code>选举的正常进行，它所能容忍的失败的<code>follower</code>数比较少，如果要容忍1个<code>follower</code>挂掉，那么至少要3个以上<code>的</code>副本，如果要容忍2个<code>follower</code>挂掉，必须要有5个以上的副本。也就是说，在生产环境下为了保证较高的容错率，必须要有大量的副本，而大量的副本又会在大数据量下导致性能的急剧下降。这种算法更多用在<code>Zookeeper</code>这种共享集群配置的系统中而很少在需要大量数据的系统中使用的原因。<code>HDFS</code>的<code>HA</code>功能也是基于“少数服从多数”的方式，但是其数据存储并不是采用这样的方式。</p><p>实际上，<code>leader</code>选举的算法非常多，比如<code>Zookeeper</code>的<code>Zab</code>、<code>Raft</code>以及<code>Viewstamped Replication</code>。而<code>Kafka</code>所使用的<code>leader</code>选举算法更像是微软的<code>PacificA</code>算法。</p><p><code>Kafka</code>在<code>Zookeeper</code>中为每一个<code>partition</code>动态的维护了一个<code>ISR</code>，这个<code>ISR</code>里的所有<code>replica</code>都跟上了<code>leader</code>，只有<code>ISR</code>里的成员才能有被选为<code>leader</code>的可能（<code>unclean.leader.election.enable=false</code>）。在这种模式下，对于f+1个副本，一个<code>Kafka topic</code>能在保证不丢失已经<code>commit</code>消息的前提下容忍f个副本的失败，在大多数使用场景下，这种模式是十分有利的。事实上，为了容忍f个副本的失败，“少数服从多数”的方式和ISR在<code>commit</code>前需要等待的副本的数量是一样的，但是ISR需要的总的副本的个数几乎是“少数服从多数”的方式的一半。</p><p>上文提到，在<code>ISR</code>中至少有一个<code>follower</code>时，<code>Kafka</code>可以确保已经<code>commit</code>的数据不丢失，但如果某一个<code>partition</code>的所有<code>replica</code>都挂了，就无法保证数据不丢失了。这种情况下有两种可行的方案：</p><p>等待<code>ISR</code>中任意一个<code>replica</code>“活”过来，并且选它作为<code>leader</code>选择第一个“活”过来的<code>replica</code>（并不一定是在<code>ISR</code>中）作为<code>leader</code>这就需要在可用性和一致性当中作出一个简单的抉择。如果一定要等待<code>ISR</code>中的<code>replica</code>“活”过来，那不可用的时间就可能会相对较长。而且如果<code>ISR</code>中所有的<code>replica</code>都无法“活”过来了，或者数据丢失了，这个<code>partition</code>将永远不可用。选择第一个“活”过来的<code>replica</code>作为<code>leader</code>,而这个<code>replica</code>不是ISR中的<code>replica</code>,那即使它并不保障已经包含了所有已<code>commit</code>的消息，它也会成为<code>leader</code>而作为<code>consumer</code>的数据源。默认情况下，<code>Kafka</code>采用第二种策略，即<code>unclean.leader.election.enable=true</code>，也可以将此参数设置为false来启用第一种策略。</p><p><code>unclean.leader.election.enable</code>这个参数对于<code>leader</code>的选举、系统的可用性以及数据的可靠性都有至关重要的影响。下面我们来分析下几种典型的场景。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/format,png-20220106142829417.png" class="" title="这里写图片描述"><p>如果上图所示，假设某个<code>partition</code>中的副本数为3，<code>replica-0, replica-1, replica-2</code>分别存放在<code>broker0, broker1</code>和<code>broker2</code>中。<code>AR=(0,1,2)，ISR=(0,1)</code>。<br>设置<code>request.required.acks=-1, min.insync.replicas=2，unclean.leader.election.enable=false</code>。这里将<code>broker0</code>中的副本也称之为<code>broker0</code>起初<code>broker0</code>为<code>leader</code>，<code>broker1</code>为<code>follower</code>。</p><ul><li><p>当<code>ISR</code>中的<code>replica-0</code>出现<code>crash</code>的情况时，<code>broker1</code>选举为新的<code>leader[ISR=(1)]</code>，因为受<code>min.insync.replicas=2</code>影响，<code>write</code>不能服务，但是<code>read</code>能继续正常服务。此种情况恢复方案：</p><ol><li>尝试恢复(重启)<code>replica-0</code>，如果能起来，系统正常；</li><li>如果<code>replica-0</code>不能恢复，需要将<code>min.insync.replicas</code>设置为1，恢复<code>write</code>功能。</li></ol></li><li><p>当<code>ISR</code>中的<code>replica-0</code>出现<code>crash</code>，紧接着<code>replica-1</code>也出现了<code>crash</code>, 此时<code>[ISR=(1),leader=-1]</code>,不能对外提供服务，此种情况恢复方案：</p><ol><li>尝试恢复<code>replica-0</code>和<code>replica-1</code>，如果都能起来，则系统恢复正常；</li><li>如果<code>replica-0</code>起来，而<code>replica-1</code>不能起来，这时候仍然不能选出<code>leader</code>，因为当设置<code>unclean.leader.election.enable=false</code>时，<code>leader</code>只能从<code>ISR</code>中选举，当<code>ISR</code>中所有副本都失效之后，需要<code>ISR</code>中最后失效的那个副本能恢复之后才能选举<code>leader</code>, 即<code>replica-0</code>先失效，<code>replica-1</code>后失效，需要<code>replica-1</code>恢复后才能选举<code>leader</code>。保守的方案建议<code>unclean.leader.election.enable</code>设置为<code>true</code>,但是这样会有丢失数据的情况发生，这样可以恢复<code>read</code>服务。同样需要将<code>min.insync.replicas</code>设置为1，恢复<code>write</code>功能；</li><li><code>replica-1</code>恢复，<code>replica-0</code>不能恢复，这个情况上面遇到过，<code>read</code>服务可用，需要将<code>min.insync.replicas</code>设置为1，恢复<code>write</code>功能；</li><li><code>replica-0</code>和<code>replica-1</code>都不能恢复，这种情况可以参考情形2.</li></ol></li><li><p>当<code>ISR</code>中的<code>replica-0, replica-1</code>同时宕机,此时<code>[ISR=(0,1)]</code>,不能对外提供服务，此种情况恢复方案：尝试恢复<code>replica-0</code>和<code>replica-1</code>，当其中任意一个副本恢复正常时，对外可以提供<code>read</code>服务。直到2个副本恢复正常，<code>write</code>功能才能恢复，或者将将<code>min.insync.replicas</code>设置为1。</p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220106145637929.png" class="" title="image-20220106145637929"></li></ul><h2 id="3-5-Kafka-高效读写数据">3.5 Kafka  高效读写数据</h2><p><strong>1）顺序写磁盘</strong></p><p><code>Kafka</code> 的 <code>producer</code> 生产数据，要写入到 <code>log</code> 文件中，写的过程是一直追加到文件末端， 为顺序写。官网有数据表明，同样的磁盘，顺序写能到  600M/s，而随机写只有  100K/s。这 与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。</p><p><strong>2）零复制技术</strong></p><img src="/dajiangdahe/2022/01/04/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20220106145550166.png" class="" title="image-20220106145550166"><h2 id="3-6-Kafka-事务">3.6 Kafka 事务</h2><p><code>Kafka</code> 从 0.11 版本开始引入了事务支持。事务可以保证  <code>Kafka</code> 在 <code>Exactly Once</code> 语义的基 础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p><h3 id="3-6-1-Producer-事务">3.6.1 Producer 事务</h3><p>为了实现跨分区跨会话的事务，需要引入一个全局唯一的 <code>Transaction ID</code>，并将 <code>Producer</code> 获得的 <code>PID </code>和 <code>Transaction ID</code> 绑定。这样当 <code>Producer</code> 重启后就可以通过正在进行的 <code>Transaction ID </code>获得原来的 <code>PID</code>。</p><p>为了管理 <code>Transaction</code>，<code>Kafka</code> 引入了一个新的组件<code> Transaction Coordinator</code>。<code>Producer</code> 就 是通过和 <code>Transaction Coordinator</code> 交互获得 <code>Transaction ID </code>对应的任务状态。<code>Transaction Coordinator </code>还负责将事务所有写入 <code>Kafka</code> 的一个内部 <code>Topic</code>，这样即使整个服务重启，由于 事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p><h3 id="3-6-2-Consumer-事务">3.6.2 Consumer 事务</h3><p>上述事务机制主要是从 <code>Producer</code> 方面考虑，对于 <code>Consumer</code> 而言，事务的保证就会相对 较弱，尤其时无法保证 <code>Commit</code> 的信息被精确消费。这是由于 <code>Consumer</code> 可以通过 <code>offset</code> 访 问任意信息，而且不同的 <code>Segment File</code> 生命周期不同，同一事务的消息可能会出现重启后被 删除的情况。</p>]]></content>
    
    
    <categories>
      
      <category>kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper_kafka_kafka-Manager单机集群环境安装</title>
    <link href="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <url>/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1>zookeeper_kafka_kafka-Manager单机集群环境安装</h1><h2 id="docker环境">docker环境</h2><p>本文使用<code>docker</code>环境下安装集群环境，通过<code>kafka-Manager</code>来进行可视化管理</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">https</span>://<span class="hljs-string">www</span>.<span class="hljs-string">docker</span>.<span class="hljs-string">com</span>/<span class="hljs-built_in">get-started</span> 选择合适的桌面版进行安装<br></code></pre></td></tr></table></figure><p><code>docker</code>换国内镜像源</p><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220103205020654.png" class="" title="image-20220103205020654"><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>,<br>    <span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><br>  ]<br></code></pre></td></tr></table></figure><p>如果是mac m1 芯片，需要将<code>experimental</code>:<code>true</code>在运行<code>image</code>时不会报错。</p><h2 id="zookeeper-kafka环境">zookeeper+kafka环境</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker pull wurstmeister/zookeeper<br>docker pull wurstmeister/kafka<br></code></pre></td></tr></table></figure><h3 id="zookeeper伪集群安装">zookeeper伪集群安装</h3><ul><li><p>这里演示使用。如需高可用，则最好部署多台zk节点。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> -d --name zoo1 -p 2181:2181  -t wurstmeister/zookeeper</span><br><span class="hljs-comment"># ip地址：172.17.0.2</span><br>docker <span class="hljs-keyword">run</span><span class="bash"> -d --name zoo2 -p 2182:2181  -t wurstmeister/zookeeper</span><br><span class="hljs-comment"># ip地址：172.17.0.3</span><br>docker <span class="hljs-keyword">run</span><span class="bash"> -d --name zoo3 -p 2183:2181 -t wurstmeister/zookeeper</span><br><span class="hljs-comment"># ip地址：172.17.0.4</span><br></code></pre></td></tr></table></figure></li><li><p>默认容器内配置文件在<code>/conf/zoo.cfg</code>，数据和日志目录默认在<code>/data</code> 和 <code>/datalog</code>，需要的话可以将上述目录映射到宿主机的可靠文件目录下。</p><p><code>/conf/zoo.cfg</code>如下图所示。</p><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220109193551584.png" class="" title="image-20220109193551584"></li><li><p>将集群节点写入<code>zoo.cfg</code></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">server.1=172.17.0.2:2888:3888<br>server.2=172.17.0.3:2888:3888<br>server.3=172.17.0.4:2888:3888<br></code></pre></td></tr></table></figure><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220109194454721.png" class="" title="image-20220109194454721"><p>3台机器分别配置一样的</p><ol><li>clientPort：客户端连接端口，监听客户端连接的端口</li><li>dataDir：数据文件目录+数据持久化路径</li><li>dataLogDir：日志文件目录</li><li>tickTime：通信心跳数，Zookeeper服务器心跳时间，单位毫秒<ol><li>Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒。</li><li>它用于心跳机制，并且设置最小的session超时时间为两倍心跳时间。(session的最小超时时间是2*tickTime)</li></ol></li><li>initLimit：leader(L)-follower(F)初始通信时限。集群中的follower跟随者服务器(F)与leader领导者服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的Zookeeper服务器连接到Leader的时限。投票选举新leader的初始化时间Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在initLimit时间内完成这个工作。</li><li>syncLimit：leader(L)-follower(F)同步通信时限。 集群中Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime，Leader认为Follwer死掉，从服务器列表中删除Follwer。在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果L发出心跳包在syncLimit之后，还没有从F那收到响应，那么就认为这个F已经不在线了。</li></ol><p><strong>配置myid:</strong></p><p>在zookeeper/data目录下创建<strong>myid</strong>，并配置id，里面的<strong>id一定要和上面配置的server.id一致</strong>，比如我1的服务器，id就是1，就是server.后面的1 server.1(<a href="http://server.id">server.id</a>)</p><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220109195350734.png" class="" title="image-20220109195350734"><p>同理配置其他2台服务器myid、conf。</p><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220109195905491.png" class="" title="image-20220109195905491"><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220109195928105.png" class="" title="image-20220109195928105"><p><strong>启动集群并查看状态</strong></p><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220110104519310.png" class="" title="image-20220110104519310"><p>依次启动zoo2，zoo3。</p><p><code>./zkServer.sh status</code>查看状态。如果<code>mode</code>显示<code>standalone</code>，则需要重启容器。</p><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220110124143375.png" class="" title="image-20220110124143375"><h3 id="kafka集群安装">kafka集群安装</h3><ul><li><p>使用docker命令可快速在同一台机器搭建多个kafka，只需要改变端口即可</p></li><li><p>节点1</p><blockquote><ol><li>此处zk地址不能使用127.0.0.1或者localhost。 如果IP变了之后需要重新生成容器</li><li>端口 2181 即zk地址</li><li>如果是docker集群搭建，将KAFKA_ZOOKEEPER_CONNECT设置成docker对应容器的地址</li></ol></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash">  -itd --name kafka1 -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=172.17.0.2:2181,172.17.0.3:2182,172.17.0.4:2183 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://172.17.0.2:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -t wurstmeister/kafka</span><br></code></pre></td></tr></table></figure></li><li><p>节点2</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash">  -itd --name kafka2 -p 9093:9093 -e KAFKA_BROKER_ID=1 -e KAFKA_ZOOKEEPER_CONNECT=172.17.0.2:2181,172.17.0.3:2182,172.17.0.4:2183 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://172.17.0.3:9093 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9093 -t wurstmeister/kafka</span><br></code></pre></td></tr></table></figure></li><li><p>节点3</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash">  -itd --name kafka3 -p 9094:9094 -e KAFKA_BROKER_ID=2 -e KAFKA_ZOOKEEPER_CONNECT=172.17.0.2:2181,172.17.0.3:2182,172.17.0.4:2183 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://172.17.0.4:9094 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9094 -t wurstmeister/kafka</span><br></code></pre></td></tr></table></figure></li><li><p>最终kafka集群搭建完成，对应端口为 9092、9093、9094 通过命令docker ps</p><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220103204913426.png" class="" title="image-20220103204913426"></li></ul><h4 id="kafka的Linux-version">kafka的Linux version</h4><blockquote><p>Linux version 5.10.76-linuxkit (root@buildkitsandbox) (gcc (Alpine 10.2.1_pre1) 10.2.1 20201203, GNU ld (GNU Binutils) 2.35.2) #1 SMP PREEMPT Mon Nov 8 11:22:26 UTC 2021</p></blockquote><p>在安装<code>vim</code>时，需要使用<code>apk add</code>命令。</p><h2 id="kafka-manager环境">kafka-manager环境</h2><p>使用<code>docker pull</code>下载安装包</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker pull kafka-manager<br></code></pre></td></tr></table></figure><p>运行<code>image</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> -itd --name=kafka-manager -p 9000:9000 -e ZK_HOSTS=<span class="hljs-string">&quot;172.17.0.2:2181,172.17.0.3:2182,172.17.0.4:2183&quot;</span> sheepkiller/kafka-manager</span><br></code></pre></td></tr></table></figure><h3 id="topic创建">topic创建</h3><ul><li><p>访问localhost:9000</p><blockquote><p>注意：如果访问界面一直登陆不进去，需要进入<code>kafka-manager</code>目录将其RUNNING_PID删除即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf RUNNING_PID<br></code></pre></td></tr></table></figure></blockquote></li><li><p>创建集群页面，其中<code>zookeeper</code>地址填入<code>172.17.0.2:2181,172.17.0.3:2182,172.17.0.4:2183</code>。其余默认</p><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220109203222567.png" class="" title="image-20220109203222567"></li><li><p>创建topic，只填入名字，其余默认</p></li><li><p>topic列表</p><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220109203401144.png" class="" title="image-20220109203401144"></li></ul><h3 id="java环境测试">java环境测试</h3><ul><li><p>pom文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>bjut.kengkeng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>kafka01<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>kafka01<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka_2.12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>21.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li><li><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> bjut.kengkeng.kafka01.producer;<br><br><span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.Producer;<br><span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;<br><span class="hljs-keyword">import</span> org.apache.kafka.common.serialization.StringSerializer;<br><br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaProducer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Producer&lt;String, String&gt; producer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String TOPIC = <span class="hljs-string">&quot;kafka-1&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">KafkaProducer</span><span class="hljs-params">()</span> </span>&#123;<br>        Properties properties = <span class="hljs-keyword">new</span> Properties();<br><br>        <span class="hljs-comment">// kafka端口</span><br>        properties.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;172.17.0.5:9092,172.17.0.6:9093,172.17.0.7:9094&quot;</span>);<br><br>        <span class="hljs-comment">// 配置value的序列化类</span><br>        <span class="hljs-comment">//properties.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br>        properties.put(<span class="hljs-string">&quot;value.serializer&quot;</span>, StringSerializer.class.getName());<br><br>        <span class="hljs-comment">// 配置key的序列化</span><br>        properties.put(<span class="hljs-string">&quot;key.serializer&quot;</span>, StringSerializer.class.getName());<br><br>        <span class="hljs-comment">//request.required.acks</span><br>        <span class="hljs-comment">//0, which means that the producer never waits for an acknowledgement from the broker (the same behavior as 0.7). This option provides the lowest latency but the weakest durability guarantees (some data will be lost when a server fails).</span><br>        <span class="hljs-comment">//1, which means that the producer gets an acknowledgement after the leader replica has received the data. This option provides better durability as the client waits until the server acknowledges the request as successful (only messages that were written to the now-dead leader but not yet replicated will be lost).</span><br>        <span class="hljs-comment">//-1, which means that the producer gets an acknowledgement after all in-sync replicas have received the data. This option provides the best durability, we guarantee that no messages will be lost as long as at least one in sync replica remains.</span><br>        properties.put(<span class="hljs-string">&quot;request.required.acks&quot;</span>, <span class="hljs-string">&quot;-1&quot;</span>);<br><br>        producer = <span class="hljs-keyword">new</span> org.apache.kafka.clients.producer.KafkaProducer&lt;&gt;(properties);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> messageNo = <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT = <span class="hljs-number">100000</span>;<br>        <span class="hljs-keyword">while</span> (messageNo &lt; COUNT) &#123;<br>            String key = String.valueOf(messageNo);<br>            String data = <span class="hljs-string">&quot;hello kafka message &quot;</span> + key;<br>            producer.send(<span class="hljs-keyword">new</span> ProducerRecord&lt;&gt;(TOPIC, key, data));<br>            System.out.println(data);<br>            messageNo ++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> KafkaProducer().producer();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> bjut.kengkeng.kafka01.consumer;<br><br><span class="hljs-keyword">import</span> bjut.kengkeng.kafka01.producer.KafkaProducer;<br><span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;<br><span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;<br><span class="hljs-keyword">import</span> org.apache.kafka.common.serialization.StringDeserializer;<br><br><span class="hljs-keyword">import</span> java.time.Duration;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaConsumer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> org.apache.kafka.clients.consumer.KafkaConsumer consumer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">KafkaConsumer</span><span class="hljs-params">()</span> </span>&#123;<br><br>        Properties props = <span class="hljs-keyword">new</span> Properties();<br>        props.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;172.17.0.2:2181,172.17.0.3:2182,172.17.0.4:2183&quot;</span>);<br>        props.put(<span class="hljs-string">&quot;group.id&quot;</span>, <span class="hljs-string">&quot;zbj-group&quot;</span>);<br>        props.put(<span class="hljs-string">&quot;max.poll.records&quot;</span>, <span class="hljs-number">100</span>);<br>        props.put(<span class="hljs-string">&quot;enable.auto.commit&quot;</span>, <span class="hljs-string">&quot;false&quot;</span>);<br>        props.put(<span class="hljs-string">&quot;auto.commit.interval.ms&quot;</span>, <span class="hljs-string">&quot;1000&quot;</span>);<br>        props.put(<span class="hljs-string">&quot;session.timeout.ms&quot;</span>, <span class="hljs-string">&quot;30000&quot;</span>);<br>        <span class="hljs-comment">//props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br>        props.put(<span class="hljs-string">&quot;key.deserializer&quot;</span>, StringDeserializer.class.getName());<br>        props.put(<span class="hljs-string">&quot;value.deserializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);<br>        consumer = <span class="hljs-keyword">new</span> org.apache.kafka.clients.consumer.KafkaConsumer(props);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;<br><br>        consumer.subscribe(Arrays.asList(KafkaProducer.TOPIC));<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> minBatchSize = <span class="hljs-number">200</span>;<br>        List&lt;ConsumerRecord&lt;String, String&gt;&gt; buffer = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">100</span>));<br>            <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;<br>                buffer.add(record);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (buffer.size() &gt;= minBatchSize) &#123;<br>                <span class="hljs-comment">// 入库操作</span><br>                <span class="hljs-comment">//insertIntoDb(buffer);</span><br>                <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : buffer) &#123;<br>                    System.out.println(record.key() + <span class="hljs-string">&quot;-&gt; &quot;</span> + record.value());<br>                &#125;<br><br>                consumer.commitSync();<br>                buffer.clear();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> KafkaConsumer().consume();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>测试</p><ul><li>先启动消费者</li><li>在启动生产者</li><li>成功</li></ul><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220103205931974.png" class="" title="image-20220103205931974"><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220103205957638-1214798.png" class="" title="image-20220103205957638"><img src="/dajiangdahe/2022/01/03/zookeeper_kafka_kafka-Manager%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/image-20220103210120872.png" class="" title="image-20220103210120872"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定时提醒脚本</title>
    <link href="/dajiangdahe/2021/12/28/%E5%AE%9A%E6%97%B6%E6%8F%90%E9%86%92%E8%84%9A%E6%9C%AC/"/>
    <url>/dajiangdahe/2021/12/28/%E5%AE%9A%E6%97%B6%E6%8F%90%E9%86%92%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1>通过server酱实现定时提醒XXX功能，配合其他爬虫使用更香😬</h1><p><code>Apscheduler</code>包是python执行定时任务的包，通过将执行函数放入<code>scheduler</code>中实现阻塞队列。<code>scheduler.add_job</code>方法中写入<code>cron</code>类型，选择合适的时间即可实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen<br><span class="hljs-keyword">from</span> apscheduler.schedulers.blocking <span class="hljs-keyword">import</span> BlockingScheduler<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-comment"># 获取天气情况</span><br><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_weather</span>():</span><br>    <span class="hljs-comment"># 济南编码：101120101</span><br>    <span class="hljs-comment"># 北京编码：101010100</span><br>    <span class="hljs-comment"># 常州编码：101191101</span><br>    <span class="hljs-comment"># 成都编码：101270101</span><br>    resp = urlopen(<span class="hljs-string">&#x27;http://www.weather.com.cn/weather/101270101.shtml&#x27;</span>)<br>    soup = BeautifulSoup(resp, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    tagDate = soup.find(<span class="hljs-string">&#x27;ul&#x27;</span>, class_=<span class="hljs-string">&quot;t clearfix&quot;</span>)<br>    dates = tagDate.h1.string<br><br>    tagToday = soup.find(<span class="hljs-string">&#x27;p&#x27;</span>, class_=<span class="hljs-string">&quot;tem&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        temperatureHigh = tagToday.span.string<br>    <span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:<br>        temperatureHigh = tagToday.find_next(<span class="hljs-string">&#x27;p&#x27;</span>, class_=<span class="hljs-string">&quot;tem&quot;</span>).span.string<br><br>    temperatureLow = tagToday.i.string<br>    weather = soup.find(<span class="hljs-string">&#x27;p&#x27;</span>, class_=<span class="hljs-string">&quot;wea&quot;</span>).string<br><br>    tagWind = soup.find(<span class="hljs-string">&#x27;p&#x27;</span>, class_=<span class="hljs-string">&quot;win&quot;</span>)<br>    winL = tagWind.i.string<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;今天是：&#x27;</span> + dates)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;风级：&#x27;</span> + winL)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最低温度：&#x27;</span> + temperatureLow)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;最高温度：&#x27;</span> + temperatureHigh)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;天气：&#x27;</span> + weather)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;- 今天是：&#x27;</span> + dates + <span class="hljs-string">&#x27;\n&#x27;</span> \<br>           + <span class="hljs-string">&#x27;- 风级：&#x27;</span> + winL + <span class="hljs-string">&#x27;\n&#x27;</span> \<br>           + <span class="hljs-string">&#x27;- 最低温度：&#x27;</span> + temperatureLow + <span class="hljs-string">&#x27;\n&#x27;</span> \<br>           + <span class="hljs-string">&#x27;- 最高温度：&#x27;</span> + temperatureHigh + <span class="hljs-string">&#x27;\n&#x27;</span> \<br>           + <span class="hljs-string">&#x27;- 天气：&#x27;</span> + weather<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">server_jiang_push</span>():</span><br>    <span class="hljs-comment"># SCT107154Tql4S5x7TkGJR8yyFSKBK2IpN 玲玲sendKey</span><br>    <span class="hljs-comment"># SCT107162To1V84RPruXW4TpOdshLHIxZq 娇娇sendKey</span><br>    <span class="hljs-comment"># SCT107171T5ezOqVN1e4QVarvp7D1YxbiC 死鱼sendKey</span><br>    <span class="hljs-comment"># SCT107509TRGThxFFS38QoqO7CBPZywvey 老大</span><br>    SCKEY = <span class="hljs-string">&#x27;SCT107509TRGThxFFS38QoqO7CBPZywvey&#x27;</span>  <span class="hljs-comment"># server酱的sendKey</span><br>    title = <span class="hljs-string">&#x27;坑坑天气小助手&#x27;</span><br>    message = get_weather()<br>    requests.post(<span class="hljs-string">f&#x27;https://sc.ftqq.com/<span class="hljs-subst">&#123;SCKEY&#125;</span>.send?title=<span class="hljs-subst">&#123;title&#125;</span>&amp;desp=<span class="hljs-subst">&#123;message&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 定时任务</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">job</span>():</span><br>    <span class="hljs-built_in">print</span>(datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))<br>    <span class="hljs-comment"># BlockingScheduler</span><br>    scheduler = BlockingScheduler(timezone=<span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span>)<br>    scheduler.add_job(server_jiang_push, <span class="hljs-string">&#x27;cron&#x27;</span>, day_of_week=<span class="hljs-string">&#x27;0-6&#x27;</span>, hour=<span class="hljs-number">22</span>, minute=<span class="hljs-number">21</span>)<br>    scheduler.start()<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    job()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>脚本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>定时提醒脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1984</title>
    <link href="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/"/>
    <url>/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/</url>
    
    <content type="html"><![CDATA[<h1>1984(乔治奥威尔)</h1><h2 id="◆-第1章-代译序（1）">◆ 第1章 代译序（1）</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223552038.png" class="" title="image-20211226223552038"><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223608691.png" class="" title="image-20211226223608691"><h2 id="◆-第2章-代译序（2">◆ 第2章 代译序（2)</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223638567.png" class="" title="image-20211226223638567"><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223649762.png" class="" title="image-20211226223649762"><h2 id="◆-第3章">◆ 第3章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223701777.png" class="" title="image-20211226223701777"><h2 id="◆-第4章">◆ 第4章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223713648.png" class="" title="image-20211226223713648"><h2 id="◆-第5章">◆ 第5章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223727079.png" class="" title="image-20211226223727079"><h2 id="◆-第6章">◆ 第6章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223745653.png" class="" title="image-20211226223745653"><h2 id="◆-第7章">◆ 第7章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223801831.png" class="" title="image-20211226223801831"><h2 id="◆-第8章">◆ 第8章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223813364.png" class="" title="image-20211226223813364"><h2 id="◆-第9章">◆ 第9章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223824104.png" class="" title="image-20211226223824104"><h2 id="◆-第10章">◆ 第10章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223834238.png" class="" title="image-20211226223834238"><h2 id="◆-第12章">◆ 第12章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223844302.png" class="" title="image-20211226223844302"><h2 id="◆-第17章">◆ 第17章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223855249.png" class="" title="image-20211226223855249"><h2 id="◆-第18章">◆ 第18章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223906178.png" class="" title="image-20211226223906178"><h2 id="◆-第19章">◆ 第19章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223917216.png" class="" title="image-20211226223917216"><h2 id="◆-第20章">◆ 第20章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226223951380.png" class="" title="image-20211226223951380"><h2 id="◆-第24章">◆ 第24章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224003029.png" class="" title="image-20211226224003029"><h2 id="◆-第25章">◆ 第25章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224014321.png" class="" title="image-20211226224014321"><h2 id="◆-第26章">◆ 第26章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224036379.png" class="" title="image-20211226224036379"><h2 id="◆-第27章">◆ 第27章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224045960.png" class="" title="image-20211226224045960"><h2 id="◆-第30章">◆ 第30章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224056698.png" class="" title="image-20211226224056698"><h2 id="◆-第31章">◆ 第31章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224106728.png" class="" title="image-20211226224106728"><h2 id="◆-第33章">◆ 第33章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224116825.png" class="" title="image-20211226224116825"><h2 id="◆-第34章">◆ 第34章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224126126.png" class="" title="image-20211226224126126"><h2 id="◆-第35章">◆ 第35章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224135131.png" class="" title="image-20211226224135131"><h2 id="◆-第37章">◆ 第37章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224144663.png" class="" title="image-20211226224144663"><h2 id="◆-第38章">◆ 第38章</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224154107.png" class="" title="image-20211226224154107"><h2 id="◆-第39章-附录（1）">◆ 第39章 附录（1）</h2><img src="/dajiangdahe/2021/12/26/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%911984/image-20211226224204139.png" class="" title="image-20211226224204139">]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>政治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Remote Support for Password Authentication Was Removed on August 13, 2021.</title>
    <link href="/dajiangdahe/2021/12/16/remote:%20Support%20for%20password%20authentication%20was%20removed%20on%20August%2013,%202021./"/>
    <url>/dajiangdahe/2021/12/16/remote:%20Support%20for%20password%20authentication%20was%20removed%20on%20August%2013,%202021./</url>
    
    <content type="html"><![CDATA[<h1>remote: Support for password authentication was removed on August 13, 2021.</h1><p><a href="https://blog.csdn.net/weixin_41010198/article/details/119698015">https://blog.csdn.net/weixin_41010198/article/details/119698015</a></p>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux开机服务自启动问题</title>
    <link href="/dajiangdahe/2021/12/10/Linux%E5%BC%80%E6%9C%BA%E6%9C%8D%E5%8A%A1%E8%87%AA%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/"/>
    <url>/dajiangdahe/2021/12/10/Linux%E5%BC%80%E6%9C%BA%E6%9C%8D%E5%8A%A1%E8%87%AA%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Linux系统下服务开机自启动脚本基本三个步骤</p><ol><li>在初始化目录下创建 <code>/etc/init.d/xxx-service</code>文件</li><li>在文件中加入对应的环境变量以及case对应的启动命令内容</li><li>增加文件权限，建议选择<code>chmod 775 xxx-service</code></li><li>使用<code>chkconfig</code>or <code>sysv-rc-conf</code> <code>xxx-service on</code></li><li>使用<code>ps -ef | grep -i xxx-service</code>查询对应服务进程状态</li></ol><h1>1.tomcat服务开机自启动</h1><p>没有<code>tomcat</code>，<code>jdk</code>需要下一个</p><p>配置<code>/etc/profile</code>文件中的环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">unset i<br>unset -f pathmunge<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/jdk路径/jdk1.8.0_221<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JRE_HOME</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/jre<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CATALINA_HOME</span>=/tomcat路径/tomcat8<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CLASSPATH</span>=.:$&#123;JAVA_HOME&#125;/lib:<span class="hljs-variable">$&#123;JRE_HOME&#125;</span>/lib:<span class="hljs-variable">$CLASSPATH</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_PATH</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/bin:$&#123;JRE_HOME&#125;/bin:<span class="hljs-variable">$&#123;CATALINA_HOME&#125;</span>/bin<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$&#123;JAVA_PATH&#125;:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>编辑完成之后使用命令进行刷新环境变量</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>在 tomcat/bin 目录下面，增加 <a href="http://setenv.sh">setenv.sh</a> 配置，服务启动的时候会调用，同时配置java内存参数。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/tomcat/</span>bin/setenv.sh <span class="hljs-comment"># 自己路径</span><br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#add tomcat pid  </span><br><span class="hljs-attr">CATALINA_PID</span>=<span class="hljs-string">&quot;$CATALINA_BASE/tomcat.pid&quot;</span>  <br><span class="hljs-comment">#add java opts  </span><br><span class="hljs-attr">JAVA_OPTS</span>=<span class="hljs-string">&quot;-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m&quot;</span> <br></code></pre></td></tr></table></figure><p>增加tomcat.service，在/usr/lib/systemd/system目录下增加tomcat.service</p><p>输入命令编辑：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/tomcat.service<br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Apache Tomcat Web Application Container<br><span class="hljs-attr">After</span>=syslog.target network.target remote-fs.target nss-lookup.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=forking<br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&#x27;JAVA_HOME=/usr/local/java/jdk1.8.0_221/&#x27;</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&#x27;CATALINA_PID=/usr/local/tomcat/tomcat.pid&#x27;</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&#x27;CATALINA_HOME=/usr/local/tomcat/&#x27;</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&#x27;CATALINA_BASE=/usr/local/tomcat/&#x27;</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&#x27;CATALINA_OPTS=-Xms512M -Xmx1024M -server -XX:+UseParallelGC&#x27;</span><br><br><span class="hljs-attr">PIDFile</span>=/usr/local/tomcat/tomcat.pid<br><span class="hljs-attr">ExecStart</span>=/usr/local/tomcat/bin/startup.sh<br><span class="hljs-attr">ExecReload</span>=/bin/kill -s HUP <span class="hljs-variable">$MAINPID</span><br><span class="hljs-attr">ExecStop</span>=/bin/kill -s QUIT <span class="hljs-variable">$MAINPID</span><br><span class="hljs-attr">PrivateTmp</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>[unit]配置了服务的描述，规定了在network启动之后执行。</p><p>[service]配置了环境变量，JAVA_HOME，服务的pid，服务的启动，停止，重启，内存参数。</p><p>[install]配置了使用用户。</p><p>当需要启动多个tomcat时，复制多个tomcat安装文件在/usr/local/下，如/usr/local/tomcat2，并配置多个tomcat.service 如tomcat2.service，tomcat3.service 在配置中修改对应的路径即可。</p><p>因为配置pid，在启动的时候会在tomcat根目录生成tomcat.pid文件，停止之后删除。</p><p>同时tomcat在启动时候，执行start不会启动两个tomcat，保证始终只有一个tomcat服务在运行。</p><p>多个tomcat可以配置在多个目录下，使用不同的端口，互不影响。</p><p>移动到<code>tomcat/bin</code>目录</p><p>1.编写开机自启动脚本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/i</span>nit.d/tomcat<br></code></pre></td></tr></table></figure><p>2.脚本内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#!/bin/sh -e</span><br><span class="hljs-comment">### BEGIN TOMCAT SERVICE</span><br><span class="hljs-comment">### END INIT INFO</span><br> <br>export JAVA_HOME=<span class="hljs-regexp">/jdk路径/</span>jdk1.<span class="hljs-number">8.0</span><br>export JRE_HOME=<span class="hljs-variable">$JAVA_HOME</span>/jre<br>export PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br>export CLASSPATH=. <span class="hljs-comment"># 从/etc/profile里面可以复制</span><br>export CATALINA_HOME=<span class="hljs-regexp">/tomcat路径/</span>tomcat<br> <br>case <span class="hljs-string">&quot;$1&quot;</span> <span class="hljs-keyword">in</span><br>start)<br>        <span class="hljs-variable">$&#123;CATALINA_HOME&#125;</span><span class="hljs-regexp">/bin/</span>startup.sh<br>        <span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br>        ;;<br>stop)<br>        <span class="hljs-variable">$&#123;CATALINA_HOME&#125;</span><span class="hljs-regexp">/bin/</span>shutdown.sh<br>        <span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br>        ;;<br>debug)<br>        <span class="hljs-variable">$&#123;CATALINA_HOME&#125;</span><span class="hljs-regexp">/bin/</span>shutdown.sh<br>        <span class="hljs-variable">$&#123;CATALINA_HOME&#125;</span><span class="hljs-regexp">/bin/</span>catalina.sh run<br>        <span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br>        ;;<br>force-reload|restart)<br>        <span class="hljs-variable">$&#123;CATALINA_HOME&#125;</span><span class="hljs-regexp">/bin/</span>startup.sh<br>        <span class="hljs-variable">$&#123;CATALINA_HOME&#125;</span><span class="hljs-regexp">/bin/</span>shutdown.sh<br>        <span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br>        ;;<br> <br>*)<br>        echo <span class="hljs-string">&quot;Usage: /etc/init.d/tomcat &#123;start|stop|restart|force-reload|debug&#125;&quot;</span><br>        <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span><br>        ;;<br>esac<br> <br><span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这样，就可以通过<code>service tomcat start </code>来启动<code>tomcat</code>了。</p><p>3.设置开机自启动（在<code>ubuntu</code>系统中使用<code>sysv-rc-conf</code>代替<code>chkconfig</code>）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">chkconfig</span> tomcat <span class="hljs-literal">on</span><br></code></pre></td></tr></table></figure><p>4.查询<code>tomcat</code>进程状态</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> -i tomcat<br></code></pre></td></tr></table></figure><h2 id="JDK安装过程">JDK安装过程</h2><p>下载<code>jdk</code>对应安装包</p><p>解压到自选目录</p><p>编辑环境变量</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>导入信息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/java/jdk1.8.0_131 #自己的jdk路径<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JRE_HOME</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/jre<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CLASSPATH</span>=.:$&#123;JAVA_HOME&#125;/lib:<span class="hljs-variable">$&#123;JRE_HOME&#125;</span>/lib:<span class="hljs-variable">$CLASSPATH</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_PATH</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/bin:$&#123;JRE_HOME&#125;/bin<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$&#123;JAVA_PATH&#125;<br></code></pre></td></tr></table></figure><p>更新环境变量文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>查看java版本</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">java <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><h1>2.redis服务开机自启动</h1><p>1、设置<code>redis.conf</code>中<code>daemonize</code>为<code>yes</code>,确保守护进程开启。</p><p>2、编写开机自启动脚本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo cp <span class="hljs-regexp">/redis路径/u</span>tils<span class="hljs-regexp">/redis_init_script /</span>etc<span class="hljs-regexp">/init.d/</span>redis<br></code></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># chkconfig: 2345 10 90  </span><br><span class="hljs-comment"># description: Start and Stop redis   </span><br>  <br>PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin:/</span>sbin:<span class="hljs-regexp">/usr/</span>bin:/bin   <br>REDISPORT=<span class="hljs-number">6379</span>  <br>EXEC=<span class="hljs-regexp">/redis路径/</span>redis-server   <br>REDIS_CLI=<span class="hljs-regexp">/redis路径/</span>redis-cli   <br> <br>PIDFILE=<span class="hljs-regexp">/var/</span>run/redis.pid   <br>CONF=<span class="hljs-string">&quot;/redis路径/redis.conf&quot;</span>  <br>AUTH=<span class="hljs-string">&quot;1234&quot;</span>  <br><br>case <span class="hljs-string">&quot;$1&quot;</span> <span class="hljs-keyword">in</span>   <br>        start)   <br>                <span class="hljs-keyword">if</span> [ -f <span class="hljs-variable">$PIDFILE</span> ]   <br>                then   <br>                        echo <span class="hljs-string">&quot;$PIDFILE exists, process is already running or crashed.&quot;</span>  <br>                <span class="hljs-keyword">else</span>  <br>                        echo <span class="hljs-string">&quot;Starting Redis server...&quot;</span>  <br>                        <span class="hljs-variable">$EXEC</span> <span class="hljs-variable">$CONF</span>   <br>                fi   <br>                <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;$?&quot;</span>=<span class="hljs-string">&quot;0&quot;</span> ]   <br>                then   <br>                        echo <span class="hljs-string">&quot;Redis is running...&quot;</span>  <br>                fi   <br>                ;;   <br>        stop)   <br>                <span class="hljs-keyword">if</span> [ ! -f <span class="hljs-variable">$PIDFILE</span> ]   <br>                then   <br>                        echo <span class="hljs-string">&quot;$PIDFILE exists, process is not running.&quot;</span>  <br>                <span class="hljs-keyword">else</span>  <br>                        PID=$(cat <span class="hljs-variable">$PIDFILE</span>)   <br>                        echo <span class="hljs-string">&quot;Stopping...&quot;</span>  <br>                       <span class="hljs-variable">$REDIS_CLI</span> -p <span class="hljs-variable">$REDISPORT</span>  SHUTDOWN    <br>                        sleep <span class="hljs-number">2</span>  <br>                       <span class="hljs-keyword">while</span> [ -x <span class="hljs-variable">$PIDFILE</span> ]   <br>                       <span class="hljs-keyword">do</span>  <br>                                echo <span class="hljs-string">&quot;Waiting for Redis to shutdown...&quot;</span>  <br>                               sleep <span class="hljs-number">1</span>  <br>                        done   <br>                        echo <span class="hljs-string">&quot;Redis stopped&quot;</span>  <br>                fi   <br>                ;;   <br>        restart|force-reload)   <br>                <span class="hljs-variable">$&#123;0&#125;</span> stop   <br>                <span class="hljs-variable">$&#123;0&#125;</span> start   <br>                ;;   <br>        *)   <br>               echo <span class="hljs-string">&quot;Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;&quot;</span> &gt;&amp;<span class="hljs-number">2</span>  <br>                <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>  <br>esac<br></code></pre></td></tr></table></figure><p>3、写完后保存退出VI</p><p>4、设置权限</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">777</span> redis<br></code></pre></td></tr></table></figure><p>5、启动测试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/i</span>nit.d/redis start<br></code></pre></td></tr></table></figure><p>启动成功会提示如下信息：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Starting</span></span> Redis server...<br><span class="hljs-function"><span class="hljs-title">Redis</span></span> is running...<br></code></pre></td></tr></table></figure><p>6、设置开机自启动（在ubuntu系统中使用sysv-rc-conf代替chkconfig）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">chkconfig</span> redis <span class="hljs-literal">on</span><br></code></pre></td></tr></table></figure><p>7、关机重启测试</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">reboot</span><br></code></pre></td></tr></table></figure><p>8、<code>redis-cli</code>测试即可。</p><p>9、查询<code>redis</code>进程状态</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> -i redis<br></code></pre></td></tr></table></figure><h2 id="make安装过程">make安装过程</h2><p>需要先执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> redis-<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>如果没有<code>make</code>包</p><p>两种下载方式：</p><ol><li><p>有网状态</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> make<br></code></pre></td></tr></table></figure></li><li><p>静默状态</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">点击此链接 http:<span class="hljs-regexp">//</span>ftp.gnu.org<span class="hljs-regexp">/gnu/m</span>ake/make-<span class="hljs-number">4.2</span>.tar.gz下载make安装包<br></code></pre></td></tr></table></figure></li></ol><p>将<code>make</code>安装包移植到Linux系统解压安装包</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">tar -zxvf <span class="hljs-built_in">make</span><span class="hljs-number">-4.2</span>.tar.gz -C /usr/<span class="hljs-keyword">local</span>/<span class="hljs-built_in">make</span><br></code></pre></td></tr></table></figure><p>进入到解压后的目录里执行<code>./configure</code>命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./configure</span><br></code></pre></td></tr></table></figure><p>在<code>/usr/local/make/make-4.2</code>目录下执行make命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>在<code>/usr/local/make/</code>目录下执行<code>make install</code>命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">make <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>输入make可以进行源码包编译</p><h1>3.oracle服务开机自启动</h1><p>1.以root身份登录到linux系统</p><p>编辑<code>/etc/oratab</code>文件，找到（Red had和Centos 7禁止oracle启动）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">testsid</span>:/data/oracle/product/<span class="hljs-number">11</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>/db_<span class="hljs-number">1</span>:N<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">testsid</span>:/data/oracle/product/<span class="hljs-number">11</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>/db_<span class="hljs-number">1</span>:Y<br></code></pre></td></tr></table></figure><p>注意：<code>/data/oracle/product/11.2.0/db_1</code>为安装的<code>$ORACLE_HOME</code>，根据情况自行修改路径。</p><p>2.配置<code>/etc/rc.d/rc.local</code>,其中路径替换成自己的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>rc.d/rc.local<br><br><span class="hljs-comment"># 添加脚本内容</span><br>su oracle -lc <span class="hljs-string">&quot;/data/oracle/product/11.2.0/db_1/bin/lsnrctl start&quot;</span><br>su oracle -lc <span class="hljs-regexp">/data/</span>oracle<span class="hljs-regexp">/product/</span><span class="hljs-number">11.2</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/db_1/</span>bin/dbstart<br></code></pre></td></tr></table></figure><p>其中第一行因为lsnrctl之后有空格，需要引号，第二行加不加引号都可以。修改完保存退出即可。</p><img src="/dajiangdahe/2021/12/10/Linux%E5%BC%80%E6%9C%BA%E6%9C%8D%E5%8A%A1%E8%87%AA%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/image-20211211184913364.png" class="" title="image-20211211184913364"><p>3.在<code>/etc/init.d/</code>下创建oracle服务启动脚本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#!/bin/sh</span><br><span class="hljs-comment"># chkconfig: 345 61 61</span><br><span class="hljs-comment"># description: Oracle 11g R2 AutoRun Servimces</span><br><span class="hljs-comment"># /etc/init.d/oracle</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Run-level Startup script for the Oracle Instance, Listener, and</span><br><span class="hljs-comment"># Web Interface</span><br>export ORACLE_BASE=<span class="hljs-regexp">/data/</span>oracle    <span class="hljs-comment">#根据个人情况修改路径</span><br>export ORACLE_HOME=<span class="hljs-variable">$ORACLE_BASE</span><span class="hljs-regexp">/product/</span><span class="hljs-number">11.2</span>.<span class="hljs-number">0</span>/db_1<br>export ORACLE_SID=testsid          <span class="hljs-comment">#改成自己的ORACLE_SID:testsid</span><br>export PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$ORACLE_HOME</span>/bin<br>ORA_OWNR=<span class="hljs-string">&quot;oracle&quot;</span><br><span class="hljs-comment"># if the executables do not exist -- display error</span><br><span class="hljs-keyword">if</span> [ ! -f <span class="hljs-variable">$ORACLE_HOME</span><span class="hljs-regexp">/bin/</span>dbstart -o ! -d <span class="hljs-variable">$ORACLE_HOME</span> ]<br>then<br>echo <span class="hljs-string">&quot;Oracle startup: cannot start&quot;</span><br><span class="hljs-keyword">exit</span> <span class="hljs-number">1</span><br>fi<br><span class="hljs-comment"># depending on parameter -- startup, shutdown, restart</span><br><span class="hljs-comment"># of the instance and listener or usage display</span><br>case <span class="hljs-string">&quot;$1&quot;</span> <span class="hljs-keyword">in</span><br>start)<br><span class="hljs-comment"># Oracle listener and instance startup</span><br>su <span class="hljs-variable">$ORA_OWNR</span> -lc <span class="hljs-variable">$ORACLE_HOME</span><span class="hljs-regexp">/bin/</span>dbstart<br>echo <span class="hljs-string">&quot;Oracle Start Succesful!OK.&quot;</span><br>;;<br>stop)<br><span class="hljs-comment"># Oracle listener and instance shutdown</span><br>su <span class="hljs-variable">$ORA_OWNR</span> -lc <span class="hljs-variable">$ORACLE_HOME</span><span class="hljs-regexp">/bin/</span>dbshut<br>echo <span class="hljs-string">&quot;Oracle Stop Succesful!OK.&quot;</span><br>;;<br>reload|restart)<br><span class="hljs-variable">$0</span> stop<br><span class="hljs-variable">$0</span> start<br>;;<br>*)<br>echo $<span class="hljs-string">&quot;Usage: `basename $0` &#123;start|stop|reload|reload&#125;&quot;</span><br><span class="hljs-keyword">exit</span> <span class="hljs-number">1</span><br>esac<br><span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>4.赋予权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod <span class="hljs-number">777</span> <span class="hljs-regexp">/etc/i</span>nit.d/oracle<br></code></pre></td></tr></table></figure><p>5.配置Oracle监听开机自启动服务</p><p>修改dbstart和dbshut启动关闭脚本,使其启动数据库的同时也自动启动监听器（即启动数据库时启动监听器，停止数据库时停止监听器）：<br>执行脚本：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># vim <span class="hljs-regexp">/data/</span>oracle<span class="hljs-regexp">/product/</span><span class="hljs-number">11.2</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/db_1/</span>bin/dbstart  # 自己路径<br>找到下面的代码:<br>ORACLE_HOME_LISTNER=$<span class="hljs-number">1</span><br>将其改为<br>ORACLE_HOME_LISTNER=$ORACLE_HOME<br></code></pre></td></tr></table></figure><p>Dbstart修改结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Set path if path not set (if called from /etc/rc)</span><br><span class="hljs-attribute">SAVE_PATH</span>=/bin:/usr/bin:/etc:$&#123;PATH&#125; ; <span class="hljs-builtin-name">export</span> PATH<br><span class="hljs-attribute">SAVE_LLP</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span><br><br><span class="hljs-comment"># First argument is used to bring up Oracle Net Listener</span><br><span class="hljs-comment">#ORACLE_HOME_LISTNER=$1</span><br><span class="hljs-attribute">ORACLE_HOME_LISTNER</span>=<span class="hljs-variable">$ORACLE_HOME</span><br><span class="hljs-keyword">if</span> [ ! <span class="hljs-variable">$ORACLE_HOME_LISTNER</span> ] ; then<br>  echo <span class="hljs-string">&quot;ORACLE_HOME_LISTNER is not SET, unable to auto-start Oracle Net Listener&quot;</span><br>  echo <span class="hljs-string">&quot;Usage: <span class="hljs-variable">$0</span> ORACLE_HOME&quot;</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-attribute">LOG</span>=<span class="hljs-variable">$ORACLE_HOME_LISTNER</span>/listener.log<br></code></pre></td></tr></table></figure><p>同样也修改dbshut脚本：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># vim <span class="hljs-regexp">/data/</span>oracle<span class="hljs-regexp">/product/</span><span class="hljs-number">11.2</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/db_1/</span>bin/dbshut # 自己路径<br>找到下面的代码:<br>ORACLE_HOME_LISTNER=$<span class="hljs-number">1</span><br>将其改为<br>ORACLE_HOME_LISTNER=$ORACLE_HOME<br></code></pre></td></tr></table></figure><p>Dbshut修正结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Set path if path not set (if called from /etc/rc)</span><br><span class="hljs-attribute">SAVE_PATH</span>=/bin:/usr/bin:/etc:$&#123;PATH&#125; ; <span class="hljs-builtin-name">export</span> PATH<br><span class="hljs-attribute">SAVE_LLP</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span><br><br><span class="hljs-comment"># The  this to bring down Oracle Net Listener</span><br><span class="hljs-comment">#ORACLE_HOME_LISTNER=$1</span><br><span class="hljs-attribute">ORACLE_HOME_LISTNER</span>=<span class="hljs-variable">$ORACLE_HOME</span><br><span class="hljs-keyword">if</span> [ ! <span class="hljs-variable">$ORACLE_HOME_LISTNER</span> ] ; then<br>  echo <span class="hljs-string">&quot;ORACLE_HOME_LISTNER is not SET, unable to auto-stop Oracle Net Listener&quot;</span><br>  echo <span class="hljs-string">&quot;Usage: <span class="hljs-variable">$0</span> ORACLE_HOME&quot;</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-attribute">LOG</span>=<span class="hljs-variable">$ORACLE_HOME_LISTNER</span>/listener.log<br></code></pre></td></tr></table></figure><p>6.再度执行Oracle服务脚本</p><p>执行脚本：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/etc/rc.d/init.d</span><br><span class="hljs-string">./oracle</span> start<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@zm-centos7 <span class="hljs-regexp">/]# cd /</span>etc<span class="hljs-regexp">/rc.d/i</span>nit.d<br>[root@zm-centos7 init.d]<span class="hljs-comment"># ./oracle start</span><br>Processing Database instance <span class="hljs-string">&quot;testsid&quot;</span>: log file <span class="hljs-regexp">/data/</span>oracle<span class="hljs-regexp">/product/</span><span class="hljs-number">11.2</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/db_1/</span>startup.log<br>Oracle Start Succesful!OK.<br></code></pre></td></tr></table></figure><ol start="7"><li>加入自动启动行列</li></ol><p>执行脚本：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">ln –s <span class="hljs-regexp">/etc/</span>rc.d<span class="hljs-regexp">/init.d/</span>oracle <span class="hljs-regexp">/etc/</span>rc0.d/K61oracle<br>ln –s <span class="hljs-regexp">/etc/</span>rc.d<span class="hljs-regexp">/init.d/</span>oracle <span class="hljs-regexp">/etc/</span>rc2.d/S61oracle<br>ln –s <span class="hljs-regexp">/etc/</span>rc.d<span class="hljs-regexp">/init.d/</span>oracle <span class="hljs-regexp">/etc/</span>rc3.d/S61oracle<br>ln –s <span class="hljs-regexp">/etc/</span>rc.d<span class="hljs-regexp">/init.d/</span>oracle <span class="hljs-regexp">/etc/</span>rc4.d/S61oracle<br>ln –s <span class="hljs-regexp">/etc/</span>rc.d<span class="hljs-regexp">/init.d/</span>oracle <span class="hljs-regexp">/etc/</span>rc6.d/K61oracle<br></code></pre></td></tr></table></figure><p>8.将服务加入到系统服务</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">chkconfig <span class="hljs-comment">--level 234 oracle on</span><br>chkconfig <span class="hljs-comment">--add oracle</span><br></code></pre></td></tr></table></figure><p>检查 oracle服务是否已经生效</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">chkconfig <span class="hljs-comment">--list  oracle</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开机启动服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL是怎样运行的--小孩子</title>
    <link href="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
    <url>/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1>MySQL是怎样运行的–小孩子</h1><p>原书地址：<a href="https://juejin.cn/book/6844733769996304392">https://juejin.cn/book/6844733769996304392</a></p><h1><strong>1.重新认识MySQL</strong></h1><h2 id="MySQL的客户端／服务器架构">MySQL的客户端／服务器架构</h2><p>以我们平时使用的微信为例，它其实是由两部分组成的，一部分是客户端程序，一部分是服务器程序。客户端可能有很多种形式，比如手机APP，电脑软件或者是网页版微信，每个客户端都有一个唯一的用户名，就是你的微信号，另一方面，腾讯公司在他们的机房里运行着一个服务器软件，我们平时操作微信其实都是用客户端来和这个服务器来打交道。比如狗哥用微信给猫爷发了一条消息的过程其实是这样的：</p><ol><li>消息被客户端包装了一下，添加了发送者和接收者信息，然后从狗哥的微信客户端传送给微信服务器；</li><li>微信服务器从消息里获取到它的发送者和接收者，根据消息的接收者信息把这条消息送达到猫爷的微信客户端，猫爷的微信客户端里就显示出狗哥给他发了一条消息。</li></ol><p><code>MySQL</code>的使用过程跟这个是一样的，它的服务器程序直接和我们存储的数据打交道，然后可以有好多客户端程序连接到这个服务器程序，发送增删改查的请求，然后服务器就响应这些请求，从而操作它维护的数据。和微信一样，<code>MySQL</code>的每个客户端都需要提供用户名密码才能登录，登录之后才能给服务器发请求来操作某些数据。我们日常使用<code>MySQL</code>的情景一般是这样的：</p><ol><li>启动<code>MySQL</code>服务器程序。</li><li>启动<code>MySQL</code>客户端程序并连接到服务器程序。</li><li>在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果。</li></ol><p>我们知道计算机很牛逼，在一台计算机上可以同时运行多个程序，比如微信、QQ、音乐播放器、文本编辑器啥的，每一个运行着的程序也被称为一个<code>进程</code>。我们的<code>MySQL</code>服务器程序和客户端程序本质上都算是计算机上的一个<code>进程</code>，这个代表着<code>MySQL</code>服务器程序的进程也被称为<code>MySQL数据库实例</code>，简称<code>数据库实例</code>。</p><p>每个进程都有一个唯一的编号，称为<code>进程ID</code>，英文名叫<code>PID</code>，这个编号是在我们启动程序的时候由操作系统随机分配的，操作系统会保证在某一时刻同一台机器上的进程号不重复。比如你打开了计算机中的QQ程序，那么操作系统会为它分配一个唯一的进程号，如果你把这个程序关掉了，那操作系统就会把这个进程号回收，之后可能会重新分配给别的进程。当我们下一次再启动 QQ程序的时候分配的就可能是另一个编号。每个进程都有一个名称，这个名称是编写程序的人自己定义的，比如我们启动的<code>MySQL</code>服务器进程的默认名称为<code>mysqld</code>， 而我们常用的<code>MySQL</code>客户端进程的默认名称为<code>mysql</code>。</p><h2 id="MySQL的安装">MySQL的安装</h2><p>不论我们通过下载源代码自行编译安装的方式还是直接使用官方提供的安装包进行安装之后，<code>MySQL</code>的服务器程序和客户端程序都会被安装到我们的机器上。不论使用上述两者的哪种安装方式，一定一定一定（重要的话说三遍）要记住你把<code>MySQL</code>安装到哪了，换句话说，一定要记住<code>MySQL</code>的安装目录。</p><blockquote><p>小贴士： <code>MySQL</code>的大部分安装包都包含了服务器程序和客户端程序，不过在Linux下使用RPM包时会有单独的服务器RPM包和客户端RPM包，需要分别安装。</p></blockquote><p>另外，<code>MySQL</code>可以运行在各种各样的操作系统上，我们后边会讨论在类<code>UNIX</code>操作系统和<code>Windows</code>操作系统上使用的一些差别。为了方便大家理解，我在<code>macOS</code> 操作系统（苹果电脑使用的操作系统）和<code>Windows</code>操作系统上都安装了<code>MySQL</code>，它们的安装目录分别是：</p><ul><li><code>macOS</code>操作系统上的安装目录：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span><br></code></pre></td></tr></table></figure><ul><li><code>Windows</code>操作系统上的安装目录：</li></ul><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\M</span>ySQL<span class="hljs-symbol">\M</span>ySQL Server 5.7<br></code></pre></td></tr></table></figure><p>下边我会以这两个安装目录为例来进一步扯出更多的概念，不过一定要注意，这两个安装目录是我的运行不同操作系统的机器上的安装目录，一定要记着把下边示例中用到安装目录的地方替换为你自己机器上的安装目录。</p><blockquote><p>小贴士： 类UNIX操作系统非常多，比如FreeBSD、Linux、macOS、Solaris等都属于UNIX操作系统的范畴，我们这里使用macOS操作系统代表类UNIX操作系统来运行MySQL。</p></blockquote><h3 id="bin目录下的可执行文件">bin目录下的可执行文件</h3><p>在<code>MySQL</code>的安装目录下有一个特别特别重要的<code>bin</code>目录，这个目录下存放着许多可执行文件，以<code>macOS</code>系统为例，这个<code>bin</code>目录的绝对路径就是（在我的机器上）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>bin<br></code></pre></td></tr></table></figure><p>我们列出一些在<code>macOS</code>中这个<code>bin</code>目录下的一部分可执行文件来看一下（文件太多，全列出来会刷屏的）：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs elm">.<br>├── mysql<br>├── mysql.server -&gt; ../sup<span class="hljs-keyword">port</span>-files/mysql.server<br>├── mysqladmin<br>├── mysqlbinlog<br>├── mysqlcheck<br>├── mysqld<br>├── mysqld_multi<br>├── mysqld_safe<br>├── mysqldump<br>├── mysql<span class="hljs-keyword">import</span><br>├── mysqlpump<br>... (省略其他文件)<br><span class="hljs-number">0</span> directories, <span class="hljs-number">40</span> files<br></code></pre></td></tr></table></figure><p><code>Windows</code>中的可执行文件与<code>macOS</code>中的类似，不过都是以<code>.exe</code>为扩展名的。这些可执行文件都是与服务器程序和客户端程序相关的，后边我们会详细唠叨一些比较重要的可执行文件，现在先看看执行这些文件的方式。</p><p>对于有可视化界面的操作系统来说，我们拿着鼠标点点点就可以执行某个可执行文件，不过现在我们更关注在命令行环境下如何执行这些可执行文件，命令行通俗的说就是那些黑框框，这里的指的是类<code>UNIX</code>系统中的<code>Shell</code>或者<code>Windows</code>系统中的<code>cmd.exe</code>，如果你现在还不知道怎么启动这些命令行工具，网上搜搜吧～ 下边我们以<code>macOS</code>系统为例来看看如何启动这些可执行文件（<code>Windows</code>中的操作是类似的，依葫芦画瓢就好了）</p><ul><li><p>使用可执行文件的相对／绝对路径</p><p>假设我们现在所处的工作目录是<code>MySQL</code>的安装目录，也就是<code>/usr/local/mysql</code>，我们想启动<code>bin</code>目录下的<code>mysqld</code>这个可执行文件，可以使用相对路径来启动：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/my</span>sqld<br></code></pre></td></tr></table></figure><p>或者直接输入<code>mysqld</code>的绝对路径也可以：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/mysql/</span>bin/mysqld<br></code></pre></td></tr></table></figure></li><li><p>将该<code>bin</code>目录的路径加入到环境变量<code>PATH</code>中</p><p>如果我们觉得每次执行一个文件都要输入一串长长的路径名贼麻烦的话，可以把该<code>bin</code>目录所在的路径添加到环境变量<code>PATH</code>中。环境变量<code>PATH</code>是一系列路径的集合，各个路径之间使用冒号<code>:</code>隔离开，比方说我的机器上的环境变量<code>PATH</code>的值就是：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin:/u</span>sr<span class="hljs-regexp">/bin:/</span>bin:<span class="hljs-regexp">/usr/</span>sbin:/sbin<br></code></pre></td></tr></table></figure><p>我的系统中这个环境变量<code>PATH</code>的值表明：当我在输入一个命令时，系统便会在<code>/usr/local/bin</code>、<code>/usr/bin:</code>、<code>/bin:</code>、<code>/usr/sbin</code>、<code>/sbin</code>这些目录下依次寻找是否存在我们输入的那个命令，如果寻找成功，则执行该目录下对应的可执行文件。所以我们现在可以修改一下这个环境变量<code>PATH</code>，把<code>MySQL</code>安装目录下的<code>bin</code>目录的路径也加入到<code>PATH</code>中，在我的机器上修改后的环境变量<code>PATH</code>的值为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin:/u</span>sr<span class="hljs-regexp">/bin:/</span>bin:<span class="hljs-regexp">/usr/</span>sbin:<span class="hljs-regexp">/sbin:/u</span>sr<span class="hljs-regexp">/local/my</span>sql/bin<br></code></pre></td></tr></table></figure><p>这样现在不论我们所处的工作目录是啥，我们都可以直接输入可执行文件的名字就可以启动它，比如这样：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mysqld</span><br></code></pre></td></tr></table></figure><p>方便多了哈～</p><blockquote><p>小贴士： 关于啥是环境变量以及如何在当前系统中添加或修改系统变量不是我们唠叨的范围，大家找本相关的书或者上网查一查哈～</p></blockquote></li></ul><h2 id="启动MySQL服务器程序">启动MySQL服务器程序</h2><h3 id="UNIX里启动服务器程序">UNIX里启动服务器程序</h3><p>在类<code>UNIX</code>系统中用来启动<code>MySQL</code>服务器程序的可执行文件有很多，大多在<code>MySQL</code>安装目录的<code>bin</code>目录下，我们一起来瞅瞅。</p><h4 id="mysqld">mysqld</h4><p><code>mysqld</code>这个可执行文件就代表着<code>MySQL</code>服务器程序，运行这个可执行文件就可以直接启动一个服务器进程。但这个命令不常用，我们继续往下看更牛逼的启动命令。</p><h4 id="mysqld-safe">mysqld_safe</h4><p><code>mysqld_safe</code>是一个启动脚本，它会间接的调用<code>mysqld</code>，而且还顺便启动了另外一个监控进程，这个监控进程在服务器进程挂了的时候，可以帮助重启它。另外，使用<code>mysqld_safe</code>启动服务器程序时，它会将服务器程序的出错信息和其他诊断信息重定向到某个文件中，产生出错日志，这样可以方便我们找出发生错误的原因。</p><h4 id="mysql-server">mysql.server</h4><p><code>mysql.server</code>也是一个启动脚本，它会间接的调用<code>mysqld_safe</code>，在调用<code>mysql.server</code>时在后边指定<code>start</code>参数就可以启动服务器程序了，就像这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql.<span class="hljs-keyword">server</span> <span class="hljs-keyword">start</span><br></code></pre></td></tr></table></figure><p>需要注意的是，这个 <em><strong>mysql.server</strong></em> 文件其实是一个链接文件，它的实际文件是 <em><strong>…/support-files/mysql.server</strong></em>。我使用的<code>macOS</code>操作系统会帮我们在<code>bin</code>目录下自动创建一个指向实际文件的链接文件，如果你的操作系统没有帮你自动创建这个链接文件，那就自己创建一个呗～ 别告诉我你不会创建链接文件，上网搜搜呗～</p><p>另外，我们还可以使用<code>mysql.server</code>命令来关闭正在运行的服务器程序，只要把<code>start</code>参数换成<code>stop</code>就好了：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">mysql.<span class="hljs-built_in">server</span> <span class="hljs-keyword">stop</span><br></code></pre></td></tr></table></figure><h4 id="mysqld-multi">mysqld_multi</h4><p>其实我们一台计算机上也可以运行多个服务器实例，也就是运行多个<code>MySQL</code>服务器进程。<code>mysql_multi</code>可执行文件可以对每一个服务器进程的启动或停止进行监控。这个命令的使用比较复杂，本书主要是为了讲清楚<code>MySQL</code>服务器和客户端运行的过程，不会对启动多个服务器程序进行过多唠叨。</p><h3 id="Windows里启动服务器程序">Windows里启动服务器程序</h3><p><code>Windows</code>里没有像类<code>UNIX</code>系统中那么多的启动脚本，但是也提供了手动启动和以服务的形式启动这两种方式，下边我们详细看。</p><h4 id="mysqld-2">mysqld</h4><p>同样的，在<code>MySQL</code>安装目录下的<code>bin</code>目录下有一个<code>mysqld</code>可执行文件，在命令行里输入<code>mysqld</code>，或者直接双击运行它就算启动了<code>MySQL</code>服务器程序了。</p><h4 id="以服务的方式运行服务器程序">以服务的方式运行服务器程序</h4><p>首先看看啥是个<code>Windows</code> 服务？如果无论是谁正在使用这台计算机，我们都需要长时间的运行某个程序，而且需要在计算机启动的时候便启动它，一般我们都会把它注册为一个<code>Windows 服务</code>，操作系统会帮我们管理它。把某个程序注册为<code>Windows</code>服务的方式挺简单，如下：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;完整的可执行文件路径&quot;</span> --install [-manual] [服务名]<br></code></pre></td></tr></table></figure><p>其中的<code>-manual</code>可以省略，加上它的话表示在<code>Windows</code>系统启动的时候不自动启动该服务，否则会自动启动。<code>服务名</code>也可以省略，默认的服务名就是<code>MySQL</code>。比如我的<code>Windows</code>计算机上<code>mysqld</code>的完整路径是：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\M</span>ySQL<span class="hljs-symbol">\M</span>ySQL Server 5.7<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\m</span>ysqld<br></code></pre></td></tr></table></figure><p>所以如果我们想把它注册为服务的话可以在命令行里这么写：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">&quot;C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\M</span>ySQL<span class="hljs-symbol">\M</span>ySQL Server 5.7<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\m</span>ysqld&quot; --install<br></code></pre></td></tr></table></figure><p>在把<code>mysqld</code>注册为<code>Windows</code>服务之后，我们就可以通过下边这个命令来启动<code>MySQL</code>服务器程序了：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> MySQL<br></code></pre></td></tr></table></figure><p>当然，如果你喜欢图形界面的话，你可以通过<code>Windows</code>的服务管理器通过用鼠标点点点的方式来启动和停止服务（作为一个程序猿，还是用黑框框吧～）。</p><p>关闭这个服务也非常简单，只要把上边的<code>start</code>换成<code>stop</code>就行了，就像这样：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">net stop MySQL<br></code></pre></td></tr></table></figure><h2 id="启动MySQL客户端程序">启动MySQL客户端程序</h2><p>在我们成功启动<code>MySQL</code>服务器程序后，就可以接着启动客户端程序来连接到这个服务器喽，<code>bin</code>目录下有许多客户端程序，比方说<code>mysqladmin</code>、<code>mysqldump</code>、<code>mysqlcheck</code>等等等等（好多呢，就不一一列举了）。这里我们重点要关注的是可执行文件<code>mysql</code>，通过这个可执行文件可以让我们和服务器程序进程交互，也就是发送请求，接收服务器的处理结果。启动这个可执行文件时一般需要一些参数，格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -h主机名  -u用户名 -<span class="hljs-selector-tag">p</span>密码<br></code></pre></td></tr></table></figure><p>各个参数的意义如下：</p><table><thead><tr><th style="text-align:left">参数名</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>-h</code></td><td>表示服务器进程所在计算机的域名或者IP地址，如果服务器进程就运行在本机的话，可以省略这个参数，或者填<code>localhost</code>或者<code>127.0.0.1</code>。也可以写作 <code>--host=主机名</code>的形式。</td></tr><tr><td style="text-align:left"><code>-u</code></td><td>表示用户名。也可以写作 <code>--user=用户名</code>的形式。</td></tr><tr><td style="text-align:left"><code>-p</code></td><td>表示密码。也可以写作 <code>--password=密码</code>的形式。</td></tr></tbody></table><blockquote><p>小贴士： **像 h、u、p 这样名称只有一个英文字母的参数称为短形式的参数，使用时前边需要加单短划线，像 host、user、password 这样大于一个英文字母的参数称为长形式的参数，使用时前边需要加双短划线。**后边会详细讨论这些参数的使用方式的，稍安勿躁～</p></blockquote><p>比如我这样执行下边这个可执行文件(用户名密码按你的实际情况填写)，就可以启动<code>MySQL</code>客户端，并且连接到服务器了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span> -hlocalhost -uroot -p<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>我们看一下连接成功后的界面：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs smali">Welcome to the MySQ<span class="hljs-class">L monitor.  Commands end with ;</span><span class="hljs-built_in"> or </span>\g.<br>Your MySQL connection id is 2<br>Server version: 5.7.21 Homebrew<br><br>Copyright (c) 2000, 2018, Oracle<span class="hljs-built_in"> and/or </span>its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation<span class="hljs-built_in"> and/or </span>its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br>Type &#x27;help;&#x27;<span class="hljs-built_in"> or </span>&#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.<br><br>mysql&gt; <br></code></pre></td></tr></table></figure><p>最后一行的<code>mysql&gt;</code>是一个客户端的提示符，之后客户端发送给服务器的命令都需要写在这个提示符后边。</p><p>如果我们想断开客户端与服务器的连接并且关闭客户端的话，可以在<code>mysql&gt;</code>提示符后输入下边任意一个命令：</p><ol><li><code>quit</code></li><li><code>exit</code></li><li><code>\q</code></li></ol><p>比如我们输入<code>quit</code>试试：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">mysql&gt; <span class="hljs-keyword">quit</span><br>Bye<br></code></pre></td></tr></table></figure><p>输出了<code>Bye</code>说明客户端程序已经关掉了。注意注意注意，这是关闭客户端程序的方式，不是关闭服务器程序的方式，怎么关闭服务器程序上一节里唠叨过了。</p><p>如果你愿意，你可以多打开几个黑框框，每个黑框框都使用<code>mysql -hlocalhost -uroot -p123456</code>来运行多个客户端程序，每个客户端程序都是互不影响的。如果你有多个电脑，也可以试试把它们用局域网连起来，在一个电脑上启动<code>MySQL</code>服务器程序，在另一个电脑上执行<code>mysql</code>命令时使用<code>IP</code>地址作为主机名来连接到服务器。</p><table><thead><tr><th>客户端程序</th><th>服务器程序</th></tr></thead><tbody><tr><td>启动：mysql -h -u -p</td><td>启动：mysqld、mysql_safe、mysql.server、mysqld_multi</td></tr><tr><td>关闭：quit、exit、\q</td><td>关闭：xxx stop 或者 net  stop xxx</td></tr></tbody></table><blockquote><p>xxx代表启动方式，类unix系统为前者，windows系统为后者。</p></blockquote><h3 id="连接注意事项">连接注意事项</h3><ul><li><p>最好不要在一行命令中输入密码。</p><p>我们直接在黑框框里输入密码很可能被别人看到，这和你当着别人的面输入银行卡密码没啥区别，所以我们在执行<code>mysql</code>连接服务器的时候可以不显式的写出密码，就像这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -hlocalhost -uroot -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>点击回车之后才会提示你输入密码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Enter</span> <span class="hljs-variable">password</span><span class="hljs-operator">:</span><br></code></pre></td></tr></table></figure><p>不过这回你输入的密码不会被显示出来，心怀不轨的人也就看不到了，输入完成点击回车就成功连接到了服务器。</p></li><li><p>如果你非要在一行命令中显式的把密码输出来，那<code>-p</code>和密码值之间不能有空白字符（其他参数名之间可以有空白字符），就像这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span> -h localhost -u root -p<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>如果加上了空白字符就是错误的，比如这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span> -h localhost -u root -p <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure></li><li><p><code>mysql</code>的各个参数的摆放顺序没有硬性规定，也就是说你也可以这么写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -<span class="hljs-selector-tag">p</span>  -u root -h localhost<br></code></pre></td></tr></table></figure></li><li><p>如果你的服务器和客户端安装在同一台机器上，<code>-h</code>参数可以省略，就像这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u root -<span class="hljs-selector-tag">p</span>  <br></code></pre></td></tr></table></figure></li><li><p>如果你使用的是类<code>UNIX</code>系统，并且省略<code>-u</code>参数后，会把你登陆操作系统的用户名当作<code>MySQL</code>的用户名去处理。</p><p>比方说我用登录操作系统的用户名是<code>xiaohaizi</code>，那么在我的机器上下边这两条命令是等价的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u xiaohaizi -<span class="hljs-selector-tag">p</span><br>mysql -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>对于<code>Windows</code>系统来说，默认的用户名是<code>ODBC</code>，你可以通过设置环境变量<code>USER</code>来添加一个默认用户名。</p></li></ul><h2 id="客户端与服务器连接的过程">客户端与服务器连接的过程</h2><p>我们现在已经知道如何启动<code>MySQL</code>的服务器程序，以及如何启动客户端程序来连接到这个服务器程序。运行着的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到回复的过程本质上是一个进程间通信的过程！<code>MySQL</code>支持下边三种客户端进程和服务器进程的通信方式。</p><h3 id="TCP-IP">TCP/IP</h3><p>真实环境中，<strong>数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间必须通过网络来进行通讯</strong>。<code>MySQL</code>采用<code>TCP</code>作为服务器和客户端之间的网络通信协议。在网络环境下，每台计算机都有一个唯一的<code>IP地址</code>，如果某个进程有需要采用<code>TCP</code>协议进行网络通信方面的需求，可以向操作系统申请一个<code>端口号</code>，这是一个整数值，它的取值范围是<code>0~65535</code>。这样在网络中的其他进程就可以通过<code>IP地址 + 端口号</code>的方式来与这个进程连接，这样进程之间就可以通过网络进行通信了。</p><p><code>MySQL</code>服务器启动的时候会默认申请<code>3306</code>端口号，之后就在这个端口号上等待客户端进程进行连接，用书面一点的话来说，<code>MySQL</code>服务器会默认监听<code>3306</code>端口。</p><blockquote><p>小贴士： <code>TCP/IP</code>网络体系结构是现在通用的一种网络体系结构，其中的<code>TCP</code>和<code>IP</code>是体系结构中两个非常重要的网络协议，如果你并不知道协议是什么，或者并不知道网络是什么，那恐怕兄弟你来错地方了，找本计算机网络的书去瞅瞅吧！ 什么？计算机网络的书写的都贼晦涩，看不懂？没关系，等我～</p></blockquote><p>如果<code>3306</code>端口号已经被别的进程占用了或者我们单纯的想自定义该数据库实例监听的端口号，那我们可以在启动服务器程序的命令行里添加<code>-P</code>参数来明确指定一下端口号，比如这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysqld</span> -P<span class="hljs-number">3307</span><br></code></pre></td></tr></table></figure><p>这样<code>MySQL</code>服务器在启动时就会去监听我们指定的端口号<code>3307</code>。</p><p>如果客户端进程想要使用<code>TCP/IP</code>网络来连接到服务器进程，比如我们在使用<code>mysql</code>来启动客户端程序时，在<code>-h</code>参数后必须跟随<code>IP地址</code>来作为需要连接的服务器进程所在主机的主机名，如果客户端进程和服务器进程在一台计算机中的话，我们可以使用<code>127.0.0.1</code>来代表本机的<code>IP地址</code>。另外，如果服务器进程监听的端口号不是默认的<code>3306</code>，我们也可以在使用<code>mysql</code>启动客户端程序时使用<code>-P</code>参数（大写的<code>P</code>，小写的<code>p</code>是用来指定密码的）来指定需要连接到的端口号。比如我们现在已经在本机启动了服务器进程，监听的端口号为<code>3307</code>，那我们启动客户端程序时可以这样写：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span> -h<span class="hljs-number">127.0.0.1</span> -uroot -P<span class="hljs-number">3307</span> -p<br></code></pre></td></tr></table></figure><p>不知大家发现了没有，我们在启动服务器程序的命令<code>mysqld</code>和启动客户端程序的命令<code>mysql</code>后边都可以使用<code>-P</code>参数，关于如何在命令后边指定参数，指定哪些参数我们稍后会详细唠叨的，稍微等等哈～</p><h3 id="命名管道和共享内存">命名管道和共享内存</h3><p>如果你是一个<code>Windows</code>用户，那么<strong>客户端进程和服务器进程之间可以考虑使用<code>命名管道</code>或<code>共享内存</code>进行通信</strong>。不过启用这些通信方式的时候需要在启动服务器程序和客户端程序时添加一些参数：</p><ul><li><p>使用<code>命名管道</code>来进行进程间通信</p><p>需要在启动服务器程序的命令中加上<code>--enable-named-pipe</code>参数，然后在启动客户端程序的命令中加入<code>--pipe</code>或者<code>--protocol=pipe</code>参数。</p></li><li><p>使用<code>共享内存</code>来进行进程间通信</p><p>需要在启动服务器程序的命令中加上<code>--shared-memory</code>参数，在成功启动服务器后，<code>共享内存</code>便成为本地客户端程序的默认连接方式，不过我们也可以在启动客户端程序的命令中加入<code>--protocol=memory</code>参数来显式的指定使用共享内存进行通信。</p><p>不过需要注意的是，使用<code>共享内存</code>的方式进行通信的服务器进程和客户端进程必须在同一台<code>Windows</code>主机中。</p></li></ul><blockquote><p>小贴士： 命名管道和共享内存是Windows操作系统中的两种进程间通信方式，如果你没听过的话也不用纠结，并不妨碍我们介绍MySQL的知识～</p></blockquote><h3 id="Unix域套接字文件">Unix域套接字文件</h3><p>如果我们的<strong>服务器进程和客户端进程都运行在同一台操作系统为类<code>Unix</code>的机器上的话</strong>，我们可以使用<code>Unix域套接字文件</code>来进行进程间通信。如果我们在启动客户端程序的时候指定的主机名为<code>localhost</code>，或者指定了<code>--protocol=socket</code>的启动参数，那服务器程序和客户端程序之间就可以通过<code>Unix</code>域套接字文件来进行通信了。<code>MySQL</code>服务器程序默认监听的<code>Unix</code>域套接字文件路径为<code>/tmp/mysql.sock</code>，客户端程序也默认连接到这个<code>Unix</code>域套接字文件。如果我们想改变这个默认路径，可以在启动服务器程序时指定<code>socket</code>参数，就像这样：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysqld <span class="hljs-comment">--socket=/tmp/a.txt</span><br></code></pre></td></tr></table></figure><p>这样服务器启动后便会监听<code>/tmp/a.txt</code>。在服务器改变了默认的<code>UNIX</code>域套接字文件后，如果客户端程序想通过<code>UNIX</code>域套接字文件进行通信的话，也需要显式的指定连接到的<code>UNIX</code>域套接字文件路径，就像这样：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysql -hlocalhost -uroot <span class="hljs-comment">--socket=/tmp/a.txt -p</span><br></code></pre></td></tr></table></figure><p>这样该客户端进程和服务器进程就可以通过路径为<code>/tmp/a.txt</code>的<code>Unix</code>域套接字文件进行通信了。</p><h2 id="服务器处理客户端请求">服务器处理客户端请求</h2><p>其实不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？客户端可以向服务器发送增删改查各类请求，我们这里以比较复杂的查询请求为例来画个图展示一下大致的过程：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167f4c7b99f87e1c~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c8d26fmg1af0ms81cpc7gm8lv39.png-97.9kB"><p>从图中我们可以看出，服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是<code>连接管理</code>、<code>解析与优化</code>、<code>存储引擎</code>。下边我们来详细看一下这三个部分都干了什么。</p><h3 id="连接管理">连接管理</h3><p>客户端进程可以采用我们上边介绍的<code>TCP/IP</code>、<code>命名管道或共享内存</code>、<code>Unix域套接字</code>这几种方式之一来与服务器进程建立连接，**每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。**从这一点大家也能看出，<code>MySQL</code>服务器会为每一个连接进来的客户端分配一个线程，但是线程分配的太多了会严重影响系统性能，所以我们也需要限制一下可以同时连接到服务器的客户端数量，至于怎么限制我们后边再说哈～</p><p><strong>在客户端程序发起连接的时候，需要携带主机信息、用户名、密码</strong>，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。另外，如果客户端程序和服务器程序不运行在一台计算机上，我们还可以采用使用了<code>SSL</code>（安全套接字）的网络连接进行通信，来保证数据传输的安全性。</p><p>当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求，<code>MySQL</code>服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理，预知后事如何，继续往下看哈～</p><h3 id="解析与优化">解析与优化</h3><p>到现在为止，<code>MySQL</code>服务器已经获得了文本形式的请求，接着 还要经过九九八十一难的处理，其中的几个比较重要的部分分别是<code>查询缓存</code>、<code>语法解析</code>和<code>查询优化</code>，下边我们详细来看。</p><h4 id="查询缓存">查询缓存</h4><p>如果我问你<code>9+8×16-3×2×17</code>的值是多少，你可能会用计算器去算一下，或者牛逼一点用心算，最终得到了结果<code>35</code>，如果我再问你一遍<code>9+8×16-3×2×17</code>的值是多少，你还用再傻呵呵的算一遍么？我们刚刚已经算过了，直接说答案就好了。<strong><code>MySQL</code>服务器程序处理查询请求的过程也是这样，会把刚刚处理过的查询请求和结果<code>缓存</code>起来</strong>，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。</p><p>当然，<code>MySQL</code>服务器并没有人聪明，如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。另外，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数<code>NOW</code>，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！</p><p><code>MySQL</code>缓存失效原因：</p><ul><li>查询请求不一致</li><li>包含某些系统函数或者自定义变量、函数之类的信息。如<code>Now</code>函数等。</li></ul><p>不过既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、 <code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或 <code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！</p><blockquote><p>小贴士： 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</p></blockquote><h4 id="语法解析">语法解析</h4><p>如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以<code>MySQL</code>服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到<code>MySQL</code>服务器内部使用的一些数据结构上来。</p><blockquote><p>小贴士： 这个从指定的文本中提取出我们需要的信息本质上算是一个编译过程，涉及词法解析、语法分析、语义分析等阶段，这些问题不属于我们讨论的范畴，大家只要了解在处理请求的过程中需要这个步骤就好了。</p></blockquote><h4 id="查询优化">查询优化</h4><p>语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的<code>MySQL</code>语句执行起来效率可能并不是很高，<code>MySQL</code>的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接吧啦吧啦的一堆东西。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们可以使用<code>EXPLAIN</code>语句来查看某个语句的执行计划，关于查询优化这部分的详细内容我们后边会仔细唠叨，现在你只需要知道在<code>MySQL</code>服务器程序处理请求的过程中有这么一个步骤就好了。</p><h3 id="存储引擎">存储引擎</h3><p>截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，<code>MySQL</code>服务器把数据的存储和提取操作都封装到了一个叫<code>存储引擎</code>的模块里。我们知道<code>表</code>是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是<code>存储引擎</code>负责的事情。为了实现不同的功能，<code>MySQL</code>提供了各式各样的<code>存储引擎</code>，不同<code>存储引擎</code>管理的表具体的存储结构可能不同，采用的存取算法也可能不同。</p><blockquote><p>小贴士： 为什么叫<code>引擎</code>呢？因为这个名字更拉风～ 其实这个存储引擎以前叫做<code>表处理器</code>，后来可能人们觉得太土，就改成了<code>存储引擎</code>的叫法，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</p></blockquote><p>为了管理方便，人们把<code>连接管理</code>、<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code>这些并不涉及真实数据存储的功能划分为<code>MySQL server</code>的功能，把真实存取数据的功能划分为<code>存储引擎</code>的功能。各种不同的存储引擎向上边的<code>MySQL server</code>层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像&quot;读取索引第一条内容&quot;、“读取索引下一条内容”、&quot;插入记录&quot;等等。</p><blockquote><p><code>Mysql</code>分为引擎层和server层。</p></blockquote><p>所以在<code>MySQL server</code>完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p><h2 id="常用存储引擎">常用存储引擎</h2><p><code>MySQL</code>支持非常多种存储引擎，我这先列举一些：</p><table><thead><tr><th>存储引擎</th><th>描述</th></tr></thead><tbody><tr><td><code>ARCHIVE</code></td><td>用于数据存档（行被插入后不能再修改）</td></tr><tr><td><code>BLACKHOLE</code></td><td>丢弃写操作，读操作会返回空内容</td></tr><tr><td><code>CSV</code></td><td>在存储数据时，以逗号分隔各个数据项</td></tr><tr><td><code>FEDERATED</code></td><td>用来访问远程表</td></tr><tr><td><code>InnoDB</code></td><td>具备外键支持功能的事务存储引擎</td></tr><tr><td><code>MEMORY</code></td><td>置于内存的表</td></tr><tr><td><code>MERGE</code></td><td>用来管理多个MyISAM表构成的表集合</td></tr><tr><td><code>MyISAM</code></td><td>主要的非事务处理存储引擎</td></tr><tr><td><code>NDB</code></td><td>MySQL集群专用存储引擎</td></tr></tbody></table><p>这么多我们怎么挑啊，哈哈，你多虑了，其实我们最常用的就是<code>InnoDB</code>和<code>MyISAM</code>，有时会提一下<code>Memory</code>。其中<code>InnoDB</code>是<code>MySQL</code>默认的存储引擎，我们之后会详细唠叨这个存储引擎的各种功能，现在先看一下一些存储引擎对于某些功能的支持情况：</p><table><thead><tr><th>Feature</th><th>MyISAM</th><th>Memory</th><th>InnoDB</th><th>Archive</th><th>NDB</th></tr></thead><tbody><tr><td>B-tree indexes</td><td>yes</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>Backup/point-in-time recovery</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>Cluster database support</td><td>no</td><td>no</td><td>no</td><td>no</td><td>yes</td></tr><tr><td>Clustered indexes</td><td>no</td><td>no</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>Compressed data</td><td>yes</td><td>no</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>Data caches</td><td>no</td><td>N/A</td><td>yes</td><td>no</td><td>yes</td></tr><tr><td>Encrypted data</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>Foreign key support</td><td>no</td><td>no</td><td>yes</td><td>no</td><td>yes</td></tr><tr><td>Full-text search indexes</td><td>yes</td><td>no</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>Geospatial data type support</td><td>yes</td><td>no</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>Geospatial indexing support</td><td>yes</td><td>no</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>Hash indexes</td><td>no</td><td>yes</td><td>no</td><td>no</td><td>yes</td></tr><tr><td>Index caches</td><td>yes</td><td>N/A</td><td>yes</td><td>no</td><td>yes</td></tr><tr><td>Locking granularity</td><td>Table</td><td>Table</td><td>Row</td><td>Row</td><td>Row</td></tr><tr><td>MVCC</td><td>no</td><td>no</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>Query cache support</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>Replication support</td><td>yes</td><td>Limited</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>Storage limits</td><td>256TB</td><td>RAM</td><td>64TB</td><td>None</td><td>384EB</td></tr><tr><td>T-tree indexes</td><td>no</td><td>no</td><td>no</td><td>no</td><td>yes</td></tr><tr><td>Transactions</td><td>no</td><td>no</td><td>yes</td><td>no</td><td>yes</td></tr><tr><td>Update statistics for data dictionary</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><p>密密麻麻列了这么多，看的头皮都发麻了，达到的效果就是告诉你：这玩意儿很复杂。其实这些东西大家没必要立即就给记住，我列出来的目的就是想让大家明白不同的存储引擎支持不同的功能，有些重要的功能我们会在后边的唠叨中慢慢让大家理解的～</p><h2 id="关于存储引擎的一些操作">关于存储引擎的一些操作</h2><h3 id="查看当前服务器程序支持的存储引擎">查看当前服务器程序支持的存储引擎</h3><p>我们可以用下边这个命令来查看当前服务器程序支持的存储引擎：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">SHOW ENGINES<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>来看一下调用效果：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW ENGINES;<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>|<span class="hljs-string"> Engine             </span>|<span class="hljs-string"> Support </span>|<span class="hljs-string"> Comment                                                        </span>|<span class="hljs-string"> Transactions </span>|<span class="hljs-string"> XA   </span>|<span class="hljs-string"> Savepoints </span>|<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>|<span class="hljs-string"> InnoDB             </span>|<span class="hljs-string"> DEFAULT </span>|<span class="hljs-string"> Supports transactions, row-level locking, and foreign keys     </span>|<span class="hljs-string"> YES          </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> YES        </span>|<br>|<span class="hljs-string"> MRG_MYISAM         </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> Collection of identical MyISAM tables                          </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> MEMORY             </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> Hash based, stored in memory, useful for temporary tables      </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> BLACKHOLE          </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> /dev/null storage engine (anything you write to it disappears) </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> MyISAM             </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> MyISAM storage engine                                          </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> CSV                </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> CSV storage engine                                             </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> ARCHIVE            </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> Archive storage engine                                         </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> PERFORMANCE_SCHEMA </span>|<span class="hljs-string"> YES     </span>|<span class="hljs-string"> Performance Schema                                             </span>|<span class="hljs-string"> NO           </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> NO         </span>|<br>|<span class="hljs-string"> FEDERATED          </span>|<span class="hljs-string"> NO      </span>|<span class="hljs-string"> Federated MySQL storage engine                                 </span>|<span class="hljs-string"> NULL         </span>|<span class="hljs-string"> NULL </span>|<span class="hljs-string"> NULL       </span>|<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>9 rows in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><p>其中的<code>Support</code>列表示该存储引擎是否可用，<code>DEFAULT</code>值代表是当前服务器程序的默认存储引擎。<code>Comment</code>列是对存储引擎的一个描述，英文的，将就着看吧。<code>Transactions</code>列代表该存储引擎是否支持事务处理。<code>XA</code>列代表着该存储引擎是否支持分布式事务。<code>Savepoints</code>代表着该存储引擎是否支持部分事务回滚。</p><blockquote><p>小贴士： 好吧，也许你并不知道什么是个事务、更别提分布式事务了，这些内容我们在后边的章节会详细唠叨，现在瞅一眼看个新鲜就得了。</p></blockquote><h3 id="设置表的存储引擎">设置表的存储引擎</h3><p>我们前边说过，存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p><h4 id="创建表时指定存储引擎">创建表时指定存储引擎</h4><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎<code>InnoDB</code>（当然这个默认的存储引擎也是可以修改的，我们在后边的章节中再说怎么改）。如果我们想显式的指定一下表的存储引擎，那可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>    建表语句;<br>) ENGINE <span class="hljs-operator">=</span> 存储引擎名称;<br></code></pre></td></tr></table></figure><p>比如我们想创建一个存储引擎为<code>MyISAM</code>的表可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> engine_demo_table(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     i <span class="hljs-type">int</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) ENGINE <span class="hljs-operator">=</span> MyISAM;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.02</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h4 id="修改表的存储引擎">修改表的存储引擎</h4><p>如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 ENGINE <span class="hljs-operator">=</span> 存储引擎名称;<br></code></pre></td></tr></table></figure><p>比如我们修改一下<code>engine_demo_table</code>表的存储引擎：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; ALTER TABLE engine_demo_table ENGINE = InnoDB;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">05</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br><span class="hljs-attribute">mysql</span>&gt;<br></code></pre></td></tr></table></figure><p>这时我们再查看一下<code>engine_demo_table</code>的表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> engine_demo_table\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>       <span class="hljs-keyword">Table</span>: engine_demo_table<br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">Table</span>: <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `engine_demo_table` (<br>  `i` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到该表的存储引擎已经改为<code>InnoDB</code>了。</p><h1>2.启动选项和系统变量</h1><p><code>MySQL</code>和所有的软件一样，具有很多功能，诸如是否使用<code>TCP/IP</code>、<code>套接字</code>进行通信，查询缓存，最大连接数，指定端口号，主机地址等功能。</p><p>接下来用<code>Mac</code>下的<code>mysqld</code>方式来进行演示。</p><h2 id="在命令行上使用选项">在命令行上使用选项</h2><p>如果我们在启动客户端程序时在<code>-h</code>参数后边紧跟服务器的IP地址，这就意味着客户端和服务器之间需要通过<code>TCP/IP</code>网络进行通信。因为我的客户端程序和服务器程序都装在一台计算机上，所以在使用客户端程序连接服务器程序时指定的主机名是<code>127.0.0.1</code>的情况下，客户端进程和服务器进程之间会使用<code>TCP/IP</code>网络进行通信。如果我们在启动服务器程序的时候就禁止各客户端使用<code>TCP/IP</code>网络进行通信，可以在启动服务器程序的命令行里添加<code>skip-networking</code>启动选项，就像这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mysqld --skip-networking <span class="hljs-regexp">//</span>禁用客户端使用TCP/IP网络进行通信。<br></code></pre></td></tr></table></figure><p>可以看到，我们在命令行中指定启动选项时需要在选项名前加上<code>--</code>前缀。另外，如果选项名是由多个单词构成的，它们之间可以由短划线<code>-</code>连接起来，也可以使用下划线<code>_</code>连接起来，也就是说<code>skip-networking</code>和<code>skip_networking</code>表示的含义是相同的。所以上边的写法与下边的写法是等价的：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysqld <span class="hljs-comment">--skip_networking</span><br></code></pre></td></tr></table></figure><p>在按照上述命令启动服务器程序后，如果我们再使用<code>mysql</code>来启动客户端程序时，再把服务器主机名指定为<code>127.0.0.1</code>（IP地址的形式）的话会显示连接失败：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit"> mysql -h127.0.0.1 -uroot -p<br>Enter password:<br><br><span class="hljs-keyword">ERROR </span>2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;127.0.0.1&#x27; (61)<br></code></pre></td></tr></table></figure><p>这就意味着我们指定的启动选项<code>skip-networking</code>生效了！</p><p>再举一个例子，我们前边说过如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用<code>InnoDB</code>作为表的存储引擎。如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">mysqld --<span class="hljs-keyword">default</span>-storage-engine=MyISAM <span class="hljs-comment">//指定默认引擎。</span><br></code></pre></td></tr></table></figure><p>我们现在就已经把表的默认存储引擎改为<code>MyISAM</code>了，在客户端程序连接到服务器程序后试着创建一个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sys_var_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     i <span class="hljs-type">INT</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.02</span> sec)<br></code></pre></td></tr></table></figure><p>这个定义语句中我们并没有明确指定表的存储引擎，创建成功后再看一下这个表的结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sys_var_demo\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>       <span class="hljs-keyword">Table</span>: sys_var_demo<br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">Table</span>: <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `sys_var_demo` (<br>  `i` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>MyISAM <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><p>可以看到该表的存储引擎已经是<code>MyISAM</code>了，说明启动选项<code>default-storage-engine</code>生效了。</p><p>所以在启动服务器程序的命令行后边指定启动选项的通用格式就是这样的：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">--<span class="hljs-comment">启动选项1</span><span class="hljs-title">[</span><span class="hljs-comment">=值1</span><span class="hljs-title">]</span> --<span class="hljs-comment">启动选项2</span><span class="hljs-title">[</span><span class="hljs-comment">=值2</span><span class="hljs-title">]</span> <span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span> --<span class="hljs-comment">启动选项n</span><span class="hljs-title">[</span><span class="hljs-comment">=值n</span><span class="hljs-title">]</span><br></code></pre></td></tr></table></figure><p>也就是说我们可以将各个启动选项写到一行中，各个启动选项之间使用空白字符隔开，在每一个启动选项名称前边添加<code>--</code>。对于不需要值的启动选项，比方说<code>skip-networking</code>，它们就不需要指定对应的值。对于需要指定值的启动选项，比如<code>default-storage-engine</code>我们在指定这个设置项的时候需要显式的指定它的值，比方说<code>InnoDB</code>、<code>MyISAM</code>啦什么的～ 在命令行上指定有值的启动选项时需要注意，选项名、=、选项值之间不可以有空白字符，比如写成下边这样就是不正确的：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">mysqld --<span class="hljs-keyword">default</span>-storage-engine = MyISAM<br></code></pre></td></tr></table></figure><p>每个MySQL程序都有许多不同的选项。大多数程序提供了一个–help选项，你可以查看该程序支持的全部启动选项以及它们的默认值。例如，使用<code>mysql --help</code>可以看到<code>mysql</code>程序支持的启动选项，<code>mysqld_safe --help</code>可以看到<code>mysqld_safe</code>程序支持的启动选项。查看<code>mysqld</code>支持的启动选项有些特别，需要使用<code>mysqld --verbose --help</code>。</p><h3 id="选项的长形式和短形式">选项的长形式和短形式</h3><p>我们前边提到的<code>skip-networking</code>、<code>default-storage-engine</code>称之为长形式的选项（因为它们很长），设计<code>MySQL</code>的大叔为了我们使用的方便，对于一些常用的选项提供了短形式，我们列举一些具有短形式的启动选项来瞅瞅（<code>MySQL</code>支持的短形式选项太多了，全列出来会刷屏的）：</p><table><thead><tr><th>长形式</th><th>短形式</th><th>含义</th></tr></thead><tbody><tr><td><code>--host</code></td><td><code>-h</code></td><td>主机名</td></tr><tr><td><code>--user</code></td><td><code>-u</code></td><td>用户名</td></tr><tr><td><code>--password</code></td><td><code>-p</code></td><td>密码</td></tr><tr><td><code>--port</code></td><td><code>-P</code></td><td>端口</td></tr><tr><td><code>--version</code></td><td><code>-V</code></td><td>版本信息</td></tr></tbody></table><p>短形式的选项名只有一个字母，与使用长形式选项时需要在选项名前加两个短划线<code>--</code>不同的是，使用短形式选项时在选项名前只加一个短划线<code>-</code>前缀。有一些短形式的选项我们之前已经接触过了，比方说我们在启动服务器程序时指定监听的端口号：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysqld</span> -P<span class="hljs-number">3307</span><br></code></pre></td></tr></table></figure><p>使用短形式指定启动选项时，选项名和选项值之间可以没有间隙，或者用空白字符隔开（<code>-p</code>选项有些特殊，<code>-p</code>和密码值之间不能有空白字符），也就是说上边的命令形式和下边的是等价的：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysqld</span> -P <span class="hljs-number">3307</span><br></code></pre></td></tr></table></figure><p>另外，选项名是区分大小写的，比如<code>-p</code>和<code>-P</code>选项拥有完全不同的含义，大家需要注意一下。</p><h2 id="配置文件中使用选项">配置文件中使用选项</h2><p>在命令行中设置启动选项只对当次启动生效，也就是说如果下一次重启程序的时候我们还想保留这些启动选项的话，还得重复把这些选项写到启动命令行中，这样真的神烦唉！于是设计<code>MySQL</code>的大叔们提出一种<code>配置文件</code>（也称为<code>选项文件</code>）的概念，我们把需要设置的启动选项都写在这个配置文件中，每次启动服务器的时候都从这个文件里加载相应的启动选项。由于这个配置文件可以长久的保存在计算机的硬盘里，所以只需我们配置一次，以后就都不用显式的把启动选项都写在启动命令行中了，所以我们推荐使用配置文件的方式来设置启动选项。</p><h3 id="配置文件的路径">配置文件的路径</h3><p><code>MySQL</code>程序在启动时会寻找多个路径下的配置文件，这些路径有的是固定的，有的是可以在命令行指定的。根据操作系统的不同，配置文件的路径也有所不同，我们分开看一下。</p><h4 id="Windows操作系统的配置文件">Windows操作系统的配置文件</h4><p>在<code>Windows</code>操作系统中，<code>MySQL</code>会按照下列路径来寻找配置文件：</p><table><thead><tr><th>路径名</th><th>备注</th></tr></thead><tbody><tr><td><code>%WINDIR%\my.ini</code>， <code>%WINDIR%\my.cnf</code></td><td></td></tr><tr><td><code>C:\my.ini</code>， <code>C:\my.cnf</code></td><td></td></tr><tr><td><code>BASEDIR\my.ini</code>， <code>BASEDIR\my.cnf</code></td><td></td></tr><tr><td><code>defaults-extra-file</code></td><td>命令行指定的额外配置文件路径</td></tr><tr><td><code>%APPDATA%\MySQL\.mylogin.cnf</code></td><td>登录路径选项（仅限客户端）</td></tr></tbody></table><p>在阅读这些<code>Windows</code>操作系统下配置文件路径的时候需要注意一些事情：</p><ul><li><p>在给定的前三个路径中，配置文件可以使用<code>.ini</code>的扩展名，也可以使用<code>.cnf</code>的扩展名。</p></li><li><p><code>%WINDIR%</code>指的是你机器上<code>Windows</code>目录的位置，通常是<code>C:\WINDOWS</code>，如果你不确定，可以使用这个命令来查看：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">echo</span> <span class="hljs-variable">%WINDIR%</span><br></code></pre></td></tr></table></figure></li><li><p><code>BASEDIR</code>指的是<code>MySQL</code>安装目录的路径，在我的<code>Windows</code>机器上的<code>BASEDIR</code>的值是：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\M</span>ySQL<span class="hljs-symbol">\M</span>ySQL Server 5.7<br></code></pre></td></tr></table></figure></li><li><p>第四个路径指的是我们在启动程序时可以通过指定<code>defaults-extra-file</code>参数的值来添加额外的配置文件路径，比方说我们在命令行上可以这么写：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">mysqld --defaults-extra-file=C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\x</span>iaohaizi<span class="hljs-symbol">\m</span>y_extra_file.txt<br></code></pre></td></tr></table></figure><p>这样<code>MySQL</code>服务器启动时就可以额外在<code>C:\Users\xiaohaizi\my_extra_file.txt</code>这个路径下查找配置文件。</p></li><li><p><code>%APPDATA%</code>表示<code>Windows</code>应用程序数据目录的值，可以使用下列命令查看：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">echo</span> <span class="hljs-variable">%APPDATA%</span><br></code></pre></td></tr></table></figure></li><li><p>列表中最后一个名为<code>.mylogin.cnf</code>配置文件有点儿特殊，它不是一个纯文本文件（其他的配置文件都是纯文本文件），而是使用<code>mysql_config_editor</code>实用程序创建的加密文件。文件中只能包含一些用于启动客户端软件时连接服务器的一些选项，包括 <code>host</code>、<code>user</code>、<code>password</code>、<code>port</code>和 <code>socket</code>。而且它只能被客户端程序所使用。</p></li></ul><blockquote><p>小贴士： mysql_config_editor实用程序其实是MySQL安装目录下的bin目录下的一个可执行文件，这个实用程序有专用的语法来生成或修改 .mylogin.cnf 文件中的内容，如何使用这个程序不是我们讨论的主题，可以到MySQL的官方文档中查看。</p></blockquote><h4 id="类Unix操作系统中的配置文件">类Unix操作系统中的配置文件</h4><p>在类<code>UNIX</code>操作系统中，<code>MySQL</code>会按照下列路径来寻找配置文件：</p><table><thead><tr><th>路径名</th><th>备注</th></tr></thead><tbody><tr><td><code>/etc/my.cnf</code></td><td></td></tr><tr><td><code>/etc/mysql/my.cnf</code></td><td></td></tr><tr><td><code>SYSCONFDIR/my.cnf</code></td><td></td></tr><tr><td><code>$MYSQL_HOME/my.cnf</code></td><td>特定于服务器的选项（仅限服务器）</td></tr><tr><td><code>defaults-extra-file</code></td><td>命令行指定的额外配置文件路径</td></tr><tr><td><code>~/.my.cnf</code></td><td>用户特定选项</td></tr><tr><td><code>~/.mylogin.cnf</code></td><td>用户特定的登录路径选项（仅限客户端）</td></tr></tbody></table><p>在阅读这些<code>UNIX</code>操作系统下配置文件路径的时候需要注意一些事情：</p><ul><li><p><code>SYSCONFDIR</code>表示在使用<code>CMake</code>构建<code>MySQL</code>时使用<code>SYSCONFDIR</code>选项指定的目录。默认情况下，这是位于编译安装目录下的<code>etc</code>目录。</p><blockquote><p>小贴士： 如果你不懂啥是个CMAKE，啥是个编译，那就跳过吧，对我们后续的文章没啥影响。</p></blockquote></li><li><p><code>MYSQL_HOME</code>是一个环境变量，该变量的值是我们自己设置的，我们想设置就设置，不想设置就不设置。该变量的值代表一个路径，我们可以在该路径下创建一个<code>my.cnf</code>配置文件，那么这个配置文件中只能放置关于启动服务器程序相关的选项（言外之意就是其他的配置文件既能存放服务器相关的选项也能存放客户端相关的选项，<code>.mylogin.cnf</code>除外，它只能存放客户端相关的一些选项）。</p><blockquote><p>小贴士： 如果大家使用mysqld_safe启动服务器程序，而且我们也没有主动设置这个MySQL_HOME环境变量的值，那这个环境变量的值将自动被设置为MySQL的安装目录，也就是MySQL服务器将会在安装目录下查找名为my.cnf配置文件（别忘了mysql.server会调用mysqld_safe，所以使用mysql.server启动服务器时也会在安装目录下查找配置文件）。</p></blockquote></li><li><p>列表中的最后两个以<code>~</code>开头的路径是用户相关的，类<code>UNIX</code> 系统中都有一个当前登陆用户的概念，每个用户都可以有一个用户目录，<code>~</code>就代表这个用户目录，大家可以查看<code>HOME</code>环境变量的值来确定一下当前用户的用户目录，比方说我的<code>macOS</code>机器上的用户目录就是<code>/Users/xiaohaizi</code>。之所以说列表中最后两个配置文件是用户相关的，是因为不同的类<code>UNIX</code>系统的用户都可以在自己的用户目录下创建<code>.my.cnf</code>或者<code>.mylogin.cnf</code>，换句话说，不同登录用户使用的<code>.my.cnf</code>或者<code>.mylogin.cnf</code>配置文件是不同的。</p></li><li><p><code>defaults-extra-file</code>的含义与Windows中的一样。</p></li><li><p><code>.mylogin.cnf</code>的含义也同<code>Windows</code>中的一样，再次强调一遍，它不是纯文本文件，只能使用<code>mysql_config_editor</code>实用程序去创建或修改，用于存放客户端登陆服务器时的相关选项。</p></li></ul><p>这也就是说，在我的计算机中这几个路径中的任意一个都可以当作配置文件来使用，如果它们不存在，你可以手动创建一个，比方说我手动在<code>~/.my.cnf</code>这个路径下创建一个配置文件。</p><p>另外，我们在唠叨如何启动<code>MySQL</code>服务器程序的时候说过，使用<code>mysqld_safe</code>程序启动服务器时，会间接调用<code>mysqld</code>，所以对于传递给<code>mysqld_safe</code>的启动选项来说，如果<code>mysqld_safe</code>程序不处理，会接着传递给<code>mysqld</code>程序处理。比方说<code>skip-networking</code>选项是由<code>mysqld</code>处理的，<code>mysqld_safe</code>并不处理，但是如果我们我们在命令行上这样执行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysqld_safe <span class="hljs-comment">--skip-networking</span><br></code></pre></td></tr></table></figure><p>则在<code>mysqld_safe</code>调用<code>mysqld</code>时，会把它处理不了的这个<code>skip-networking</code>选项交给<code>mysqld</code>处理。</p><h4 id="配置文件的内容">配置文件的内容</h4><p>与在命令行中指定启动选项不同的是，配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号<code>[]</code>扩起来，像这样：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs clojure">[server]<br>(具体的启动选项...)<br><br>[mysqld]<br>(具体的启动选项...)<br><br>[mysqld_safe]<br>(具体的启动选项...)<br><br>[client]<br>(具体的启动选项...)<br><br>[mysql]<br>(具体的启动选项...)<br><br>[mysqladmin]<br>(具体的启动选项...)<br></code></pre></td></tr></table></figure><p>像这个配置文件里就定义了许多个组，组名分别是<code>server</code>、<code>mysqld</code>、<code>mysqld_safe</code>、<code>client</code>、<code>mysql</code>、<code>mysqladmin</code>。每个组下边可以定义若干个启动选项，我们以<code>[server]</code>组为例来看一下填写启动选项的形式（其他组中启动选项的形式是一样的）：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">[server]<br>optio<span class="hljs-symbol">n1</span>     <span class="hljs-attr">#这是option1</span>，该选项不需要选项值<br>optio<span class="hljs-symbol">n2</span> = value<span class="hljs-number">2</span>      <span class="hljs-attr">#这是option2</span>，该选项需要选项值<br>...<br></code></pre></td></tr></table></figure><p>在配置文件中指定启动选项的语法类似于命令行语法，但是<strong>配置文件中只能使用长形式的选项。在配置文件中指定的启动选项不允许加<code>--</code>前缀，并且每行只指定一个选项，而且<code>=</code>周围可以有空白字符</strong>（命令行中选项名、<code>=</code>、选项值之间不允许有空白字符）。另外，在配置文件中，我们可以使用<code>#</code>来添加注释，从<code>#</code>出现直到行尾的内容都属于注释内容，读取配置文件时会忽略这些注释内容。为了大家更容易对比启动选项在命令行和配置文件中指定的区别，我们再把命令行中指定<code>option1</code>和<code>option2</code>两个选项的格式写一遍看看：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">--<span class="hljs-comment">option1</span> --<span class="hljs-comment">option2=value2</span><br></code></pre></td></tr></table></figure><p>配置文件中不同的选项组是给不同的启动命令使用的，如果选项组名称与程序名称相同，则组中的选项将专门应用于该程序。例如， <code>[mysqld]</code>和<code>[mysql]</code>组分别应用于<code>mysqld</code>服务器程序和<code>mysql</code>客户端程序。不过有两个选项组比较特别：</p><ul><li><code>[server]</code>组下边的启动选项将作用于所有的服务器程序。</li><li><code>[client]</code>组下边的启动选项将作用于所有的客户端程序。</li></ul><p>需要注意的一点是，<code>mysqld_safe</code>和<code>mysql.server</code>这两个程序在启动时都会读取<code>[mysqld]</code>选项组中的内容。为了直观感受一下，我们挑一些启动命令来看一下它们能读取的选项组都有哪些：</p><table><thead><tr><th>启动命令</th><th>类别</th><th>能读取的组</th></tr></thead><tbody><tr><td><code>mysqld</code></td><td>启动服务器</td><td><code>[mysqld]</code>、<code>[server]</code></td></tr><tr><td><code>mysqld_safe</code></td><td>启动服务器</td><td><code>[mysqld]</code>、<code>[server]</code>、<code>[mysqld_safe]</code></td></tr><tr><td><code>mysql.server</code></td><td>启动服务器</td><td><code>[mysqld]</code>、<code>[server]</code>、<code>[mysql.server]</code></td></tr><tr><td><code>mysql</code></td><td>启动客户端</td><td><code>[mysql]</code>、<code>[client]</code></td></tr><tr><td><code>mysqladmin</code></td><td>启动客户端</td><td><code>[mysqladmin]</code>、<code>[client]</code></td></tr><tr><td><code>mysqldump</code></td><td>启动客户端</td><td><code>[mysqldump]</code>、<code>[client]</code></td></tr></tbody></table><p>现在我们以<code>macOS</code>操作系统为例，在<code>/etc/mysql/my.cnf</code>这个配置文件中添加一些内容（<code>Windows</code>系统参考上边提到的配置文件路径）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">server</span>]<br>skip-networking<br><span class="hljs-keyword">default</span>-<span class="hljs-keyword">storage</span>-engine=MyISAM<br></code></pre></td></tr></table></figure><p>然后直接用<code>mysqld</code>启动服务器程序：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mysqld</span><br></code></pre></td></tr></table></figure><p>虽然在命令行没有添加启动选项，但是在程序启动的时候，就会默认的到我们上边提到的配置文件路径下查找配置文件，其中就包括<code>/etc/mysql/my.cnf</code>。又由于<code>mysqld</code>命令可以读取<code>[server]</code>选项组的内容，所以<code>skip-networking</code>和<code>default-storage-engine=MyISAM</code>这两个选项是生效的。你可以把这些启动选项放在<code>[client]</code>组里再试试用<code>mysqld</code>启动服务器程序，看一下里边的启动选项生效不（剧透一下，不生效）。</p><blockquote><p>小贴士： 如果我们想指定mysql.server程序的启动参数，则必须将它们放在配置文件中，而不是放在命令行中。mysql.server仅支持start和stop作为命令行参数。</p></blockquote><h4 id="特定MySQL版本的专用选项组">特定MySQL版本的专用选项组</h4><p>我们可以在选项组的名称后加上特定的<code>MySQL</code>版本号，比如对于<code>[mysqld]</code>选项组来说，我们可以定义一个<code>[mysqld-5.7]</code>的选项组，它的含义和<code>[mysqld]</code>一样，只不过只有版本号为<code>5.7</code>的<code>mysqld</code>程序才能使用这个选项组中的选项。</p><h4 id="配置文件的优先级">配置文件的优先级</h4><p>我们前边唠叨过<code>MySQL</code>将在某些固定的路径下搜索配置文件，我们也可以通过在命令行上指定<code>defaults-extra-file</code>启动选项来指定额外的配置文件路径。<code>MySQL</code>将按照我们在上表中给定的顺序依次读取各个配置文件，如果该文件不存在则忽略。**值得注意的是，如果我们在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准。**比方说<code>/etc/my.cnf</code>文件的内容是这样的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">default-storage-engine</span>=InnoDB<br></code></pre></td></tr></table></figure><p>而<code>~/.my.cnf</code>文件中的内容是这样的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">default-storage-engine</span>=MyISAM<br></code></pre></td></tr></table></figure><p>又因为<code>~/.my.cnf</code>比<code>/etc/my.cnf</code>顺序靠后，所以如果两个配置文件中出现相同的启动选项，以<code>~/.my.cnf</code>中的为准，所以<code>MySQL</code>服务器程序启动之后，<code>default-storage-engine</code>的值就是<code>MyISAM</code>。</p><h4 id="同一个配置文件中多个组的优先级">同一个配置文件中多个组的优先级</h4><p>我们说同一个命令可以访问配置文件中的多个组，比如<code>mysqld</code>可以访问<code>[mysqld]</code>、<code>[server]</code>组，如果在同一个配置文件中，比如<code>~/.my.cnf</code>，在这些组里出现了同样的配置项，比如这样：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">default-storage-engine</span>=InnoDB<br><br><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">default-storage-engine</span>=MyISAM<br></code></pre></td></tr></table></figure><p>那么，将以最后一个出现的组中的启动选项为准，比方说例子中<code>default-storage-engine</code>既出现在<code>[mysqld]</code>组也出现在<code>[server]</code>组，因为<code>[mysqld]</code>组在<code>[server]</code>组后边，就以<code>[mysqld]</code>组中的配置项为准。</p><h4 id="defaults-file的使用">defaults-file的使用</h4><p>如果我们不想让<code>MySQL</code>到默认的路径下搜索配置文件（就是上表中列出的那些），可以在命令行指定<code>defaults-file</code>选项，比如这样（以<code>UNIX</code>系统为例）：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mysqld --defaults-<span class="hljs-keyword">file</span>=<span class="hljs-regexp">/tmp/my</span>config.txt<br></code></pre></td></tr></table></figure><p>这样，在程序启动的时候将只在<code>/tmp/myconfig.txt</code>路径下搜索配置文件。如果文件不存在或无法访问，则会发生错误。</p><blockquote><p>小贴士： 注意<code>defaults-extra-file</code>和<code>defaults-file</code>的区别，使用<code>defaults-extra-file</code>可以指定额外的配置文件搜索路径（也就是说那些固定的配置文件路径也会被搜索）。</p></blockquote><h4 id="命令行和配置文件中启动选项的区别">命令行和配置文件中启动选项的区别</h4><p>在命令行上指定的绝大部分启动选项都可以放到配置文件中，但是有一些选项是专门为命令行设计的，比方说<code>defaults-extra-file</code>、<code>defaults-file</code>这样的选项本身就是为了指定配置文件路径的，再放在配置文件中使用就没啥意义了。剩下的一些只能用在命令行上而不能用到配置文件中的启动选项就不一一列举了，用到的时候再提哈（本书中基本用不到，有兴趣的到官方文档看哈）。</p><p>另外有一点需要特别注意，如果同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准！比如我们在配置文件中写了：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">default-storage-engine</span>=InnoDB<br></code></pre></td></tr></table></figure><p>而我们的启动命令是：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql.<span class="hljs-keyword">server</span> <span class="hljs-keyword">start</span> <span class="hljs-comment">--default-storage-engine=MyISAM</span><br></code></pre></td></tr></table></figure><p>那最后<code>default-storage-engine</code>的值就是<code>MyISAM</code>！</p><h2 id="系统变量">系统变量</h2><h3 id="系统变量简介">系统变量简介</h3><p><code>MySQL</code>服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为<code>MySQL</code>系统变量，比如允许同时连入的客户端数量用系统变量<code>max_connections</code>表示，表的默认存储引擎用系统变量<code>default_storage_engine</code>表示，查询缓存的大小用系统变量<code>query_cache_size</code>表示，<code>MySQL</code>服务器程序的系统变量有好几百条，我们就不一一列举了。每个系统变量都有一个默认值，我们可以使用命令行或者配置文件中的选项在启动服务器时改变一些系统变量的值。大多数的系统变量的值也可以在程序运行过程中修改，而无需停止并重新启动它。</p><h3 id="查看系统变量">查看系统变量</h3><p>我们可以使用下列命令查看<code>MySQL</code>服务器程序支持的系统变量以及它们的当前值：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> [LIKE 匹配的模式<span class="hljs-comment">]</span>;<br></code></pre></td></tr></table></figure><p>由于<code>系统变量</code>实在太多了，如果我们直接使用<code>SHOW VARIABLES</code>查看的话就直接刷屏了，所以通常都会带一个<code>LIKE</code>过滤条件来查看我们需要的系统变量的值，比方说这么写：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | InnoDB |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.01 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES like &#x27;max_connections&#x27;;</span><br><span class="hljs-section">+-----------------+-------+</span><br><span class="hljs-section">| Variable_name   | Value |</span><br><span class="hljs-section">+-----------------+-------+</span><br><span class="hljs-section">| max_connections | 151   |</span><br><span class="hljs-section">+-----------------+-------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>可以看到，现在服务器程序使用的默认存储引擎就是<code>InnoDB</code>，允许同时连接的客户端数量最多为<code>151</code>。别忘了<code>LIKE</code>表达式后边可以跟通配符来进行模糊查询，也就是说我们可以这么写：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;default%&#x27;;</span><br><span class="hljs-section">+-------------------------------+-----------------------+</span><br><span class="hljs-section">| Variable_name                 | Value                 |</span><br><span class="hljs-section">+-------------------------------+-----------------------+</span><br>| default<span class="hljs-emphasis">_authentication_plugin | mysql_native_password |</span><br><span class="hljs-emphasis">| default_password_lifetime     | 0                     |</span><br><span class="hljs-emphasis">| default_storage_engine        | InnoDB                |</span><br><span class="hljs-emphasis">| default_tmp_storage_engine    | InnoDB                |</span><br><span class="hljs-emphasis">| default_week_</span>format           | 0                     |<br><span class="hljs-code">+-------------------------------+</span>-----------------------+<br>5 rows in set (0.01 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><p>这样就查出了所有以<code>default</code>开头的系统变量的值。</p><h3 id="设置系统变量">设置系统变量</h3><h4 id="通过启动选项设置">通过启动选项设置</h4><p>大部分的<code>系统变量</code>都可以通过启动服务器时传送启动选项的方式来进行设置。如何填写启动选项我们上边已经花了大篇幅来唠叨了，就是下边两种方式：</p><ul><li><p>通过命令行添加启动选项。</p><p>比方说我们在启动服务器程序时用这个命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysqld <span class="hljs-attribute">--default-storage-engine</span>=MyISAM <span class="hljs-attribute">--max-connections</span>=10<br></code></pre></td></tr></table></figure></li><li><p>通过配置文件添加启动选项。</p><p>我们可以这样填写配置文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">default-storage-engine</span>=MyISAM<br><span class="hljs-attr">max-connections</span>=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li></ul><p>当使用上边两种方式中的任意一种启动服务器程序后，我们再来查看一下系统变量的值：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | MyISAM |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;max_connections&#x27;;</span><br><span class="hljs-section">+-----------------+-------+</span><br><span class="hljs-section">| Variable_name   | Value |</span><br><span class="hljs-section">+-----------------+-------+</span><br><span class="hljs-section">| max_connections | 10    |</span><br><span class="hljs-section">+-----------------+-------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><p>可以看到<code>default_storage_engine</code>和<code>max_connections</code>这两个系统变量的值已经被修改了。有一点需要注意的是，<strong>对于启动选项来说，如果启动选项名由多个单词组成，各个单词之间用短划线<code>-</code>或者下划线<code>_</code>连接起来都可以，但是它对应的系统变量的单词之间必须使用下划线<code>_</code>连接起来。</strong></p><h4 id="服务器程序运行过程中设置">服务器程序运行过程中设置</h4><p><code>系统变量</code>比较牛逼的一点就是，对于大部分系统变量来说，它们的值可以在服务器程序运行过程中进行动态修改而无需停止并重启服务器。不过系统变量有作用范围之分，下边详细唠叨下。</p><h5 id="设置不同作用范围的系统变量">设置不同作用范围的系统变量</h5><p>我们前边说过，多个客户端程序可以同时连接到一个服务器程序。对于同一个系统变量，我们有时想让不同的客户端有不同的值。比方说狗哥使用客户端A，他想让当前客户端对应的默认存储引擎为<code>InnoDB</code>，所以他可以把系统变量<code>default_storage_engine</code>的值设置为<code>InnoDB</code>；猫爷使用客户端B，他想让当前客户端对应的默认存储引擎为<code>MyISAM</code>，所以他可以把系统变量<code>default_storage_engine</code>的值设置为<code>MyISAM</code>。这样可以使狗哥和猫爷的的客户端拥有不同的默认存储引擎，使用时互不影响，十分方便。但是这样各个客户端都私有一份系统变量会产生这么两个问题：</p><ul><li>有一些系统变量并不是针对单个客户端的，比如允许同时连接到服务器的客户端数量<code>max_connections</code>，查询缓存的大小<code>query_cache_size</code>，这些公有的系统变量让某个客户端私有显然不合适。</li><li>一个新连接到服务器的客户端对应的系统变量的值该怎么设置？</li></ul><p>为了解决这两个问题，设计<code>MySQL</code>的大叔提出了系统变量的<code>作用范围</code>的概念，具体来说<code>作用范围</code>分为这两种：</p><ul><li><code>GLOBAL</code>：全局变量，影响服务器的整体操作。</li><li><code>SESSION</code>：会话变量，影响某个客户端连接的操作。（注：<code>SESSION</code>有个别名叫<code>LOCAL</code>）</li></ul><p>在服务器启动时，会将每个全局变量初始化为其默认值（可以通过命令行或选项文件中指定的选项更改这些默认值）。然后服务器还为每个连接的客户端维护一组会话变量，客户端的会话变量在连接时使用相应全局变量的当前值初始化。</p><p>这话有点儿绕，还是以<code>default_storage_engine</code>举例，在服务器启动时会初始化一个名为<code>default_storage_engine</code>，作用范围为<code>GLOBAL</code>的系统变量。之后每当有一个客户端连接到该服务器时，服务器都会单独为该客户端分配一个名为<code>default_storage_engine</code>，作用范围为<code>SESSION</code>的系统变量，该作用范围为<code>SESSION</code>的系统变量值按照当前作用范围为<code>GLOBAL</code>的同名系统变量值进行初始化。</p><p>很显然，通过启动选项设置的系统变量的作用范围都是<code>GLOBAL</code>的，也就是对所有客户端都有效的，因为在系统启动的时候还没有客户端程序连接进来呢。了解了系统变量的<code>GLOBAL</code>和<code>SESSION</code>作用范围之后，我们再看一下在服务器程序运行期间通过客户端程序设置系统变量的语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> [<span class="hljs-keyword">GLOBAL</span>|<span class="hljs-keyword">SESSION</span>] 系统变量名 = 值;<br></code></pre></td></tr></table></figure><p>或者写成这样也行：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> [@@(<span class="hljs-keyword">GLOBAL</span>|<span class="hljs-keyword">SESSION</span>).]var_name = XXX;<br></code></pre></td></tr></table></figure><p>比如我们想在服务器运行过程中把作用范围为<code>GLOBAL</code>的系统变量<code>default_storage_engine</code>的值修改为<code>MyISAM</code>，也就是想让之后新连接到服务器的客户端都用<code>MyISAM</code>作为默认的存储引擎，那我们可以选择下边两条语句中的任意一条来进行设置：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">语句一：<span class="hljs-keyword">SET</span> GLOBAL <span class="hljs-comment">default_storage_engine = MyISAM</span>;<br>语句二：<span class="hljs-keyword">SET</span> @@GLOBAL.default_storage_engine <span class="hljs-comment">= MyISAM</span>;<br></code></pre></td></tr></table></figure><p>如果只想对本客户端生效，也可以选择下边三条语句中的任意一条来进行设置：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">语句一：<span class="hljs-keyword">SET</span> SESSION <span class="hljs-comment">default_storage_engine = MyISAM</span>;<br>语句二：<span class="hljs-keyword">SET</span> @@SESSION.default_storage_engine <span class="hljs-comment">= MyISAM</span>;<br>语句三：<span class="hljs-keyword">SET</span> default_storage_engine <span class="hljs-comment">= MyISAM</span>;<br></code></pre></td></tr></table></figure><p>从上边的<code>语句三</code>也可以看出，如果在设置系统变量的语句中省略了作用范围，默认的作用范围就是<code>SESSION</code>。也就是说<code>SET 系统变量名 = 值</code>和<code>SET SESSION 系统变量名 = 值</code>是等价的。</p><h5 id="查看不同作用范围的系统变量">查看不同作用范围的系统变量</h5><p><code>系统变量</code>有<code>作用范围</code>之分，<code>SHOW VARIABLES</code>默认查看的是<code>SESSION</code>作用范围的系统变量。</p><p>当然我们也可以在查看系统变量的语句上加上要查看哪个<code>作用范围</code>的系统变量，就像这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> [<span class="hljs-keyword">GLOBAL</span>|<span class="hljs-keyword">SESSION</span>] VARIABLES [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br></code></pre></td></tr></table></figure><p>下边我们演示一下完整的设置并查看系统变量的过程：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW SESSION VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | InnoDB |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW GLOBAL VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | InnoDB |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt; SET SESSION default_storage_engine = MyISAM;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW SESSION VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | MyISAM |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW GLOBAL VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| default_storage_engine | InnoDB |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><p>可以看到，最初<code>default_storage_engine</code>的系统变量无论是在<code>GLOBAL</code>作用范围上还是在<code>SESSION</code>作用范围上的值都是<code>InnoDB</code>，我们在<code>SESSION</code>作用范围把它的值设置为<code>MyISAM</code>之后，可以看到<code>GLOBAL</code>作用范围的值并没有改变。</p><blockquote><p>小贴士： 如果某个客户端改变了某个系统变量在<code>GLOBAL</code>作用范围的值，并不会影响该系统变量在当前已经连接的客户端作用范围为<code>SESSION</code>的值，只会影响后续连入的客户端在作用范围为<code>SESSION</code>的值。</p></blockquote><h5 id="注意事项">注意事项</h5><ul><li>并不是所有系统变量都具有<code>GLOBAL</code>和<code>SESSION</code>的作用范围。<ul><li>有一些系统变量只具有<code>GLOBAL</code>作用范围，比方说<code>max_connections</code>，表示服务器程序支持同时最多有多少个客户端程序进行连接。</li><li>有一些系统变量只具有<code>SESSION</code>作用范围，比如<code>insert_id</code>，表示在对某个包含<code>AUTO_INCREMENT</code>列的表进行插入时，该列初始的值。</li><li>有一些系统变量的值既具有<code>GLOBAL</code>作用范围，也具有<code>SESSION</code>作用范围，比如我们前边用到的<code>default_storage_engine</code>，而且其实大部分的系统变量都是这样的，</li></ul></li><li>有些系统变量是只读的，并不能设置值。</li></ul><h4 id="启动选项和系统变量的区别">启动选项和系统变量的区别</h4><p><code>启动选项</code>是在程序启动时我们程序员传递的一些参数，而<code>系统变量</code>是影响服务器程序运行行为的变量，它们之间的关系如下：</p><ul><li>大部分的系统变量都可以被当作启动选项传入。</li><li>有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置，比如<code>auto_increment_offset</code>、<code>character_set_client</code>啥的。</li><li>有些启动选项也不是系统变量，比如<code>defaults-file</code>。</li></ul><h3 id="状态变量">状态变量</h3><p>为了让我们更好的了解服务器程序的运行情况，<code>MySQL</code>服务器程序中维护了好多关于程序运行状态的变量，它们被称为<code>状态变量</code>。比方说<code>Threads_connected</code>表示当前有多少客户端与服务器建立了连接，<code>Handler_update</code>表示已经更新了多少行记录吧啦吧啦，像这样显示服务器程序状态信息的<code>状态变量</code>还有好几百个，我们就不一一唠叨了，等遇到了会详细说它们的作用的。</p><p>由于<code>状态变量</code>是用来显示服务器程序运行状况的，所以它们的值只能由服务器程序自己来设置，我们程序员是不能设置的。与<code>系统变量</code>类似，<code>状态变量</code>也有<code>GLOBAL</code>和<code>SESSION</code>两个作用范围的，所以查看<code>状态变量</code>的语句可以这么写：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> [<span class="hljs-keyword">GLOBAL</span>|<span class="hljs-keyword">SESSION</span>] STATUS [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br></code></pre></td></tr></table></figure><p>类似的，如果我们不写明作用范围，默认的作用范围是<code>SESSION</code>，比方说这样：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW STATUS LIKE &#x27;thread%&#x27;;</span><br><span class="hljs-section">+-------------------+-------+</span><br><span class="hljs-section">| Variable_name     | Value |</span><br><span class="hljs-section">+-------------------+-------+</span><br>| Threads<span class="hljs-emphasis">_cached    | 0     |</span><br><span class="hljs-emphasis">| Threads_connected | 1     |</span><br><span class="hljs-emphasis">| Threads_created   | 1     |</span><br><span class="hljs-emphasis">| Threads_</span>running   | 1     |<br><span class="hljs-code">+-------------------+</span>-------+<br>4 rows in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><p>所有以<code>Thread</code>开头的<code>SESSION</code>作用范围的状态变量就都被展示出来了。</p><p>比方说<code>version</code>，表示当前<code>MySQL</code>的版本，我们客户端是不能设置它的值的，只能在<code>SHOW VARIABLES</code>语句里查看。</p><h1>3.字符集和比较规则</h1><h2 id="字符集和比较规则简介">字符集和比较规则简介</h2><h3 id="字符集简介">字符集简介</h3><p>我们知道在计算机中只能存储二进制数据，那该怎么存储字符串呢？当然是建立字符与二进制数据的映射关系了，建立这个关系最起码要搞清楚两件事儿：</p><ol><li><p>你要把哪些字符映射成二进制数据？</p><p>也就是界定清楚字符范围。</p></li><li><p>怎么映射？</p><p>将一个字符映射成一个二进制数据的过程也叫做<code>编码</code>，将一个二进制数据映射到一个字符的过程叫做<code>解码</code>。</p></li></ol><p>人们抽象出一个<code>字符集</code>的概念来描述某个字符范围的编码规则。比方说我们来自定义一个名称为<code>xiaohaizi</code>的字符集，它包含的字符范围和编码规则如下：</p><ul><li><p>包含字符<code>'a'</code>、<code>'b'</code>、<code>'A'</code>、<code>'B'</code>。</p></li><li><p>编码规则如下：</p><p>采用1个字节编码一个字符的形式，字符和字节的映射关系如下：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;a&#x27;</span> -&gt; <span class="hljs-number">00000001</span> (十六进制：<span class="hljs-number">0x01</span>)<br><span class="hljs-string">&#x27;b&#x27;</span> -&gt; <span class="hljs-number">00000010</span> (十六进制：<span class="hljs-number">0x02</span>)<br><span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">00000011</span> (十六进制：<span class="hljs-number">0x03</span>)<br><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">00000100</span> (十六进制：<span class="hljs-number">0x04</span>)<br></code></pre></td></tr></table></figure></li></ul><p>有了<code>xiaohaizi</code>字符集，我们就可以用二进制形式表示一些字符串了，下边是一些字符串用<code>xiaohaizi</code>字符集编码后的二进制表示：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;bA&#x27;</span> -&gt; <span class="hljs-number">0000001000000011</span>  (十六进制：<span class="hljs-number">0x0203</span>)<br><span class="hljs-string">&#x27;baB&#x27;</span> -&gt; <span class="hljs-number">000000100000000100000100</span>  (十六进制：<span class="hljs-number">0x020104</span>)<br><span class="hljs-string">&#x27;cd&#x27;</span> -&gt; 无法表示，字符集xiaohaizi不包含字符<span class="hljs-string">&#x27;c&#x27;</span>和<span class="hljs-string">&#x27;d&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="比较规则简介">比较规则简介</h3><p>在我们确定了<code>xiaohaizi</code>字符集表示字符的范围以及编码规则后，怎么比较两个字符的大小呢？最容易想到的就是直接比较这两个字符对应的二进制编码的大小，比方说字符<code>'a'</code>的编码为<code>0x01</code>，字符<code>'b'</code>的编码为<code>0x02</code>，所以<code>'a'</code>小于<code>'b'</code>，这种简单的比较规则也可以被称为二进制比较规则，英文名为<code>binary collation</code>。</p><p>二进制比较规则是简单，但有时候并不符合现实需求，比如在很多场合对于英文字符我们都是不区分大小写的，也就是说<code>'a'</code>和<code>'A'</code>是相等的，在这种场合下就不能简单粗暴的使用二进制比较规则了，这时候我们可以这样指定比较规则：</p><ol><li>将两个大小写不同的字符全都转为大写或者小写。</li><li>再比较这两个字符对应的二进制数据。</li></ol><p>这是一种稍微复杂一点点的比较规则，但是实际生活中的字符不止英文字符一种，比如我们的汉字有几万之多，对于某一种字符集来说，比较两个字符大小的规则可以制定出很多种，也就是说同一种字符集可以有多种比较规则，我们稍后就要介绍各种现实生活中用的字符集以及它们的一些比较规则。</p><h3 id="一些重要的字符集">一些重要的字符集</h3><p>不幸的是，这个世界太大了，不同的人制定出了好多种<code>字符集</code>，它们表示的字符范围和用到的编码规则可能都不一样。我们看一下一些常用字符集的情况：</p><ul><li><p><code>ASCII</code>字符集–<strong>1个字节</strong></p><p>共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才128个字符，所以可以使用1个字节来进行编码，我们看一些字符的编码方式：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;L&#x27;</span> -&gt;  <span class="hljs-number">01001100</span>（十六进制：<span class="hljs-number">0x4C</span>，十进制：<span class="hljs-number">76</span>）<br><span class="hljs-string">&#x27;M&#x27;</span> -&gt;  <span class="hljs-number">01001101</span>（十六进制：<span class="hljs-number">0x4D</span>，十进制：<span class="hljs-number">77</span>）<br></code></pre></td></tr></table></figure></li><li><p><code>ISO 8859-1</code>字符集–<strong>1个字节</strong></p><p>共收录256个字符，是在<code>ASCII</code>字符集的基础上又扩充了128个西欧常用字符(包括德法两国的字母)，也可以使用1个字节来进行编码。这个字符集也有一个别名<code>latin1</code>。</p></li><li><p><code>GB2312</code>字符集–<strong>1个字节or2个字节</strong></p><p>收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个，其他文字符号682个。同时这种字符集又兼容<code>ASCII</code>字符集，所以在编码方式上显得有些奇怪：</p><ul><li>如果该字符在<code>ASCII</code>字符集中，则采用1字节编码。</li><li>否则采用2字节编码。</li></ul><p>这种表示一个字符需要的字节数可能不同的编码方式称为<code>变长编码方式</code>。比方说字符串<code>'爱u'</code>，其中<code>'爱'</code>需要用2个字节进行编码，编码后的十六进制表示为<code>0xB0AE</code>，<code>'u'</code>需要用1个字节进行编码，编码后的十六进制表示为<code>0x75</code>，所以拼合起来就是<code>0xB0AE75</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>我们怎么区分某个字节代表一个单独的字符还是代表某个字符的一部分呢？别忘了`ASCII`字符集只收录128个字符，使用0～127就可以表示全部字符，所以如果某个字节是在0～127之内的，就意味着一个字节代表一个单独的字符，否则就是两个字节代表一个单独的字符。<br></code></pre></td></tr></table></figure></li><li><p><code>GBK</code>字符集–<strong>中文2个字节，英文1个字节</strong></p><p><code>GBK</code>字符集只是在收录字符范围上对<code>GB2312</code>字符集作了扩充，编码方式上兼容<code>GB2312</code>。</p></li><li><p><code>utf8</code>字符集–<strong>1～4个字节</strong></p><p>收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容<code>ASCII</code>字符集，采用变长编码方式，编码一个字符需要使用1～4个字节，比方说这样：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;L&#x27;</span> -&gt;  <span class="hljs-number">01001100</span>（十六进制：<span class="hljs-number">0x4C</span>）<br><span class="hljs-string">&#x27;啊&#x27;</span> -&gt;  <span class="hljs-number">111001011001010110001010</span>（十六进制：<span class="hljs-number">0xE5958A</span>）<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>其实准确的说，utf8只是Unicode字符集的一种编码方案，Unicode字符集可以采用utf8、utf16、utf32这几种编码方案，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符。更详细的Unicode和其编码方案的知识不是本书的重点，大家上网查查哈～<br><br>MySQL中并不区分字符集和编码方案的概念，所以后边唠叨的时候把utf8、utf16、utf32都当作一种字符集对待。<br></code></pre></td></tr></table></figure></li></ul><p>对于同一个字符，不同字符集也可能有不同的编码方式。比如对于汉字<code>'我'</code>来说，<code>ASCII</code>字符集中根本没有收录这个字符，<code>utf8</code>和<code>gb2312</code>字符集对汉字<code>我</code>的编码方式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">utf8</span>编码：<span class="hljs-number">111001101000100010010001</span> (<span class="hljs-number">3</span>个字节，十六进制表示是：<span class="hljs-number">0</span>xE<span class="hljs-number">68891</span>)<br><span class="hljs-attribute">gb2312</span>编码：<span class="hljs-number">1011000010101110</span> (<span class="hljs-number">2</span>个字节，十六进制表示是：<span class="hljs-number">0</span>xB<span class="hljs-number">0</span>AE)<br></code></pre></td></tr></table></figure><h2 id="MySQL中支持的字符集和排序规则">MySQL中支持的字符集和排序规则</h2><h3 id="MySQL中的utf8和utf8mb4">MySQL中的utf8和utf8mb4</h3><p>我们上边说<code>utf8</code>字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在<code>MySQL</code>中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计<code>MySQL</code>的大叔偷偷的定义了两个概念：</p><ul><li><code>utf8mb3</code>：阉割过的<code>utf8</code>字符集，只使用1～3个字节表示字符。</li><li><code>utf8mb4</code>：正宗的<code>utf8</code>字符集，使用1～4个字节表示字符。</li></ul><p>有一点需要大家十分的注意，在<code>MySQL</code>中<code>utf8</code>是<code>utf8mb3</code>的别名，所以之后在<code>MySQL</code>中提到<code>utf8</code>就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如<strong>存储一些emoji表情啥的，那请使用<code>utf8mb4</code></strong>。</p><h3 id="字符集的查看">字符集的查看</h3><p><code>MySQL</code>支持好多好多种字符集，查看当前<code>MySQL</code>中支持的字符集可以用下边这个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> (<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span><span class="hljs-operator">|</span>CHARSET) [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br></code></pre></td></tr></table></figure><p>其中<code>CHARACTER SET</code>和<code>CHARSET</code>是同义词，用任意一个都可以。我们查询一下（支持的字符集太多了，我们省略了一些）：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW CHARSET;<br>+----------+---------------------------------+---------------------+--------+<br>|<span class="hljs-string"> Charset  </span>|<span class="hljs-string"> Description                     </span>|<span class="hljs-string"> Default collation   </span>|<span class="hljs-string"> Maxlen </span>|<br>+----------+---------------------------------+---------------------+--------+<br>|<span class="hljs-string"> big5     </span>|<span class="hljs-string"> Big5 Traditional Chinese        </span>|<span class="hljs-string"> big5_chinese_ci     </span>|<span class="hljs-string">      2 </span>|<br>...<br>|<span class="hljs-string"> latin1   </span>|<span class="hljs-string"> cp1252 West European            </span>|<span class="hljs-string"> latin1_swedish_ci   </span>|<span class="hljs-string">      1 </span>|<br>|<span class="hljs-string"> latin2   </span>|<span class="hljs-string"> ISO 8859-2 Central European     </span>|<span class="hljs-string"> latin2_general_ci   </span>|<span class="hljs-string">      1 </span>|<br>...<br>|<span class="hljs-string"> ascii    </span>|<span class="hljs-string"> US ASCII                        </span>|<span class="hljs-string"> ascii_general_ci    </span>|<span class="hljs-string">      1 </span>|<br>...<br>|<span class="hljs-string"> gb2312   </span>|<span class="hljs-string"> GB2312 Simplified Chinese       </span>|<span class="hljs-string"> gb2312_chinese_ci   </span>|<span class="hljs-string">      2 </span>|<br>...<br>|<span class="hljs-string"> gbk      </span>|<span class="hljs-string"> GBK Simplified Chinese          </span>|<span class="hljs-string"> gbk_chinese_ci      </span>|<span class="hljs-string">      2 </span>|<br>|<span class="hljs-string"> latin5   </span>|<span class="hljs-string"> ISO 8859-9 Turkish              </span>|<span class="hljs-string"> latin5_turkish_ci   </span>|<span class="hljs-string">      1 </span>|<br>...<br>|<span class="hljs-string"> utf8     </span>|<span class="hljs-string"> UTF-8 Unicode                   </span>|<span class="hljs-string"> utf8_general_ci     </span>|<span class="hljs-string">      3 </span>|<br>|<span class="hljs-string"> ucs2     </span>|<span class="hljs-string"> UCS-2 Unicode                   </span>|<span class="hljs-string"> ucs2_general_ci     </span>|<span class="hljs-string">      2 </span>|<br>...<br>|<span class="hljs-string"> latin7   </span>|<span class="hljs-string"> ISO 8859-13 Baltic              </span>|<span class="hljs-string"> latin7_general_ci   </span>|<span class="hljs-string">      1 </span>|<br>|<span class="hljs-string"> utf8mb4  </span>|<span class="hljs-string"> UTF-8 Unicode                   </span>|<span class="hljs-string"> utf8mb4_general_ci  </span>|<span class="hljs-string">      4 </span>|<br>|<span class="hljs-string"> utf16    </span>|<span class="hljs-string"> UTF-16 Unicode                  </span>|<span class="hljs-string"> utf16_general_ci    </span>|<span class="hljs-string">      4 </span>|<br>|<span class="hljs-string"> utf16le  </span>|<span class="hljs-string"> UTF-16LE Unicode                </span>|<span class="hljs-string"> utf16le_general_ci  </span>|<span class="hljs-string">      4 </span>|<br>...<br>|<span class="hljs-string"> utf32    </span>|<span class="hljs-string"> UTF-32 Unicode                  </span>|<span class="hljs-string"> utf32_general_ci    </span>|<span class="hljs-string">      4 </span>|<br>|<span class="hljs-string"> binary   </span>|<span class="hljs-string"> Binary pseudo charset           </span>|<span class="hljs-string"> binary              </span>|<span class="hljs-string">      1 </span>|<br>...<br>|<span class="hljs-string"> gb18030  </span>|<span class="hljs-string"> China National Standard GB18030 </span>|<span class="hljs-string"> gb18030_chinese_ci  </span>|<span class="hljs-string">      4 </span>|<br>+----------+---------------------------------+---------------------+--------+<br>41 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>可以看到，我使用的这个<code>MySQL</code>版本一共支持<code>41</code>种字符集，其中的<code>Default collation</code>列表示这种字符集中一种默认的<code>比较规则</code>。大家注意返回结果中的最后一列<code>Maxlen</code>，它代表该种字符集表示一个字符最多需要几个字节。为了让大家的印象更深刻，我把几个常用到的字符集的<code>Maxlen</code>列摘抄下来，大家务必记住：</p><table><thead><tr><th>字符集名称</th><th>Maxlen</th></tr></thead><tbody><tr><td><code>ascii</code></td><td><code>1</code></td></tr><tr><td><code>latin1</code></td><td><code>1</code></td></tr><tr><td><code>gb2312</code></td><td><code>2</code></td></tr><tr><td><code>gbk</code></td><td><code>2</code></td></tr><tr><td><code>utf8</code></td><td><code>3</code></td></tr><tr><td><code>utf8mb4</code></td><td><code>4</code></td></tr></tbody></table><h3 id="比较规则的查看">比较规则的查看</h3><p>查看<code>MySQL</code>中支持的比较规则的命令如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">COLLATION</span> [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br></code></pre></td></tr></table></figure><p>我们前边说过一种字符集可能对应着若干种比较规则，<code>MySQL</code>支持的字符集就已经非常多了，所以支持的比较规则更多，我们先只查看一下<code>utf8</code>字符集下的比较规则：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW COLLATION LIKE &#x27;utf8\_%&#x27;;<br>+--------------------------+---------+-----+---------+----------+---------+<br>|<span class="hljs-string"> Collation                </span>|<span class="hljs-string"> Charset </span>|<span class="hljs-string"> Id  </span>|<span class="hljs-string"> Default </span>|<span class="hljs-string"> Compiled </span>|<span class="hljs-string"> Sortlen </span>|<br>+--------------------------+---------+-----+---------+----------+---------+<br>|<span class="hljs-string"> utf8_general_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string">  33 </span>|<span class="hljs-string"> Yes     </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       1 </span>|<br>|<span class="hljs-string"> utf8_bin                 </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string">  83 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       1 </span>|<br>|<span class="hljs-string"> utf8_unicode_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 192 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_icelandic_ci        </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 193 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_latvian_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 194 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_romanian_ci         </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 195 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_slovenian_ci        </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 196 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_polish_ci           </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 197 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_estonian_ci         </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 198 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_spanish_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 199 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_swedish_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 200 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_turkish_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 201 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_czech_ci            </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 202 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_danish_ci           </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 203 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_lithuanian_ci       </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 204 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_slovak_ci           </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 205 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_spanish2_ci         </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 206 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_roman_ci            </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 207 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_persian_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 208 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_esperanto_ci        </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 209 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_hungarian_ci        </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 210 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_sinhala_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 211 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_german2_ci          </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 212 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_croatian_ci         </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 213 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_unicode_520_ci      </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 214 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_vietnamese_ci       </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 215 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       8 </span>|<br>|<span class="hljs-string"> utf8_general_mysql500_ci </span>|<span class="hljs-string"> utf8    </span>|<span class="hljs-string"> 223 </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Yes      </span>|<span class="hljs-string">       1 </span>|<br>+--------------------------+---------+-----+---------+----------+---------+<br>27 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>这些比较规则的命名还挺有规律的，具体规律如下：</p><ul><li><p>比较规则名称以与其关联的字符集的名称开头。如上图的查询结果的比较规则名称都是以<code>utf8</code>开头的。</p></li><li><p>后边紧跟着该比较规则主要作用于哪种语言，比如<code>utf8_polish_ci</code>表示以波兰语的规则比较，<code>utf8_spanish_ci</code>是以西班牙语的规则比较，<code>utf8_general_ci</code>是一种通用的比较规则。</p></li><li><p>名称后缀意味着该比较规则是否区分语言中的重音、大小写啥的，具体可以用的值如下：</p><table><thead><tr><th>后缀</th><th>英文释义</th><th>描述</th></tr></thead><tbody><tr><td><code>_ai</code></td><td><code>accent insensitive</code></td><td>不区分重音</td></tr><tr><td><code>_as</code></td><td><code>accent sensitive</code></td><td>区分重音</td></tr><tr><td><code>_ci</code></td><td><code>case insensitive</code></td><td>不区分大小写</td></tr><tr><td><code>_cs</code></td><td><code>case sensitive</code></td><td>区分大小写</td></tr><tr><td><code>_bin</code></td><td><code>binary</code></td><td>以二进制方式比较</td></tr></tbody></table><p>比如<code>utf8_general_ci</code>这个比较规则是以<code>ci</code>结尾的，说明不区分大小写。</p></li></ul><p>每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则，<code>SHOW COLLATION</code>的返回结果中的<code>Default</code>列的值为<code>YES</code>的就是该字符集的默认比较规则，比方说<code>utf8</code>字符集默认的比较规则就是<code>utf8_general_ci</code>。</p><h2 id="字符集和比较规则的应用">字符集和比较规则的应用</h2><h3 id="各级别的字符集和比较规则">各级别的字符集和比较规则</h3><p><code>MySQL</code>有4个级别的字符集和比较规则，分别是：</p><ul><li>服务器级别</li><li>数据库级别</li><li>表级别</li><li>列级别</li></ul><p>我们接下来仔细看一下怎么设置和查看这几个级别的字符集和比较规则。</p><h4 id="服务器级别">服务器级别</h4><p><code>MySQL</code>提供了两个系统变量来表示服务器级别的字符集和比较规则：</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td><code>character_set_server</code></td><td>服务器级别的字符集</td></tr><tr><td><code>collation_server</code></td><td>服务器级别的比较规则</td></tr></tbody></table><p>我们看一下这两个系统变量的值：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_server&#x27;;</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| Variable_name        | Value |</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| character_set_server | utf8  |</span><br><span class="hljs-section">+----------------------+-------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_server&#x27;;</span><br><span class="hljs-section">+------------------+-----------------+</span><br><span class="hljs-section">| Variable_name    | Value           |</span><br><span class="hljs-section">+------------------+-----------------+</span><br><span class="hljs-section">| collation_server | utf8_general_ci |</span><br><span class="hljs-section">+------------------+-----------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>可以看到在我的计算机中服务器级别默认的字符集是<code>utf8</code>，默认的比较规则是<code>utf8_general_ci</code>。</p><p>我们可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用<code>SET</code>语句修改这两个变量的值。比如我们可以在配置文件中这样写：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">character_set_server</span>=gbk<br><span class="hljs-attr">collation_server</span>=gbk_chinese_ci<br></code></pre></td></tr></table></figure><p>当服务器启动的时候读取这个配置文件后这两个系统变量的值便修改了。</p><h4 id="数据库级别">数据库级别</h4><p>我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> 数据库名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> 比较规则名称];<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">DATABASE</span> 数据库名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> 比较规则名称];<br></code></pre></td></tr></table></figure><p>其中的<code>DEFAULT</code>可以省略，并不影响语句的语义。比方说我们新创建一个名叫<code>charset_demo_db</code>的数据库，在创建的时候指定它使用的字符集为<code>gb2312</code>，比较规则为<code>gb2312_chinese_ci</code>：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> charset_demo_db<br>    -&gt; <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> gb2312<br>    -&gt; <span class="hljs-keyword">COLLATE</span> gb2312_chinese_ci;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> affected (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><p>如果想查看当前数据库使用的字符集和比较规则，可以查看下面两个系统变量的值（前提是使用<code>USE</code>语句选择当前默认数据库，如果没有默认数据库，则变量与相应的服务器级系统变量具有相同的值）：</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td><code>character_set_database</code></td><td>当前数据库的字符集</td></tr><tr><td><code>collation_database</code></td><td>当前数据库的比较规则</td></tr></tbody></table><p>我们来查看一下刚刚创建的<code>charset_demo_db</code>数据库的字符集和比较规则：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; USE charset_demo_db;<br>Database changed<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_database&#x27;;</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| Variable_name          | Value  |</span><br><span class="hljs-section">+------------------------+--------+</span><br><span class="hljs-section">| character_set_database | gb2312 |</span><br><span class="hljs-section">+------------------------+--------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_database&#x27;;</span><br><span class="hljs-section">+--------------------+-------------------+</span><br><span class="hljs-section">| Variable_name      | Value             |</span><br><span class="hljs-section">+--------------------+-------------------+</span><br><span class="hljs-section">| collation_database | gb2312_chinese_ci |</span><br><span class="hljs-section">+--------------------+-------------------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><p>可以看到这个<code>charset_demo_db</code>数据库的字符集和比较规则就是我们在创建语句中指定的。需要注意的一点是： <em><strong>character_set_database</strong></em> 和 <em><strong>collation_database</strong></em> 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则。</p><p>数据库的创建语句中也可以不指定字符集和比较规则，比如这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> 数据库名;<br></code></pre></td></tr></table></figure><p>这样的话将使用服务器级别的字符集和比较规则作为数据库的字符集和比较规则。</p><h4 id="表级别">表级别</h4><p>我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (列的信息)<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [<span class="hljs-keyword">COLLATE</span> 比较规则名称]]<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [<span class="hljs-keyword">COLLATE</span> 比较规则名称]<br></code></pre></td></tr></table></figure><p>比方说我们在刚刚创建的<code>charset_demo_db</code>数据库中创建一个名为<code>t</code>的表，并指定这个表的字符集和比较规则：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     col <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><p>如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。假设我们的创建表<code>t</code>的语句是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t(<br>    col <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>)<br>);<br></code></pre></td></tr></table></figure><p>因为表<code>t</code>的建表语句中并没有明确指定字符集和比较规则，则表<code>t</code>的字符集和比较规则将继承所在数据库<code>charset_demo_db</code>的字符集和比较规则，也就是<code>gb2312</code>和<code>gb2312_chinese_ci</code>。</p><h4 id="列级别">列级别</h4><p>需要注意的是，对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>    列名 字符串类型 [<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称] [<span class="hljs-keyword">COLLATE</span> 比较规则名称],<br>    其他列...<br>);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 列名 字符串类型 [<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称] [<span class="hljs-keyword">COLLATE</span> 比较规则名称];<br></code></pre></td></tr></table></figure><p>比如我们修改一下表<code>t</code>中列<code>col</code>的字符集和比较规则可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> t MODIFY col <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> gbk <span class="hljs-keyword">COLLATE</span> gbk_chinese_ci;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.04</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>mysql<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则。比方说表<code>t</code>的字符集是<code>utf8</code>，比较规则是<code>utf8_general_ci</code>，修改列<code>col</code>的语句是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> t MODIFY col <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>那列<code>col</code>的字符集和编码将使用表<code>t</code>的字符集和比较规则，也就是<code>utf8</code>和<code>utf8_general_ci</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示会发生错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的话就会出错，因为ascii字符集并不能表示汉字字符。<br></code></pre></td></tr></table></figure><h4 id="仅修改字符集或仅修改比较规则">仅修改字符集或仅修改比较规则</h4><p>由于字符集和比较规则是互相有联系的，如果我们只修改了字符集，比较规则也会跟着变化，如果只修改了比较规则，字符集也会跟着变化，具体规则如下：</p><ul><li>只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。</li><li>只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。</li></ul><p>不论哪个级别的字符集和比较规则，这两条规则都适用，我们以服务器级别的字符集和比较规则为例来看一下详细过程：</p><ul><li><p>只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; SET character_set_server = gb2312;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_server&#x27;;</span><br><span class="hljs-section">+----------------------+--------+</span><br><span class="hljs-section">| Variable_name        | Value  |</span><br><span class="hljs-section">+----------------------+--------+</span><br><span class="hljs-section">| character_set_server | gb2312 |</span><br><span class="hljs-section">+----------------------+--------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt;  SHOW VARIABLES LIKE &#x27;collation_server&#x27;;</span><br><span class="hljs-section">+------------------+-------------------+</span><br><span class="hljs-section">| Variable_name    | Value             |</span><br><span class="hljs-section">+------------------+-------------------+</span><br><span class="hljs-section">| collation_server | gb2312_chinese_ci |</span><br><span class="hljs-section">+------------------+-------------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>我们只修改了<code>character_set_server</code>的值为<code>gb2312</code>，<code>collation_server</code>的值自动变为了<code>gb2312_chinese_ci</code>。</p></li><li><p>只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; SET collation_server = utf8_general_ci;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_server&#x27;;</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| Variable_name        | Value |</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| character_set_server | utf8  |</span><br><span class="hljs-section">+----------------------+-------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_server&#x27;;</span><br><span class="hljs-section">+------------------+-----------------+</span><br><span class="hljs-section">| Variable_name    | Value           |</span><br><span class="hljs-section">+------------------+-----------------+</span><br><span class="hljs-section">| collation_server | utf8_general_ci |</span><br><span class="hljs-section">+------------------+-----------------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><p>我们只修改了<code>collation_server</code>的值为<code>utf8_general_ci</code>，<code>character_set_server</code>的值自动变为了<code>utf8</code>。</p></li></ul><h4 id="各级别字符集和比较规则小结">各级别字符集和比较规则小结</h4><p>我们介绍的这4个级别字符集和比较规则的联系如下：</p><ul><li>如果<strong>创建或修改列</strong>时没有显式的指定字符集和比较规则，<strong>则该列默认用表的字符集和比较规则</strong></li><li>如果<strong>创建表</strong>时没有显式的指定字符集和比较规则，<strong>则该表默认用数据库的字符集和比较规则</strong></li><li>如果<strong>创建数据库</strong>时没有显式的指定字符集和比较规则，<strong>则该数据库默认用服务器的字符集和比较规则</strong></li></ul><p>知道了这些规则之后，对于给定的表，我们应该知道它的各个列的字符集和比较规则是什么，从而根据这个列的类型来确定存储数据时每个列的实际数据占用的存储空间大小了。比方说我们向表<code>t</code>中插入一条记录：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; INSERT INTO t(col) VALUES(<span class="hljs-emphasis">&#x27;我我&#x27;</span>);<br>Query OK, 1 row affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM t;</span><br><span class="hljs-section">+--------+</span><br><span class="hljs-section">| s      |</span><br><span class="hljs-section">+--------+</span><br><span class="hljs-section">| 我我   |</span><br><span class="hljs-section">+--------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>首先列<code>col</code>使用的字符集是<code>gbk</code>，一个字符<code>'我'</code>在<code>gbk</code>中的编码为<code>0xCED2</code>，占用两个字节，两个字符的实际数据就占用4个字节。如果把该列的字符集修改为<code>utf8</code>的话，这两个字符就实际占用6个字节啦～</p><h3 id="客户端和服务器通信中的字符集">客户端和服务器通信中的字符集</h3><h4 id="编码和解码使用的字符集不一致的后果">编码和解码使用的字符集不一致的后果</h4><p>说到底，字符串在计算机上的体现就是一个字节串，如果你使用不同字符集去解码这个字节串，最后得到的结果可能让你挠头。</p><p>我们知道字符<code>'我'</code>在<code>utf8</code>字符集编码下的字节串长这样：<code>0xE68891</code>，如果一个程序把这个字节串发送到另一个程序里，另一个程序用不同的字符集去解码这个字节串，假设使用的是<code>gbk</code>字符集来解释这串字节，解码过程就是这样的：</p><ol><li>首先看第一个字节<code>0xE6</code>，它的值大于<code>0x7F</code>（十进制：127），说明是两字节编码，继续读一字节后是<code>0xE688</code>，然后从<code>gbk</code>编码表中查找字节为<code>0xE688</code>对应的字符，发现是字符<code>'鎴'</code></li><li>继续读一个字节<code>0x91</code>，它的值也大于<code>0x7F</code>，再往后读一个字节发现木有了，所以这是半个字符。</li><li>所以<code>0xE68891</code>被<code>gbk</code>字符集解释成一个字符<code>'鎴'</code>和半个字符。</li></ol><p>假设用<code>iso-8859-1</code>，也就是<code>latin1</code>字符集去解释这串字节，解码过程如下：</p><ol><li>先读第一个字节<code>0xE6</code>，它对应的<code>latin1</code>字符为<code>æ</code>。</li><li>再读第二个字节<code>0x88</code>，它对应的<code>latin1</code>字符为<code>ˆ</code>。</li><li>再读第三个字节<code>0x91</code>，它对应的<code>latin1</code>字符为<code>‘</code>。</li><li>所以整串字节<code>0xE68891</code>被<code>latin1</code>字符集解释后的字符串就是<code>'æˆ‘'</code></li></ol><p>可见，如果对于同一个字符串编码和解码使用的字符集不一样，会产生意想不到的结果，作为人类的我们看上去就像是产生了乱码一样。</p><h4 id="字符集转换的概念">字符集转换的概念</h4><p>如果接收<code>0xE68891</code>这个字节串的程序按照<code>utf8</code>字符集进行解码，然后又把它按照<code>gbk</code>字符集进行编码，最后编码后的字节串就是<code>0xCED2</code>，我们把这个过程称为<code>字符集的转换</code>，也就是字符串<code>'我'</code>从<code>utf8</code>字符集转换为<code>gbk</code>字符集。</p><h4 id="MySQL中字符集的转换">MySQL中字符集的转换</h4><p>我们知道从客户端发往服务器的请求本质上就是一个字符串，服务器向客户端返回的结果本质上也是一个字符串，而字符串其实是使用某种字符集编码的二进制数据。这个字符串可不是使用一种字符集的编码方式一条道走到黑的，从发送请求到返回结果这个过程中伴随着多次字符集的转换，在这个过程中会用到3个系统变量，我们先把它们写出来看一下：</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td><code>character_set_client</code></td><td>服务器解码请求时使用的字符集</td></tr><tr><td><code>character_set_connection</code></td><td>服务器处理请求时会把请求字符串从<code>character_set_client</code>转为<code>character_set_connection</code></td></tr><tr><td><code>character_set_results</code></td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>这几个系统变量在我的计算机上的默认值如下（不同操作系统的默认值可能不同）：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_client&#x27;;</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| Variable_name        | Value |</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| character_set_client | utf8  |</span><br><span class="hljs-section">+----------------------+-------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_connection&#x27;;</span><br><span class="hljs-section">+--------------------------+-------+</span><br><span class="hljs-section">| Variable_name            | Value |</span><br><span class="hljs-section">+--------------------------+-------+</span><br><span class="hljs-section">| character_set_connection | utf8  |</span><br><span class="hljs-section">+--------------------------+-------+</span><br>1 row in set (0.01 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_results&#x27;;</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| Variable_name         | Value |</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| character_set_results | utf8  |</span><br><span class="hljs-section">+-----------------------+-------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>大家可以看到这几个系统变量的值都是<code>utf8</code>，为了体现出字符集在请求处理过程中的变化，我们这里特意修改一个系统变量的值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; set character_set_connection = gbk;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br></code></pre></td></tr></table></figure><p>所以现在系统变量<code>character_set_client</code>和<code>character_set_results</code>的值还是<code>utf8</code>，而<code>character_set_connection</code>的值为<code>gbk</code>。现在假设我们客户端发送的请求是下边这个字符串：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> s = <span class="hljs-string">&#x27;我&#x27;</span>;<br></code></pre></td></tr></table></figure><p>为了方便大家理解这个过程，我们只分析字符<code>'我'</code>在这个过程中字符集的转换。</p><p>现在看一下在请求从发送到结果返回过程中字符集的变化：</p><ol><li><p>客户端发送请求所使用的字符集</p><p>一般情况下客户端所使用的字符集和当前操作系统一致，不同操作系统使用的字符集可能不一样，如下：</p><ul><li>类<code>Unix</code>系统使用的是<code>utf8</code></li><li><code>Windows</code>使用的是<code>gbk</code></li></ul><p>例如我在使用的<code>macOS</code>操作系统时，客户端使用的就是<code>utf8</code>字符集。所以字符<code>'我'</code>在发送给服务器的请求中的字节形式就是：<code>0xE68891</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>如果你使用的是可视化工具，比如navicat之类的，这些工具可能会使用自定义的字符集来编码发送到服务器的字符串，而不采用操作系统默认的字符集（所以在学习的时候还是尽量用黑框框哈）。<br></code></pre></td></tr></table></figure></li><li><p>服务器接收到客户端发送来的请求其实是一串二进制的字节，它会认为这串字节采用的字符集是<code>character_set_client</code>，然后把这串字节转换为<code>character_set_connection</code>字符集编码的字符。</p><p>由于我的计算机上<code>character_set_client</code>的值是<code>utf8</code>，首先会按照<code>utf8</code>字符集对字节串<code>0xE68891</code>进行解码，得到的字符串就是<code>'我'</code>，然后按照<code>character_set_connection</code>代表的字符集，也就是<code>gbk</code>进行编码，得到的结果就是字节串<code>0xCED2</code>。</p></li><li><p>因为表<code>t</code>的列<code>col</code>采用的是<code>gbk</code>字符集，与<code>character_set_connection</code>一致，所以直接到列中找字节值为<code>0xCED2</code>的记录，最后找到了一条记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>如果某个列使用的字符集和character_set_connection代表的字符集不一致的话，还需要进行一次字符集转换。<br></code></pre></td></tr></table></figure></li><li><p>上一步骤找到的记录中的<code>col</code>列其实是一个字节串<code>0xCED2</code>，<code>col</code>列是采用<code>gbk</code>进行编码的，所以首先会将这个字节串使用<code>gbk</code>进行解码，得到字符串<code>'我'</code>，然后再把这个字符串使用<code>character_set_results</code>代表的字符集，也就是<code>utf8</code>进行编码，得到了新的字节串：<code>0xE68891</code>，然后发送给客户端。</p></li><li><p>由于客户端是用的字符集是<code>utf8</code>，所以可以顺利的将<code>0xE68891</code>解释成字符<code>我</code>，从而显示到我们的显示器上，所以我们人类也读懂了返回的结果。</p></li></ol><p>如果你读上边的文字有点晕，可以参照这个图来仔细分析一下这几个步骤：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a2f479833d3340~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d6dfk4orjaj1ra8536aijb99.png-112.4kB"><p>从这个分析中我们可以得出这么几点需要注意的地方：</p><ul><li><p>服务器认为客户端发送过来的请求是用<code>character_set_client</code>编码的。</p><p>假设你的客户端采用的字符集和 <em><strong>character_set_client</strong></em> 不一样的话，这就会出现意想不到的情况。比如我的客户端使用的是<code>utf8</code>字符集，如果把系统变量<code>character_set_client</code>的值设置为<code>ascii</code>的话，服务器可能无法理解我们发送的请求，更别谈处理这个请求了。</p></li><li><p>服务器将把得到的结果集使用<code>character_set_results</code>编码后发送给客户端。</p><p>假设你的客户端采用的字符集和 <em><strong>character_set_results</strong></em> 不一样的话，这就可能会出现客户端无法解码结果集的情况，结果就是在你的屏幕上出现乱码。比如我的客户端使用的是<code>utf8</code>字符集，如果把系统变量<code>character_set_results</code>的值设置为<code>ascii</code>的话，可能会产生乱码。</p></li><li><p><code>character_set_connection</code>只是服务器在将请求的字节串从<code>character_set_client</code>转换为<code>character_set_connection</code>时使用，它是什么其实没多重要，但是一定要注意，该字符集包含的字符范围一定涵盖请求中的字符，要不然会导致有的字符无法使用<code>character_set_connection</code>代表的字符集进行编码。比如你把<code>character_set_client</code>设置为<code>utf8</code>，把<code>character_set_connection</code>设置成<code>ascii</code>，那么此时你如果从客户端发送一个汉字到服务器，那么服务器无法使用<code>ascii</code>字符集来编码这个汉字，就会向用户发出一个警告。</p></li></ul><p>知道了在<code>MySQL</code>中从发送请求到返回结果过程里发生的各种字符集转换，但是为啥要转来转去的呢？不晕么？</p><p>答：是的，很头晕，所以我们通常都把 <em><strong>character_set_client</strong></em> 、<em><strong>character_set_connection</strong></em>、<em><strong>character_set_results</strong></em> 这三个系统变量设置成和客户端使用的字符集一致的情况，这样减少了很多无谓的字符集转换。为了方便我们设置，<code>MySQL</code>提供了一条非常简便的语句：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> NAMES 字符集名;<br></code></pre></td></tr></table></figure><p>这一条语句产生的效果和我们执行这3条的效果是一样的：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">SET character_set_client</span> = 字符集名;<br><span class="hljs-attribute">SET character_set_connection</span> = 字符集名;<br><span class="hljs-attribute">SET character_set_results</span> = 字符集名;<br></code></pre></td></tr></table></figure><p>比方说我的客户端使用的是<code>utf8</code>字符集，所以需要把这几个系统变量的值都设置为<code>utf8</code>：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; SET NAMES utf8;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_client&#x27;;</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| Variable_name        | Value |</span><br><span class="hljs-section">+----------------------+-------+</span><br><span class="hljs-section">| character_set_client | utf8  |</span><br><span class="hljs-section">+----------------------+-------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt;  SHOW VARIABLES LIKE &#x27;character_set_connection&#x27;;</span><br><span class="hljs-section">+--------------------------+-------+</span><br><span class="hljs-section">| Variable_name            | Value |</span><br><span class="hljs-section">+--------------------------+-------+</span><br><span class="hljs-section">| character_set_connection | utf8  |</span><br><span class="hljs-section">+--------------------------+-------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_results&#x27;;</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| Variable_name         | Value |</span><br><span class="hljs-section">+-----------------------+-------+</span><br><span class="hljs-section">| character_set_results | utf8  |</span><br><span class="hljs-section">+-----------------------+-------+</span><br>1 row in set (0.00 sec)<br><br>mysql&gt;<br>小贴士：<br><br>如果你使用的是Windows系统，那应该设置成gbk。<br></code></pre></td></tr></table></figure><p>另外，如果你想在启动客户端的时候就把<code>character_set_client</code>、<code>character_set_connection</code>、<code>character_set_results</code>这三个系统变量的值设置成一样的，那我们可以在启动客户端的时候指定一个叫<code>default-character-set</code>的启动选项，比如在配置文件里可以这么写：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">client</span>]<br><span class="hljs-literal">default</span>-character-<span class="hljs-keyword">set</span>=utf8<br></code></pre></td></tr></table></figure><p>它起到的效果和执行一遍<code>SET NAMES utf8</code>是一样一样的，都会将那三个系统变量的值设置成<code>utf8</code>。</p><h3 id="比较规则的应用">比较规则的应用</h3><p>结束了字符集的漫游，我们把视角再次聚焦到<code>比较规则</code>，<code>比较规则</code>的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中，所以有时候也称为<code>排序规则</code>。比方说表<code>t</code>的列<code>col</code>使用的字符集是<code>gbk</code>，使用的比较规则是<code>gbk_chinese_ci</code>，我们向里边插入几条记录：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">mysql</span>&gt; <span class="hljs-selector-tag">INSERT</span> <span class="hljs-selector-tag">INTO</span> <span class="hljs-selector-tag">t</span>(col) <span class="hljs-selector-tag">VALUES</span>(<span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-string">&#x27;A&#x27;</span>), (<span class="hljs-string">&#x27;B&#x27;</span>);<br><span class="hljs-selector-tag">Query</span> <span class="hljs-selector-tag">OK</span>, <span class="hljs-selector-tag">4</span> <span class="hljs-selector-tag">rows</span> <span class="hljs-selector-tag">affected</span> (<span class="hljs-number">0.00</span> sec)<br><span class="hljs-selector-tag">Records</span>: <span class="hljs-selector-tag">4</span>  <span class="hljs-selector-tag">Duplicates</span>: <span class="hljs-selector-tag">0</span>  <span class="hljs-selector-tag">Warnings</span>: <span class="hljs-selector-tag">0</span><br><br><span class="hljs-selector-tag">mysql</span>&gt;<br></code></pre></td></tr></table></figure><p>我们查询的时候按照<code>t</code>列排序一下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t ORDER BY col;</span><br><span class="hljs-section">+------+</span><br><span class="hljs-section">| col  |</span><br><span class="hljs-section">+------+</span><br>| a    |<br>| A    |<br>| b    |<br>| B    |<br><span class="hljs-section">| 我   |</span><br><span class="hljs-section">+------+</span><br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>可以看到在默认的比较规则<code>gbk_chinese_ci</code>中是不区分大小写的，我们现在把列<code>col</code>的比较规则修改为<code>gbk_bin</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; ALTER TABLE t MODIFY col VARCHAR(<span class="hljs-number">10</span>) COLLATE gbk_bin;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">5</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">02</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">5</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>由于<code>gbk_bin</code>是直接比较字符的编码，所以是区分大小写的，我们再看一下排序后的查询结果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t ORDER BY s;</span><br><span class="hljs-section">+------+</span><br><span class="hljs-section">| s    |</span><br><span class="hljs-section">+------+</span><br>| A    |<br>| B    |<br>| a    |<br>| b    |<br><span class="hljs-section">| 我   |</span><br><span class="hljs-section">+------+</span><br>5 rows in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><p>所以如果以后大家在对字符串做比较或者对某个字符串列做排序操作时没有得到想象中的结果，需要思考一下是不是<code>比较规则</code>的问题～</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">小贴士：<br><br>列`col`中各个字符在使用gbk字符集编码后对应的数字如下：<br><span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">65</span> （十进制）<br><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">66</span> （十进制）<br><span class="hljs-string">&#x27;a&#x27;</span> -&gt; <span class="hljs-number">97</span> （十进制）<br><span class="hljs-string">&#x27;b&#x27;</span> -&gt; <span class="hljs-number">98</span> （十进制）<br><span class="hljs-string">&#x27;我&#x27;</span> -&gt; <span class="hljs-number">25105</span> （十进制）<br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li><p><code>字符集</code>指的是某个字符范围的编码规则。</p></li><li><p><code>比较规则</code>是针对某个字符集中的字符比较大小的一种规则。</p></li><li><p>在<code>MySQL</code>中，一个字符集可以有若干种比较规则，其中有一个默认的比较规则，一个比较规则必须对应一个字符集。</p></li><li><p>查看<code>MySQL</code>中查看支持的字符集和比较规则的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> (<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span><span class="hljs-operator">|</span>CHARSET) [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">COLLATION</span> [<span class="hljs-keyword">LIKE</span> 匹配的模式];<br></code></pre></td></tr></table></figure></li><li><p>MySQL有四个级别的字符集和比较规则</p></li></ol><ul><li><p>服务器级别</p><p><code>character_set_server</code>表示服务器级别的字符集，<code>collation_server</code>表示服务器级别的比较规则。</p></li><li><p>数据库级别</p><p>创建和修改数据库时可以指定字符集和比较规则：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> 数据库名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> 比较规则名称];<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">DATABASE</span> 数据库名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-keyword">COLLATE</span> 比较规则名称];<br></code></pre></td></tr></table></figure><p><code>character_set_database</code>表示当前数据库的字符集，<code>collation_database</code>表示当前默认数据库的比较规则，这两个系统变量是只读的，不能修改。如果没有指定当前默认数据库，则变量与相应的服务器级系统变量具有相同的值。</p></li><li><p>表级别</p><p>创建和修改表的时候指定表的字符集和比较规则：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (列的信息)<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [<span class="hljs-keyword">COLLATE</span> 比较规则名称]];<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br>    [[<span class="hljs-keyword">DEFAULT</span>] <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称]<br>    [<span class="hljs-keyword">COLLATE</span> 比较规则名称];<br></code></pre></td></tr></table></figure></li><li><p>列级别</p><p>创建和修改列定义的时候可以指定该列的字符集和比较规则：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>    列名 字符串类型 [<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称] [<span class="hljs-keyword">COLLATE</span> 比较规则名称],<br>    其他列...<br>);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 列名 字符串类型 [<span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集名称] [<span class="hljs-keyword">COLLATE</span> 比较规则名称];<br></code></pre></td></tr></table></figure></li></ul><ol><li><p>从发送请求到接收结果过程中发生的字符集转换：</p><ul><li>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</li><li>服务器将客户端发送来的字节串采用<code>character_set_client</code>代表的字符集进行解码，将解码后的字符串再按照<code>character_set_connection</code>代表的字符集进行编码。</li><li>如果<code>character_set_connection</code>代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从<code>character_set_connection</code>代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</li><li>将从某个列获取到的字节串从该列使用的字符集转换为<code>character_set_results</code>代表的字符集后发送到客户端。</li><li>客户端使用操作系统的字符集解析收到的结果集字节串。</li></ul><p>在这个过程中各个系统变量的含义如下：</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td><code>character_set_client</code></td><td>服务器解码请求时使用的字符集</td></tr><tr><td><code>character_set_connection</code></td><td>服务器处理请求时会把请求字符串从<code>character_set_client</code>转为<code>character_set_connection</code></td></tr><tr><td><code>character_set_results</code></td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>一般情况下要使用保持这三个变量的值和客户端使用的字符集相同。</p></li><li><p>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</p></li></ol><h1>4.InnoDB记录存储结构</h1><h2 id="准备工作">准备工作</h2><p><code>MySQL</code>服务器上负责对表中数据的读取和写入工作的部分是<code>存储引擎</code>，而服务器又支持不同类型的存储引擎，比如<code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>啥的，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，真实数据在不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如<code>Memory</code>都不用磁盘来存储数据，也就是说关闭服务器后表中的数据就消失了。</p><h2 id="InnoDB页简介">InnoDB页简介</h2><p><code>InnoDB</code>是一个<strong>将表中的数据存储到磁盘上的存储引擎</strong>，所以即使关机后重启我们的数据还是存在的。**真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。**而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，<code>InnoDB</code>存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，<code>InnoDB</code>采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 <em><strong>16</strong></em> KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p><h2 id="InnoDB行格式">InnoDB行格式</h2><p>我们平时是以<strong>记录为单位</strong>来向表中插入数据的，这些记录在磁盘上的存放方式也被称为<code>行格式</code>或者<code>记录格式</code>。设计<code>InnoDB</code>存储引擎的大叔们到现在为止设计了4种不同类型的<code>行格式</code>，分别是<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>和<code>Compressed</code>行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。</p><h3 id="指定行格式的语法">指定行格式的语法</h3><p>我们可以在创建或修改表的语句中指定<code>行格式</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="hljs-operator">=</span>行格式名称<br>    <br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 ROW_FORMAT<span class="hljs-operator">=</span>行格式名称<br></code></pre></td></tr></table></figure><p>比如我们在<code>xiaohaizi</code>数据库里创建一个演示用的表<code>record_format_demo</code>，可以这样指定它的<code>行格式</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> USE xiaohaizi;<br>Database changed<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> record_format_demo (<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c3 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c4 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>COMPACT;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><p>可以看到我们刚刚创建的这个表的<code>行格式</code>就是<code>Compact</code>，另外，我们还显式指定了这个表的字符集为<code>ascii</code>，因为<code>ascii</code>字符集只包括空格、标点符号、数字、大小写字母和一些不可见字符，所以我们的汉字是不能存到这个表里的。我们现在向这个表中插入两条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> record_format_demo(c1, c2, c3, c4) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;aaaa&#x27;</span>, <span class="hljs-string">&#x27;bbb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>), (<span class="hljs-string">&#x27;eeee&#x27;</span>, <span class="hljs-string">&#x27;fff&#x27;</span>, <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">NULL</span>);<br>Query OK, <span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.02</span> sec)<br>Records: <span class="hljs-number">2</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>现在表中的记录就是这个样子的：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM record_format_demo;</span><br><span class="hljs-section">+------+-----+------+------+</span><br><span class="hljs-section">| c1   | c2  | c3   | c4   |</span><br><span class="hljs-section">+------+-----+------+------+</span><br>| aaaa | bbb | cc   | d    |<br><span class="hljs-section">| eeee | fff | NULL | NULL |</span><br><span class="hljs-section">+------+-----+------+------+</span><br>2 rows in set (0.00 sec)<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><p>演示表的内容也填充好了，现在我们就来看看各个行格式下的存储方式到底有啥不同吧～</p><h3 id="COMPACT行格式">COMPACT行格式</h3><p>废话不多说，直接看图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e8fafc21aa~tplv-t2oaga2asx-watermark-20211201102238092.awebp" class="" title="image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB"><p>大家从图中可以看出来，一条完整的记录其实可以被分为<code>记录的额外信息</code>和<code>记录的真实数据</code>两大部分，下边我们详细看一下这两部分的组成。</p><h4 id="记录的额外信息">记录的额外信息</h4><p>这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是<code>变长字段长度列表</code>、<code>NULL值列表</code>和<code>记录头信息</code>，我们分别看一下。</p><h5 id="变长字段长度列表">变长字段长度列表</h5><p>我们知道<code>MySQL</code>支持一些变长的数据类型，比如<code>VARCHAR(M)</code>、<code>VARBINARY(M)</code>、各种<code>TEXT</code>类型，各种<code>BLOB</code>类型，我们也可以把拥有这些数据类型的列称为<code>变长字段</code>，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把<code>MySQL</code>服务器搞懵，所以这些变长字段占用的存储空间分为两部分：</p><ol><li>真正的数据内容</li><li>占用的字节数</li></ol><p>在<code>Compact</code>行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，<strong>各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！</strong></p><p>我们拿<code>record_format_demo</code>表中的第一条记录来举个例子。因为<code>record_format_demo</code>表的<code>c1</code>、<code>c2</code>、<code>c4</code>列都是<code>VARCHAR(10)</code>类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为<code>record_format_demo</code>表中的各个列都使用的是<code>ascii</code>字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各变长字段内容的长度：</p><table><thead><tr><th>列名</th><th>存储内容</th><th>内容长度（十进制表示）</th><th>内容长度（十六进制表示）</th></tr></thead><tbody><tr><td><code>c1</code></td><td><code>'aaaa'</code></td><td><code>4</code></td><td><code>0x04</code></td></tr><tr><td><code>c2</code></td><td><code>'bbb'</code></td><td><code>3</code></td><td><code>0x03</code></td></tr><tr><td><code>c4</code></td><td><code>'d'</code></td><td><code>1</code></td><td><code>0x01</code></td></tr></tbody></table><p>又因为这些长度值需要按照列的逆序存放，所以最后<code>变长字段长度列表</code>的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">01 </span><span class="hljs-number">03</span> <span class="hljs-number">04</span> <br></code></pre></td></tr></table></figure><p>把这个字节串组成的<code>变长字段长度列表</code>填入上边的示意图中的效果就是：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e8fb363bb4~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9gbruvo504dlg1qsf19nbeu878.png-37kB"><p>由于第一行记录中<code>c1</code>、<code>c2</code>、<code>c4</code>列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。具体用1个还是2个字节来表示真实数据占用的字节数，<code>InnoDB</code>有它的一套规则，我们首先声明一下<code>W</code>、<code>M</code>和<code>L</code>的意思：</p><ol><li>假设某个字符集中表示一个字符最多需要使用的字节数为<code>W</code>，也就是使用<code>SHOW CHARSET</code>语句的结果中的<code>Maxlen</code>列，比方说<code>utf8</code>字符集中的<code>W</code>就是<code>3</code>，<code>gbk</code>字符集中的<code>W</code>就是<code>2</code>，<code>ascii</code>字符集中的<code>W</code>就是<code>1</code>。</li><li>对于变长类型<code>VARCHAR(M)</code>来说，这种类型表示能存储最多<code>M</code>个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是<code>M×W</code>。</li><li>假设它实际存储的字符串占用的字节数是<code>L</code>。</li></ol><p>所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：</p><ul><li><p>如果<code>M×W &lt;= 255</code>，那么使用1个字节来表示真正字符串占用的字节数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs !">也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。<br></code></pre></td></tr></table></figure></li><li><p>如果<code>M×W &gt; 255</code>，则分为两种情况：</p><ul><li>如果<code>L &lt;= 127</code>，则用1个字节来表示真正字符串占用的字节数。</li><li>如果<code>L &gt; 127</code>，则用2个字节来表示真正字符串占用的字节数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？设计InnoDB的大叔使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。<br><br>对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中（我们后边会唠叨），在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。<br></code></pre></td></tr></table></figure></li></ul><p>总结一下就是说：<strong>如果该可变字段允许存储的最大字节数（<code>M×W</code>）超过255字节并且真实存储的字节数（<code>L</code>）超过127字节，则使用2个字节，否则使用1个字节。</strong></p><p>另外需要注意的一点是，变长字段长度列表中只存储值为 <em><strong>非NULL</strong></em> 的列内容占用的长度，值为 <em><strong>NULL</strong></em> 的列的长度是不储存的 。也就是说对于第二条记录来说，因为<code>c4</code>列的值为<code>NULL</code>，所以第二条记录的<code>变长字段长度列表</code>只需要存储<code>c1</code>和<code>c2</code>列的长度即可。其中<code>c1</code>列存储的值为<code>'eeee'</code>，占用的字节数为<code>4</code>，<code>c2</code>列存储的值为<code>'fff'</code>，占用的字节数为<code>3</code>。数字<code>4</code>可以用1个字节表示，<code>3</code>也可以用1个字节表示，所以整个<code>变长字段长度列表</code>共需2个字节。填充完<code>变长字段长度列表</code>的两条记录的对比图如下：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e8fe4ee6b0~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9grq2b2jok1062t8tov21lqjbj.png-42.6kB"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。<br></code></pre></td></tr></table></figure><h5 id="NULL值列表">NULL值列表</h5><p>我们知道表中的某些列可能存储<code>NULL</code>值，如果把这些<code>NULL</code>值都放到<code>记录的真实数据</code>中存储会很占地方，所以<code>Compact</code>行格式把这些值为<code>NULL</code>的列统一管理起来，存储到<code>NULL</code>值列表中，它的处理过程是这样的：</p><ol><li><p>首先统计表中允许存储<code>NULL</code>的列有哪些。</p><p>我们前边说过，主键列、被<code>NOT NULL</code>修饰的列都是不可以存储<code>NULL</code>值的，所以在统计的时候不会把这些列算进去。比方说表<code>record_format_demo</code>的3个列<code>c1</code>、<code>c3</code>、<code>c4</code>都是允许存储<code>NULL</code>值的，而<code>c2</code>列是被<code>NOT NULL</code>修饰，不允许存储<code>NULL</code>值。</p></li><li><p>如果表中没有允许存储 <em><strong>NULL</strong></em> 的列，则 <em>NULL值列表</em> 也不存在了，否则将每个允许存储<code>NULL</code>的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为<code>NULL</code>。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为<code>NULL</code>。</li></ul><p>因为表<code>record_format_demo</code>有3个值允许为<code>NULL</code>的列，所以这3个列和二进制位的对应关系就是这样：</p></li></ol><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9018133f7~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9g88mtt1tj51ua1qh51vjo12pg5k.png-10.4kB"><ol><li><p>再一次强调，二进制位按照列的顺序逆序排列，所以第一个列<code>c1</code>和最后一个二进制位对应。</p></li><li><p><code>MySQL</code>规定<code>NULL值列表</code>必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补<code>0</code>。</p><p>表<code>record_format_demo</code>只有3个值允许为<code>NULL</code>的列，对应3个二进制位，不足一个字节，所以在字节的高位补<code>0</code>，效果就是这样：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e901669f45~tplv-t2oaga2asx-watermark.awebp" alt="image_1c9g8g27b1bdlu7t187emsc46s61.png-19.4kB"></p><p>以此类推，如果一个表中有9个允许为<code>NULL</code>，那这个记录的<code>NULL</code>值列表部分就需要2个字节来表示了。</p></li></ol><p>知道了规则之后，我们再返回头看表<code>record_format_demo</code>中的两条记录中的<code>NULL值列表</code>应该怎么储存。因为只有<code>c1</code>、<code>c3</code>、<code>c4</code>这3个列允许存储<code>NULL</code>值，所以所有记录的<code>NULL值列表</code>只需要一个字节。</p><ul><li><p>对于第一条记录来说，<code>c1</code>、<code>c3</code>、<code>c4</code>这3个列的值都不为<code>NULL</code>，所以它们对应的二进制位都是<code>0</code>，画个图就是这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e901befeac~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9g8m05b19ge1c8v2bf163djre6e.png-21.5kB"> 所以第一条记录的`NULL值列表`用十六进制表示就是：`0x00`。</li><li><p>对于第二条记录来说，<code>c1</code>、<code>c3</code>、<code>c4</code>这3个列中<code>c3</code>和<code>c4</code>的值都为<code>NULL</code>，所以这3个列对应的二进制位的情况就是：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e944a8af0c~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9g8ps5c1snv1bhj3m48151sfl6r.png-20.6kB"><p>所以第二条记录的<code>NULL值列表</code>用十六进制表示就是：<code>0x06</code>。</p></li></ul><p>所以这两条记录在填充了<code>NULL值列表</code>后的示意图就是这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e95903144f~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9grs9m4co8134u1t2rjhm1q6rc0.png-39kB"><h5 id="记录头信息">记录头信息</h5><p>除了<code>变长字段长度列表</code>、<code>NULL值列表</code>之外，还有一个用于描述记录的<code>记录头信息</code>，它是由固定的<code>5</code>个字节组成。<code>5</code>个字节也就是<code>40</code>个二进制位，不同的位代表不同的意思，如图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e97718ef01~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9geiglj1ah31meo80ci8n1eli8f.png-29.5kB"><p>这些二进制位代表的详细信息如下表：</p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td><code>预留位1</code></td><td><code>1</code></td><td>没有使用</td></tr><tr><td><code>预留位2</code></td><td><code>1</code></td><td>没有使用</td></tr><tr><td><code>delete_mask</code></td><td><code>1</code></td><td>标记该记录是否被删除</td></tr><tr><td><code>min_rec_mask</code></td><td><code>1</code></td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><code>n_owned</code></td><td><code>4</code></td><td>表示当前记录拥有的记录数</td></tr><tr><td><code>heap_no</code></td><td><code>13</code></td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td><code>record_type</code></td><td><code>3</code></td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td><code>next_record</code></td><td><code>16</code></td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>大家不要被这么多的属性和陌生的概念给吓着，我这里只是为了内容的完整性把这些位代表的意思都写了出来，现在没必要把它们的意思都记住，记住也没啥用，现在只需要看一遍混个脸熟，等之后用到这些属性的时候我们再回过头来看。</p><p>因为我们并不清楚这些属性详细的用法，所以这里就不分析各个属性值是怎么产生的了，之后我们遇到会详细看的。所以我们现在直接看一下<code>record_format_demo</code>中的两条记录的<code>头信息</code>分别是什么：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/17075b82cb070959~tplv-t2oaga2asx-watermark.awebp" class="" title="img"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>再一次强调，大家如果看不懂记录头信息里各个位代表的概念千万别纠结，我们后边会说的～<br></code></pre></td></tr></table></figure><h4 id="记录的真实数据">记录的真实数据</h4><p>对于<code>record_format_demo</code>表来说，<code>记录的真实数据</code>除了<code>c1</code>、<code>c2</code>、<code>c3</code>、<code>c4</code>这几个我们自己定义的列的数据以外，<code>MySQL</code>会为每个记录默认的添加一些列（也称为<code>隐藏列</code>），具体的列如下：</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td><code>row_id</code></td><td>否</td><td><code>6</code>字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td><code>transaction_id</code></td><td>是</td><td><code>6</code>字节</td><td>事务ID</td></tr><tr><td><code>roll_pointer</code></td><td>是</td><td><code>7</code>字节</td><td>回滚指针</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，我们为了美观才写成了row_id、transaction_id和roll_pointer。<br></code></pre></td></tr></table></figure><p>这里需要提一下<code>InnoDB</code>表对主键的生成策略：优**先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个<code>Unique</code>键作为主键，如果表中连<code>Unique</code>键都没有定义的话，则<code>InnoDB</code>会为表默认添加一个名为<code>row_id</code>的隐藏列作为主键。**所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 <em><strong>transaction_id</strong></em> 和 <em><strong>roll_pointer</strong></em> 这两个列，但是 <em><strong>row_id</strong></em> 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心，<code>InnoDB</code>存储引擎会自己帮我们生成的。</p><p>因为表<code>record_format_demo</code>并没有定义主键，所以<code>MySQL</code>服务器会为每条记录增加上述的3个列。现在看一下加上<code>记录的真实数据</code>的两个记录长什么样吧：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e973b70372~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9h256f9nke14311adhtu61ie2dn.png-92kB"><p>看这个图的时候我们需要注意几点：</p><ol><li>表<code>record_format_demo</code>使用的是<code>ascii</code>字符集，所以<code>0x61616161</code>就表示字符串<code>'aaaa'</code>，<code>0x626262</code>就表示字符串<code>'bbb'</code>，以此类推。</li><li>注意第1条记录中<code>c3</code>列的值，它是<code>CHAR(10)</code>类型的，它实际存储的字符串是：<code>'cc'</code>，而<code>ascii</code>字符集中的字节表示是<code>'0x6363'</code>，虽然表示这个字符串只占用了2个字节，但整个<code>c3</code>列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用空格字符填充，空格字符在<code>ascii</code>字符集的表示就是<code>0x20</code>。</li><li>注意第2条记录中<code>c3</code>和<code>c4</code>列的值都为<code>NULL</code>，它们被存储在了前边的<code>NULL值列表</code>处，在记录的真实数据处就不再冗余存储，从而节省存储空间。</li></ol><h4 id="CHAR-M-列的存储格式">CHAR(M)列的存储格式</h4><p><code>record_format_demo</code>表的<code>c1</code>、<code>c2</code>、<code>c4</code>列的类型是<code>VARCHAR(10)</code>，而<code>c3</code>列的类型是<code>CHAR(10)</code>，我们说在<code>Compact</code>行格式下只会把变长类型的列的长度逆序存到<code>变长字段长度列表</code>中，就像这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e985c8d9a7~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9jdkga71kegkjs14o111ov1ce3kn.png-12.5kB"><p>但是这只是因为我们的<code>record_format_demo</code>表采用的是<code>ascii</code>字符集，这个字符集是一个定长字符集，也就是说表示一个字符采用固定的一个字节，如果采用变长的字符集（也就是表示一个字符需要的字节数不确定，比如<code>gbk</code>表示一个字符要1～2个字节、<code>utf8</code>表示一个字符要1~3个字节等）的话，<code>c3</code>列的长度也会被存储到<code>变长字段长度列表</code>中，比如我们修改一下<code>record_format_demo</code>表的字符集：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; ALTER TABLE record_format_demo MODIFY COLUMN c<span class="hljs-number">3</span> CHAR(<span class="hljs-number">10</span>) CHARACTER SET utf<span class="hljs-number">8</span>;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">2</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">02</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">2</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>修改该列字符集后记录的<code>变长字段长度列表</code>也发生了变化，如图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e973ff4fde~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9jeb6defgf1o981lgfciokjl4.png-43.1kB"><p>这就意味着：<strong>对于 <em>CHAR(M)</em> 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。</strong></p><p>另外有一点还需要注意，变长字符集的<code>CHAR(M)</code>类型的列要求至少占用<code>M</code>个字节，而<code>VARCHAR(M)</code>却没有这个要求。比方说对于使用<code>utf8</code>字符集的<code>CHAR(10)</code>的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用<code>10</code>个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。（这里你感受到设计<code>Compact</code>行格式的大叔既想节省存储空间，又不想更新<code>CHAR(M)</code>类型的列产生碎片时的纠结心情了吧。）</p><h3 id="Redundant行格式">Redundant行格式</h3><p>其实知道了<code>Compact</code>行格式之后，其他的行格式就是依葫芦画瓢了。我们现在要介绍的<code>Redundant</code>行格式是<code>MySQL5.0</code>之前用的一种行格式，也就是说它已经非常老了，但是本着知识完整性的角度还是要提一下，大家乐呵乐呵的看就好。</p><p>画个图展示一下<code>Redundant</code>行格式的全貌：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e99a69ba3d~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9h896lcuqi16081qub1v8c12jkft.png-36.2kB"><p>现在我们把表<code>record_format_demo</code>的行格式修改为<code>Redundant</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; ALTER TABLE record_format_demo ROW_FORMAT=Redundant;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">05</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>为了方便大家理解和节省篇幅，我们直接把表<code>record_format_demo</code>在<code>Redundant</code>行格式下的两条记录的真实存储数据提供出来，之后我们着重分析两种行格式的不同即可。</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9a5b7c847~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9h8tnav166c187m1nhap61153qgn.png-91.6kB"><p>下边我们从各个方面看一下<code>Redundant</code>行格式有什么不同的地方：</p><ul><li><p>字段长度偏移列表</p><p>注意<code>Compact</code>行格式的开头是<code>变长字段长度列表</code>，而<code>Redundant</code>行格式的开头是<code>字段长度偏移列表</code>，与<code>变长字段长度列表</code>有两处不同：</p><ul><li><p>没有了变长两个字，意味着<code>Redundant</code>行格式会把该条记录中所有列（包括<code>隐藏列</code>）的长度信息都按照逆序存储到<code>字段长度偏移列表</code>。</p></li><li><p>多了个偏移两个字，这意味着计算列值长度的方式不像<code>Compact</code>行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。</p><p>比如第一条记录的<code>字段长度偏移列表</code>就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">25 </span><span class="hljs-number">24</span> <span class="hljs-number">1</span>A <span class="hljs-number">17</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span>C <span class="hljs-number">06</span><br></code></pre></td></tr></table></figure><p>因为它是逆序排放的，所以按照列的顺序排列就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">06 </span><span class="hljs-number">0</span>C <span class="hljs-number">13</span> <span class="hljs-number">17</span> <span class="hljs-number">1</span>A <span class="hljs-number">24</span> <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>按照两个相邻数值的差值来计算各个列值的长度的意思就是：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">第一列(`row_id`)的长度就是 <span class="hljs-number">0</span>x06个字节，也就是<span class="hljs-number">6</span>个字节。<br><br>第二列(`transaction_id`)的长度就是 (<span class="hljs-number">0</span>x0C - <span class="hljs-number">0</span>x06)个字节，也就是<span class="hljs-number">6</span>个字节。<br><br>第三列(`roll_pointer`)的长度就是 (<span class="hljs-number">0</span>x13 - <span class="hljs-number">0</span>x0C)个字节，也就是<span class="hljs-number">7</span>个字节。<br><br>第四列(`c1`)的长度就是 (<span class="hljs-number">0</span>x17 - <span class="hljs-number">0</span>x13)个字节，也就是<span class="hljs-number">4</span>个字节。<br><br>第五列(`c2`)的长度就是 (<span class="hljs-number">0</span>x1A - <span class="hljs-number">0</span>x17)个字节，也就是<span class="hljs-number">3</span>个字节。<br><br>第六列(`c3`)的长度就是 (<span class="hljs-number">0</span>x24 - <span class="hljs-number">0</span>x1A)个字节，也就是<span class="hljs-number">10</span>个字节。<br><br>第七列(`c4`)的长度就是 (<span class="hljs-number">0</span>x25 - <span class="hljs-number">0</span>x24)个字节，也就是<span class="hljs-number">1</span>个字节。<br></code></pre></td></tr></table></figure></li></ul></li><li><p>记录头信息</p><p><code>Redundant</code>行格式的记录头信息占用<code>6</code>字节，<code>48</code>个二进制位，这些二进制位代表的意思如下：</p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td><code>预留位1</code></td><td><code>1</code></td><td>没有使用</td></tr><tr><td><code>预留位2</code></td><td><code>1</code></td><td>没有使用</td></tr><tr><td><code>delete_mask</code></td><td><code>1</code></td><td>标记该记录是否被删除</td></tr><tr><td><code>min_rec_mask</code></td><td><code>1</code></td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><code>n_owned</code></td><td><code>4</code></td><td>表示当前记录拥有的记录数</td></tr><tr><td><code>heap_no</code></td><td><code>13</code></td><td>表示当前记录在页面堆的位置信息</td></tr><tr><td><code>n_field</code></td><td><code>10</code></td><td>表示记录中列的数量</td></tr><tr><td><code>1byte_offs_flag</code></td><td><code>1</code></td><td>标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的</td></tr><tr><td><code>next_record</code></td><td><code>16</code></td><td>表示下一条记录的绝对位置</td></tr></tbody></table><p>第一条记录中的头信息是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">0</span>F <span class="hljs-number">00</span> BC<br></code></pre></td></tr></table></figure><p>根据这六个字节可以计算出各个属性的值，如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">预留位1：0x00<br>预留位2：0x00<br><span class="hljs-section">delete_mask: 0x00</span><br><span class="hljs-section">min_rec_mask: 0x00</span><br><span class="hljs-section">n_owned: 0x00</span><br><span class="hljs-section">heap_no: 0x02</span><br><span class="hljs-section">n_field: 0x07</span><br><span class="hljs-section">1byte_offs_flag: 0x01</span><br><span class="hljs-section">next_record:0xBC</span><br></code></pre></td></tr></table></figure><p>与<code>Compact</code>行格式的记录头信息对比来看，有两处不同：</p><ul><li><code>Redundant</code>行格式多了<code>n_field</code>和<code>1byte_offs_flag</code>这两个属性。</li><li><code>Redundant</code>行格式没有<code>record_type</code>这个属性。</li></ul></li><li><p><code>1byte_offs_flag</code>的值是怎么选择的</p><p><code>字段长度偏移列表</code>实质上是存储每个列中的值占用的空间在<code>记录的真实数据</code>处结束的位置，还是拿<code>record_format_demo</code>第一条记录为例，<code>0x06</code>代表第一个列在<code>记录的真实数据</code>第6个字节处结束，<code>0x0C</code>代表第二个列在<code>记录的真实数据</code>第12个字节处结束，<code>0x13</code>代表第三个列在<code>记录的真实数据</code>第19个字节处结束，等等等等，最后一个列对应的偏移量值为<code>0x25</code>，也就意味着最后一个列在<code>记录的真实数据</code>第37个字节处结束，也就意味着整条记录的<code>真实数据</code>实际上占用<code>37</code>个字节。</p><p>我们前边说过每个列对应的偏移量可以占用1个字节或者2个字节来存储，那到底什么时候用1个字节，什么时候用2个字节呢？其实是根据该条<code>Redundant</code>行格式<code>记录的真实数据</code>占用的总大小来判断的：</p><ul><li>当记录的真实数据占用的字节数不大于127（十六进制<code>0x7F</code>，二进制<code>01111111</code>）时，每个列对应的偏移量占用1个字节。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>如果整个记录的真实数据占用的存储空间都不大于127个字节，那么每个列对应的偏移量值肯定也就不大于127，也就可以使用1个字节来表示喽。<br></code></pre></td></tr></table></figure><ul><li>当记录的真实数据占用的字节数大于127，但不大于32767（十六进制<code>0x7FFF</code>，二进制<code>0111111111111111</code>）时，每个列对应的偏移量占用2个字节。</li><li>有没有记录的真实数据大于32767的情况呢？有，不过此时的记录已经存放到了溢出页中，在本页中只保留前<code>768</code>个字节和20个字节的溢出页面地址（当然这20个字节中还记录了一些别的信息）。因为<code>字段长度偏移列表</code>处只需要记录每个列在本页面中的偏移就好了，所以每个列使用2个字节来存储偏移量就够了。</li></ul><p>大家可以看出来，设计<code>Redundant</code>行格式的大叔还是比较简单粗暴的，直接使用整个<code>记录的真实数据</code>长度来决定使用1个字节还是2个字节存储列对应的偏移量。只要整条记录的真实数据占用的存储空间大小大于127，即使第一个列的值占用存储空间小于127，那对不起，也需要使用2个字节来表示该列对应的偏移量。简单粗暴，就是这么简单粗暴（所以这种行格式有些过时了～）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>大家有没有疑惑，一个字节能表示的范围是0～255，为啥在记录的真实数据占用的存储空间大于127时就采用2个字节表示各个列的偏移量呢？稍安勿躁，后边马上揭晓。<br></code></pre></td></tr></table></figure><p>为了在解析记录时知道每个列的偏移量是使用1个字节还是2个字节表示的，设计<code>Redundant</code>行格式的大叔特意在<code>记录头信息</code>里放置了一个称之为<code>1byte_offs_flag</code>的属性：</p><ul><li>当它的值为1时，表明使用1个字节存储。</li><li>当它的值为0时，表明使用2个字节存储。</li></ul></li><li><p><code>Redundant</code>行格式中<code>NULL</code>值的处理</p><p>因为<code>Redundant</code>行格式并没有<code>NULL值列表</code>，所以设计<code>Redundant</code>行格式的大叔在<code>字段长度偏移列表</code>中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为<code>NULL</code>的依据，该比特位也可以被称之为<code>NULL比特位</code>。也就是说在解析一条记录的某个列时，首先看一下该列对应的偏移量的<code>NULL比特位</code>是不是为<code>1</code>，如果为<code>1</code>，那么该列的值就是<code>NULL</code>，否则不是<code>NULL</code>。</p><p>这也就解释了上边介绍为什么只要记录的真实数据大于127（十六进制<code>0x7F</code>，二进制<code>01111111</code>）时，就采用2个字节来表示一个列对应的偏移量，主要是第一个比特位是所谓的<code>NULL比特位</code>，用来标记该列的值是否为<code>NULL</code>。</p><p>但是还有一点要注意，对于值为<code>NULL</code>的列来说，该列的类型是否为定长类型决定了<code>NULL</code>值的实际存储方式，我们接下来分析一下<code>record_format_demo</code>表的第二条记录，它对应的<code>字段长度偏移列表</code>如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A4</span> A<span class="hljs-number">4</span> <span class="hljs-number">1</span>A <span class="hljs-number">17</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span>C <span class="hljs-number">06</span><br></code></pre></td></tr></table></figure><p>按照列的顺序排放就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">06 </span><span class="hljs-number">0</span>C <span class="hljs-number">13</span> <span class="hljs-number">17</span> <span class="hljs-number">1</span>A A4 A4<br></code></pre></td></tr></table></figure><p>我们分情况看一下：</p><ul><li><p>如果存储<code>NULL</code>值的字段是定长类型的，比方说<code>CHAR(M)</code>数据类型的，则<code>NULL</code>值也将占用记录的真实数据部分，并把该字段对应的数据使用<code>0x00</code>字节填充。</p><p>如图第二条记录的<code>c3</code>列的值是<code>NULL</code>，而<code>c3</code>列的类型是<code>CHAR(10)</code>，占用记录的真实数据部分10字节，所以我们看到在<code>Redundant</code>行格式中使用<code>0x00000000000000000000</code>来表示<code>NULL</code>值。</p><p>另外，<code>c3</code>列对应的偏移量为<code>0xA4</code>，它对应的二进制实际是：<code>10100100</code>，可以看到最高位为<code>1</code>，意味着该列的值是<code>NULL</code>。将最高位去掉后的值变成了<code>0100100</code>，对应的十进制值为<code>36</code>，而<code>c2</code>列对应的偏移量为<code>0x1A</code>，也就是十进制的<code>26</code>。<code>36 - 26 = 10</code>，也就是说最终<code>c3</code>列占用的存储空间为10个字节。</p></li><li><p>如果该存储<code>NULL</code>值的字段是变长数据类型的，则不在<code>记录的真实数据</code>处占用任何存储空间。</p><p>比如<code>record_format_demo</code>表的<code>c4</code>列是<code>VARCHAR(10)</code>类型的，<code>VARCHAR(10)</code>是一个变长数据类型，<code>c4</code>列对应的偏移量为<code>0xA4</code>，与<code>c3</code>列对应的偏移量相同，这也就意味着它的值也为<code>NULL</code>，将<code>0xA4</code>的最高位去掉后对应的十进制值也是<code>36</code>，<code>36 - 36 = 0</code>，也就意味着<code>c4</code>列本身不占用任何<code>记录的实际数据</code>处的空间。</p></li></ul></li></ul><p>除了以上的几点之外，<code>Redundant</code>行格式和<code>Compact</code>行格式还是大致相同的。</p><h4 id="CHAR-M-列的存储格式-2">CHAR(M)列的存储格式</h4><p>我们知道<code>Compact</code>行格式在<code>CHAR(M)</code>类型的列中存储数据的时候还挺麻烦，分变长字符集和定长字符集的情况，而在<code>Redundant</code>行格式中十分干脆，不管该列使用的字符集是啥，只要是使用<code>CHAR(M)</code>类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和<code>M</code>的乘积。比方说使用<code>utf8</code>字符集的<code>CHAR(10)</code>类型的列占用的真实数据空间始终为<code>30</code>个字节，使用<code>gbk</code>字符集的<code>CHAR(10)</code>类型的列占用的真实数据空间始终为<code>20</code>个字节。<strong>由此可以看出来，使用<code>Redundant</code>行格式的<code>CHAR(M)</code>类型的列是不会产生碎片的。</strong></p><h3 id="行溢出数据">行溢出数据</h3><h4 id="VARCHAR-M-最多能存储的数据">VARCHAR(M)最多能存储的数据</h4><p>我们知道对于<code>VARCHAR(M)</code>类型的列最多可以占用<code>65535</code>个字节。其中的<code>M</code>代表该类型最多存储的字符数量，如果我们使用<code>ascii</code>字符集的话，一个字符就代表一个字节，我们看看<code>VARCHAR(65535)</code>是否可用：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> varchar_size_demo(<br>    -&gt;     c <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">65535</span>)<br>    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;<br>ERROR <span class="hljs-number">1118</span> (<span class="hljs-number">42000</span>): <span class="hljs-keyword">Row</span> size too <span class="hljs-keyword">large</span>. The maximum <span class="hljs-keyword">row</span> size <span class="hljs-keyword">for</span> the used <span class="hljs-keyword">table</span> <span class="hljs-keyword">type</span>, <span class="hljs-keyword">not</span> counting BLOBs, <span class="hljs-keyword">is</span> <span class="hljs-number">65535.</span> This includes <span class="hljs-keyword">storage</span> overhead, <span class="hljs-keyword">check</span> the manual. You have <span class="hljs-keyword">to</span> change <span class="hljs-keyword">some</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">to</span> <span class="hljs-type">TEXT</span> <span class="hljs-keyword">or</span> BLOBs<br>mysql&gt;<br></code></pre></td></tr></table></figure><p>从报错信息里可以看出，<code>MySQL</code>对一条记录占用的最大存储空间是有限制的，除了<code>BLOB</code>或者<code>TEXT</code>类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过<code>65535</code>个字节。所以<code>MySQL</code>服务器建议我们把存储类型改为<code>TEXT</code>或者<code>BLOB</code>的类型。这个<code>65535</code>个字节除了列本身的数据之外，还包括一些其他的数据（<code>storage overhead</code>），比如说我们为了存储一个<code>VARCHAR(M)</code>类型的列，其实需要占用3部分存储空间：</p><ul><li>真实数据</li><li>真实数据占用字节的长度</li><li><code>NULL</code>值标识，如果该列有<code>NOT NULL</code>属性则可以没有这部分存储空间</li></ul><p>如果该<code>VARCHAR</code>类型的列没有<code>NOT NULL</code>属性，那最多只能存储<code>65532</code>个字节的数据，因为真实数据的长度可能占用2个字节，<code>NULL</code>值标识需要占用1个字节：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> varchar_size_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>      c <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">65532</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>Compact;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.02</span> sec)<br></code></pre></td></tr></table></figure><p>如果<code>VARCHAR</code>类型的列有<code>NOT NULL</code>属性，那最多只能存储<code>65533</code>个字节的数据，因为真实数据的长度可能占用2个字节，不需要<code>NULL</code>值标识：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> varchar_size_demo;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> varchar_size_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>      c <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">65533</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>Compact;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.02</span> sec)<br></code></pre></td></tr></table></figure><p>如果<code>VARCHAR(M)</code>类型的列使用的不是<code>ascii</code>字符集，那会怎么样呢？来看一下：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs subunit">mysql&gt; DROP TABLE varchar_size_demo;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; CREATE TABLE varchar_size_demo(<br>    -&gt;       c VARCHAR(65532)<br>    -&gt; ) CHARSET=gbk ROW_FORMAT=Compact;<br><span class="hljs-keyword">ERROR </span>1074 (42000): Column length too big for column &#x27;c&#x27; (max = 32767); use BLOB or TEXT instead<br><br>mysql&gt; CREATE TABLE varchar_size_demo(<br>    -&gt;       c VARCHAR(65532)<br>    -&gt; ) CHARSET=utf8 ROW_FORMAT=Compact;<br><span class="hljs-keyword">ERROR </span>1074 (42000): Column length too big for column &#x27;c&#x27; (max = 21845); use BLOB or TEXT instead<br></code></pre></td></tr></table></figure><p>从执行结果中可以看出，如果<code>VARCHAR(M)</code>类型的列使用的不是<code>ascii</code>字符集，那<code>M</code>的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为<code>NULL</code>的情况下，<code>gbk</code>字符集表示一个字符最多需要<code>2</code>个字节，那在该字符集下，<code>M</code>的最大取值就是<code>32766</code>（也就是：65532/2），也就是说最多能存储<code>32766</code>个字符；<code>utf8</code>字符集表示一个字符最多需要<code>3</code>个字节，那在该字符集下，<code>M</code>的最大取值就是<code>21844</code>，就是说最多能存储<code>21844</code>（也就是：65532/3）个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！<br></code></pre></td></tr></table></figure><h4 id="记录中的数据太多产生的溢出">记录中的数据太多产生的溢出</h4><p>我们以<code>ascii</code>字符集下的<code>varchar_size_demo</code>表为例，插入一条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> varchar_size_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>       c <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">65532</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>Compact;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> varchar_size_demo(c) <span class="hljs-keyword">VALUES</span>(REPEAT(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">65532</span>));<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>其中的<code>REPEAT('a', 65532)</code>是一个函数调用，它表示生成一个把字符<code>'a'</code>重复<code>65532</code>次的字符串。前边说过，<code>MySQL</code>中磁盘和内存交互的基本单位是<code>页</code>，也就是说<code>MySQL</code>是以<code>页</code>为基本单位来管理存储空间的，我们的记录都会被分配到某个<code>页</code>中存储。而一个页的大小一般是<code>16KB</code>，也就是<code>16384</code>字节，而一个<code>VARCHAR(M)</code>类型的列就最多可以存储<code>65532</code>个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</p><p>在<code>Compact</code>和<code>Redundant</code>行格式中，对于占用存储空间非常大的列，在<code>记录的真实数据</code>处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后<code>记录的真实数据</code>处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9aab47ea5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d48e3imu1vcp5rsh8cg0b1o169.png-149kB"><p>从图中可以看出来，**对于<code>Compact</code>和<code>Redundant</code>行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前<code>768</code>个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做<code>行溢出</code>，**存储超出<code>768</code>字节的那些页面也被称为<code>溢出页</code>。画一个简图就是这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9a5d5637a~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1conbskr7apj19ns1d194vs1buo1t.png-35.8kB"><p>最后需要注意的是，不只是 <em><strong>VARCHAR(M)</strong></em> 类型的列，其他的 <em><strong>TEXT</strong></em>、<em><strong>BLOB</strong></em> 类型的列在存储数据非常多的时候也会发生<code>行溢出</code>。</p><h4 id="行溢出的临界点">行溢出的临界点</h4><p>那发生<code>行溢出</code>的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生<code>行溢出</code>？</p><p><strong><code>MySQL</code>中规定一个页中至少存放两行记录</strong>，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。以上边的<code>varchar_size_demo</code>表为例，它只有一个列<code>c</code>，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会<code>行溢出</code>的现象呢？这得分析一下页中的空间都是如何利用的。</p><ul><li><p>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要<code>132</code>个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。</p></li><li><p>每个记录需要的额外信息是<code>27</code>字节。</p><p>这27个字节包括下边这些部分：</p><ul><li>2个字节用于存储真实数据的长度</li><li>1个字节用于存储列是否是NULL值</li><li>5个字节大小的头信息</li><li>6个字节的<code>row_id</code>列</li><li>6个字节的<code>transaction_id</code>列</li><li>7个字节的<code>roll_pointer</code>列</li></ul></li></ul><p>假设一个列中存储的数据字节数为n，设计<code>MySQL</code>的大叔规定如果该列不发生溢出的现象，就需要满足下边这个式子：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">132 </span>+ <span class="hljs-number">2</span>×(<span class="hljs-number">27</span> + n) &lt; <span class="hljs-number">16384</span><br></code></pre></td></tr></table></figure><p>求解这个式子得出的解是：<code>n &lt; 8099</code>。也就是说如果一个列中存储的数据小于<code>8099</code>个字节，那么该列就不会成为<code>溢出列</code>，否则该列就需要成为<code>溢出列</code>。不过这个<code>8099</code>个字节的结论只是针对只有一个列的<code>varchar_size_demo</code>表来说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：<strong>你不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为<code>溢出列</code>。</strong></p><h3 id="Dynamic和Compressed行格式">Dynamic和Compressed行格式</h3><p>下边要介绍另外两个行格式，<code>Dynamic</code>和<code>Compressed</code>行格式，我现在使用的<code>MySQL</code>版本是<code>5.7</code>，它的默认行格式就是<code>Dynamic</code>，这俩行格式和<code>Compact</code>行格式挺像，只不过在处理<code>行溢出</code>数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9b2c2b71e~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1conbtnmr1sg1hao1nf41pi1eb72a.png-29.9kB"><p><code>Compressed</code>行格式和<code>Dynamic</code>不同的一点是，<code>Compressed</code>行格式会采用压缩算法对页面进行压缩，以节省空间。</p><h2 id="总结-2">总结</h2><ol><li><p>页是<code>MySQL</code>中磁盘和内存交互的基本单位，也是<code>MySQL</code>是管理存储空间的基本单位。</p></li><li><p>指定和修改行格式的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="hljs-operator">=</span>行格式名称<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 ROW_FORMAT<span class="hljs-operator">=</span>行格式名称<br></code></pre></td></tr></table></figure></li><li><p><code>InnoDB</code>目前定义了4种行格式</p><ul><li><p>COMPACT行格式</p><p>具体组成如图： <img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e8fafc21aa~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB"></p></li><li><p>Redundant行格式</p><p>具体组成如图： <img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/169710e9ca9cbeb5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctfppb4c1cng1m8718l91760jde9.png-36.2kB"></p></li><li><p>Dynamic和Compressed行格式</p><p>这两种行格式类似于<code>COMPACT行格式</code>，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。</p><p>另外，<code>Compressed</code>行格式会采用压缩算法对页面进行压缩。</p></li></ul></li></ol><ul><li>一个页一般是<code>16KB</code>，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为<code>行溢出</code>。</li></ul><h1>5.InnoDB数据页结构</h1><h2 id="不同类型的页简介">不同类型的页简介</h2><p><strong>前边我们简单提了一下<code>页</code>的概念，它是<code>InnoDB</code>管理存储空间的基本单位，一个页的大小一般是<code>16KB</code>。</strong><code>InnoDB</code>为了不同的目的而设计了许多种不同类型的<code>页</code>，比如存放表空间头部信息的页，存放<code>Insert Buffer</code>信息的页，存放<code>INODE</code>信息的页，存放<code>undo</code>日志信息的页等等等等。当然了，如果我说的这些名词你一个都没有听过，就当我放了个屁吧～ 不过这没有一毛钱关系，我们今儿个也不准备说这些类型的页，我们聚焦的是那些存放我们表中记录的那种类型的页，官方称这种存放记录的页为索引（<code>INDEX</code>）页，鉴于我们还没有了解过索引是个什么东西，而这些表中的记录就是我们日常口中所称的<code>数据</code>，所以目前还是叫这种存放记录的页为<code>数据页</code>吧。</p><h2 id="数据页结构的快速浏览">数据页结构的快速浏览</h2><p>数据页代表的这块<code>16KB</code>大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16f13ee1e2dfac7c~tplv-t2oaga2asx-watermark.awebp" class="" title="img"><p>从图中可以看出，一个<code>InnoDB</code>数据页的存储空间大致被划分成了<code>7</code>个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。下边我们用表格的方式来大致描述一下这7个部分都存储一些啥内容（快速的瞅一眼就行了，后边会详细唠叨的）：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td><code>File Header</code></td><td>文件头部</td><td><code>38</code>字节</td><td>页的一些通用信息</td></tr><tr><td><code>Page Header</code></td><td>页面头部</td><td><code>56</code>字节</td><td>数据页专有的一些信息</td></tr><tr><td><code>Infimum + Supremum</code></td><td>最小记录和最大记录</td><td><code>26</code>字节</td><td>两个虚拟的行记录</td></tr><tr><td><code>User Records</code></td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td><code>Free Space</code></td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td><code>Page Directory</code></td><td>页面目录</td><td>不确定</td><td>页中的某些记录的相对位置</td></tr><tr><td><code>File Trailer</code></td><td>文件尾部</td><td><code>8</code>字节</td><td>校验页是否完整</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>我们接下来并不打算按照页中各个部分的出现顺序来依次介绍它们，因为各个部分中会出现很多大家目前不理解的概念，这会打击各位读文章的信心与兴趣，希望各位能接受这种拍摄手法～<br></code></pre></td></tr></table></figure><h2 id="记录在页中的存储">记录在页中的存储</h2><p>在页的7个组成部分中，我们自己存储的记录会按照我们指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有<code>User Records</code>这个部分，每当我们插入一条记录，都会从<code>Free Space</code>部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到<code>User Records</code>部分，当<code>Free Space</code>部分的空间全部被<code>User Records</code>部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c0fe86555ed~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cosvi1in9st476cdqfki1n39m.png-133.8kB"><p>为了更好的管理在<code>User Records</code>中的这些记录，<code>InnoDB</code>可费了一番力气呢，在哪费力气了呢？不就是把记录按照指定的行格式一条一条摆在<code>User Records</code>部分么？其实这话还得从记录行格式的<code>记录头信息</code>中说起。</p><h3 id="记录头信息的秘密">记录头信息的秘密</h3><p>为了故事的顺利发展，我们先创建一个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> page_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c1 <span class="hljs-type">INT</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c2 <span class="hljs-type">INT</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10000</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">PRIMARY</span> KEY (c1)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>Compact;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><p>这个新创建的<code>page_demo</code>表有3个列，其中<code>c1</code>和<code>c2</code>列是用来存储整数的，<code>c3</code>列是用来存储字符串的。需要注意的是，我们把 <em><strong>c1</strong></em> 列指定为主键，所以在具体的行格式中InnoDB就没必要为我们去创建那个所谓的 <em><strong>row_id</strong></em> 隐藏列了。而且我们为这个表指定了<code>ascii</code>字符集以及<code>Compact</code>的行格式。所以这个表中记录的行格式示意图就是这样的：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c0feca77be3~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9o2eib2vl11qnf1dfl1d2lco313.png-76.4kB"><p>从图中可以看到，我们特意把<code>记录头信息</code>的5个字节的数据给标出来了，说明它很重要，我们再次先把这些<code>记录头信息</code>中各个属性的大体意思浏览一下（我们目前使用<code>Compact</code>行格式进行演示）：</p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td><code>预留位1</code></td><td><code>1</code></td><td>没有使用</td></tr><tr><td><code>预留位2</code></td><td><code>1</code></td><td>没有使用</td></tr><tr><td><code>delete_mask</code></td><td><code>1</code></td><td>标记该记录是否被删除</td></tr><tr><td><code>min_rec_mask</code></td><td><code>1</code></td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><code>n_owned</code></td><td><code>4</code></td><td>表示当前记录拥有的记录数</td></tr><tr><td><code>heap_no</code></td><td><code>13</code></td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td><code>record_type</code></td><td><code>3</code></td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td><code>next_record</code></td><td><code>16</code></td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>由于我们现在主要在唠叨<code>记录头信息</code>的作用，所以为了大家理解上的方便，我们只在<code>page_demo</code>表的行格式演示图中画出有关的头信息属性以及<code>c1</code>、<code>c2</code>、<code>c3</code>列的信息（其他信息没画不代表它们不存在啊，只是为了理解上的方便在图中省略了～），简化后的行格式示意图就是这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c0ff1ae5364~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9o52lt41v5c7vk1vm91fsm174b2d.png-49.5kB"><p>下边我们试着向<code>page_demo</code>表中插入几条记录：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; INSERT INTO page_demo VALUES(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, &#x27;aaaa&#x27;), (<span class="hljs-number">2</span>, <span class="hljs-number">200</span>, &#x27;bbbb&#x27;), (<span class="hljs-number">3</span>, <span class="hljs-number">300</span>, &#x27;cccc&#x27;), (<span class="hljs-number">4</span>, <span class="hljs-number">400</span>, &#x27;dddd&#x27;);<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">4</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">4</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>为了方便大家分析这些记录在<code>页</code>的<code>User Records</code>部分中是怎么表示的，我把记录中头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c0ff83f9870~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9qs0j281knc16hc1hqsgj01v0o2c.png-82.8kB"><p>看这个图的时候需要注意一下，各条记录在<code>User Records</code>中存储的时候并没有空隙，这里只是为了大家观看方便才把每条记录单独画在一行中。我们对照着这个图来看看记录头信息中的各个属性是啥意思：</p><ul><li><p><code>delete_mask</code></p><p>这个属性标记着当前记录是否被删除，占用1个二进制位，值为<code>0</code>的时候代表记录并没有被删除，为<code>1</code>的时候代表记录被删除掉了。</p><p>啥？被删除的记录还在<code>页</code>中么？是的，摆在台面上的和背地里做的可能大相径庭，你以为它删除了，可它还在真实的磁盘上[摊手]（忽然想起冠希～）。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的<code>垃圾链表</code>，在这个链表中的记录占用的空间称之为所谓的<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>将这个delete_mask位设置为1和将被删除的记录加入到垃圾链表中其实是两个阶段，我们后边在介绍事务的时候会详细唠叨删除操作的详细过程，稍安勿躁。<br></code></pre></td></tr></table></figure></li><li><p><code>min_rec_mask</code></p><p>B+树的每层非叶子节点中的最小记录都会添加该标记，什么是个<code>B+</code>树？什么是个非叶子节点？好吧，等会再聊这个问题。反正我们自己插入的四条记录的<code>min_rec_mask</code>值都是<code>0</code>，意味着它们都不是<code>B+</code>树的非叶子节点中的最小记录。</p></li><li><p><code>n_owned</code></p><p>这个暂时保密，稍后它是主角～</p></li><li><p><code>heap_no</code></p><p>这个属性表示当前记录在本<code>页</code>中的位置，从图中可以看出来，我们插入的4条记录在本<code>页</code>中的位置分别是：<code>2</code>、<code>3</code>、<code>4</code>、<code>5</code>。是不是少了点啥？是的，怎么不见<code>heap_no</code>值为<code>0</code>和<code>1</code>的记录呢？</p><p>这其实是设计<code>InnoDB</code>的大叔们玩的一个小把戏，他们自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为<code>伪记录</code>或者<code>虚拟记录</code>。这两个伪记录一个代表<code>最小记录</code>，一个代表<code>最大记录</code>，等一下哈~，记录可以比大小么？</p><p>是的，记录也可以比大小，对于一条完整的记录来说，比较记录的大小就是比较<code>主键</code>的大小。比方说我们插入的4行记录的主键值分别是：<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>，这也就意味着这4条记录的大小从小到大依次递增。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>请注意我强调了对于`一条完整的记录`来说，比较记录的大小就相当于比的是主键的大小。后边我们还会介绍只存储一条记录的部分列的情况，敬请期待～<br></code></pre></td></tr></table></figure><p>但是不管我们向<code>页</code>中插入了多少自己的记录，设计<code>InnoDB</code>的大叔们都规定他们定义的两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的<code>记录头信息</code>和8字节大小的一个固定的部分组成的，如图所示</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c100ff0ccc2~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9ra45eam7t1mil9o1h3ucqdhv.png-50.4kB"><p>由于这两条记录不是我们自己定义的记录，所以它们并不存放在<code>页</code>的<code>User Records</code>部分，他们被单独放在一个称为<code>Infimum + Supremum</code>的部分，如图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c10773d8cee~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1c9qs1mn2t3j1nt344116nk15uf2p.png-119.7kB"><p>从图中我们可以看出来，最小记录和最大记录的<code>heap_no</code>值分别是<code>0</code>和<code>1</code>，也就是说它们的位置最靠前。</p></li><li><p><code>record_type</code></p><p>这个属性表示当前记录的类型，一共有4种类型的记录，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的<code>record_type</code>值都是<code>0</code>，而最小记录和最大记录的<code>record_type</code>值分别为<code>2</code>和<code>3</code>。</p><p>至于<code>record_type</code>为<code>1</code>的情况，我们之后在说索引的时候会重点强调的。</p></li><li><p><code>next_record</code></p><p>这玩意儿非常重要，它**表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。**比方说第一条记录的<code>next_record</code>值为<code>32</code>，意味着从第一条记录的真实数据的地址处向后找<code>32</code>个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个<code>链表</code>，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，<code>下一条记录</code>指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 <em><strong>Infimum记录（也就是最小记录）</strong></em> 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 <em><strong>Supremum记录（也就是最大记录）</strong></em> ，为了更形象的表示一下这个<code>next_record</code>起到的作用，我们用箭头来替代一下<code>next_record</code>中的地址偏移量：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c1084c440b4~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cot1r96210ph1jng1td41ouj85c13.png-120.5kB"><p>从图中可以看出来，我们的记录按照主键从小到大的顺序形成了一个单链表。<code>最大记录</code>的<code>next_record</code>的值为<code>0</code>，这也就是说最大记录是没有<code>下一条记录</code>了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; DELETE FROM page_demo WHERE c<span class="hljs-number">1</span> = <span class="hljs-number">2</span>;<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">1</span> row affected (<span class="hljs-number">0</span>.<span class="hljs-number">02</span> sec)<br></code></pre></td></tr></table></figure><p>删掉第2条记录后的示意图就是：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c108ee1da43~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cul8slbp1om0p31b3u1be11gco9.png-119.6kB"><p>从图中可以看出来，删除第2条记录前后主要发生了这些变化：</p><ul><li>第2条记录并没有从存储空间中移除，而是把该条记录的<code>delete_mask</code>值设置为<code>1</code>。</li><li>第2条记录的<code>next_record</code>值变为了0，意味着该记录没有下一条记录了。</li><li>第1条记录的<code>next_record</code>指向了第3条记录。</li><li>还有一点你可能忽略了，就是<code>最大记录</code>的<code>n_owned</code>值从<code>5</code>变成了<code>4</code>，关于这一点的变化我们稍后会详细说明的。</li></ul><p>所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>你会不会觉得next_record这个指针有点儿怪，为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？<br><br>因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表、NULL值列表中的信息都是逆序存放，这样可以使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。当然如果你看不懂这句话的话就不要勉强了，果断跳过～<br></code></pre></td></tr></table></figure></li></ul><p>再来看一个有意思的事情，因为主键值为<code>2</code>的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中，会发生什么事呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> page_demo <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;bbbb&#x27;</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>我们看一下记录的存储情况：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c109f25d55d~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cot2j9n94a511jd15clrrfp6p1t.png-137.8kB"><p>从图中可以看到，<code>InnoDB</code>并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。<br></code></pre></td></tr></table></figure><h2 id="Page-Directory（页目录）">Page Directory（页目录）</h2><p>现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> page_demo <span class="hljs-keyword">WHERE</span> c1 = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>最笨的办法：从<code>Infimum</code>记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到[摊手]），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。</p><p>这个方法在页中存储的记录数量比较少的情况用起来也没啥问题，比方说现在我们的表里只有<code>4</code>条自己插入的记录，所以最多找<code>4</code>次就可以把所有记录都遍历一遍，但是如果一个页中存储了非常多的记录，这么查找对性能来说还是有损耗的，所以我们说这种遍历查找这是一个<code>笨</code>办法。但是设计<code>InnoDB</code>的大叔们是什么人，他们能用这么笨的办法么，当然是要设计一种更6的查找方式喽，他们从书的目录中找到了灵感。</p><p>我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计<code>InnoDB</code>的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：</p><ol><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的<code>n_owned</code>属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近<code>页</code>的尾部的地方，这个地方就是所谓的<code>Page Directory</code>，也就是<code>页目录</code>（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为<code>槽</code>（英文名：<code>Slot</code>），所以这个页面目录就是由<code>槽</code>组成的。</li></ol><p>比方说现在的<code>page_demo</code>表中正常的记录共有6条，<code>InnoDB</code>会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c10c57164a6~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1couapvdmb5mvm1i0l5m0vcb2a.png-128.2kB"><p>从这个图中我们需要注意这么几点：</p><ul><li>现在<code>页目录</code>部分中有两个槽，也就意味着我们的记录被分成了两个组，<code>槽1</code>中的值是<code>112</code>，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；<code>槽0</code>中的值是<code>99</code>，代表最小记录的地址偏移量。</li><li>注意最小和最大记录的头信息中的<code>n_owned</code>属性<ul><li>最小记录的<code>n_owned</code>值为<code>1</code>，这就代表着以最小记录结尾的这个分组中只有<code>1</code>条记录，也就是最小记录本身。</li><li>最大记录的<code>n_owned</code>值为<code>5</code>，这就代表着以最大记录结尾的这个分组中只有<code>5</code>条记录，包括最大记录本身还有我们自己插入的<code>4</code>条记录。</li></ul></li></ul><p><code>99</code>和<code>112</code>这样的地址偏移量很不直观，我们用箭头指向的方式替代数字</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c10f2e61ad5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1couate3jr19gc18gl1cva1fcg34.png-100.8kB"><p>这样看就顺眼多了嘛！为什么最小记录的<code>n_owned</code>值为1，而最大记录的<code>n_owned</code>值为<code>5</code>呢，这里头有什么猫腻么？</p><p>是的，设计<code>InnoDB</code>的大叔们对每个分组中的记录条数是有规定的：<strong>对于最小记录所在的分组只能有 <em>1</em> 条记录，最大记录所在的分组拥有的记录条数只能在 <em>1~8</em> 条之间，剩下的分组中记录的条数范围只能在是 <em>4~8</em> 条之间</strong>。所以分组是按照下边的步骤进行的：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从<code>页目录</code>中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的<code>n_owned</code>值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在<code>页目录</code>中新增一个<code>槽</code>来记录这个新增分组中最大的那条记录的偏移量。</li></ul><p>由于现在<code>page_demo</code>表中的记录太少，无法演示添加了<code>页目录</code>之后加快查找速度的过程，所以再往<code>page_demo</code>表中添加一些记录：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; INSERT INTO page_demo VALUES(<span class="hljs-number">5</span>, <span class="hljs-number">500</span>, &#x27;eeee&#x27;), (<span class="hljs-number">6</span>, <span class="hljs-number">600</span>, &#x27;ffff&#x27;), (<span class="hljs-number">7</span>, <span class="hljs-number">700</span>, &#x27;gggg&#x27;), (<span class="hljs-number">8</span>, <span class="hljs-number">800</span>, &#x27;hhhh&#x27;), (<span class="hljs-number">9</span>, <span class="hljs-number">900</span>, &#x27;iiii&#x27;), (<span class="hljs-number">10</span>, <span class="hljs-number">1000</span>, &#x27;jjjj&#x27;), (<span class="hljs-number">11</span>, <span class="hljs-number">1100</span>, &#x27;kkkk&#x27;), (<span class="hljs-number">12</span>, <span class="hljs-number">1200</span>, &#x27;llll&#x27;), (<span class="hljs-number">13</span>, <span class="hljs-number">1300</span>, &#x27;mmmm&#x27;), (<span class="hljs-number">14</span>, <span class="hljs-number">1400</span>, &#x27;nnnn&#x27;), (<span class="hljs-number">15</span>, <span class="hljs-number">1500</span>, &#x27;oooo&#x27;), (<span class="hljs-number">16</span>, <span class="hljs-number">1600</span>, &#x27;pppp&#x27;);<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">12</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">12</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>哈，我们一口气又往表中添加了12条记录，现在页里边就一共有18条记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c10e3449897~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d6g64af2sgj1816ktl1q22dehp.png-189.1kB"><p>因为把16条记录的全部信息都画在一张图里太占地方，让人眼花缭乱的，所以只保留了用户记录头信息中的<code>n_owned</code>和<code>next_record</code>属性，也省略了各个记录之间的箭头，我没画不等于没有啊！现在看怎么从这个<code>页目录</code>中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的<code>二分法</code>来进行快速查找。5个槽的编号分别是：<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>，所以初始情况下最低的槽就是<code>low=0</code>，最高的槽就是<code>high=4</code>。比方说我们想找主键值为<code>6</code>的记录，过程是这样的：</p><ol><li>计算中间槽的位置：<code>(0+4)/2=2</code>，所以查看<code>槽2</code>对应记录的主键值为<code>8</code>，又因为<code>8 &gt; 6</code>，所以设置<code>high=2</code>，<code>low</code>保持不变。</li><li>重新计算中间槽的位置：<code>(0+2)/2=1</code>，所以查看<code>槽1</code>对应的主键值为<code>4</code>，又因为<code>4 &lt; 6</code>，所以设置<code>low=1</code>，<code>high</code>保持不变。</li><li>因为<code>high - low</code>的值为1，所以确定主键值为<code>6</code>的记录在<code>槽2</code>对应的组中。此刻我们需要找到<code>槽2</code>中主键值最小的那条记录，然后沿着单向链表遍历<code>槽2</code>中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里<code>槽2</code>对应的记录是主键值为<code>8</code>的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到<code>槽1</code>对应的记录（主键值为<code>4</code>），该条记录的下一条记录就是<code>槽2</code>中主键值最小的记录，该记录的主键值为<code>5</code>。所以我们可以从这条主键值为<code>5</code>的记录出发，遍历<code>槽2</code>中的各条记录，直到找到主键值为<code>6</code>的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li></ol><p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p><ol><li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li><li>通过记录的<code>next_record</code>属性遍历该槽所在的组中的各个记录。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>如果你不知道二分法是个什么东西，找个基础算法书看看吧。什么？算法书写的看不懂？等我～<br></code></pre></td></tr></table></figure><h2 id="Page-Header（页面头部）">Page Header（页面头部）</h2><p>设计<code>InnoDB</code>的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫<code>Page Header</code>的部分，它是<code>页</code>结构的第二部分，这个部分占用固定的<code>56</code>个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>PAGE_N_DIR_SLOTS</code></td><td><code>2</code>字节</td><td>在页目录中的槽数量</td></tr><tr><td><code>PAGE_HEAP_TOP</code></td><td><code>2</code>字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td></tr><tr><td><code>PAGE_N_HEAP</code></td><td><code>2</code>字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td><code>PAGE_FREE</code></td><td><code>2</code>字节</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td><code>PAGE_GARBAGE</code></td><td><code>2</code>字节</td><td>已删除记录占用的字节数</td></tr><tr><td><code>PAGE_LAST_INSERT</code></td><td><code>2</code>字节</td><td>最后插入记录的位置</td></tr><tr><td><code>PAGE_DIRECTION</code></td><td><code>2</code>字节</td><td>记录插入的方向</td></tr><tr><td><code>PAGE_N_DIRECTION</code></td><td><code>2</code>字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td><code>PAGE_N_RECS</code></td><td><code>2</code>字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td><code>PAGE_MAX_TRX_ID</code></td><td><code>8</code>字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td><code>PAGE_LEVEL</code></td><td><code>2</code>字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td><code>PAGE_INDEX_ID</code></td><td><code>8</code>字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td><code>PAGE_BTR_SEG_LEAF</code></td><td><code>10</code>字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td><code>PAGE_BTR_SEG_TOP</code></td><td><code>10</code>字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><p>如果大家认真看过前边的文章，从<code>PAGE_N_DIR_SLOTS</code>到<code>PAGE_LAST_INSERT</code>以及<code>PAGE_N_RECS</code>的意思大家一定是清楚的，如果不清楚，对不起，你应该回头再看一遍前边的文章。剩下的状态信息看不明白不要着急，饭要一口一口吃，东西要一点一点学（一定要稍安勿躁哦，不要被这些名词吓到）。在这里我们先唠叨一下<code>PAGE_DIRECTION</code>和<code>PAGE_N_DIRECTION</code>的意思：</p><ul><li><p><code>PAGE_DIRECTION</code></p><p>假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是<code>PAGE_DIRECTION</code>。</p></li><li><p><code>PAGE_N_DIRECTION</code></p><p>假设连续几次插入新记录的方向都是一致的，<code>InnoDB</code>会把沿着同一个方向插入记录的条数记下来，这个条数就用<code>PAGE_N_DIRECTION</code>这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</p></li></ul><p>至于我们没提到的那些属性，我没说是因为现在不需要大家知道。不要着急，当我们学完了后边的内容，你再回头看，一切都是那么清晰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>说到这个有些东西后边我们学过后回头看就很清晰的事儿不禁让我想到了乔布斯在斯坦福大学的演讲，摆一下原文：<br><br>“You can&#x27;t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future.You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.”<br><br>上边这段话纯属心血来潮写的，大意是坚持做自己喜欢的事儿，你在做的时候可能并不能搞清楚这些事儿对自己之后的人生有啥影响，但当你一路走来回头看时，一切都是那么清晰，就像是命中注定的一样。上述内容跟MySQL毫无干系，请忽略～<br></code></pre></td></tr></table></figure><h2 id="File-Header（文件头部）">File Header（文件头部）</h2><p>上边唠叨的<code>Page Header</code>是专门针对<code>数据页</code>记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。我们现在描述的<code>File Header</code>针对各种类型的页都通用，也就是说不同类型的页都会以<code>File Header</code>作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁啦吧啦吧啦～ 这个部分占用固定的<code>38</code>个字节，是由下边这些内容组成的：</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td><code>4</code>字节</td><td>页的校验和（checksum值）</td></tr><tr><td><code>FIL_PAGE_OFFSET</code></td><td><code>4</code>字节</td><td>页号</td></tr><tr><td><code>FIL_PAGE_PREV</code></td><td><code>4</code>字节</td><td>上一个页的页号</td></tr><tr><td><code>FIL_PAGE_NEXT</code></td><td><code>4</code>字节</td><td>下一个页的页号</td></tr><tr><td><code>FIL_PAGE_LSN</code></td><td><code>8</code>字节</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td><code>FIL_PAGE_TYPE</code></td><td><code>2</code>字节</td><td>该页的类型</td></tr><tr><td><code>FIL_PAGE_FILE_FLUSH_LSN</code></td><td><code>8</code>字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td><code>4</code>字节</td><td>页属于哪个表空间</td></tr></tbody></table><p>对照着这个表格，我们看几个目前比较重要的部分：</p><ul><li><p><code>FIL_PAGE_SPACE_OR_CHKSUM</code></p><p>这个代表当前页面的校验和（checksum）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为<code>校验和</code>。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</p></li><li><p><code>FIL_PAGE_OFFSET</code></p><p>每一个<code>页</code>都有一个单独的页号，就跟你的身份证号码一样，<code>InnoDB</code>通过页号来可以唯一定位一个<code>页</code>。</p></li><li><p><code>FIL_PAGE_TYPE</code></p><p>这个代表当前<code>页</code>的类型，我们前边说过，<code>InnoDB</code>为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的<code>数据页</code>，其实还有很多别的类型的页，具体如下表：</p><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td><code>FIL_PAGE_TYPE_ALLOCATED</code></td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td><code>FIL_PAGE_UNDO_LOG</code></td><td>0x0002</td><td>Undo日志页</td></tr><tr><td><code>FIL_PAGE_INODE</code></td><td>0x0003</td><td>段信息节点</td></tr><tr><td><code>FIL_PAGE_IBUF_FREE_LIST</code></td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td><code>FIL_PAGE_IBUF_BITMAP</code></td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td><code>FIL_PAGE_TYPE_SYS</code></td><td>0x0006</td><td>系统页</td></tr><tr><td><code>FIL_PAGE_TYPE_TRX_SYS</code></td><td>0x0007</td><td>事务系统数据</td></tr><tr><td><code>FIL_PAGE_TYPE_FSP_HDR</code></td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td><code>FIL_PAGE_TYPE_XDES</code></td><td>0x0009</td><td>扩展描述页</td></tr><tr><td><code>FIL_PAGE_TYPE_BLOB</code></td><td>0x000A</td><td>溢出页</td></tr><tr><td><code>FIL_PAGE_INDEX</code></td><td>0x45BF</td><td>索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table><p>我们存放记录的数据页的类型其实是<code>FIL_PAGE_INDEX</code>，也就是所谓的<code>索引页</code>。至于啥是个索引，且听下回分解～</p></li><li><p><code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code></p><p>我们前边强调过，<code>InnoDB</code>都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），<code>InnoDB</code>可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们本集中唠叨的<code>数据页</code>（也就是类型为<code>FIL_PAGE_INDEX</code>的页）是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a95c10eb9d61ce~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ca00fhg418pl1f1a1iav1uo3aou9.png-90.9kB"></li></ul><p>关于<code>File Header</code>的其他属性我们暂时用不到，等用到的时候再提哈～</p><h2 id="File-Trailer">File Trailer</h2><p>我们知道<code>InnoDB</code>存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以<code>页</code>为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计<code>InnoDB</code>的大叔们在每个页的尾部都加了一个<code>File Trailer</code>部分，这个部分由<code>8</code>个字节组成，可以分成2个小部分：</p><ul><li><p>前4个字节代表页的校验和</p><p>这个部分是和<code>File Header</code>中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为<code>File Header</code>在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在<code>File Header</code>中的校验和就代表着已经修改过的页，而在<code>File Trailer</code>中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p></li><li><p>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）</p><p>这个部分也是为了校验页的完整性的，只不过我们目前还没说<code>LSN</code>是个什么意思，所以大家可以先不用管这个属性。</p></li></ul><p>这个<code>File Trailer</code>与<code>File Header</code>类似，都是所有类型的页通用的。</p><h2 id="总结-3">总结</h2><ol><li>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做<code>数据页</code>。</li><li>一个数据页可以被大致划分为7个部分，分别是<ul><li><code>File Header</code>，表示页的一些通用信息，占固定的38字节。</li><li><code>Page Header</code>，表示数据页专有的一些信息，占固定的56个字节。</li><li><code>Infimum + Supremum</code>，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的<code>26</code>个字节。</li><li><code>User Records</code>：真实存储我们插入的记录的部分，大小不固定。</li><li><code>Free Space</code>：页中尚未使用的部分，大小不确定。</li><li><code>Page Directory</code>：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。</li><li><code>File Trailer</code>：用于检验页是否完整的部分，占用固定的8个字节。</li></ul></li><li>每个记录的头信息中都有一个<code>next_record</code>属性，从而使页中的所有记录串联成一个<code>单链表</code>。</li><li><code>InnoDB</code>会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个<code>槽</code>，存放在<code>Page Directory</code>中，所以在一个页中根据主键查找记录是非常快的，分为两步：<ul><li>通过二分法确定该记录所在的槽。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ul></li><li>每个数据页的<code>File Header</code>部分都有上一个和下一个页的编号，所以所有的数据页会组成一个<code>双链表</code>。</li><li>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的<code>LSN</code>值，如果首部和尾部的校验和和<code>LSN</code>值校验不成功的话，就说明同步过程出现了问题。</li></ol><h1>6.B+树索引</h1><p>前边我们详细唠叨了<code>InnoDB</code>数据页的7个组成部分，知道了各个数据页可以组成一个<code>双向链表</code>，而每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边儿的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在<code>页目录</code>中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录（如果你对这段话有一丁点儿疑惑，那么接下来的部分不适合你，返回去看一下数据页结构吧）。页和记录的关系示意图如下：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1b8eafbb4~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cov976plf2u1j3g1jp8serjc616.png-87.7kB"><p>其中页a、页b、页c … 页n 这些页可以不在物理结构上相连，只要通过双向链表相关联即可。</p><h2 id="没有索引的查找">没有索引的查找</h2><p>本集的主题是<code>索引</code>，在正式介绍<code>索引</code>之前，我们需要了解一下没有索引的时候是怎么查找记录的。为了方便大家理解，我们下边先只唠叨搜索条件为对某个列精确匹配的情况，所谓精确匹配，就是搜索条件中用等于<code>=</code>连接起的表达式，比如这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> [列名列表] <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 列名 = xxx;<br></code></pre></td></tr></table></figure><h3 id="在一个页中的查找">在一个页中的查找</h3><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li><p>以主键为搜索条件</p><p>这个查找过程我们已经很熟悉了，可以在<code>页目录</code>中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p></li><li><p>以其他列作为搜索条件</p><p>对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的<code>页目录</code>，所以我们无法通过二分法快速定位相应的<code>槽</code>。这种情况下只能从<code>最小记录</code>开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p></li></ul><h3 id="在很多页中查找">在很多页中查找</h3><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页。</li><li>从所在的页内中查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的，如果一个表有一亿条记录，使用这种方式去查找记录那要等到猴年马月才能等到查找结果。所以祖国和人民都在期盼一种能高效完成搜索的方法，<code>索引</code>同志就要亮相登台了。</p><h2 id="索引">索引</h2><p>为了故事的顺利发展，我们先建一个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> index_demo(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c1 <span class="hljs-type">INT</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c2 <span class="hljs-type">INT</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c3 <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">PRIMARY</span> KEY(c1)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><p>这个新建的<code>index_demo</code>表中有2个<code>INT</code>类型的列，1个<code>CHAR(1)</code>类型的列，而且我们规定了<code>c1</code>列为主键，这个表使用<code>Compact</code>行格式来实际存储记录的。为了我们理解上的方便，我们简化了一下<code>index_demo</code>表的行格式示意图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1ba8d05b2~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caac8jr7hhcld017gd1lch1n1m33.png-97.1kB"><p>我们只在示意图里展示记录的这几个部分：</p><ul><li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录、<code>2</code>表示最小记录、<code>3</code>表示最大记录、<code>1</code>我们还没用过，等会再说～</li><li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。</li><li><code>各个列的值</code>：这里只记录在<code>index_demo</code>表中的三个列，分别是<code>c1</code>、<code>c2</code>和<code>c3</code>。</li><li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>为了节省篇幅，我们之后的示意图中会把记录的<code>其他信息</code>这个部分省略掉，因为它占地方并且不会有什么观赏效果。另外，为了方便理解，我们觉得把记录竖着放看起来感觉更好，所以将记录格式示意图的<code>其他信息</code>去掉并把它竖起来的效果就是这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1b0cad198~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caacokob6ne1nv41meda0s7vk3g.png-68.1kB"><p>把一些记录放到页里边的示意图就是：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1be0d43ce~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caadhc4g1pb7hk81fcd4vt1u6r3t.png-79.8kB"><h3 id="一个简单的索引方案">一个简单的索引方案</h3><p>回到正题，我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 <em><strong>不得不</strong></em> 依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？还记得我们为根据主键值快速定位一条记录在页中的位置而设立的页目录么？我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完成下边这些事儿：</p><ul><li><p>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</p><p>为了故事的顺利发展，我们这里需要做一个假设：假设我们的每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设之后我们向<code>index_demo</code>表插入3条记录：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; INSERT INTO index_demo VALUES(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, &#x27;u&#x27;), (<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, &#x27;d&#x27;), (<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, &#x27;y&#x27;);<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">3</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">01</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">3</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1b5a6e2af~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caaf26411d51bq7jtrvesr04a.png-29.5kB"><p>从图中可以看出来，<code>index_demo</code>表中的3条记录都被插入到了编号为<code>10</code>的数据页中了。此时我们再来插入一条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> index_demo <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>因为<code>页10</code>最多只能放3条记录，所以我们不得不再分配一个新页：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd1b581b013~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caafbcj1qpo1ad2j8q1ci4136s4n.png-44.5kB"><p>咦？怎么分配的页号是<code>28</code>呀，不应该是<code>11</code>么？再次强调一遍，新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。它们只是通过维护着上一个页和下一个页的编号而建立了链表关系。另外，<code>页10</code>中用户记录最大的主键值是<code>5</code>，而<code>页28</code>中有一条记录的主键值是<code>4</code>，因为<code>5 &gt; 4</code>，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为<code>4</code>的记录的时候需要伴随着一次记录移动，也就是把主键值为<code>5</code>的记录移动到<code>页28</code>中，然后再把主键值为<code>4</code>的记录插入到<code>页10</code>中，这个过程的示意图如下：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2641f1c47~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caafkq3h1akv1mde14h2kjul6554.png-96.9kB"><p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为<code>页分裂</code>。</p></li><li><p>给所有的页建立一个目录项。</p><p>由于数据页的编号可能并不是连续的，所以在向<code>index_demo</code>表中插入许多条记录后，可能是这样的效果：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd27e1f3cf3~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cab9u9midn61fgq1mi58j0gadm.png-65.7kB"><p>因为这些<code>16KB</code>的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：</p><ul><li>页的用户记录中最小的主键值，我们用<code>key</code>来表示。</li><li>页号，我们用<code>page_no</code>表示。</li></ul><p>所以我们为上边几个页做好的目录就像这样子：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd282d6b9b9~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caba0afo11fa1cli1nu070m16bg1j.png-119.1kB"><p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为<code>20</code>的记录，具体查找过程分两步：</p><ol><li>先从目录项中根据二分法快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 <code>12 &lt; 20 &lt; 209</code>），它对应的页是<code>页9</code>。</li><li>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</li></ol></li></ul><p>至此，针对数据页做的简易目录就搞定了。不过忘了说了，这个<code>目录</code>有一个别名，称为<code>索引</code>。</p><h3 id="InnoDB中的索引方案">InnoDB中的索引方案</h3><p>上边之所以称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储，但是这样做有几个问题：</p><ul><li><code>InnoDB</code>是使用页来作为管理存储空间的基本单位，也就是最多能保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li><li>我们时常会对记录进行增删，假设我们把<code>页28</code>中的记录都删除了，<code>页28</code>也就没有存在的必要了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把<code>目录项2</code>后的目录项都向前移动一下，这种牵一发而动全身的设计不是什么好主意～</li></ul><p>所以，设计<code>InnoDB</code>的大叔们需要一种可以灵活管理所有<code>目录项</code>的方式。他们灵光乍现，忽然发现这些<code>目录项</code>其实长得跟我们的用户记录差不多，只不过<code>目录项</code>中的两个列是<code>主键</code>和<code>页号</code>而已，所以他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。那<code>InnoDB</code>怎么区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>呢？别忘了记录头信息里的<code>record_type</code>属性，它的各个取值代表的意思如下：</p><ul><li><code>0</code>：普通的用户记录</li><li><code>1</code>：目录项记录</li><li><code>2</code>：最小记录</li><li><code>3</code>：最大记录</li></ul><p>哈哈，原来这个值为<code>1</code>的<code>record_type</code>是这个意思呀，我们把前边使用到的目录项放到数据页中的样子就是这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd295fd42b5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1caahuomf15m11e5k19v1bf21inq9.png-145.9kB"><p>从图中可以看出来，我们新分配了一个编号为<code>30</code>的页来专门存储<code>目录项记录</code>。这里再次强调一遍<code>目录项记录</code>和普通的<code>用户记录</code>的不同点：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而普通用户记录的<code>record_type</code>值是0。</li><li><code>目录项记录</code>只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有<code>InnoDB</code>自己添加的隐藏列。</li><li>还记得我们之前在唠叨记录头信息的时候说过一个叫<code>min_rec_mask</code>的属性么，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li></ul><p>除了上述几点外，这两者就没啥差别了，它们用的是一样的数据页（页面类型都是<code>0x45BF</code>，这个属性在<code>File Header</code>中，忘了的话可以翻到前边的文章看），页的组成结构也是一样一样的（就是我们前边介绍过的7个部分），都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li>先到存储<code>目录项记录</code>的页，也就是页<code>30</code>中通过二分法快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以定位到对应的记录所在的页就是<code>页9</code>。</li><li>再到存储用户记录的<code>页9</code>中根据二分法快速定位到主键值为<code>20</code>的用户记录。</li></ol><p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的<code>目录项记录</code>，该咋办呢？</p><p>当然是再多整一个存储<code>目录项记录</code>的页喽～ 为了大家更好的理解新分配一个<code>目录项记录</code>页的过程，我们假设一个存储<code>目录项记录</code>的页最多只能存放4条<code>目录项记录</code>（请注意是假设哦，真实情况下可以存放好多条的），所以如果此时我们再向上图中插入一条主键值为<code>320</code>的用户记录的话，那就需要分配一个新的存储<code>目录项记录</code>的页喽：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd29ebc7a4c~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cacabsrh17a5133q1otf725gi92q.png-135.7kB"><p>从图中可以看出，我们插入了一条主键值为<code>320</code>的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了<code>页31</code>。</li><li>因为原先存储<code>目录项记录</code>的<code>页30</code>的容量已满（我们前边假设只能存储4条<code>目录项记录</code>），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul><p>现在因为存储<code>目录项记录</code>的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p><ol><li><p>确定<code>目录项记录</code>页</p><p>我们现在的存储<code>目录项记录</code>的页有两个，即<code>页30</code>和<code>页32</code>，又因为<code>页30</code>表示的目录项的主键值的范围是<code>[1, 320)</code>，<code>页32</code>表示的目录项的主键值不小于<code>320</code>，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p></li><li><p>通过<code>目录项记录</code>页确定用户记录真实所在的页。</p><p>在一个存储<code>目录项记录</code>的页中通过主键值定位一条目录项记录的方式说过了，不赘述了～</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p><p>在一个存储用户记录的页中通过主键值定位一条用户记录的方式已经说过200遍了，你再不会我就，我就，我就求你到上一篇唠叨数据页结构的文章中多看几遍，求你了～</p></li></ol><p>那么问题来了，在这个查询步骤的第1步中我们需要定位存储<code>目录项记录</code>的页，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多存储<code>目录项记录</code>的页，那我们怎么根据主键值快速定位一个存储<code>目录项记录</code>的页呢？其实也简单，为这些存储<code>目录项记录</code>的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2a6c7a65f~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cacafpso19vpkik1j5rtrd17cm3a.png-158.1kB"><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表<code>页30</code>和<code>页32</code>，如果用户记录的主键值在<code>[1, 320)</code>之间，则到<code>页30</code>中查找更详细的<code>目录项记录</code>，如果主键值不小于<code>320</code>的话，就到<code>页32</code>中查找更详细的<code>目录项记录</code>。不过这张图好漂亮喔，随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2a6fb9126~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ca80gps314u9121u1rdp9r7md8cm.png-55.6kB"><p>这玩意儿像不像一个倒过来的<code>树</code>呀，上头是树根，下头是树叶！其实这是一种组织数据的形式，或者说是一种数据结构，它的名称是<code>B+</code>树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>为啥叫`B+`呢，`B`树是个啥？喔对不起，这不是我们讨论的范围，你可以去找一本数据结构或算法的书来看。什么？数据结构的书看不懂？等我～<br></code></pre></td></tr></table></figure><p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到<code>B+</code>树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<code>叶子节点</code>或<code>叶节点</code>，其余用来存放<code>目录项</code>的节点称为<code>非叶子节点</code>或者<code>内节点</code>，其中<code>B+</code>树最上边的那个节点也称为<code>根节点</code>。</p><p>从图中可以看出来，一个<code>B+</code>树的节点其实可以分成好多层，设计<code>InnoDB</code>的大叔们为了讨论方便，规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前的讨论我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设，假设，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：</p><ul><li>如果<code>B+</code>树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li><li>如果<code>B+</code>树有2层，最多能存放<code>1000×100=100000</code>条记录。</li><li>如果<code>B+</code>树有3层，最多能存放<code>1000×1000×100=100000000</code>条记录。</li><li>如果<code>B+</code>树有4层，最多能存放<code>1000×1000×1000×100=100000000000</code>条记录。哇咔咔～这么多的记录！！！</li></ul><p>你的表里能存放<code>100000000000</code>条记录么？所以一般情况下，我们用到的<code>B+</code>树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过二分法实现快速定位记录，这不是很牛么，哈哈！</p><h4 id="聚簇索引">聚簇索引</h4><p>我们上边介绍的<code>B+</code>树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li>页内的记录是按照主键的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li></ul></li><li><p><code>B+</code>树的叶子节点存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p>我们把具有这两种特性的<code>B+</code>树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种<code>聚簇索引</code>并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建（后边会介绍索引相关的语句），<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的索引即数据，数据即索引。</p><h4 id="二级索引">二级索引</h4><p>大家有木有发现，上边介绍的<code>聚簇索引</code>只能在搜索条件是主键值时才能发挥作用，因为<code>B+</code>树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？</p><p>不，我们可以多建几棵<code>B+</code>树，不同的<code>B+</code>树中的数据采用不同的排序规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一棵<code>B+</code>树，效果如下图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2a89adfa5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cactc8jg14j91likvmd1h8cn3o4h.png-161.6kB"><p>这个<code>B+</code>树与上边介绍的聚簇索引有几处不同：</p><ul><li>使用记录<code>c2</code>列的大小进行记录和页的排序，这包括三个方面的含义：<ul><li>页内的记录是按照<code>c2</code>列的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中记录的<code>c2</code>列大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的<code>c2</code>列大小顺序排成一个双向链表。</li></ul></li><li><code>B+</code>树的叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。</li><li>目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>c2列+页号</code>的搭配。</li></ul><p>所以如果我们现在想通过<code>c2</code>列的值查找某些记录的话就可以使用我们刚刚建好的这个<code>B+</code>树了。以查找<code>c2</code>列的值为<code>4</code>的记录为例，查找过程如下：</p><ol><li><p>确定<code>目录项记录</code>页</p><p>根据<code>根页面</code>，也就是<code>页44</code>，可以快速定位到<code>目录项记录</code>所在的页为<code>页42</code>（因为<code>2 &lt; 4 &lt; 9</code>）。</p></li><li><p>通过<code>目录项记录</code>页确定用户记录真实所在的页。</p><p>在<code>页42</code>中可以快速定位到实际存储用户记录的页，但是由于<code>c2</code>列并没有唯一性约束，所以<code>c2</code>列值为<code>4</code>的记录可能分布在多个数据页中，又因为<code>2 &lt; 4 ≤ 4</code>，所以确定实际存储用户记录的页在<code>页34</code>和<code>页35</code>中。</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p><p>到<code>页34</code>和<code>页35</code>中定位到具体的记录。</p></li><li><p>但是这个<code>B+</code>树的叶子节点中的记录只存储了<code>c2</code>和<code>c1</code>（也就是<code>主键</code>）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</p></li></ol><p>各位各位，看到步骤4的操作了么？我们根据这个以<code>c2</code>列大小排序的<code>B+</code>树只能确定我们要查找记录的主键值，所以如果我们想根据<code>c2</code>列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程也被称为<code>回表</code>。也就是根据<code>c2</code>列的值查询一条完整的用户记录需要使用到<code>2</code>棵<code>B+</code>树！！！</p><p>为什么我们还需要一次<code>回表</code>操作呢？直接把完整的用户记录放到<code>叶子节点</code>不就好了么？你说的对，如果把完整的用户记录放到<code>叶子节点</code>是可以不用<code>回表</code>，但是太占地方了呀～相当于每建立一棵<code>B+</code>树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照<code>非主键列</code>建立的<code>B+</code>树需要一次<code>回表</code>操作才可以定位到完整的用户记录，所以这种<code>B+</code>树也被称为<code>二级索引</code>（英文名<code>secondary index</code>），或者<code>辅助索引</code>。由于我们使用的是<code>c2</code>列的大小作为<code>B+</code>树的排序规则，所以我们也称这个<code>B+</code>树为为c2列建立的索引。</p><h5 id="联合索引">联合索引</h5><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让<code>B+</code>树按照<code>c2</code>和<code>c3</code>列的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照<code>c2</code>列进行排序。</li><li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li></ul><p>为<code>c2</code>和<code>c3</code>列建立的索引的示意图如下：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2b0b70d72~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d80rmun21al711ok1tvo1i161rnpp.png-172.2kB"><p>如图所示，我们需要注意一下几点：</p><ul><li>每条<code>目录项记录</code>都由<code>c2</code>、<code>c3</code>、<code>页号</code>这三个部分组成，各条记录先按照<code>c2</code>列的值进行排序，如果记录的<code>c2</code>列相同，则按照<code>c3</code>列的值进行排序。</li><li><code>B+</code>树叶子节点处的用户记录由<code>c2</code>、<code>c3</code>和主键<code>c1</code>列组成。</li></ul><p>千万要注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><ul><li>建立<code>联合索引</code>只会建立如上图一样的1棵<code>B+</code>树。</li><li>为c2和c3列分别建立索引会分别以<code>c2</code>和<code>c3</code>列的大小为排序规则建立2棵<code>B+</code>树。</li></ul><h3 id="InnoDB的B-树索引的注意事项">InnoDB的B+树索引的注意事项</h3><h4 id="根页面万年不动窝">根页面万年不动窝</h4><p>我们前边介绍<code>B+</code>树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上<code>B+</code>树的形成过程是这样的：</p><ul><li>每当为某个表创建一个<code>B+</code>树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个<code>B+</code>树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当<code>根节点</code>中的可用空间用完时继续插入记录，此时会将<code>根节点</code>中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><p>这个过程需要大家特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的<code>根节点</code>的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出<code>根节点</code>的页号，从而来访问这个索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>跟大家剧透一下，这个存储某个索引的根节点在哪个页面中的信息就是传说中的数据字典中的一项信息，关于更多数据字典的内容，后边会详细唠叨，别着急哈。<br></code></pre></td></tr></table></figure><h4 id="内节点中目录项记录的唯一性">内节点中目录项记录的唯一性</h4><p>我们知道<code>B+</code>树索引的内节点中目录项记录的内容是<code>索引列 + 页号</code>的搭配，但是这个搭配对于二级索引来说有点儿不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的：</p><table><thead><tr><th><code>c1</code></th><th><code>c2</code></th><th><code>c3</code></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p>如果二级索引中目录项记录的内容只是<code>索引列 + 页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的<code>B+</code>树应该长这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2c5b9ef01~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cp9vthl71h9n8091dkdjek16qg1j.png-58.6kB"><p>如果我们想新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>'c'</code>，那么在修改这个为<code>c2</code>列建立的二级索引对应的<code>B+</code>树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的<code>c2</code>列的值都是<code>1</code>，而我们新插入的这条记录的<code>c2</code>列的值也是<code>1</code>，那我们这条新插入的记录到底应该放到<code>页4</code>中，还是应该放到<code>页5</code>中啊？答案是：对不起，懵逼了。</p><p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除<code>页号</code>这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录了，这样就能保证<code>B+</code>树每一层节点中各条目录项记录除<code>页号</code>这个字段外是唯一的，所以我们为<code>c2</code>列建立二级索引后的示意图实际上应该是这样子的：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2c92fbca0~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cpb919suginpp7lbgsk0147f20.png-58.6kB"><p>这样我们再插入记录<code>(9, 1, 'c')</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 主键 + 页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为<code>B+</code>树同一层中不同目录项记录的<code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p><h4 id="一个页面最少存储2条记录">一个页面最少存储2条记录</h4><p>我们前边说过一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？逗我呢？所以<code>InnoDB</code>的一个数据页至少可以存放两条记录，这也是我们之前唠叨记录行格式的时候说过一个结论（我们当时依据这个结论推导了表中只有一个列时该列在不发生行溢出的情况下最多能存储多少字节，忘了的话回去看看吧）。</p><h3 id="MyISAM中的索引方案简单介绍">MyISAM中的索引方案简单介绍</h3><p>至此，我们介绍的都是<code>InnoDB</code>存储引擎中的索引方案，为了内容的完整性，以及各位可能在面试的时候遇到这类的问题，我们有必要再简单介绍一下<code>MyISAM</code>存储引擎中的索引方案。我们知道<code>InnoDB</code>中索引即数据，也就是聚簇索引的那棵<code>B+</code>树的叶子节点中已经把所有完整的用户记录都包含了，而<code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p><ul><li><p>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。</p><p><code>MyISAM</code>记录也需要记录头信息来存储一些额外数据，我们以上边唠叨过的<code>index_demo</code>表为例，看一下这个表中的记录使用<code>MyISAM</code>作为存储引擎在存储空间中的表示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a01bd2d0c5ad53~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cpc7go2o12t1ocd17nvr6msth9.png-58.9kB"><p>由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。</p></li><li><p>使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<code>主键值 + 行号</code>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！</p><p>这一点和<code>InnoDB</code>是完全不相同的，在<code>InnoDB</code>存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着<code>MyISAM</code>中建立的索引相当于全部都是<code>二级索引</code>！</p></li><li><p>如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和<code>InnoDB</code>中的索引差不多，不过在叶子节点处存储的是<code>相应的列 + 行号</code>。这些索引也全部都是<code>二级索引</code>。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>MyISAM的行格式有定长记录格式（Static）、变长记录格式（Dynamic）、压缩记录格式（Compressed）。上边用到的index_demo表采用定长记录格式，也就是一条记录占用存储空间的大小是固定的，这样就可以轻松算出某条记录在数据文件中的地址偏移量。但是变长记录格式就不行了，MyISAM会直接在索引叶子节点处存储该条记录在数据文件中的地址偏移量。通过这个可以看出，MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里边儿找记录，虽然说也不慢，但还是比不上直接用地址去访问。<br><br>此处我们只是非常简要的介绍了一下MyISAM的索引，具体细节全拿出来又可以写一篇文章了。这里只是希望大家理解InnoDB中的索引即数据，数据即索引，而MyISAM中却是索引是索引、数据是数据。<br></code></pre></td></tr></table></figure><h3 id="MySQL中创建和删除索引的语句">MySQL中创建和删除索引的语句</h3><p>光顾着唠叨索引的原理了，那我们如何使用<code>MySQL</code>语句去建立这种索引呢？<code>InnoDB</code>和<code>MyISAM</code>会自动为主键或者声明为<code>UNIQUE</code>的列去自动建立<code>B+</code>树索引，但是如果我们想为其他的列建立索引就需要我们显式的去指明。为啥不自动为每个列都建立个索引呢？别忘了，每建立一个索引都会建立一棵<code>B+</code>树，每插入一条记录都要维护各个记录、数据页的排序关系，这是很费性能和存储空间的。</p><p>我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TALBE 表名 (<br>    各种列的信息 ··· , <br>    [<span class="hljs-keyword">KEY</span>|<span class="hljs-keyword">INDEX</span>] 索引名 (需要被索引的单个列或多个列)<br>)<br></code></pre></td></tr></table></figure><p>其中的<code>KEY</code>和<code>INDEX</code>是同义词，任意选用一个就可以。我们也可以在修改表结构的时候添加索引：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">ALTER</span> <span class="hljs-meta">TABLE</span> 表名 <span class="hljs-meta">ADD</span> [<span class="hljs-meta">INDEX</span>|<span class="hljs-meta">KEY</span>] 索引名 (需要被索引的单个列或多个列);<br></code></pre></td></tr></table></figure><p>也可以在修改表结构的时候删除索引：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">ALTER</span> <span class="hljs-meta">TABLE</span> 表名 <span class="hljs-meta">DROP</span> [<span class="hljs-meta">INDEX</span>|<span class="hljs-meta">KEY</span>] 索引名;<br></code></pre></td></tr></table></figure><p>比方说我们想在创建<code>index_demo</code>表的时候就为<code>c2</code>和<code>c3</code>列添加一个<code>联合索引</code>，可以这么写建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> index_demo(<br>    c1 <span class="hljs-type">INT</span>,<br>    c2 <span class="hljs-type">INT</span>,<br>    c3 <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY(c1),<br>    INDEX idx_c2_c3 (c2, c3)<br>);<br></code></pre></td></tr></table></figure><p>在这个建表语句中我们创建的索引名是<code>idx_c2_c3</code>，这个名称可以随便起，不过我们还是建议以<code>idx_</code>为前缀，后边跟着需要建立索引的列名，多个列名之间用下划线<code>_</code>分隔开。</p><p>如果我们想删除这个索引，可以这么写：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> index_demo <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> idx_c2_c3;<br></code></pre></td></tr></table></figure><h1>7.B+树索引的使用</h1><p>我们前边详细、详细又详细的唠叨了<code>InnoDB</code>存储引擎的<code>B+</code>树索引，我们必须熟悉下边这些结论：</p><ul><li>每个索引都对应一棵<code>B+</code>树，<code>B+</code>树分为好多层，最下边一层是叶子节点，其余的是内节点。所有<code>用户记录</code>都存储在<code>B+</code>树的叶子节点，所有<code>目录项记录</code>都存储在非叶节点。</li><li><code>InnoDB</code>存储引擎会自动为主键（如果没有它会自动帮我们添加）建立<code>聚簇索引</code>，聚簇索引的叶子节点包含完整的用户记录。</li><li>我们可以为自己感兴趣的列建立<code>二级索引</code>，<code>二级索引</code>的叶子节点包含的用户记录由<code>索引列 + 主键</code>组成，所以如果想通过<code>二级索引</code>来查找完整的用户记录的话，需要通过<code>回表</code>操作，也就是在通过<code>二级索引</code>找到主键值之后再到<code>聚簇索引</code>中查找完整的用户记录。</li><li><code>B+</code>树中<strong>每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表</strong>，而且每个<strong>页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表</strong>。如果是<code>联合索引</code>的话，则页面和记录先按照<code>联合索引</code>前边的列排序，如果该列值相同，再按照<code>联合索引</code>后边的列排序。</li><li>通过索引查找记录是从<code>B+</code>树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了<code>Page Directory</code>（页目录），所以在这些页面中的查找非常快。</li></ul><p>如果你读上边的几点结论有些任何一点点疑惑的话，那下边的内容不适合你，回过头先去看前边的内容去。</p><h2 id="索引的代价">索引的代价</h2><p>在熟悉了<code>B+</code>树索引原理之后，本篇文章的主题是唠叨如何更好的使用索引，虽然索引是个好东西，可不能乱建，在介绍如何更好的使用索引之前先要了解一下使用这玩意儿的代价，它在空间和时间上都会拖后腿：</p><ul><li><p>空间上的代价</p><p>这个是显而易见的，每建立一个索引都要为它建立一棵<code>B+</code>树，每一棵<code>B+</code>树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的<code>B+</code>树由许多数据页组成，那可是很大的一片存储空间呢。</p></li><li><p>时间上的代价</p><p>每次对表中的数据进行增、删、改操作时，都需要去修改各个<code>B+</code>树索引。而且我们讲过，<code>B+</code>树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的<code>B+</code>树都要进行相关的维护操作，这还能不给性能拖后腿么？</p></li></ul><p>所以说，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们先得学学这些索引在哪些条件下起作用的。</p><h2 id="B-树索引适用的条件">B+树索引适用的条件</h2><p>下边我们将唠叨许多种让<code>B+</code>树索引发挥最大效能的技巧和注意事项，不过大家要清楚，所有的技巧都是源自你对<code>B+</code>树索引本质的理解，所以如果你还不能保证对<code>B+</code>树索引充分的理解，那么再次建议回过头把前边的内容看完了再来，要不然读文章对你来说是一种折磨。首先，<code>B+</code>树索引并不是万能的，并不是所有的查询语句都能用到我们建立的索引。下边介绍几个我们可能使用<code>B+</code>树索引来进行查询的情况。为了故事的顺利发展，我们需要先创建一个表，这个表是用来存储人的一些基本信息的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> auto_increment,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    KEY idx_name_birthday_phone_number (name, birthday, phone_number)<br>);<br></code></pre></td></tr></table></figure><p>对于这个<code>person_info</code>表我们需要注意两点：</p><ul><li>表中的主键是<code>id</code>列，它存储一个自动递增的整数。所以<code>InnoDB</code>存储引擎会自动为<code>id</code>列建立聚簇索引。</li><li>我们额外定义了一个二级索引<code>idx_name_birthday_phone_number</code>，它是由3个列组成的联合索引。所以在这个索引对应的<code>B+</code>树的叶子节点处存储的用户记录只保留<code>name</code>、<code>birthday</code>、<code>phone_number</code>这三个列的值以及主键<code>id</code>的值，并不会保存<code>country</code>列的值。</li></ul><p>从这两点注意中我们可以再次看到，一个表中有多少索引就会建立多少棵<code>B+</code>树，<code>person_info</code>表会为聚簇索引和<code>idx_name_birthday_phone_number</code>索引建立2棵<code>B+</code>树。下边我们画一下索引<code>idx_name_birthday_phone_number</code>的示意图，不过既然我们已经掌握了<code>InnoDB</code>的<code>B+</code>树索引原理，那我们在画图的时候为了让图更加清晰，所以在省略一些不必要的部分，比如记录的额外信息，各页面的页号等等，其中内节点中目录项记录的页号信息我们用箭头来代替，在记录结构中只保留<code>name</code>、<code>birthday</code>、<code>phone_number</code>、<code>id</code>这四个列的真实数据值，所以示意图就长这样（留心的同学看出来了，这其实和《高性能MySQL》里举的例子的图差不多，我觉得这个例子特别好，所以就借鉴了一下）：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16db02bc665cf0b1~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1dmo2n5c11ij019unpjtpf21tdr9.png-121.1kB"><p>为了方便大家理解，我们特意标明了哪些是内节点，哪些是叶子节点。再次强调一下，内节点中存储的是<code>目录项记录</code>，叶子节点中存储的是<code>用户记录</code>（由于不是聚簇索引，所以用户记录是不完整的，缺少<code>country</code>列的值）。从图中可以看出，这个<code>idx_name_birthday_phone_number</code>索引对应的<code>B+</code>树中页面和记录的排序方式就是这样的：</p><ul><li>先按照<code>name</code>列的值进行排序。</li><li>如果<code>name</code>列的值相同，则按照<code>birthday</code>列的值进行排序。</li><li>如果<code>birthday</code>列的值也相同，则按照<code>phone_number</code>的值进行排序。</li></ul><p>这个排序方式十分、特别、非常、巨、very very very重要，因为只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找。下边的内容都仰仗这个图了，大家对照着图理解。</p><h3 id="全值匹配">全值匹配</h3><p>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span> <span class="hljs-keyword">AND</span> phone_number = <span class="hljs-string">&#x27;15123983239&#x27;</span>;<br></code></pre></td></tr></table></figure><p>我们建立的<code>idx_name_birthday_phone_number</code>索引包含的3个列在这个查询语句中都展现出来了。大家可以想象一下这个查询过程：</p><ul><li>因为<code>B+</code>树的数据页和记录先是按照<code>name</code>列的值进行排序的，所以先可以很快定位<code>name</code>列的值是<code>Ashburn</code>的记录位置。</li><li>在<code>name</code>列相同的记录里又是按照<code>birthday</code>列的值进行排序的，所以在<code>name</code>列的值是<code>Ashburn</code>的记录里又可以快速定位<code>birthday</code>列的值是<code>'1990-09-27'</code>的记录。</li><li>如果很不幸，<code>name</code>和<code>birthday</code>列的值都是相同的，那记录是按照<code>phone_number</code>列的值排序的，所以联合索引中的三个列都可能被用到。</li></ul><p>有的同学也许有个疑问，<code>WHERE</code>子句中的几个搜索条件的顺序对查询结果有啥影响么？也就是说如果我们调换<code>name</code>、<code>birthday</code>、<code>phone_number</code>这几个搜索列的顺序对查询的执行过程有影响么？比方说写成下边这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span> <span class="hljs-keyword">AND</span> phone_number = <span class="hljs-string">&#x27;15123983239&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span>;<br></code></pre></td></tr></table></figure><p>答案是：没影响哈。<code>MySQL</code>有一个叫查询优化器的东东，会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。我们后边儿会有专门的章节来介绍查询优化器，敬请期待。</p><h3 id="匹配左边的列">匹配左边的列</h3><p>其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span>;<br></code></pre></td></tr></table></figure><p>或者包含多个左边的列也行：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span>;<br></code></pre></td></tr></table></figure><p>那为什么搜索条件中必须出现左边的列才可以使用到这个<code>B+</code>树索引呢？比如下边的语句就用不到这个<code>B+</code>树索引么？</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span>;<br></code></pre></td></tr></table></figure><p>是的，的确用不到，因为<code>B+</code>树的数据页和记录先是按照<code>name</code>列的值排序的，在<code>name</code>列的值相同的情况下才使用<code>birthday</code>列进行排序，也就是说<code>name</code>列的值不同的记录中<code>birthday</code>的值可能是无序的。而现在你跳过<code>name</code>列直接根据<code>birthday</code>的值去查找，臣妾做不到呀～ 那如果我就想在只使用<code>birthday</code>的值去通过<code>B+</code>树索引进行查找咋办呢？这好办，你再对<code>birthday</code>列建一个<code>B+</code>树索引就行了，创建索引的语法不用我唠叨了吧。</p><p>但是需要特别注意的一点是，如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列。比方说联合索引<code>idx_name_birthday_phone_number</code>中列的定义顺序是<code>name</code>、<code>birthday</code>、<code>phone_number</code>，如果我们的搜索条件中只有<code>name</code>和<code>phone_number</code>，而没有中间的<code>birthday</code>，比方说这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> phone_number = <span class="hljs-string">&#x27;15123983239&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这样只能用到<code>name</code>列的索引，<code>birthday</code>和<code>phone_number</code>的索引就用不上了，因为<code>name</code>值相同的记录先按照<code>birthday</code>的值进行排序，<code>birthday</code>值相同的记录才按照<code>phone_number</code>值进行排序。</p><h3 id="匹配列前缀">匹配列前缀</h3><p>我们前边说过为某个列建立索引的意思其实就是在对应的<code>B+</code>树的记录中使用该列的值进行排序，比方说<code>person_info</code>表上建立的联合索引<code>idx_name_birthday_phone_number</code>会先用<code>name</code>列的值进行排序，所以这个联合索引对应的<code>B+</code>树中的记录的<code>name</code>列的排列就是这样的：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">Aaron<br>Aaron<br><span class="hljs-meta">...</span><br>Aaron<br>Asa<br>Ashburn<br><span class="hljs-meta">...</span><br>Ashburn<br>Baird<br>Barlow<br><span class="hljs-meta">...</span><br>Barlow<br></code></pre></td></tr></table></figure><p>字符串排序的本质就是比较哪个字符串大一点儿，哪个字符串小一点，比较字符串大小就用到了该列的字符集和比较规则，这个我们前边儿唠叨过，就不多唠叨了。这里需要注意的是，一般的比较规则都是逐个比较字符的大小，也就是说我们比较两个字符串的大小的过程其实是这样的：</p><ul><li>先比较字符串的第一个字符，第一个字符小的那个字符串就比较小。</li><li>如果两个字符串的第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小。</li><li>如果两个字符串的第二个字符也相同，那就接着比较第三个字符，依此类推。</li></ul><p>所以一个排好序的字符串列其实有这样的特点：</p><ul><li>先按照字符串的第一个字符进行排序。</li><li>如果第一个字符相同再按照第二个字符进行排序。</li><li>如果第二个字符相同再按照第三个字符进行排序，依此类推。</li></ul><p>也就是说这些字符串的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的，比方说我们想查询名字以<code>'As'</code>开头的记录，那就可以这么写查询语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;As%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%As%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>MySQL</code>就无法快速定位记录位置了，因为字符串中间有<code>'As'</code>的字符串并没有排好序，所以只能全表扫描了。有时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个<code>url</code>列，该列中存储了许多url：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------------+</span><br><span class="hljs-section">| url            |</span><br><span class="hljs-section">+----------------+</span><br>| www.baidu.com  |<br>| www.google.com |<br>| www.gov.cn     |<br>| ...            |<br><span class="hljs-section">| www.wto.org    |</span><br><span class="hljs-section">+----------------+</span><br></code></pre></td></tr></table></figure><p>假设已经对该<code>url</code>列创建了索引，如果我们想查询以<code>com</code>为后缀的网址的话可以这样写查询条件：<code>WHERE url LIKE '%com'</code>，但是这样的话无法使用该<code>url</code>列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存<code>url</code>列中的数据：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------------+</span><br><span class="hljs-section">| url            |</span><br><span class="hljs-section">+----------------+</span><br>| moc.udiab.www  |<br>| moc.elgoog.www |<br>| nc.vog.www     |<br>| ...            |<br><span class="hljs-section">| gro.otw.www    |</span><br><span class="hljs-section">+----------------+</span><br></code></pre></td></tr></table></figure><p>这样再查找以<code>com</code>为后缀的网址时搜索条件便可以这么写：<code>WHERE url LIKE 'moc%'</code>，这样就可以用到索引了。</p><h3 id="匹配范围值">匹配范围值</h3><p>回头看我们<code>idx_name_birthday_phone_number</code>索引的<code>B+</code>树示意图，所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span>;<br></code></pre></td></tr></table></figure><p>由于<code>B+</code>树中的数据页和记录是先按<code>name</code>列排序的，所以我们上边的查询过程其实是这样的：</p><ul><li>通过B+树在叶子节点中找到第一条<code>name</code>值大于<code>Asa</code>的二级索引记录，读取该记录的主键值进行回表操作，获得对应的聚簇索引记录后发送给客户端。</li><li>根据上一步找到的记录，沿着记录所在的链表向后查找（同一页面中的记录使用单向链表连接起来，数据页之间用双向链表连接起来）下一条二级索引记录，判断该记录是否符合name &lt; 'Barlow’条件，如果符合，则进行回表操作后发送至客户端。</li><li>重复上一步骤，直到某条二级索引记录不符合name &lt;'Barlow’条件为止。</li></ul><p>不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到<code>B+</code>树索引，比方说这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span> <span class="hljs-keyword">AND</span> birthday &gt; <span class="hljs-string">&#x27;1980-01-01&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上边这个查询可以分成两个部分：</p><ol><li>通过条件<code>name &gt; 'Asa' AND name &lt; 'Barlow' </code>来对<code>name</code>进行范围，查找的结果可能有多条<code>name</code>值不同的记录，</li><li>对这些<code>name</code>值不同的记录继续通过<code>birthday &gt; '1980-01-01'</code>条件继续过滤。</li></ol><p>这样子对于联合索引<code>idx_name_birthday_phone_number</code>来说，只能用到<code>name</code>列的部分，而用不到<code>birthday</code>列的部分，因为只有<code>name</code>值相同的情况下才能用<code>birthday</code>列的值进行排序，而这个查询中通过<code>name</code>进行范围查找的记录中可能并不是按照<code>birthday</code>列进行排序的，所以在搜索条件中继续以<code>birthday</code>列进行查找时是用不到这个<code>B+</code>树索引的。</p><h3 id="精确匹配某一列并范围匹配另外一列">精确匹配某一列并范围匹配另外一列</h3><p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday &gt; <span class="hljs-string">&#x27;1980-01-01&#x27;</span> <span class="hljs-keyword">AND</span> birthday &lt; <span class="hljs-string">&#x27;2000-12-31&#x27;</span> <span class="hljs-keyword">AND</span> phone_number &gt; <span class="hljs-string">&#x27;15100000000&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这个查询的条件可以分为3个部分：</p><ol><li><code>name = 'Ashburn'</code>，对<code>name</code>列进行精确查找，当然可以使用<code>B+</code>树索引了。</li><li><code>birthday &gt; '1980-01-01' AND birthday &lt; '2000-12-31'</code>，由于<code>name</code>列是精确查找，所以通过<code>name = 'Ashburn'</code>条件查找后得到的结果的<code>name</code>值都是相同的，它们会再按照<code>birthday</code>的值进行排序。所以此时对<code>birthday</code>列进行范围查找是可以用到<code>B+</code>树索引的。</li><li><code>phone_number &gt; '15100000000'</code>，通过<code>birthday</code>的范围查找的记录的<code>birthday</code>的值可能不同，所以这个条件无法再利用<code>B+</code>树索引了，只能遍历上一步查询得到的记录。</li></ol><p>同理，下边的查询也是可能用到这个<code>idx_name_birthday_phone_number</code>联合索引的：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday = <span class="hljs-string">&#x27;1980-01-01&#x27;</span> <span class="hljs-keyword">AND</span> phone_number &gt; <span class="hljs-string">&#x27;15100000000&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="用于排序">用于排序</h3><p>我们在写查询语句的时候经常需要对查询出来的记录通过<code>ORDER BY</code>子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、吧啦吧啦排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在<code>MySQL</code>中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>），跟<code>文件</code>这个词儿一沾边儿，就显得这些排序操作非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果<code>ORDER BY</code>子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday, phone_number <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这个查询的结果集需要先按照<code>name</code>值排序，如果记录的<code>name</code>值相同，则需要按照<code>birthday</code>来排序，如果<code>birthday</code>的值相同，则需要按照<code>phone_number</code>排序。大家可以回过头去看我们建立的<code>idx_name_birthday_phone_number</code>索引的示意图，因为这个<code>B+</code>树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行<code>回表</code>操作取出该索引中不包含的列就好了。简单吧？是的，索引就是这么牛逼。</p><h4 id="使用联合索引进行排序注意事项">使用联合索引进行排序注意事项</h4><p>对于<code>联合索引</code>有个问题需要注意，<code>ORDER BY</code>的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出<code>ORDER BY phone_number, birthday, name</code>的顺序，那也是用不了<code>B+</code>树索引，这种颠倒顺序就不能使用索引的原因我们上边详细说过了，这就不赘述了。</p><p>同理，<code>ORDER BY name</code>、<code>ORDER BY name, birthday</code>这种匹配索引左边的列的形式可以使用部分的<code>B+</code>树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> birthday, phone_number <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这个查询能使用联合索引进行排序是因为<code>name</code>列的值相同的记录是按照<code>birthday</code>, <code>phone_number</code>排序的，说了好多遍了都。</p><h4 id="不可以使用索引进行排序的几种情况">不可以使用索引进行排序的几种情况</h4><h5 id="ASC、DESC混用">ASC、DESC混用</h5><p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是<code>ASC</code>规则排序，要么都是<code>DESC</code>规则排序。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">小贴士：<br><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>子句后的列如果不加<span class="hljs-keyword">ASC</span>或者<span class="hljs-keyword">DESC</span>默认是按照<span class="hljs-keyword">ASC</span>排序规则排序的，也就是升序排序的。<br></code></pre></td></tr></table></figure><p>为啥会有这种奇葩规定呢？这个还得回头想想这个<code>idx_name_birthday_phone_number</code>联合索引中记录的结构：</p><ul><li>先按照记录的<code>name</code>列的值进行升序排列。</li><li>如果记录的<code>name</code>列的值相同，再按照<code>birthday</code>列的值进行升序排列。</li><li>如果记录的<code>birthday</code>列的值相同，再按照<code>phone_number</code>列的值进行升序排列。</li></ul><p>如果查询中的各个排序列的排序顺序是一致的，比方说下边这两种情况：</p><ul><li><p><code>ORDER BY name, birthday LIMIT 10</code></p><p>这种情况直接从索引的最左边开始往右读10行记录就可以了。</p></li><li><p><code>ORDER BY name DESC, birthday DESC LIMIT 10</code>，</p><p>这种情况直接从索引的最右边开始往左读10行记录就可以了。</p></li></ul><p>但是如果我们查询的需求是先按照<code>name</code>列进行升序排列，再按照<code>birthday</code>列进行降序排列的话，比如说这样的查询语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这样如果使用索引排序的话过程就是这样的：</p><ul><li>先从索引的最左边确定<code>name</code>列最小的值，然后找到<code>name</code>列等于该值的所有记录，然后从<code>name</code>列等于该值的最右边的那条记录开始往左找10条记录。</li><li>如果<code>name</code>列等于最小的值的记录不足10条，再继续往右找<code>name</code>值第二小的记录，重复上边那个过程，直到找到10条记录为止。</li></ul><p>累不累？累！重点是这样不能高效使用索引，而要采取更复杂的算法去从索引中取数据，设计<code>MySQL</code>的大叔觉得这样还不如直接文件排序来的快，所以就规定使用联合索引的各个排序列的排序顺序必须是一致的。</p><h5 id="排序列包含非同一个索引的列">排序列包含非同一个索引的列</h5><p>有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, country <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p><code>name</code>和<code>country</code>并不属于一个联合索引中的列，所以无法使用索引进行排序，至于为啥我就不想再唠叨了，自己用前边的理论自己捋一捋吧～</p><h5 id="排序列使用了复杂的表达式">排序列使用了复杂的表达式</h5><p>要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> UPPER(<span class="hljs-type">name</span>) <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>使用了<code>UPPER</code>函数修饰过的列就不是单独的列啦，这样就无法使用索引进行排序啦。</p><h3 id="用于分组">用于分组</h3><p>有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span>, birthday, phone_number, COUNT(*) <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday, phone_number<br></code></pre></td></tr></table></figure><p>这个查询语句相当于做了3次分组操作：</p><ol><li>先把记录按照<code>name</code>值进行分组，所有<code>name</code>值相同的记录划分为一组。</li><li>将每个<code>name</code>值相同的分组里的记录再按照<code>birthday</code>的值进行分组，将<code>birthday</code>值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</li><li>再将上一步中产生的小分组按照<code>phone_number</code>的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把<code>大分组</code>分成若干个<code>小分组</code>，然后把若干个<code>小分组</code>再细分成更多的<code>小小分组</code>。</li></ol><p>然后针对那些<code>小小分组</code>进行统计，比如在我们这个查询语句中就是统计每个<code>小小分组</code>包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的<code>B+</code>树中的索引列的顺序是一致的，而我们的<code>B+</code>树索引又是按照索引列排好序的，这不正好么，所以可以直接使用<code>B+</code>树索引进行分组。</p><p>和使用<code>B+</code>树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组，吧啦吧啦的～</p><h2 id="回表的代价">回表的代价</h2><p>上边的讨论对<code>回表</code>这个词儿多是一带而过，可能大家没啥深刻的体会，下边我们详细唠叨下。还是用<code>idx_name_birthday_phone_number</code>索引为例，看下边这个查询：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span>;<br></code></pre></td></tr></table></figure><p>在使用<code>idx_name_birthday_phone_number</code>索引进行查询时大致可以分为这两个步骤：</p><ol><li>从索引<code>idx_name_birthday_phone_number</code>对应的<code>B+</code>树中取出<code>name</code>值在<code>Asa</code>～<code>Barlow</code>之间的用户记录。</li><li>由于索引<code>idx_name_birthday_phone_number</code>对应的<code>B+</code>树用户记录中只包含<code>name</code>、<code>birthday</code>、<code>phone_number</code>、<code>id</code>这4个字段，而查询列表是<code>*</code>，意味着要查询表中所有字段，也就是还要包括<code>country</code>字段。这时需要把从上一步中获取到的每一条记录的<code>id</code>字段都到聚簇索引对应的<code>B+</code>树中找到完整的用户记录，也就是我们通常所说的<code>回表</code>，然后把完整的用户记录返回给查询用户。</li></ol><p>由于索引<code>idx_name_birthday_phone_number</code>对应的<code>B+</code>树中的记录首先会按照<code>name</code>列的值进行排序，所以值在<code>Asa</code>～<code>Barlow</code>之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为<code>顺序I/O</code>。根据第1步中获取到的**记录的<code>id</code>字段的值可能并不相连，而在聚簇索引中记录是根据<code>id</code>（也就是主键）的顺序排列的，所以根据这些并不连续的<code>id</code>值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为<code>随机I/O</code>。**一般情况下，顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。所以这个使用索引<code>idx_name_birthday_phone_number</code>的查询有这么两个特点：</p><ul><li>会使用到两个<code>B+</code>树索引，一个二级索引，一个聚簇索引。</li><li>访问二级索引使用<code>顺序I/O</code>，访问聚簇索引使用<code>随机I/O</code>。</li></ul><p>需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用<code>二级索引</code>。比方说<code>name</code>值在<code>Asa</code>～<code>Barlow</code>之间的用户记录数量占全部记录数量90%以上，那么如果使用<code>idx_name_birthday_phone_number</code>索引的话，有90%多的<code>id</code>值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。</p><p>那什么时候采用全表扫描的方式，什么时候使用采用<code>二级索引 + 回表</code>的方式去执行查询呢？这个就是传说中的查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用<code>二级索引 + 回表</code>的方式。当然优化器做的分析工作不仅仅是这么简单，但是大致上是个这个过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用<code>二级索引 + 回表</code>的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>添加了<code>LIMIT 10</code>的查询更容易让优化器采用<code>二级索引 + 回表</code>的方式进行查询。</p><p>对于有排序需求的查询，上边讨论的采用<code>全表扫描</code>还是<code>二级索引 + 回表</code>的方式进行查询的条件也是成立的，比方说下边这个查询：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday, phone_number;<br></code></pre></td></tr></table></figure><p>由于查询列表是<code>*</code>，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（<code>filesort</code>）低，所以优化器会倾向于使用<code>全表扫描</code>的方式执行查询。如果我们加了<code>LIMIT</code>子句，比如这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday, phone_number <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这样需要回表的记录特别少，优化器就会倾向于使用<code>二级索引 + 回表</code>的方式执行查询。</p><h3 id="覆盖索引">覆盖索引</h3><p>为了彻底告别<code>回表</code>操作带来的性能损耗，我们建议：最好在查询列表里只包含索引列，比如这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span>, birthday, phone_number <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span><br></code></pre></td></tr></table></figure><p>因为我们只查询<code>name</code>, <code>birthday</code>, <code>phone_number</code>这三个索引列的值，所以在通过<code>idx_name_birthday_phone_number</code>索引得到结果后就不必到<code>聚簇索引</code>中再查找记录的剩余列，也就是<code>country</code>列的值了，这样就省去了<code>回表</code>操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为<code>索引覆盖</code>。排序操作也优先使用<code>覆盖索引</code>的方式进行查询，比方说这个查询：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span>, birthday, phone_number  <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday, phone_number;<br></code></pre></td></tr></table></figure><p>虽然这个查询中没有<code>LIMIT</code>子句，但是采用了<code>覆盖索引</code>，所以查询优化器就会直接使用<code>idx_name_birthday_phone_number</code>索引进行排序而不需要回表操作了。</p><p>当然，如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是我们很不鼓励用<code>*</code>号作为查询列表，最好把我们需要查询的列依次标明。</p><h2 id="如何挑选索引">如何挑选索引</h2><p>上边我们以<code>idx_name_birthday_phone_number</code>索引为例对索引的适用条件进行了详细的唠叨，下边看一下我们在建立索引时或者编写查询语句时就应该注意的一些事项。</p><h3 id="只为用于搜索、排序或分组的列创建索引">只为用于搜索、排序或分组的列创建索引</h3><p>也就是说，只为出现在<code>WHERE</code>子句中的列、连接子句中的连接列，或者出现在<code>ORDER BY</code>或<code>GROUP BY</code>子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> birthday, country <span class="hljs-keyword">FROM</span> person_name <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span>;<br></code></pre></td></tr></table></figure><p>像查询列表中的<code>birthday</code>、<code>country</code>这两个列就不需要建立索引，我们只需要为出现在<code>WHERE</code>子句中的<code>name</code>列创建索引就可以了。</p><h3 id="考虑列的基数">考虑列的基数</h3><p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2, 5, 8, 2, 5, 8, 2, 5, 8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。这个<code>列的基数</code>指标非常重要，直接影响我们是否能有效的利用索引。假设某个列的基数为<code>1</code>，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了～ 而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。所以结论就是：<strong>最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</strong></p><h3 id="索引列的类型尽量小">索引列的类型尽量小</h3><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<code>TINYINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>这么几种，它们占用的存储空间依次递增，我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用<code>INT</code>就不要使用<code>BIGINT</code>，能使用<code>MEDIUMINT</code>就不要使用<code>INT</code>～ 这是因为：</p><ul><li>数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的<code>I/O</code>。</p><h3 id="索引字符串值的前缀">索引字符串值的前缀</h3><p>我们知道一个字符串其实是由若干个字符组成，如果我们在<code>MySQL</code>中使用<code>utf8</code>字符集去存储字符串的话，编码一个字符需要占用<code>1~3</code>个字节。假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的<code>B+</code>树中有这么两个问题：</p><ul><li><code>B+</code>树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。</li><li>如果<code>B+</code>树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li></ul><p>我们前边儿说过索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案 — 只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样只在<code>B+</code>树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题，何乐而不为，比方说我们在建表语句中只对<code>name</code>列的前10个字符进行索引可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    KEY idx_name_birthday_phone_number (name(<span class="hljs-number">10</span>), birthday, phone_number)<br>);    <br></code></pre></td></tr></table></figure><p><code>name(10)</code>就表示在建立的<code>B+</code>树索引中只保留记录的前<code>10</code>个字符的编码，这种只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。</p><h4 id="索引列前缀对排序的影响">索引列前缀对排序的影响</h4><p>如果使用了索引列前缀，比方说前边只把<code>name</code>列的前10个字符放到了二级索引中，下边这个查询可能就有点儿尴尬了：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>因为二级索引中不包含完整的<code>name</code>列信息，所以无法对前十个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只好乖乖的用文件排序喽。</p><h3 id="让索引列在比较表达式中单独出现">让索引列在比较表达式中单独出现</h3><p>假设表中有一个整数列<code>my_col</code>，我们为这个列建立了索引。下边的两个<code>WHERE</code>子句虽然语义是一致的，但是在效率上却有差别：</p><ol><li><code>WHERE my_col * 2 &lt; 4</code></li><li><code>WHERE my_col &lt; 4/2</code></li></ol><p>第1个<code>WHERE</code>子句中<code>my_col</code>列并不是以单独列的形式出现的，而是以<code>my_col * 2</code>这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于<code>4</code>，所以这种情况下是使用不到为<code>my_col</code>列建立的<code>B+</code>树索引的。而第2个<code>WHERE</code>子句中<code>my_col</code>列并是以单独列的形式出现的，这样的情况可以直接使用<code>B+</code>树索引。</p><p>所以结论就是：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p><h3 id="主键插入顺序">主键插入顺序</h3><p>我们知道，对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在<code>1~100</code>之间：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16db02bc7153fee5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1capq3r1o1geqdck1cnc1fkihj39.png-28.1kB"><p>如果此时再插入一条主键值为<code>9</code>的记录，那它插入的位置就如下图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16db02bc77059366~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1capq7nnv13en8b31lvtj2i1e8lm.png-35.3kB"><p>可这个数据页已经满了啊，再插进来咋办呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：性能损耗！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：让主键具有<code>AUTO_INCREMENT</code>，让存储引擎自己为表生成主键，而不是我们手动插入 ，比方说我们可以这样定义<code>person_info</code>表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>    id <span class="hljs-type">INT</span> UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    KEY idx_name_birthday_phone_number (name(<span class="hljs-number">10</span>), birthday, phone_number)<br>);    <br></code></pre></td></tr></table></figure><p>我们自定义的主键列<code>id</code>拥有<code>AUTO_INCREMENT</code>属性，在插入记录时存储引擎会自动为我们填入自增的主键值。</p><h3 id="冗余和重复索引">冗余和重复索引</h3><p>有时候有的同学有意或者无意的就对同一个列创建了多个索引，比方说这样写建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>    id <span class="hljs-type">INT</span> UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    KEY idx_name_birthday_phone_number (name(<span class="hljs-number">10</span>), birthday, phone_number),<br>    KEY idx_name (name(<span class="hljs-number">10</span>))<br>);    <br></code></pre></td></tr></table></figure><p>我们知道，通过<code>idx_name_birthday_phone_number</code>索引就可以对<code>name</code>列进行快速搜索，再创建一个专门针对<code>name</code>列的索引就算是一个<code>冗余</code>索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p><p>另一种情况，我们可能会对某个列重复建立索引，比方说这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> repeat_index_demo (<br>    c1 <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    c2 <span class="hljs-type">INT</span>,<br>    <span class="hljs-keyword">UNIQUE</span> uidx_c1 (c1),<br>    INDEX idx_c1 (c1)<br>);  <br></code></pre></td></tr></table></figure><p>我们看到，<code>c1</code>既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p><h2 id="总结-4">总结</h2><p>上边只是我们在创建和使用<code>B+</code>树索引的过程中需要注意的一些点，后边我们还会陆续介绍更多的优化方法和注意事项，敬请期待。本集内容总结如下：</p><ol><li><code>B+</code>树索引在空间和时间上都有代价，所以没事儿别瞎建索引。</li><li><code>B+</code>树索引适用于下边这些情况：<ul><li>全值匹配</li><li>匹配左边的列</li><li>匹配范围值</li><li>精确匹配某一列并范围匹配另外一列</li><li>用于排序</li><li>用于分组</li></ul></li><li>在使用索引时需要注意下边这些事项：<ul><li>只为用于搜索、排序或分组的列创建索引</li><li>为列的基数大的列创建索引</li><li>索引列的类型尽量小</li><li>可以只对字符串值的前缀建立索引</li><li>只有索引列在比较表达式中单独出现才可以适用索引</li><li>为了尽可能少的让<code>聚簇索引</code>发生页面分裂和记录移位的情况，建议让主键拥有<code>AUTO_INCREMENT</code>属性。</li><li>定位并删除表中的重复和冗余索引</li><li>尽量使用<code>覆盖索引</code>进行查询，避免<code>回表</code>带来的性能损耗。</li></ul></li></ol><h1>8.MySQL 的数据目录</h1><h2 id="数据库和文件系统的关系">数据库和文件系统的关系</h2><p>我们知道像<code>InnoDB</code>、<code>MyISAM</code>这样的存储引擎都是把表存储在磁盘上的，而操作系统用来管理磁盘的那个东东又被称为<code>文件系统</code>，所以用专业一点的话来表述就是：像 <em><strong>InnoDB</strong></em> 、 <em><strong>MyISAM</strong></em> 这样的存储引擎都是把表存储在文件系统上的。当我们想读取数据的时候，这些存储引擎会从文件系统中把数据读出来返回给我们，当我们想写入数据的时候，这些存储引擎会把这些数据又写回文件系统。本章就是要唠叨一下<code>InnoDB</code>和<code>MyISAM</code>这两个存储引擎的数据如何在文件系统中存储的。</p><h2 id="MySQL数据目录">MySQL数据目录</h2><p>MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件，之后在运行过程中产生的数据也都会存储到这个目录下的某些文件中，这个目录就称为<code>数据目录</code>，我们下边就要详细唠唠这个目录下具体都有哪些重要的东西。</p><h3 id="数据目录和安装目录的区别">数据目录和安装目录的区别</h3><p>我们之前只接触过<code>MySQL</code>的安装目录（在安装<code>MySQL</code>的时候我们可以自己指定），我们重点强调过这个<code>安装目录</code>下非常重要的<code>bin</code>目录，它里边存储了许多关于控制客户端程序和服务器程序的命令（许多可执行文件，比如<code>mysql</code>，<code>mysqld</code>，<code>mysqld_safe</code>等等等等好几十个）。而<code>数据目录</code>是用来存储<code>MySQL</code>在运行过程中产生的数据，一定要和本章要讨论的<code>安装目录</code>区别开！一定要区分开！一定要区分开！一定要区分开！</p><h3 id="如何确定MySQL中的数据目录">如何确定MySQL中的数据目录</h3><p>那说了半天，到底<code>MySQL</code>把数据都存到哪个路径下呢？其实<code>数据目录</code>对应着一个系统变量<code>datadir</code>，我们在使用客户端与服务器建立连接之后查看这个系统变量的值就可以了：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;datadir&#x27;;</span><br><span class="hljs-section">+---------------+-----------------------+</span><br><span class="hljs-section">| Variable_name | Value                 |</span><br><span class="hljs-section">+---------------+-----------------------+</span><br><span class="hljs-section">| datadir       | /usr/local/var/mysql/ |</span><br><span class="hljs-section">+---------------+-----------------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>从结果中可以看出，在我的计算机上<code>MySQL</code>的数据目录就是<code>/usr/local/var/mysql/</code>，你用你的计算机试试呗～</p><h2 id="数据目录的结构">数据目录的结构</h2><p><code>MySQL</code>在运行过程中都会产生哪些数据呢？当然会包含我们创建的数据库、表、视图和触发器吧啦吧啦的用户数据，除了这些用户数据，为了程序更好的运行，<code>MySQL</code>也会创建一些其他的额外数据，我们接下来细细的品味一下这个<code>数据目录</code>下的内容。</p><h3 id="数据库在文件系统中的表示">数据库在文件系统中的表示</h3><p>每当我们使用<code>CREATE DATABASE 数据库名</code>语句创建一个数据库的时候，在文件系统上实际发生了什么呢？其实很简单，每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹，我们每当我们新建一个数据库时，<code>MySQL</code>会帮我们做这两件事儿：</p><ol><li>在<code>数据目录</code>下创建一个和数据库名同名的子目录（或者说是文件夹）。</li><li>在该与数据库名同名的子目录下创建一个名为<code>db.opt</code>的文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则是个啥。</li></ol><p>比方说我们查看一下在我的计算机上当前有哪些数据库：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW DATABASES;</span><br><span class="hljs-section">+--------------------+</span><br><span class="hljs-section">| Database           |</span><br><span class="hljs-section">+--------------------+</span><br>| information<span class="hljs-emphasis">_schema |</span><br><span class="hljs-emphasis">| charset_demo_db    |</span><br><span class="hljs-emphasis">| dahaizi            |</span><br><span class="hljs-emphasis">| mysql              |</span><br><span class="hljs-emphasis">| performance_</span>schema |<br>| sys                |<br><span class="hljs-section">| xiaohaizi          |</span><br><span class="hljs-section">+--------------------+</span><br>7 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>可以看到在我的计算机上当前有7个数据库，其中<code>charset_demo_db</code>、<code>dahaizi</code>和<code>xiaohaizi</code>数据库是我们自定义的，其余4个数据库是属于MySQL自带的系统数据库。我们再看一下我的计算机上的<code>数据目录</code>下的内容：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stata">.<br>├── auto.cnf<br>├── <span class="hljs-keyword">ca</span>-key.pem<br>├── <span class="hljs-keyword">ca</span>.pem<br>├── charset_demo_db<br>├── client-cert.pem<br>├── client-key.pem<br>├── dahaizi<br>├── ib_buffer_pool<br>├── ib_logfile0<br>├── ib_logfile1<br>├── ibdata1<br>├── ibtmp1<br>├── mysql<br>├── performance_schema<br>├── private_key.pem<br>├── public_key.pem<br>├── server-cert.pem<br>├── server-key.pem<br>├── sys<br>├── xiaohaizideMacBook-<span class="hljs-keyword">Pro</span>.<span class="hljs-keyword">local</span>.<span class="hljs-keyword">err</span><br>├── xiaohaizideMacBook-<span class="hljs-keyword">Pro</span>.<span class="hljs-keyword">local</span>.pid<br>└── xiaohaizi<br><br>6 directories, 16 files<br></code></pre></td></tr></table></figure><p>当然这个数据目录下的文件和子目录比较多哈，但是如果仔细看的话，除了<code>information_schema</code>这个系统数据库外，其他的数据库在<code>数据目录</code>下都有对应的子目录。这个<code>information_schema</code>比较特殊，设计MySQL的大叔们对它的实现进行了特殊对待，没有使用相应的数据库目录，我们忽略它的存在就好了哈。</p><h3 id="表在文件系统中的表示">表在文件系统中的表示</h3><p>我们的数据其实都是以记录的形式插入到表中的，每个表的信息其实可以分为两种：</p><ol><li>表结构的定义</li><li>表中的数据</li></ol><p><code>表结构</code>就是该表的名称是啥，表里边有多少列，每个列的数据类型是啥，有啥约束条件和索引，用的是啥字符集和比较规则吧啦吧啦的各种信息，这些信息都体现在了我们的建表语句中了。为了保存这些信息，<code>InnoDB</code>和<code>MyISAM</code>这两种存储引擎都在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于描述表结构的文件，文件名是这样：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">表名<span class="hljs-string">.frm</span><br></code></pre></td></tr></table></figure><p>比方说我们在<code>dahaizi</code>数据库下创建一个名为<code>test</code>的表：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; USE dahaizi;<br><span class="hljs-keyword">Database</span> changed<br><br>mysql&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test (<br>    -&gt;     c1 <span class="hljs-type">INT</span><br>    -&gt; );<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><p>那在数据库<code>dahaizi</code>对应的子目录下就会创建一个名为<code>test.frm</code>的用于描述表结构的文件。值得注意的是，这个后缀名为.frm是以二进制格式存储的，我们直接打开会是乱码的～ 你还不赶紧在你的计算机上创建个表试试～</p><p>描述表结构的文件我们知道怎么存储了，那表中的数据存到什么文件中了呢？在这个问题上，不同的存储引擎就产生了分歧了，下边我们分别看一下<code>InnoDB</code>和<code>MyISAM</code>是用什么文件来保存表中数据的。</p><h4 id="InnoDB是如何存储表数据的">InnoDB是如何存储表数据的</h4><p>我们前边重点唠叨过<code>InnoDB</code>的一些实现原理，到现在为止我们应该熟悉下边这些东东：</p><ul><li><code>InnoDB</code>其实是使用<code>页</code>为基本单位来管理存储空间的，默认的<code>页</code>大小为<code>16KB</code>。</li><li>对于<code>InnoDB</code>存储引擎来说，每个索引都对应着一棵<code>B+</code>树，该<code>B+</code>树的每个节点都是一个数据页，数据页之间不必要是物理连续的，因为数据页之间有<code>双向链表</code>来维护着这些页的顺序。</li><li><code>InnoDB</code>的聚簇索引的叶子节点存储了完整的用户记录，也就是所谓的索引即数据，数据即索引。</li></ul><p>为了更好的管理这些页，设计<code>InnoDB</code>的大叔们提出了一个<code>表空间</code>或者<code>文件空间</code>（英文名：<code>table space</code>或者<code>file space</code>）的概念，这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个<code>表空间</code>可以被划分为很多很多很多个<code>页</code>，我们的表数据就存放在某个<code>表空间</code>下的某些页里。设计<code>InnoDB</code>的大叔将表空间划分为几种不同的类型，我们一个一个看一下。</p><h5 id="系统表空间（system-tablespace）">系统表空间（system tablespace）</h5><p>这个所谓的<code>系统表空间</code>可以对应文件系统上一个或多个实际的文件，默认情况下，<code>InnoDB</code>会在<code>数据目录</code>下创建一个名为<code>ibdata1</code>（在你的数据目录下找找看有木有）、大小为<code>12M</code>的文件，这个文件就是对应的<code>系统表空间</code>在文件系统上的表示。怎么才<code>12M</code>？这么点儿还没插多少数据就用完了，哈哈，那是因为这个文件是所谓的<code>自扩展文件</code>，也就是当不够用的时候它会自己增加文件大小～</p><p>当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的<code>ibdata1</code>这个文件名难听，那可以在<code>MySQL</code>启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下配置文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_data_file_path</span>=data1:<span class="hljs-number">512</span>M<span class="hljs-comment">;data2:512M:autoextend</span><br></code></pre></td></tr></table></figure><p>这样在<code>MySQL</code>启动之后就会创建这两个512M大小的文件作为<code>系统表空间</code>，其中的<code>autoextend</code>表明这两个文件如果不够用会自动扩展<code>data2</code>文件的大小。</p><p>我们也可以把<code>系统表空间</code>对应的文件路径不配置到<code>数据目录</code>下，甚至可以配置到单独的磁盘分区上，涉及到的启动参数就是<code>innodb_data_file_path</code>和<code>innodb_data_home_dir</code>，具体的配置逻辑挺绕的，我们这就不多唠叨了，知道改哪个参数可以修改<code>系统表空间</code>对应的文件，有需要的时候到官方文档里一查就好了。</p><p>需要注意的一点是，在一个MySQL服务器中，系统表空间只有一份。从MySQL5.5.7到MySQL5.6.6之间的各个版本中，我们表中的数据都会被默认存储到这个 <em><strong>系统表空间</strong></em>。</p><h5 id="独立表空间-file-per-table-tablespace">独立表空间(file-per-table tablespace)</h5><p>在MySQL5.6.6以及之后的版本中，<code>InnoDB</code>并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该<code>独立表空间</code>的文件，文件名和表名相同，只不过添加了一个<code>.ibd</code>的扩展名而已，所以完整的文件名称长这样：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">表名<span class="hljs-string">.ibd</span><br></code></pre></td></tr></table></figure><p>比方说假如我们使用了<code>独立表空间</code>去存储<code>xiaohaizi</code>数据库下的<code>test</code>表的话，那么在该表所在数据库对应的<code>xiaohaizi</code>目录下会为<code>test</code>表创建这两个文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">test</span>.frm<br><span class="hljs-keyword">test</span>.ibd<br></code></pre></td></tr></table></figure><p>其中<code>test.ibd</code>文件就用来存储<code>test</code>表中的数据和索引。当然我们也可以自己指定使用<code>系统表空间</code>还是<code>独立表空间</code>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code>控制，比如说我们想刻意将表数据都存储到<code>系统表空间</code>时，可以在启动<code>MySQL</code>服务器的时候这样配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span><br><span class="hljs-attr">innodb_file_per_table</span>=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>当<code>innodb_file_per_table</code>的值为<code>0</code>时，代表使用系统表空间；当<code>innodb_file_per_table</code>的值为<code>1</code>时，代表使用独立表空间。不过<code>innodb_file_per_table</code>参数只对新建的表起作用，对于已经分配了表空间的表并不起作用。如果我们想把已经存在系统表空间中的表转移到独立表空间，可以使用下边的语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">TABLESPACE</span> [=] innodb_file_per_table;<br></code></pre></td></tr></table></figure><p>或者把已经存在独立表空间的表转移到系统表空间，可以使用下边的语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">TABLESPACE</span> [=] innodb_system;<br></code></pre></td></tr></table></figure><p>其中中括号扩起来的<code>=</code>可有可无，比方说我们想把<code>test</code>表从独立表空间移动到系统表空间，可以这么写：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> test <span class="hljs-keyword">TABLESPACE</span> innodb_system;<br></code></pre></td></tr></table></figure><h5 id="其他类型的表空间">其他类型的表空间</h5><p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、undo表空间（undo tablespace）、临时表空间（temporary tablespace）吧啦吧啦的，具体情况我们就不细唠叨了，等用到的时候再提。</p><h4 id="MyISAM是如何存储表数据的">MyISAM是如何存储表数据的</h4><p>好了，唠叨完了<code>InnoDB</code>的系统表空间和独立表空间，现在轮到<code>MyISAM</code>了。我们知道不像<code>InnoDB</code>的索引和数据是一个东东，在<code>MyISAM</code>中的索引全部都是<code>二级索引</code>，该存储引擎的数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件。而且和<code>InnoDB</code>不同的是，<code>MyISAM</code>并没有什么所谓的<code>表空间</code>一说，表数据都存放到对应的数据库子目录下。假如<code>test</code>表使用<code>MyISAM</code>存储引擎的话，那么在它所在数据库对应的<code>xiaohaizi</code>目录下会为<code>test</code>表创建这三个文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">test</span>.frm<br><span class="hljs-keyword">test</span>.MYD<br><span class="hljs-keyword">test</span>.MYI<br></code></pre></td></tr></table></figure><p>其中<code>test.MYD</code>代表表的数据文件，也就是我们插入的用户记录；<code>test.MYI</code>代表表的索引文件，我们为该表创建的索引都会放到这个文件中。</p><h3 id="视图在文件系统中的表示">视图在文件系统中的表示</h3><p>我们知道<code>MySQL</code>中的视图其实是虚拟的表，也就是某个查询语句的一个别名而已，所以在存储<code>视图</code>的时候是不需要存储真实的数据的，只需要把它的结构存储起来就行了。和<code>表</code>一样，描述视图结构的文件也会被存储到所属数据库对应的子目录下边，只会存储一个<code>视图名.frm</code>的文件。</p><h3 id="其他的文件">其他的文件</h3><p>除了我们上边说的这些用户自己存储的数据以外，<code>数据目录</code>下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件：</p><ul><li><p>服务器进程文件。</p><p>我们知道每运行一个<code>MySQL</code>服务器程序，都意味着启动一个进程。<code>MySQL</code>服务器会把自己的进程ID写入到一个文件中。</p></li><li><p>服务器日志文件。</p><p>在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志吧啦吧啦各种日志，这些日志各有各的用途，我们之后会重点唠叨各种日志的用途，现在先了解一下就可以了。</p></li><li><p>默认/自动生成的SSL和RSA证书和密钥文件。</p><p>主要是为了客户端和服务器安全通信而创建的一些文件， 大家看不懂可以忽略～</p></li></ul><h2 id="文件系统对数据库的影响">文件系统对数据库的影响</h2><p>因为<code>MySQL</code>的数据都是存在文件系统中的，就不得不受到文件系统的一些制约，这在数据库和表的命名、表的大小和性能方面体现的比较明显，比如下边这些方面：</p><ul><li><p>数据库名称和表名称不得超过文件系统所允许的最大长度。</p><p>每个数据库都对应<code>数据目录</code>的一个子目录，数据库名称就是这个子目录的名称；每个表都会在数据库子目录下产生一个和表名同名的<code>.frm</code>文件，如果是<code>InnoDB</code>的独立表空间或者使用<code>MyISAM</code>引擎还会有别的文件的名称与表名一致。这些目录或文件名的长度都受限于文件系统所允许的长度～</p></li><li><p>特殊字符的问题</p><p>为了避免因为数据库名和表名出现某些特殊字符而造成文件系统不支持的情况，<code>MySQL</code>会把数据库名和表名中所有除数字和拉丁字母以外的所有字符在文件名里都映射成 <code>@+编码值</code>的形式作为文件名。比方说我们创建的表的名称为<code>'test?'</code>，由于<code>?</code>不属于数字或者拉丁字母，所以会被映射成编码值，所以这个表对应的<code>.frm</code>文件的名称就变成了<code>test@003f.frm</code>。</p></li><li><p>文件长度受文件系统最大长度限制</p><p>对于<code>InnoDB</code>的独立表空间来说，每个表的数据都会被存储到一个与表名同名的<code>.ibd</code>文件中；对于<code>MyISAM</code>存储引擎来说，数据和索引会分别存放到与表同名的<code>.MYD</code>和<code>.MYI</code>文件中。这些文件会随着表中记录的增加而增大，它们的大小受限于文件系统支持的最大文件大小。</p></li></ul><h2 id="MySQL系统数据库简介">MySQL系统数据库简介</h2><p>我们前边提到了MySQL的几个系统数据库，这几个数据库包含了MySQL服务器运行过程中所需的一些信息以及一些运行状态信息，我们现在稍微了解一下。</p><ul><li><p><code>mysql</code></p><p>这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p></li><li><p><code>information_schema</code></p><p>这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引吧啦吧啦。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。</p></li><li><p><code>performance_schema</code></p><p>这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。</p></li><li><p><code>sys</code></p><p>这个数据库主要是通过视图的形式把<code>information_schema</code>和<code>performance_schema</code>结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。</p></li></ul><h1>9.InnoDB的表空间</h1><p>通过前边儿的内容大家知道，<code>表空间</code>是一个抽象的概念，对于系统表空间来说，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应着文件系统中一个名为<code>表名.ibd</code>的实际文件。大家可以把表空间想象成被切分为许许多多个<code>页</code>的池子，当我们想为某个表插入一条记录的时候，就从池子中捞出一个对应的页来把数据写进去。本章内容会深入到表空间的各个细节中，带领大家在<code>InnoDB</code>存储结构的池子中畅游。由于本章中将会涉及比较多的概念，虽然这些概念都不难，但是却相互依赖，所以奉劝大家在看的时候：</p><ul><li>不要跳着看！</li><li>不要跳着看！</li><li>不要跳着看！</li></ul><h2 id="回忆一些旧知识">回忆一些旧知识</h2><h3 id="页面类型">页面类型</h3><p>再一次强调，InnoDB是以页为单位管理存储空间的，我们的聚簇索引（也就是完整的表数据）和其他的二级索引都是以<code>B+</code>树的形式保存到表空间的，而<code>B+</code>树的节点就是数据页。我们前边说过，这个数据页的类型名其实是：<code>FIL_PAGE_INDEX</code>，除了这种存放索引数据的页面类型之外，InnoDB也为了不同的目的设计了若干种不同类型的页面，为了唤醒大家的记忆，我们再一次把各种常用的页面类型提出来：</p><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td><code>FIL_PAGE_TYPE_ALLOCATED</code></td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td><code>FIL_PAGE_UNDO_LOG</code></td><td>0x0002</td><td>Undo日志页</td></tr><tr><td><code>FIL_PAGE_INODE</code></td><td>0x0003</td><td>段信息节点</td></tr><tr><td><code>FIL_PAGE_IBUF_FREE_LIST</code></td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td><code>FIL_PAGE_IBUF_BITMAP</code></td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td><code>FIL_PAGE_TYPE_SYS</code></td><td>0x0006</td><td>系统页</td></tr><tr><td><code>FIL_PAGE_TYPE_TRX_SYS</code></td><td>0x0007</td><td>事务系统数据</td></tr><tr><td><code>FIL_PAGE_TYPE_FSP_HDR</code></td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td><code>FIL_PAGE_TYPE_XDES</code></td><td>0x0009</td><td>扩展描述页</td></tr><tr><td><code>FIL_PAGE_TYPE_BLOB</code></td><td>0x000A</td><td>BLOB页</td></tr><tr><td><code>FIL_PAGE_INDEX</code></td><td>0x45BF</td><td>索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table><p>因为页面类型前边都有个<code>FIL_PAGE</code>或者<code>FIL_PAGE_TYPE</code>的前缀，为简便起见我们后边唠叨页面类型的时候就把这些前缀省略掉了，比方说<code>FIL_PAGE_TYPE_ALLOCATED</code>类型称为<code>ALLOCATED</code>类型，<code>FIL_PAGE_INDEX</code>类型称为<code>INDEX</code>类型。</p><h3 id="页面通用部分">页面通用部分</h3><p>我们前边说过数据页，也就是<code>INDEX</code>类型的页由7个部分组成，其中的两个部分是所有类型的页面都通用的。当然我不能寄希望于你把我说的话都记住，所以在这里重新强调一遍，任何类型的页面都有下边这种通用的结构：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f33c338667~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crjupisqne61uer17ikh6l1v8k9.png-44.9kB"><p>从上图中可以看出，任何类型的页都会包含这两个部分：</p><ul><li><code>File Header</code>：记录页面的一些通用信息</li><li><code>File Trailer</code>：校验页是否完整，保证从内存到磁盘刷新时内容的一致性。</li></ul><p>对于<code>File Trailer</code>我们不再做过多强调，全部忘记了的话可以到将数据页的那一章回顾一下。我们这里再强调一遍<code>File Header</code>的各个组成部分：</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td><code>4</code>字节</td><td>页的校验和（checksum值）</td></tr><tr><td><code>FIL_PAGE_OFFSET</code></td><td><code>4</code>字节</td><td>页号</td></tr><tr><td><code>FIL_PAGE_PREV</code></td><td><code>4</code>字节</td><td>上一个页的页号</td></tr><tr><td><code>FIL_PAGE_NEXT</code></td><td><code>4</code>字节</td><td>下一个页的页号</td></tr><tr><td><code>FIL_PAGE_LSN</code></td><td><code>8</code>字节</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td><code>FIL_PAGE_TYPE</code></td><td><code>2</code>字节</td><td>该页的类型</td></tr><tr><td><code>FIL_PAGE_FILE_FLUSH_LSN</code></td><td><code>8</code>字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td><code>4</code>字节</td><td>页属于哪个表空间</td></tr></tbody></table><p>现在除了名称里边儿带有<code>LSN</code>的两个字段大家可能看不懂以外，其他的字段肯定都是倍儿熟了，不过我们仍要强调这么几点：</p><ul><li>表空间中的每一个页都对应着一个页号，也就是<code>FIL_PAGE_OFFSET</code>，这个页号由4个字节组成，也就是32个比特位，所以一个表空间最多可以拥有2³²个页，**如果按照页的默认大小16KB来算，一个表空间最多支持64TB的数据。**表空间的第一个页的页号为0，之后的页号分别是1，2，3…依此类推</li><li>某些类型的页可以组成链表，链表中的页可以不按照物理顺序存储，而是根据<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>来存储上一个页和下一个页的页号。需要注意的是，这两个字段主要是为了<code>INDEX</code>类型的页，也就是我们之前一直说的数据页建立<code>B+</code>树后，为每层节点建立双向链表用的，一般类型的页是不使用这两个字段的。</li><li>每个页的类型由<code>FIL_PAGE_TYPE</code>表示，比如像数据页的该字段的值就是<code>0x45BF</code>，我们后边会介绍各种不同类型的页，不同类型的页在该字段上的值是不同的。</li></ul><h2 id="独立表空间结构">独立表空间结构</h2><p>我们知道<code>InnoDB</code>支持许多种类型的表空间，本章重点关注独立表空间和系统表空间的结构。它们的结构比较相似，但是由于系统表空间中额外包含了一些关于整个系统的信息，所以我们先挑简单一点的独立表空间来唠叨，稍后再说系统表空间的结构。</p><h3 id="区（extent）的概念">区（extent）的概念</h3><p>表空间中的页实在是太多了，为了更好的管理这些页面，设计<code>InnoDB</code>的大叔们提出了<code>区</code>（英文名：<code>extent</code>）的概念。**对于16KB的页来说，连续的64个页就是一个<code>区</code>，也就是说一个区默认占用1MB空间大小。**不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。画个图表示就是这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f33c4a1c3a~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cri1nutcorp5ghf5c7vqagt1j.png-71.4kB"><p>其中<code>extent 0</code> ~ <code>extent 255</code>这256个区算是第一个组，<code>extent 256</code> ~ <code>extent 511</code>这256个区算是第二个组，<code>extent 512</code> ~ <code>extent 767</code>这256个区算是第三个组（上图中并未画全第三个组全部的区，请自行脑补），依此类推可以划分更多的组。这些组的头几个页面的类型都是类似的，就像这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f33df9307a~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crjo0hl4q8u1dkdofe187b10fa9.png-105.2kB"><p>从上图中我们能得到如下信息：</p><ul><li><strong>第一个组最开始的3个页面的类型是固定的</strong>，也就是说<code>extent 0</code>这个区最开始的3个页面的类型是固定的，分别是：<ul><li><code>FSP_HDR</code>类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的<code>区</code>，也就是<code>extent 0</code> ~ <code>extent 255</code>这256个区的属性，稍后详细唠叨。需要注意的一点是，整个表空间只有一个<code>FSP_HDR</code>类型的页面。</li><li><code>IBUF_BITMAP</code>类型：这个类型的页面是存储本组所有的区的所有页面关于<code>INSERT BUFFER</code>的信息。当然，你现在不用知道啥是个<code>INSERT BUFFER</code>，后边会详细说到你吐。</li><li><code>INODE</code>类型：这个类型的页面存储了许多称为<code>INODE</code>的数据结构，还是那句话，现在你不需要知道啥是个<code>INODE</code>，后边儿会说到你吐。</li></ul></li><li><strong>其余各组最开始的2个页面的类型是固定的</strong>，也就是说<code>extent 256</code>、<code>extent 512</code>这些区最开始的2个页面的类型是固定的，分别是：<ul><li><code>XDES</code>类型：全称是<code>extent descriptor</code>，用来登记本组256个区的属性，也就是说对于在<code>extent 256</code>区中的该类型页面存储的就是<code>extent 256</code> ~ <code>extent 511</code>这些区的属性，对于在<code>extent 512</code>区中的该类型页面存储的就是<code>extent 512</code> ~ <code>extent 767</code>这些区的属性。上边介绍的<code>FSP_HDR</code>类型的页面其实和<code>XDES</code>类型的页面的作用类似，只不过<code>FSP_HDR</code>类型的页面还会额外存储一些表空间的属性。</li><li><code>IBUF_BITMAP</code>类型：上边介绍过了。</li></ul></li></ul><p>好了，宏观的结构介绍完了，里边儿的名词大家也不用记清楚，只要大致记得：表空间被划分为许多连续的<code>区</code>，每个区默认由64个页组成，每256个区划分为一组，每个组的最开始的几个页面类型是固定的就好了。</p><h3 id="段（segment）的概念">段（segment）的概念</h3><p>为啥好端端的提出一个<code>区</code>（<code>extent</code>）的概念呢？我们以前分析问题的套路都是这样的：表中的记录存储到页里边儿，然后页作为节点组成<code>B+</code>树，这个<code>B+</code>树就是索引，然后吧啦吧啦一堆聚簇索引和二级索引的区别。这套路也没啥不妥的呀～</p><p>是的，如果我们表中数据量很少的话，比如说你的表中只有几十条、几百条数据的话，的确用不到<code>区</code>的概念，因为简单的几个页就能把对应的数据存储起来，但是你架不住表里的记录越来越多呀。</p><p>？？啥？？表里的记录多了又怎样？<code>B+</code>树的每一层中的页都会形成一个双向链表呀，<code>File Header</code>中的<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>字段不就是为了形成双向链表设置的么？</p><p>是的是的，您说的都对，从理论上说，不引入<code>区</code>的概念只使用<code>页</code>的概念对存储引擎的运行并没啥影响，但是我们来考虑一下下边这个场景：</p><ul><li>我们每向表中**插入一条记录，本质上就是向该表的聚簇索引以及所有二级索引代表的<code>B+</code>树的节点中插入数据。**而<code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页</code>为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍<code>B+</code>树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O</code>是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</li></ul><p>所以，所以，所以才引入了<code>区</code>（<code>extent</code>）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照<code>区</code>为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个区），但是从性能角度看，可以消除很多的随机<code>I/O</code>，功大于过嘛！</p><p>事情到这里就结束了么？太天真了，我们提到的范围查询，其实是对<code>B+</code>树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以设计<code>InnoDB</code>的大叔们对<code>B+</code>树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的<code>区</code>，非叶子节点也有自己独有的<code>区</code>。<strong>存放叶子节点的区的集合就算是一个<code>段</code>（<code>segment</code>），存放非叶子节点的区的集合也算是一个<code>段</code>。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</strong></p><p>默认情况下<strong>一个使用<code>InnoDB</code>存储引擎的表只有一个聚簇索引，一个索引会生成2个段</strong>，而段是以区为单位申请存储空间的，一个区默认占用1M存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。设计<code>InnoDB</code>的大叔们都挺节俭的，当然也考虑到了这种情况。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。**现在为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，设计<code>InnoDB</code>的大叔们提出了一个碎片（fragment）区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。**碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。</li></ul><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。除了索引的叶子节点段和非叶子节点段之外，<code>InnoDB</code>中还有为存储一些特殊的数据而定义的段，比如回滚段，当然我们现在并不关心别的类型的段，现在只需要知道段是一些零散的页面以及一些完整的区的集合就好了。</p><h3 id="区的分类">区的分类</h3><p>通过上边一通唠叨，大家知道了表空间的是由若干个区组成的，这些区大体上可以分为4种类型：</p><ul><li>空闲的区：现在还没有用到这个区中的任何页面。</li><li>有剩余空间的碎片区：表示碎片区中还有可用的页面。</li><li>没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li>附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</li></ul><p>这4种类型的区也可以被称为区的4种状态（<code>State</code>），设计<code>InnoDB</code>的大叔们为这4种状态的区定义了特定的名词儿：</p><table><thead><tr><th>状态名</th><th>含义</th></tr></thead><tbody><tr><td><code>FREE</code></td><td>空闲的区</td></tr><tr><td><code>FREE_FRAG</code></td><td>有剩余空间的碎片区</td></tr><tr><td><code>FULL_FRAG</code></td><td>没有剩余空间的碎片区</td></tr><tr><td><code>FSEG</code></td><td>附属于某个段的区</td></tr></tbody></table><p>需要再次强调一遍的是，处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区都是独立的，算是直属于表空间；而处于<code>FSEG</code>状态的区是附属于某个段的。</p><blockquote><p>小贴士： 如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于<code>FSEG</code>的区全都隶属于某个段，而处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</p></blockquote><p>为了方便管理这些区，设计<code>InnoDB</code>的大叔设计了一个称为<code>XDES Entry</code>的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个<code>XDES Entry</code>结构，这个结构记录了对应的区的一些属性。我们先看图来对这个结构有个大致的了解：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f343654829~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crre79uq9971bsdj9s1i0j11en8a.png-96.2kB"><p>从图中我们可以看出，<code>XDES Entry</code>是一个40个字节的结构，大致分为4个部分，各个部分的释义如下：</p><ul><li><p><code>Segment ID</code>（8字节）</p><p>每一个段都有一个唯一的编号，用ID表示，此处的<code>Segment ID</code>字段表示就是该区所在的段。当然前提是该区已经被分配给某个段了，不然的话该字段的值没啥意义。</p></li><li><p><code>List Node</code>（12字节）</p><p>这个部分可以将若干个<code>XDES Entry</code>结构串联成一个链表，大家看一下这个<code>List Node</code>的结构：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f3444b1515~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crre8tlh1vmqtfipk663l173q97.png-69.1kB"><p>如果我们想定位表空间内的某一个位置的话，只需指定页号以及该位置在指定页号中的页内偏移量即可。所以：</p><ul><li><code>Pre Node Page Number</code>和<code>Pre Node Offset</code>的组合就是指向前一个<code>XDES Entry</code>的指针</li><li><code>Next Node Page Number</code>和<code>Next Node Offset</code>的组合就是指向后一个<code>XDES Entry</code>的指针。</li></ul><p>把一些<code>XDES Entry</code>结构连成一个链表有啥用？稍安勿躁，我们稍后唠叨<code>XDES Entry</code>结构组成的链表问题。</p></li><li><p><code>State</code>（4字节）</p><p>这个字段表明区的状态。可选的值就是我们前边说过的那4个，分别是：<code>FREE</code>、<code>FREE_FRAG</code>、<code>FULL_FRAG</code>和<code>FSEG</code>。具体释义就不多唠叨了，前边说的够仔细了。</p></li><li><p><code>Page State Bitmap</code>（16字节）</p><p>这个部分共占用16个字节，也就是128个比特位。我们说一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。比如<code>Page State Bitmap</code>部分的第1和第2个比特位对应着区中的第1个页面，第3和第4个比特位对应着区中的第2个页面，依此类推，<code>Page State Bitmap</code>部分的第127和128个比特位对应着区中的第64个页面。这两个比特位的第一个位表示对应的页是否是空闲的，第二个比特位还没有用。</p></li></ul><h4 id="XDES-Entry链表">XDES Entry链表</h4><p>到现在为止，我们已经提出了五花八门的概念，什么区、段、碎片区、附属于段的区、<code>XDES Entry</code>结构吧啦吧啦的概念，走远了千万别忘了自己为什么出发，我们把事情搞这么麻烦的初心仅仅是想**提高向表插入数据的效率又不至于数据量少的表浪费空间。**现在我们知道向表中插入数据本质上就是向表中各个索引的叶子节点段、非叶子节点段插入数据，也知道了不同的区有不同的状态，再回到最初的起点，捋一捋向某个段中插入数据的过程：</p><ul><li><p>当段中数据较少的时候，首先会查看表空间中是否有状态为<code>FREE_FRAG</code>的区，也就是找还有空闲空间的碎片区，如果找到了，那么从该区中取一些零散的页把数据插进去；否则到表空间下申请一个状态为<code>FREE</code>的区，也就是空闲的区，把该区的状态变为<code>FREE_FRAG</code>，然后从该新申请的区中取一些零散的页把数据插进去。之后不同的段使用零散页的时候都会从该区中取，直到该区中没有空闲空间，然后该区的状态就变成了<code>FULL_FRAG</code>。</p><p>现在的问题是你怎么知道表空间里的哪些区是<code>FREE</code>的，哪些区的状态是<code>FREE_FRAG</code>的，哪些区是<code>FULL_FRAG</code>的？要知道表空间的大小是可以不断增大的，当增长到GB级别的时候，区的数量也就上千了，我们总不能每次都遍历这些区对应的<code>XDES Entry</code>结构吧？这时候就是<code>XDES Entry</code>中的<code>List Node</code>部分发挥奇效的时候了，我们可以通过<code>List Node</code>中的指针，做这么三件事：</p><ul><li>把状态为<code>FREE</code>的区对应的<code>XDES Entry</code>结构通过<code>List Node</code>来连接成一个链表，这个链表我们就称之为<code>FREE</code>链表。</li><li>把状态为<code>FREE_FRAG</code>的区对应的<code>XDES Entry</code>结构通过<code>List Node</code>来连接成一个链表，这个链表我们就称之为<code>FREE_FRAG</code>链表。</li><li>把状态为<code>FULL_FRAG</code>的区对应的<code>XDES Entry</code>结构通过<code>List Node</code>来连接成一个链表，这个链表我们就称之为<code>FULL_FRAG</code>链表。</li></ul><p>这样每当我们想找一个<code>FREE_FRAG</code>状态的区时，就直接把<code>FREE_FRAG</code>链表的头节点拿出来，从这个节点中取一些零散的页来插入数据，当这个节点对应的区用完时，就修改一下这个节点的<code>State</code>字段的值，然后从<code>FREE_FRAG</code>链表中移到<code>FULL_FRAG</code>链表中。同理，如果<code>FREE_FRAG</code>链表中一个节点都没有，那么就直接从<code>FREE</code>链表中取一个节点移动到<code>FREE_FRAG</code>链表的状态，并修改该节点的<code>STATE</code>字段值为<code>FREE_FRAG</code>，然后从这个节点对应的区中获取零散的页就好了。</p></li><li><p>当段中数据已经占满了32个零散的页后，就直接申请完整的区来插入数据了。</p><p>还是那个问题，我们怎么知道哪些区属于哪个段的呢？再遍历各个<code>XDES Entry</code>结构？遍历是不可能遍历的，这辈子都不可能遍历的，有链表还遍历个毛线啊。所以我们把状态为<code>FSEG</code>的区对应的<code>XDES Entry</code>结构都加入到一个链表喽？傻呀，不同的段哪能共用一个区呢？你想把索引a的叶子节点段和索引b的叶子节点段都存储到一个区中么？显然我们想要每个段都有它独立的链表，所以可以根据段号（也就是<code>Segment ID</code>）来建立链表，有多少个段就建多少个链表？好像也有点问题，因为一个段中可以有好多个区，有的区是完全空闲的，有的区还有一些页面可以用，有的区已经没有空闲页面可以用了，所以我们有必要继续细分，设计<code>InnoDB</code>的大叔们为每个段中的区对应的<code>XDES Entry</code>结构建立了三个链表：</p><ul><li><code>FREE</code>链表：同一个段中，所有页面都是空闲的区对应的<code>XDES Entry</code>结构会被加入到这个链表。注意和直属于表空间的<code>FREE</code>链表区别开了，此处的<code>FREE</code>链表是附属于某个段的。</li><li><code>NOT_FULL</code>链表：同一个段中，仍有空闲空间的区对应的<code>XDES Entry</code>结构会被加入到这个链表。</li><li><code>FULL</code>链表：同一个段中，已经没有空闲空间的区对应的<code>XDES Entry</code>结构会被加入到这个链表。</li></ul><p>再次强调一遍，每一个索引都对应两个段，每个段都会维护上述的3个链表，比如下边这个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t (<br>    c1 <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    c2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    c3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (c1),<br>    KEY idx_c2 (c2)<br>)ENGINE<span class="hljs-operator">=</span>InnoDB;<br></code></pre></td></tr></table></figure><p>这个表<code>t</code>共有两个索引，一个聚簇索引，一个二级索引<code>idx_c2</code>，所以这个表共有4个段，每个段都会维护上述3个链表，总共是12个链表，加上我们上边说过的直属于表空间的3个链表，整个独立表空间共需要维护15个链表。所以段在数据量比较大时插入数据的话，会先获取<code>NOT_FULL</code>链表的头节点，直接把数据插入这个头节点对应的区中即可，如果该区的空间已经被用完，就把该节点移到<code>FULL</code>链表中。</p></li></ul><h4 id="链表基节点">链表基节点</h4><p>上边光是介绍了一堆链表，可我们怎么找到这些链表呢，或者说怎么找到某个链表的头节点或者尾节点在表空间中的位置呢？设计<code>InnoDB</code>的大叔当然考虑了这个问题，他们设计了一个叫<code>List Base Node</code>的结构，翻译成中文就是链表的基节点。这个结构中包含了链表的头节点和尾节点的指针以及这个链表中包含了多少节点的信息，我们画图看一下这个结构的示意图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f388927e1c~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crrehf6i1jsq1j5cubj1mdoh77a4.png-81.6kB"><p>我们上边介绍的每个链表都对应这么一个<code>List Base Node</code>结构，其中：</p><ul><li><code>List Length</code>表明该链表一共有多少节点，</li><li><code>First Node Page Number</code>和<code>First Node Offset</code>表明该链表的头节点在表空间中的位置。</li><li><code>Last Node Page Number</code>和<code>Last Node Offset</code>表明该链表的尾节点在表空间中的位置。</li></ul><p>一般我们把某个链表对应的<code>List Base Node</code>结构放置在表空间中固定的位置，这样想找定位某个链表就变得so easy啦。</p><h4 id="链表小结">链表小结</h4><p>综上所述，表空间是由若干个区组成的，每个区都对应一个<code>XDES Entry</code>的结构，直属于表空间的区对应的<code>XDES Entry</code>结构可以分成<code>FREE</code>、<code>FREE_FRAG</code>和<code>FULL_FRAG</code>这3个链表；每个段可以附属若干个区，每个段中的区对应的<code>XDES Entry</code>结构可以分成<code>FREE</code>、<code>NOT_FULL</code>和<code>FULL</code>这3个链表。每个链表都对应一个<code>List Base Node</code>的结构，这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。正是因为这些链表的存在，管理这些区才变成了一件so easy的事情。</p><h3 id="段的结构">段的结构</h3><p>我们前边说过，段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。像每个区都有对应的<code>XDES Entry</code>来记录这个区中的属性一样，设计<code>InnoDB</code>的大叔为每个段都定义了一个<code>INODE Entry</code>结构来记录一下段中的属性。大家看一下示意图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f4087c4a56~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crrju0cnji91a2fhv91ijb15hgb1.png-111.4kB"><p>它的各个部分释义如下：</p><ul><li><p><code>Segment ID</code></p><p>就是指这个<code>INODE Entry</code>结构对应的段的编号（ID）。</p></li><li><p><code>NOT_FULL_N_USED</code></p><p>这个字段指的是在<code>NOT_FULL</code>链表中已经使用了多少个页面。</p></li><li><p>3个<code>List Base Node</code></p><p>分别为段的<code>FREE</code>链表、<code>NOT_FULL</code>链表、<code>FULL</code>链表定义了<code>List Base Node</code>，这样我们想查找某个段的某个链表的头节点和尾节点的时候，就可以直接到这个部分找到对应链表的<code>List Base Node</code>。so easy!</p></li><li><p><code>Magic Number</code>：</p><p>这个值是用来标记这个<code>INODE Entry</code>是否已经被初始化了（初始化的意思就是把各个字段的值都填进去了）。如果这个数字是值的<code>97937874</code>，表明该<code>INODE Entry</code>已经初始化，否则没有被初始化。（不用纠结这个值有啥特殊含义，人家规定的）。</p></li><li><p><code>Fragment Array Entry</code></p><p>我们前边强调过无数次段是一些零散页面和一些完整的区的集合，每个<code>Fragment Array Entry</code>结构都对应着一个零散的页面，这个结构一共4个字节，表示一个零散页面的页号。</p></li></ul><p>结合着这个<code>INODE Entry</code>结构，大家可能对段是一些零散页面和一些完整的区的集合的理解再次深刻一些。</p><h3 id="各类型页面详细情况">各类型页面详细情况</h3><p>到现在为止我们已经大概清楚了表空间、段、区、XDES Entry、INODE Entry、各种以<code>XDES Entry</code>为节点的链表的基本概念了，可是总有一种飞在天上不踏实的感觉，每个区对应的<code>XDES Entry</code>结构到底存储在表空间的什么地方？直属于表空间的<code>FREE</code>、<code>FREE_FRAG</code>、<code>FULL_FRAG</code>链表的基节点到底存储在表空间的什么地方？每个段对应的<code>INODE Entry</code>结构到底存在表空间的什么地方？我们前边介绍了每256个连续的区算是一个组，想解决刚才提出来的这些个疑问还得从每个组开头的一些类型相同的页面说起，接下来我们一个页面一个页面的分析，真相马上就要浮出水面了。</p><h4 id="FSP-HDR类型">FSP_HDR类型</h4><p>首先看第一个组的第一个页面，当然也是表空间的第一个页面，页号为<code>0</code>。这个页面的类型是<code>FSP_HDR</code>，它存储了表空间的一些整体属性以及第一个组内256个区的对应的<code>XDES Entry</code>结构，直接看这个类型的页面的示意图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f4733af475~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crmfvigk938c8h1hahglr15329.png-146.8kB"><p>从图中可以看出，一个完整的<code>FSP_HDR</code>类型的页面大致由5个部分组成，各个部分的具体释义如下表：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td><code>File Header</code></td><td>文件头部</td><td><code>38</code>字节</td><td>页的一些通用信息</td></tr><tr><td><code>File Space Header</code></td><td>表空间头部</td><td><code>112</code>字节</td><td>表空间的一些整体属性信息</td></tr><tr><td><code>XDES Entry</code></td><td>区描述信息</td><td><code>10240</code>字节</td><td>存储本组256个区对应的属性信息</td></tr><tr><td><code>Empty Space</code></td><td>尚未使用空间</td><td><code>5986</code>字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td><code>File Trailer</code></td><td>文件尾部</td><td><code>8</code>字节</td><td>校验页是否完整</td></tr></tbody></table><p><code>File Header</code>和<code>File Trailer</code>就不再强调了，另外的几个部分中，<code>Empty Space</code>是尚未使用的空间，我们不用管它，重点来看看<code>File Space Header</code>和<code>XDES Entry</code>这两个部分。</p><h5 id="File-Space-Header部分">File Space Header部分</h5><p>从名字就可以看出来，这个部分是用来存储表空间的一些整体属性的，废话少说，看图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f47508ede5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1crrp2qp310rc10fd33ch716hcp.png-148.1kB"><p>哇唔，字段有点儿多哦，不急一个一个慢慢看。下面是各个属性的简单描述：</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>Space ID</code></td><td><code>4</code>字节</td><td>表空间的ID</td></tr><tr><td><code>Not Used</code></td><td><code>4</code>字节</td><td>这4个字节未被使用，可以忽略</td></tr><tr><td><code>Size</code></td><td><code>4</code>字节</td><td>当前表空间占有的页面数</td></tr><tr><td><code>FREE Limit</code></td><td><code>4</code>字节</td><td>尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表</td></tr><tr><td><code>Space Flags</code></td><td><code>4</code>字节</td><td>表空间的一些占用存储空间比较小的属性</td></tr><tr><td><code>FRAG_N_USED</code></td><td><code>4</code>字节</td><td>FREE_FRAG链表中已使用的页面数量</td></tr><tr><td><code>List Base Node for FREE List</code></td><td><code>16</code>字节</td><td>FREE链表的基节点</td></tr><tr><td><code>List Base Node for FREE_FRAG List</code></td><td><code>16</code>字节</td><td>FREE_FRAG链表的基节点</td></tr><tr><td><code>List Base Node for FULL_FRAG List</code></td><td><code>16</code>字节</td><td>FULL_FRAG链表的基节点</td></tr><tr><td><code>Next Unused Segment ID</code></td><td><code>8</code>字节</td><td>当前表空间中下一个未使用的 Segment ID</td></tr><tr><td><code>List Base Node for SEG_INODES_FULL List</code></td><td><code>16</code>字节</td><td>SEG_INODES_FULL链表的基节点</td></tr><tr><td><code>List Base Node for SEG_INODES_FREE List</code></td><td><code>16</code>字节</td><td>SEG_INODES_FREE链表的基节点</td></tr></tbody></table><p>这里头的<code>Space ID</code>、<code>Not Used</code>、<code>Size</code>这三个字段大家肯定一看就懂，其他的字段我们再详细瞅瞅，为了大家的阅读体验，我就不严格按照实际的字段顺序来解释各个字段了哈。</p><ul><li><p><code>List Base Node for FREE List</code>、<code>List Base Node for FREE_FRAG List</code>、<code>List Base Node for FULL_FRAG List</code>。</p><p>这三个大家看着太亲切了，分别是直属于表空间的<code>FREE</code>链表的基节点、<code>FREE_FRAG</code>链表的基节点、<code>FULL_FRAG</code>链表的基节点，这三个链表的基节点在表空间的位置是固定的，就是在表空间的第一个页面（也就是<code>FSP_HDR</code>类型的页面）的<code>File Space Header</code>部分。所以之后定位这几个链表就so easy啦。</p></li><li><p><code>FRAG_N_USED</code></p><p>这个字段表明在<code>FREE_FRAG</code>链表中已经使用的页面数量。</p></li><li><p><code>FREE Limit</code></p><p>我们知道表空间都对应着具体的磁盘文件，一开始我们创建表空间的时候对应的磁盘文件中都没有数据，所以我们需要对表空间完成一个初始化操作，包括为表空间中的区建立<code>XDES Entry</code>结构，为各个段建立<code>INODE Entry</code>结构，建立各种链表吧啦吧啦的各种操作。我们可以一开始就为表空间申请一个特别大的空间，但是实际上有绝大部分的区是空闲的，我们可以选择把所有的这些空闲区对应的<code>XDES Entry</code>结构加入<code>FREE</code>链表，也可以选择只把一部分的空闲区加入<code>FREE</code>链表，等啥时候空闲链表中的<code>XDES Entry</code>结构对应的区不够使了，再把之前没有加入<code>FREE</code>链表的空闲区对应的<code>XDES Entry</code>结构加入<code>FREE</code>链表，中心思想就是啥时候用到啥时候初始化，设计<code>InnoDB</code>的大叔采用的就是后者，他们为表空间定义了<code>FREE Limit</code>这个字段，在该字段表示的页号之前的区都被初始化了，之后的区尚未被初始化。</p></li><li><p><code>Next Unused Segment ID</code></p><p>表中每个索引都对应2个段，每个段都有一个唯一的ID，那当我们为某个表新创建一个索引的时候，就意味着要创建两个新的段。那怎么为这个新创建的段找一个唯一的ID呢？去遍历现在表空间中所有的段么？我们说过，遍历是不可能遍历的，这辈子都不可能遍历，所以设计<code>InnoDB</code>的大叔们提出了这个名叫<code>Next Unused Segment ID</code>的字段，该字段表明当前表空间中最大的段ID的下一个ID，这样在创建新段的时候赋予新段一个唯一的ID值就so easy啦，直接使用这个字段的值就好了。</p></li><li><p><code>Space Flags</code></p><p>表空间对于一些布尔类型的属性，或者只需要寥寥几个比特位搞定的属性都放在了这个<code>Space Flags</code>中存储，虽然它只有4个字节，32个比特位大小，却存储了好多表空间的属性，详细情况如下表：</p><table><thead><tr><th>标志名称</th><th>占用的空间（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td><code>POST_ANTELOPE</code></td><td>1</td><td>表示文件格式是否大于<code>ANTELOPE</code></td></tr><tr><td><code>ZIP_SSIZE</code></td><td>4</td><td>表示压缩页面的大小</td></tr><tr><td><code>ATOMIC_BLOBS</code></td><td>1</td><td>表示是否自动把值非常长的字段放到BLOB页里</td></tr><tr><td><code>PAGE_SSIZE</code></td><td>4</td><td>页面大小</td></tr><tr><td><code>DATA_DIR</code></td><td>1</td><td>表示表空间是否是从默认的数据目录中获取的</td></tr><tr><td><code>SHARED</code></td><td>1</td><td>是否为共享表空间</td></tr><tr><td><code>TEMPORARY</code></td><td>1</td><td>是否为临时表空间</td></tr><tr><td><code>ENCRYPTION</code></td><td>1</td><td>表空间是否加密</td></tr><tr><td><code>UNUSED</code></td><td>18</td><td>没有使用到的比特位</td></tr></tbody></table><blockquote><p>小贴士： 不同MySQL版本里 SPACE_FLAGS 代表的属性可能有些差异，我们这里列举的是5.7.21版本的。不过大家现在不必深究它们的意思，因为我们一旦把这些概念展开，就需要非常大的篇幅，主要怕大家受不了。我们还是先挑重要的看，把主要的表空间结构了解完，这些 SPACE_FLAGS 里的属性的细节就暂时不深究了。</p></blockquote></li><li><p><code>List Base Node for SEG_INODES_FULL List</code>和<code>List Base Node for SEG_INODES_FREE List</code></p><p>每个段对应的<code>INODE Entry</code>结构会集中存放到一个类型为<code>INODE</code>的页中，如果表空间中的段特别多，则会有多个<code>INODE Entry</code>结构，可能一个页放不下，这些<code>INODE</code>类型的页会组成两种列表：</p><ul><li><code>SEG_INODES_FULL</code>链表，该链表中的<code>INODE</code>类型的页面都已经被<code>INODE Entry</code>结构填充满了，没空闲空间存放额外的<code>INODE Entry</code>了。</li><li><code>SEG_INODES_FREE</code>链表，该链表中的<code>INODE</code>类型的页面仍有空闲空间来存放<code>INODE Entry</code>结构。</li></ul><p>由于我们现在还没有详细唠叨<code>INODE</code>类型页，所以等会说过<code>INODE</code>类型的页之后再回过头来看着两个链表。</p></li></ul><h5 id="XDES-Entry部分">XDES Entry部分</h5><p>紧接着<code>File Space Header</code>部分的就是<code>XDES Entry</code>部分了，我们嘴上唠叨过无数次，却从没见过真身的<code>XDES Entry</code>就是在表空间的第一个页面中保存的。我们知道一个<code>XDES Entry</code>结构的大小是40字节，但是一个页面的大小有限，只能存放有限个<code>XDES Entry</code>结构，所以我们才把256个区划分成一组，在每组的第一个页面中存放256个<code>XDES Entry</code>结构。大家回看那个<code>FSP_HDR</code>类型页面的示意图，<code>XDES Entry 0</code>就对应着<code>extent 0</code>，<code>XDES Entry 1</code>就对应着<code>extent 1</code>… 依此类推，<code>XDES Entry255</code>就对应着<code>extent 255</code>。</p><p>因为每个区对应的<code>XDES Entry</code>结构的地址是固定的，所以我们访问这些结构就so easy啦，至于该结构的详细使用情况我们已经唠叨的够明白了，在这就不赘述了。</p><h4 id="XDES类型">XDES类型</h4><p>我们说过，每一个<code>XDES Entry</code>结构对应表空间的一个区，虽然一个<code>XDES Entry</code>结构只占用40字节，但你抵不住表空间的区的数量也多啊。在区的数量非常多时，一个单独的页可能就不够存放足够多的<code>XDES Entry</code>结构，所以我们把表空间的区分为了若干个组，每组开头的一个页面记录着本组内所有的区对应的<code>XDES Entry</code>结构。由于第一个组的第一个页面有些特殊，因为它也是整个表空间的第一个页面，所以除了记录本组中的所有区对应的<code>XDES Entry</code>结构以外，还记录着表空间的一些整体属性，这个页面的类型就是我们刚刚说完的<code>FSP_HDR</code>类型，整个表空间里只有一个这个类型的页面。除去第一个分组以外，之后的每个分组的第一个页面只需要记录本组内所有的区对应的<code>XDES Entry</code>结构即可，不需要再记录表空间的属性了，为了和<code>FSP_HDR</code>类型做区别，我们把之后每个分组的第一个页面的类型定义为<code>XDES</code>，它的结构和<code>FSP_HDR</code>类型是非常相似的：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f475c0ec2a~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cs3vmoii1h971aje1iveack1l109.png-149.5kB"><p>与<code>FSP_HDR</code>类型的页面对比，除了少了<code>File Space Header</code>部分之外，也就是除了少了记录表空间整体属性的部分之外，其余的部分是一样一样的。由于我们上边唠叨的已经够仔细了，对于<code>XDES</code>类型的页面也就不重复唠叨了哈。</p><h4 id="IBUF-BITMAP类型">IBUF_BITMAP类型</h4><p>对比前边介绍表空间的图，每个分组的第二个页面的类型都是<code>IBUF_BITMAP</code>，这种类型的页里边记录了一些有关<code>Change Buffer</code>的东东，由于这个<code>Change Buffer</code>里又包含了贼多的概念，考虑到大家在一章中接受这么多新概念有点呼吸不适，怕大家心脏病犯了所以就把<code>Change Buffer</code>的相关知识放到后边的章节中，大家稍安勿躁哈。</p><h4 id="INODE类型">INODE类型</h4><p>再次对比前边介绍表空间的图，第一个分组的第三个页面的类型是<code>INODE</code>。我们前边说过设计<code>InnoDB</code>的大叔为每个索引定义了两个段，而且为某些特殊功能定义了些特殊的段。为了方便管理，他们又为每个段设计了一个<code>INODE Entry</code>结构，这个结构中记录了关于这个段的相关属性。而我们这会儿要介绍的这个<code>INODE</code>类型的页就是为了存储<code>INODE Entry</code>结构而存在的。好了，废话少说，直接看图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16ef3a8df380813e~tplv-t2oaga2asx-watermark.awebp" class="" title="img"><p>从图中可以看出，一个<code>INODE</code>类型的页面是由这几部分构成的：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td><code>File Header</code></td><td>文件头部</td><td><code>38</code>字节</td><td>页的一些通用信息</td></tr><tr><td><code>List Node for INODE Page List</code></td><td>通用链表节点</td><td><code>12</code>字节</td><td>存储上一个INODE页面和下一个INODE页面的指针</td></tr><tr><td><code>INODE Entry</code></td><td>段描述信息</td><td><code>16320</code>字节</td><td></td></tr><tr><td><code>Empty Space</code></td><td>尚未使用空间</td><td><code>6</code>字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td><code>File Trailer</code></td><td>文件尾部</td><td><code>8</code>字节</td><td>校验页是否完整</td></tr></tbody></table><p>除了<code>File Header</code>、<code>Empty Space</code>、<code>File Trailer</code>这几个老朋友外，我们重点关注<code>List Node for INODE Page List</code>和<code>INODE Entry</code>这两个部分。</p><p>首先看<code>INODE Entry</code>部分，我们前边已经详细介绍过这个结构的组成了，主要包括对应的段内零散页面的地址以及附属于该段的<code>FREE</code>、<code>NOT_FULL</code>和<code>FULL</code>链表的基节点。每个<code>INODE Entry</code>结构占用192字节，一个页面里可以存储<code>85</code>个这样的结构。</p><p>重点看一下<code>List Node for INODE Page List</code>这个玩意儿，因为一个表空间中可能存在超过85个段，所以可能一个<code>INODE</code>类型的页面不足以存储所有的段对应的<code>INODE Entry</code>结构，所以就需要额外的<code>INODE</code>类型的页面来存储这些结构。还是为了方便管理这些<code>INODE</code>类型的页面，设计<code>InnoDB</code>的大叔们将这些<code>INODE</code>类型的页面串联成两个不同的链表：</p><ul><li><code>SEG_INODES_FULL</code>链表：该链表中的<code>INODE</code>类型的页面中已经没有空闲空间来存储额外的<code>INODE Entry</code>结构了。</li><li><code>SEG_INODES_FREE</code>链表：该链表中的<code>INODE</code>类型的页面中还有空闲空间来存储额外的<code>INODE Entry</code>结构了。</li></ul><p>想必大家已经认出这两个链表了，我们前边提到过这两个链表的基节点就存储在<code>File Space Header</code>里边，也就是说这两个链表的基节点的位置是固定的，所以我们可以很轻松的访问到这两个链表。以后每当我们新创建一个段（创建索引时就会创建段）时，都会创建一个<code>INODE Entry</code>结构与之对应，存储<code>INODE Entry</code>的大致过程就是这样的：</p><ul><li>先看看<code>SEG_INODES_FREE</code>链表是否为空，如果不为空，直接从该链表中获取一个节点，也就相当于获取到一个仍有空闲空间的<code>INODE</code>类型的页面，然后把该<code>INODE Entry</code>结构放到该页面中。当该页面中无剩余空间时，就把该页放到<code>SEG_INODES_FULL</code>链表中。</li><li>如果<code>SEG_INODES_FREE</code>链表为空，则需要从表空间的<code>FREE_FRAG</code>链表中申请一个页面，修改该页面的类型为<code>INODE</code>，把该页面放到<code>SEG_INODES_FREE</code>链表中，与此同时把该<code>INODE Entry</code>结构放入该页面。</li></ul><h3 id="Segment-Header-结构的运用">Segment Header 结构的运用</h3><p>我们知道一个索引会产生两个段，分别是叶子节点段和非叶子节点段，而每个段都会对应一个<code>INODE Entry</code>结构，那我们怎么知道某个段对应哪个<code>INODE Entry</code>结构呢？所以得找个地方记下来这个对应关系。希望你还记得我们在唠叨数据页，也就是<code>INDEX</code>类型的页时有一个<code>Page Header</code>部分，当然我不能指望你记住，所以把<code>Page Header</code>部分再抄一遍给你看：</p><p><strong>Page Header部分</strong>（为突出重点，省略了好多属性）</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>…</td><td>…</td><td>…</td></tr><tr><td><code>PAGE_BTR_SEG_LEAF</code></td><td><code>10</code>字节</td><td>B+树叶子段的头部信息，仅在B+树的根页定义</td></tr><tr><td><code>PAGE_BTR_SEG_TOP</code></td><td><code>10</code>字节</td><td>B+树非叶子段的头部信息，仅在B+树的根页定义</td></tr></tbody></table><p>其中的<code>PAGE_BTR_SEG_LEAF</code>和<code>PAGE_BTR_SEG_TOP</code>都占用10个字节，它们其实对应一个叫<code>Segment Header</code>的结构，该结构图示如下：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f48c4472a3~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d6a74gu41fuqcqm1htri771d1k16.png-65.1kB"><p>各个部分的具体释义如下：</p><table><thead><tr><th>名称</th><th>占用字节数</th><th>描述</th></tr></thead><tbody><tr><td><code>Space ID of the INODE Entry</code></td><td><code>4</code></td><td>INODE Entry结构所在的表空间ID</td></tr><tr><td><code>Page Number of the INODE Entry</code></td><td><code>4</code></td><td>INODE Entry结构所在的页面页号</td></tr><tr><td><code>Byte Offset of the INODE Ent</code></td><td><code>2</code></td><td>INODE Entry结构在该页面中的偏移量</td></tr></tbody></table><p>这样子就很清晰了，<code>PAGE_BTR_SEG_LEAF</code>记录着叶子节点段对应的<code>INODE Entry</code>结构的地址是哪个表空间的哪个页面的哪个偏移量，<code>PAGE_BTR_SEG_TOP</code>记录着非叶子节点段对应的<code>INODE Entry</code>结构的地址是哪个表空间的哪个页面的哪个偏移量。这样子索引和其对应的段的关系就建立起来了。不过需要注意的一点是，因为一个索引只对应两个段，所以只需要在索引的根页面中记录这两个结构即可。</p><h3 id="真实表空间对应的文件大小">真实表空间对应的文件大小</h3><p>等会儿等会儿，上边的这些概念已经压的快喘不过气了。不过独立表空间有那么大么？我到数据目录里看了，一个新建的表对应的<code>.ibd</code>文件只占用了96K，才6个页面大小，上边的内容该不是扯犊子吧？</p><p>哈，一开始表空间占用的空间自然是很小，因为表里边都没有数据嘛！不过别忘了这些<code>.ibd</code>文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p><h2 id="系统表空间">系统表空间</h2><p>了解完了独立表空间的基本结构，系统表空间的结构也就好理解多了，系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，所以会比独立表空间多出一些记录这些信息的页面。因为这个系统表空间最牛逼，相当于是表空间之首，所以它的<code>表空间 ID</code>（Space ID）是<code>0</code>。</p><h3 id="系统表空间的整体结构">系统表空间的整体结构</h3><p>系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面，如图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f4911220d8~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1csbied27ohe1rgg32gquulplm.png-147.4kB"><p>可以看到，系统表空间和独立表空间的前三个页面（页号分别为<code>0</code>、<code>1</code>、<code>2</code>，类型分别是<code>FSP_HDR</code>、<code>IBUF_BITMAP</code>、<code>INODE</code>）的类型是一致的，只是页号为<code>3</code>～<code>7</code>的页面是系统表空间特有的，我们来看一下这些多出来的页面都是干啥使的：</p><table><thead><tr><th>页号</th><th>页面类型</th><th>英文描述</th><th>描述</th></tr></thead><tbody><tr><td><code>3</code></td><td><code>SYS</code></td><td>Insert Buffer Header</td><td>存储Insert Buffer的头部信息</td></tr><tr><td><code>4</code></td><td><code>INDEX</code></td><td>Insert Buffer Root</td><td>存储Insert Buffer的根页面</td></tr><tr><td><code>5</code></td><td><code>TRX_SYS</code></td><td>Transction System</td><td>事务系统的相关信息</td></tr><tr><td><code>6</code></td><td><code>SYS</code></td><td>First Rollback Segment</td><td>第一个回滚段的页面</td></tr><tr><td><code>7</code></td><td><code>SYS</code></td><td>Data Dictionary Header</td><td>数据字典头部信息</td></tr></tbody></table><p>除了这几个记录系统属性的页面之外，系统表空间的<code>extent 1</code>和<code>extent 2</code>这两个区，也就是页号从<code>64</code>~<code>191</code>这128个页面被称为<code>Doublewrite buffer</code>，也就是双写缓冲区。不过上述的大部分知识都涉及到了事务和多版本控制的问题，这些问题我们会放在后边的章节集中唠叨，现在讲述太影响用户体验，所以现在我们只唠叨一下有关InnoDB数据字典的知识，其余的概念在后边再看。</p><h4 id="InnoDB数据字典">InnoDB数据字典</h4><p>我们平时使用<code>INSERT</code>语句向表中插入的那些记录称之为用户数据，MySQL只是作为一个软件来为我们来保管这些数据，提供方便的增删改查接口而已。但是每当我们向一个表中插入一条记录的时候，MySQL先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的<code>B+</code>树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：</p><ul><li>某个表属于哪个表空间，表里边有多少列</li><li>表对应的每一个列的类型是什么</li><li>该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面</li><li>该表有哪些外键，外键对应哪个表的哪些列</li><li>某个表空间对应文件系统上文件路径是什么</li><li>balabala … 还有好多，不一一列举了</li></ul><p>上述这些数据并不是我们使用<code>INSERT</code>语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为<code>元数据</code>。InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些<code>元数据</code>：</p><table><thead><tr><th>表名</th><th>描述</th></tr></thead><tbody><tr><td><code>SYS_TABLES</code></td><td>整个InnoDB存储引擎中所有的表的信息</td></tr><tr><td><code>SYS_COLUMNS</code></td><td>整个InnoDB存储引擎中所有的列的信息</td></tr><tr><td><code>SYS_INDEXES</code></td><td>整个InnoDB存储引擎中所有的索引的信息</td></tr><tr><td><code>SYS_FIELDS</code></td><td>整个InnoDB存储引擎中所有的索引对应的列的信息</td></tr><tr><td><code>SYS_FOREIGN</code></td><td>整个InnoDB存储引擎中所有的外键的信息</td></tr><tr><td><code>SYS_FOREIGN_COLS</code></td><td>整个InnoDB存储引擎中所有的外键对应列的信息</td></tr><tr><td><code>SYS_TABLESPACES</code></td><td>整个InnoDB存储引擎中所有的表空间信息</td></tr><tr><td><code>SYS_DATAFILES</code></td><td>整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息</td></tr><tr><td><code>SYS_VIRTUAL</code></td><td>整个InnoDB存储引擎中所有的虚拟生成列的信息</td></tr></tbody></table><p>这些系统表也被称为<code>数据字典</code>，它们都是以<code>B+</code>树的形式保存在系统表空间的某些页面中，其中<code>SYS_TABLES</code>、<code>SYS_COLUMNS</code>、<code>SYS_INDEXES</code>、<code>SYS_FIELDS</code>这四个表尤其重要，称之为基本系统表（basic system tables），我们先看看这4个表的结构：</p><h5 id="SYS-TABLES表">SYS_TABLES表</h5><p><strong>SYS_TABLES表的列</strong></p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td><code>NAME</code></td><td>表的名称</td></tr><tr><td><code>ID</code></td><td>InnoDB存储引擎中每个表都有一个唯一的ID</td></tr><tr><td><code>N_COLS</code></td><td>该表拥有列的个数</td></tr><tr><td><code>TYPE</code></td><td>表的类型，记录了一些文件格式、行格式、压缩等信息</td></tr><tr><td><code>MIX_ID</code></td><td>已过时，忽略</td></tr><tr><td><code>MIX_LEN</code></td><td>表的一些额外的属性</td></tr><tr><td><code>CLUSTER_ID</code></td><td>未使用，忽略</td></tr><tr><td><code>SPACE</code></td><td>该表所属表空间的ID</td></tr></tbody></table><p>这个<code>SYS_TABLES</code>表有两个索引：</p><ul><li>以<code>NAME</code>列为主键的聚簇索引</li><li>以<code>ID</code>列建立的二级索引</li></ul><h5 id="SYS-COLUMNS表">SYS_COLUMNS表</h5><p><strong>SYS_COLUMNS表的列</strong></p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td><code>TABLE_ID</code></td><td>该列所属表对应的ID</td></tr><tr><td><code>POS</code></td><td>该列在表中是第几列</td></tr><tr><td><code>NAME</code></td><td>该列的名称</td></tr><tr><td><code>MTYPE</code></td><td>main data type，主数据类型，就是那堆INT、CHAR、VARCHAR、FLOAT、DOUBLE之类的东东</td></tr><tr><td><code>PRTYPE</code></td><td>precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许NULL值，是否允许负数啥的</td></tr><tr><td><code>LEN</code></td><td>该列最多占用存储空间的字节数</td></tr><tr><td><code>PREC</code></td><td>该列的精度，不过这列貌似都没有使用，默认值都是0</td></tr></tbody></table><p>这个<code>SYS_COLUMNS</code>表只有一个聚集索引：</p><ul><li>以<code>(TABLE_ID, POS)</code>列为主键的聚簇索引</li></ul><h5 id="SYS-INDEXES表">SYS_INDEXES表</h5><p><strong>SYS_INDEXES表的列</strong></p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td><code>TABLE_ID</code></td><td>该索引所属表对应的ID</td></tr><tr><td><code>ID</code></td><td>InnoDB存储引擎中每个索引都有一个唯一的ID</td></tr><tr><td><code>NAME</code></td><td>该索引的名称</td></tr><tr><td><code>N_FIELDS</code></td><td>该索引包含列的个数</td></tr><tr><td><code>TYPE</code></td><td>该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td></tr><tr><td><code>SPACE</code></td><td>该索引根页面所在的表空间ID</td></tr><tr><td><code>PAGE_NO</code></td><td>该索引根页面所在的页面号</td></tr><tr><td><code>MERGE_THRESHOLD</code></td><td>如果页面中的记录被删除到某个比例，就把该页面和相邻页面合并，这个值就是这个比例</td></tr></tbody></table><p>这个<code>SYS_INDEXES</code>表只有一个聚集索引：</p><ul><li>以<code>(TABLE_ID, ID)</code>列为主键的聚簇索引</li></ul><h5 id="SYS-FIELDS表">SYS_FIELDS表</h5><p><strong>SYS_FIELDS表的列</strong></p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td><code>INDEX_ID</code></td><td>该索引列所属的索引的ID</td></tr><tr><td><code>POS</code></td><td>该索引列在某个索引中是第几列</td></tr><tr><td><code>COL_NAME</code></td><td>该索引列的名称</td></tr></tbody></table><p>这个<code>SYS_FIELDS</code>表只有一个聚集索引：</p><ul><li>以<code>(INDEX_ID, POS)</code>列为主键的聚簇索引</li></ul><h5 id="Data-Dictionary-Header页面">Data Dictionary Header页面</h5><p>只要有了上述4个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。比方说我们想看看<code>SYS_TABLESPACES</code>这个系统表里存储了哪些表空间以及表空间对应的属性，那就可以：</p><ul><li>到<code>SYS_TABLES</code>表中根据表名定位到具体的记录，就可以获取到<code>SYS_TABLESPACES</code>表的<code>TABLE_ID</code></li><li>使用这个<code>TABLE_ID</code>到<code>SYS_COLUMNS</code>表中就可以获取到属于该表的所有列的信息。</li><li>使用这个<code>TABLE_ID</code>还可以到<code>SYS_INDEXES</code>表中获取所有的索引的信息，索引的信息中包括对应的<code>INDEX_ID</code>，还记录着该索引对应的<code>B+</code>数根页面是哪个表空间的哪个页面。</li><li>使用<code>INDEX_ID</code>就可以到<code>SYS_FIELDS</code>表中获取所有索引列的信息。</li></ul><p>也就是说这4个表是表中之表，那这4个表的元数据去哪里获取呢？没法搞了，只能把这4个表的元数据，就是它们有哪些列、哪些索引等信息硬编码到代码中，然后设计<code>InnoDB</code>的大叔又拿出一个固定的页面来记录这4个表的聚簇索引和二级索引对应的<code>B+树</code>位置，这个页面就是页号为<code>7</code>的页面，类型为<code>SYS</code>，记录了<code>Data Dictionary Header</code>，也就是数据字典的头部信息。除了这4个表的5个索引的根页面信息外，这个页号为<code>7</code>的页面还记录了整个InnoDB存储引擎的一些全局属性，说话太啰嗦，直接看这个页面的示意图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16efe1e5a01aeac9~tplv-t2oaga2asx-watermark.awebp" class="" title="img"><p>可以看到这个页面由下边几个部分组成：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td><code>File Header</code></td><td>文件头部</td><td><code>38</code>字节</td><td>页的一些通用信息</td></tr><tr><td><code>Data Dictionary Header</code></td><td>数据字典头部信息</td><td><code>56</code>字节</td><td>记录一些基本系统表的根页面位置以及InnoDB存储引擎的一些全局信息</td></tr><tr><td><code>Segment Header</code></td><td>段头部信息</td><td><code>10</code>字节</td><td>记录本页面所在段对应的INODE Entry位置信息</td></tr><tr><td><code>Empty Space</code></td><td>尚未使用空间</td><td><code>16272</code>字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td><code>File Trailer</code></td><td>文件尾部</td><td><code>8</code>字节</td><td>校验页是否完整</td></tr></tbody></table><p>可以看到这个页面里竟然有<code>Segment Header</code>部分，意味着设计InnoDB的大叔把这些有关数据字典的信息当成一个段来分配存储空间，我们就姑且称之为<code>数据字典段</code>吧。由于目前我们需要记录的数据字典信息非常少（可以看到<code>Data Dictionary Header</code>部分仅占用了56字节），所以该段只有一个碎片页，也就是页号为<code>7</code>的这个页。</p><p>接下来我们需要细细唠叨一下<code>Data Dictionary Header</code>部分的各个字段：</p><ul><li><code>Max Row ID</code>：我们说过如果我们不显式的为表定义主键，而且表中也没有<code>UNIQUE</code>索引，那么<code>InnoDB</code>存储引擎会默认为我们生成一个名为<code>row_id</code>的列作为主键。因为它是主键，所以每条记录的<code>row_id</code>列的值不能重复。原则上只要一个表中的<code>row_id</code>列不重复就可以了，也就是说表a和表b拥有一样的<code>row_id</code>列也没啥关系，不过设计InnoDB的大叔只提供了这个<code>Max Row ID</code>字段，不论哪个拥有<code>row_id</code>列的表插入一条记录时，该记录的<code>row_id</code>列的值就是<code>Max Row ID</code>对应的值，然后再把<code>Max Row ID</code>对应的值加1，也就是说这个<code>Max Row ID</code>是全局共享的。</li><li><code>Max Table ID</code>：InnoDB存储引擎中的所有的表都对应一个唯一的ID，每次新建一个表时，就会把本字段的值作为该表的ID，然后自增本字段的值。</li><li><code>Max Index ID</code>：InnoDB存储引擎中的所有的索引都对应一个唯一的ID，每次新建一个索引时，就会把本字段的值作为该索引的ID，然后自增本字段的值。</li><li><code>Max Space ID</code>：InnoDB存储引擎中的所有的表空间都对应一个唯一的ID，每次新建一个表空间时，就会把本字段的值作为该表空间的ID，然后自增本字段的值。</li><li><code>Mix ID Low(Unused)</code>：这个字段没啥用，跳过。</li><li><code>Root of SYS_TABLES clust index</code>：本字段代表<code>SYS_TABLES</code>表聚簇索引的根页面的页号。</li><li><code>Root of SYS_TABLE_IDS sec index</code>：本字段代表<code>SYS_TABLES</code>表为<code>ID</code>列建立的二级索引的根页面的页号。</li><li><code>Root of SYS_COLUMNS clust index</code>：本字段代表<code>SYS_COLUMNS</code>表聚簇索引的根页面的页号。</li><li><code>Root of SYS_INDEXES clust index</code>本字段代表<code>SYS_INDEXES</code>表聚簇索引的根页面的页号。</li><li><code>Root of SYS_FIELDS clust index</code>：本字段代表<code>SYS_FIELDS</code>表聚簇索引的根页面的页号。</li><li><code>Unused</code>：这4个字节没用，跳过。</li></ul><p>以上就是页号为<code>7</code>的页面的全部内容，初次看可能会懵逼（因为有点儿绕），大家多瞅几次。</p><h5 id="information-schema系统数据库">information_schema系统数据库</h5><p>需要注意一点的是，用户是不能直接访问<code>InnoDB</code>的这些内部系统表的，除非你直接去解析系统表空间对应文件系统上的文件。不过设计InnoDB的大叔考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库<code>information_schema</code>中提供了一些以<code>innodb_sys</code>开头的表：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; USE information_schema;<br>Database changed<br><br>mysql&gt; SHOW TABLES LIKE &#x27;innodb_sys%&#x27;;<br>+--------------------------------------------+<br>|<span class="hljs-string"> Tables_in_information_schema (innodb_sys%) </span>|<br>+--------------------------------------------+<br>|<span class="hljs-string"> INNODB_SYS_DATAFILES                       </span>|<br>|<span class="hljs-string"> INNODB_SYS_VIRTUAL                         </span>|<br>|<span class="hljs-string"> INNODB_SYS_INDEXES                         </span>|<br>|<span class="hljs-string"> INNODB_SYS_TABLES                          </span>|<br>|<span class="hljs-string"> INNODB_SYS_FIELDS                          </span>|<br>|<span class="hljs-string"> INNODB_SYS_TABLESPACES                     </span>|<br>|<span class="hljs-string"> INNODB_SYS_FOREIGN_COLS                    </span>|<br>|<span class="hljs-string"> INNODB_SYS_COLUMNS                         </span>|<br>|<span class="hljs-string"> INNODB_SYS_FOREIGN                         </span>|<br>|<span class="hljs-string"> INNODB_SYS_TABLESTATS                      </span>|<br>+--------------------------------------------+<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>在<code>information_schema</code>数据库中的这些以<code>INNODB_SYS</code>开头的表并不是真正的内部系统表（内部系统表就是我们上边唠叨的以<code>SYS</code>开头的那些表），而是在存储引擎启动时读取这些以<code>SYS</code>开头的系统表，然后填充到这些以<code>INNODB_SYS</code>开头的表中。以<code>INNODB_SYS</code>开头的表和以<code>SYS</code>开头的表中的字段并不完全一样，但供大家参考已经足矣。这些表太多了，我就不唠叨了，大家自个儿动手试着查一查这些表中的数据吧哈～</p><h3 id="总结图">总结图</h3><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a739f4a99c9a08~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d9ppsbelendcbb13hghhn18pe9.png-3564.2kB"><h1>10.单表访问方法</h1><p>对于我们这些<code>MySQL</code>的使用者来说，<code>MySQL</code>其实就是一个软件，平时用的最多的就是查询功能。DBA时不时丢过来一些慢查询语句让优化，我们如果连查询是怎么执行的都不清楚还优化个毛线，所以是时候掌握真正的技术了。我们在第一章的时候就曾说过，<code>MySQL Server</code>有一个称为<code>查询优化器</code>的模块，一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的<code>执行计划</code>，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。不过查询优化这个主题有点儿大，在学会跑之前还得先学会走，所以本章先来瞅瞅<code>MySQL</code>怎么执行单表查询（就是<code>FROM</code>子句后边只有一个表，最简单的那种查询～）。不过需要强调的一点是，在学习本章前务必看过前边关于记录结构、数据页结构以及索引的部分，如果你不能保证这些东西已经完全掌握，那么本章不适合你。</p><p>为了故事的顺利发展，我们先得有个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> single_table (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    key1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key2 <span class="hljs-type">INT</span>,<br>    key3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    common_field <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    KEY idx_key1 (key1),<br>    <span class="hljs-keyword">UNIQUE</span> KEY idx_key2 (key2),<br>    KEY idx_key3 (key3),<br>    KEY idx_key_part(key_part1, key_part2, key_part3)<br>) Engine<span class="hljs-operator">=</span>InnoDB CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p>我们为这个<code>single_table</code>表建立了1个聚簇索引和4个二级索引，分别是：</p><ul><li>为<code>id</code>列建立的聚簇索引。</li><li>为<code>key1</code>列建立的<code>idx_key1</code>二级索引。</li><li>为<code>key2</code>列建立的<code>idx_key2</code>二级索引，而且该索引是唯一二级索引。</li><li>为<code>key3</code>列建立的<code>idx_key3</code>二级索引。</li><li>为<code>key_part1</code>、<code>key_part2</code>、<code>key_part3</code>列建立的<code>idx_key_part</code>二级索引，这也是一个联合索引。</li></ul><p>然后我们需要为这个表插入10000行记录，除<code>id</code>列外其余的列都插入随机值就好了，具体的插入语句我就不写了，自己写个程序插入吧（id列是自增主键列，不需要我们手动插入）。</p><h2 id="访问方法（access-method）的概念">访问方法（access method）的概念</h2><p>想必各位都用过高德地图来查找到某个地方的路线吧（此处没有为高德地图打广告的意思，他们没给我钱，大家用百度地图也可以啊），如果我们搜西安钟楼到大雁塔之间的路线的话，地图软件会给出n种路线供我们选择，如果我们实在闲的没事儿干并且足够有钱的话，还可以用南辕北辙的方式绕地球一圈到达目的地。也就是说，不论采用哪一种方式，我们最终的目标就是到达大雁塔这个地方。回到<code>MySQL</code>中来，我们平时所写的那些查询语句本质上只是一种声明式的语法，只是告诉<code>MySQL</code>我们要获取的数据符合哪些规则，至于<code>MySQL</code>背地里是怎么把查询结果搞出来的那是<code>MySQL</code>自己的事儿。对于单个表的查询来说，设计MySQL的大叔把查询的执行方式大致分为下边两种：</p><ul><li><p>使用全表扫描进行查询</p><p>这种执行方式很好理解，就是把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。不管是啥查询都可以使用这种方式执行，当然，这种也是最笨的执行方式。</p></li><li><p>使用索引进行查询</p><p>因为直接使用全表扫描的方式执行查询要遍历好多记录，所以代价可能太大了。如果查询语句中的搜索条件可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。使用索引来执行查询的方式五花八门，又可以细分为许多种类：</p><ul><li>针对主键或唯一二级索引的等值查询</li><li>针对普通二级索引的等值查询</li><li>针对索引列的范围查询</li><li>直接扫描整个索引</li></ul></li></ul><p>设计<code>MySQL</code>的大叔把<code>MySQL</code>执行查询语句的方式称之为<code>访问方法</code>或者<code>访问类型</code>。同一个查询语句可能可以使用多种不同的访问方法来执行，虽然最后的查询结果都是一样的，但是执行的时间可能差老鼻子远了，就像是从钟楼到大雁塔，你可以坐火箭去，也可以坐飞机去，当然也可以坐乌龟去。下边细细道来各种<code>访问方法</code>的具体内容。</p><h2 id="const">const</h2><p>有的时候我们可以通过主键列来定位一条记录，比方说这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">1438</span>;<br></code></pre></td></tr></table></figure><p><code>MySQL</code>会直接利用主键值在聚簇索引中定位对应的用户记录，就像这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843dec61b4e~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctendl4319v659s1dfoj6lssl16.png-36.4kB"><p>原谅我把聚簇索引对应的复杂的<code>B+</code>树结构搞了一个极度精简版，为了突出重点，我们忽略掉了<code>页</code>的结构，直接把所有的叶子节点的记录都放在一起展示，而且记录中只展示我们关心的索引列，对于<code>single_table</code>表的聚簇索引来说，展示的就是<code>id</code>列。我们想突出的重点就是：<code>B+</code>树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的<code>B+</code>树叶子节点中的记录就是按照<code>id</code>列排序的。<code>B+</code>树本来就是一个矮矮的大胖子，所以这样根据主键值定位一条记录的速度贼快。类似的，我们根据唯一二级索引列来定位一条记录的速度也是贼快的，比如下边这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 = <span class="hljs-number">3841</span>;<br></code></pre></td></tr></table></figure><p>这个查询的执行过程的示意图就是这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843e05c8e33~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cthurrlpbhlotsjru1dsjrrl30.png-110.2kB"><p>可以看到这个查询的执行分两步，第一步先从<code>idx_key2</code>对应的<code>B+</code>树索引中根据<code>key2</code>列与常数的等值比较条件定位到一条二级索引记录，然后再根据该记录的<code>id</code>值到聚簇索引中获取到完整的用户记录。</p><p>设计<code>MySQL</code>的大叔认为通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像坐火箭一样快的，所以他们把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：**<code>const</code>，意思是常数级别的，代价是可以忽略不计的。**不过这种<code>const</code>访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个<code>const</code>访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。</p><p>对于唯一二级索引来说，查询该列为<code>NULL</code>值的情况比较特殊，比如这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用<code>const</code>访问方法来执行（至于是什么访问方法我们下边马上说）。</p><h2 id="ref">ref</h2><p>有时候我们对某个普通的二级索引列与常数进行等值比较，比如这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></td></tr></table></figure><p>对于这个查询，我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到对应记录的<code>id</code>值，然后再回表到聚簇索引中查找完整的用户记录。**由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。**如果匹配的记录较少，则回表的代价还是比较低的，所以<code>MySQL</code>可能选择使用索引而不是全表扫描的方式来执行查询。设计<code>MySQL</code>的大叔就把这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为：<code>ref</code>。我们看一下采用<code>ref</code>访问方法执行查询的图示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843e5e227f1~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctf14vso11cdclsmc6ac8pru9h.png-109.5kB"><p>从图示中可以看出，对于普通的二级索引来说，通过索引列进行等值比较后可能匹配到多条连续的记录，而不是像主键或者唯一二级索引那样最多只能匹配1条记录，所以这种<code>ref</code>访问方法比<code>const</code>差了那么一丢丢，但是在二级索引等值比较时匹配的记录数较少时的效率还是很高的（如果匹配的二级索引记录太多那么回表的成本就太大了），跟坐高铁差不多。不过需要注意下边两种情况：</p><ul><li><p>二级索引列值为<code>NULL</code>的情况</p><p>不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含<code>NULL</code>值的数量并不限制，所以我们采用<code>key IS NULL</code>这种形式的搜索条件最多只能使用<code>ref</code>的访问方法，而不是<code>const</code>的访问方法。</p></li><li><p>对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用<code>ref</code>的访问方法，比方说下边这几个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key_part1 = <span class="hljs-string">&#x27;god like&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key_part1 = <span class="hljs-string">&#x27;god like&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;legendary&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key_part1 = <span class="hljs-string">&#x27;god like&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;legendary&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;penta kill&#x27;</span>;<br></code></pre></td></tr></table></figure><p>但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为<code>ref</code>了，比方说这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key_part1 = <span class="hljs-string">&#x27;god like&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 &gt; <span class="hljs-string">&#x27;legendary&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="ref-or-null">ref_or_null</h2><p>有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为<code>NULL</code>的记录也找出来，就像下边这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">OR</span> key1 <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为<code>ref_or_null</code>，这个<code>ref_or_null</code>访问方法的执行过程如下：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843e8927bee~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctf21uu8113m1ajm1rcitgf5eeco.png-122.5kB"><p>可以看到，上边的查询相当于先分别从<code>idx_key1</code>索引对应的<code>B+</code>树中找出<code>key1 IS NULL</code>和<code>key1 = 'abc'</code>的两个连续的记录范围，然后根据这些二级索引记录中的<code>id</code>值再回表查找完整的用户记录。</p><h2 id="range">range</h2><p>我们之前介绍的几种访问方法都是在对索引列与某一个常数进行等值比较的时候才可能使用到（<code>ref_or_null</code>比较奇特，还计算了值为<code>NULL</code>的情况），但是有时候我们面对的搜索条件更复杂，比如下边这个查询：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table WHERE key<span class="hljs-number">2</span> IN (<span class="hljs-number">1438</span>, <span class="hljs-number">6328</span>) OR (key<span class="hljs-number">2</span> &gt;= <span class="hljs-number">38</span> AND key<span class="hljs-number">2</span> &lt;= <span class="hljs-number">79</span>);<br></code></pre></td></tr></table></figure><p>我们当然还可以使用全表扫描的方式来执行这个查询，不过也可以使用<code>二级索引 + 回表</code>的方式执行，如果采用<code>二级索引 + 回表</code>的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是索引列需要匹配某个或某些范围的值，在本查询中<code>key2</code>列的值只要匹配下列3个范围中的任何一个就算是匹配成功了：</p><ul><li><code>key2</code>的值是<code>1438</code></li><li><code>key2</code>的值是<code>6328</code></li><li><code>key2</code>的值在<code>38</code>和<code>79</code>之间。</li></ul><p>设计<code>MySQL</code>的大叔把这种利用索引进行范围匹配的访问方法称之为：<code>range</code>。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">小贴士：<br><br>此处所说的使用索引进行范围匹配中的 `索引` 可以是聚簇索引，也可以是二级索引。<br></code></pre></td></tr></table></figure><p>如果把这几个所谓的<code>key2</code>列的值需要满足的<code>范围</code>在数轴上体现出来的话，那应该是这个样子：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843e91231c9~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cth9mkf41li1dad1tnd6dm5139.png-9.2kB"><p>也就是从数学的角度看，每一个所谓的范围都是数轴上的一个<code>区间</code>，3个范围也就对应着3个区间：</p><ul><li>范围1：<code>key2 = 1438</code></li><li>范围2：<code>key2 = 6328</code></li><li>范围3：<code>key2 ∈ [38, 79]</code>，注意这里是闭区间。</li></ul><p>我们可以把那种索引列等值匹配的情况称之为<code>单点区间</code>，上边所说的<code>范围1</code>和<code>范围2</code>都可以被称为单点区间，像<code>范围3</code>这种的我们可以称为连续范围区间。</p><h2 id="index">index</h2><p>看下边这个查询：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> key_part<span class="hljs-number">1</span>, key_part<span class="hljs-number">2</span>, key_part<span class="hljs-number">3</span> FROM single_table WHERE key_part<span class="hljs-number">2</span> = &#x27;abc&#x27;;<br></code></pre></td></tr></table></figure><p>由于<code>key_part2</code>并不是联合索引<code>idx_key_part</code>最左索引列，所以我们无法使用<code>ref</code>或者<code>range</code>访问方法来执行这个语句。但是这个查询符合下边这两个条件：</p><ul><li>它的查询列表只有3个列：<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>，而索引<code>idx_key_part</code>又包含这三个列。</li><li>搜索条件中只有<code>key_part2</code>列。这个列也包含在索引<code>idx_key_part</code>中。</li></ul><p>也就是说我们可以直接通过遍历<code>idx_key_part</code>索引的叶子节点的记录来比较<code>key_part2 = 'abc'</code>这个条件是否成立，把匹配成功的二级索引记录的<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多，设计<code>MySQL</code>的大叔就把这种采用遍历二级索引记录的执行方式称之为：<code>index</code>。</p><h2 id="all">all</h2><p>最直接的查询执行方式就是我们已经提了无数遍的全表扫描，对于<code>InnoDB</code>表来说也就是直接扫描聚簇索引，设计<code>MySQL</code>的大叔把这种使用全表扫描执行查询的方式称之为：<code>all</code>。</p><h2 id="注意事项-2">注意事项</h2><h3 id="重温-二级索引-回表">重温 二级索引 + 回表</h3><p>一般情况下只能利用单个二级索引执行查询，比方说下边的这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">AND</span> key2 &gt; <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>查询优化器会识别到这个查询中的两个搜索条件：</p><ul><li><code>key1 = 'abc'</code></li><li><code>key2 &gt; 1000</code></li></ul><p>优化器一般会根据<code>single_table</code>表的统计数据来判断到底使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询（关于如何比较的细节我们后边的章节中会唠叨）。然后将从该二级索引中查询到的结果经过回表得到完整的用户记录后再根据其余的<code>WHERE</code>条件过滤记录。一般来说，等值查找比范围查找需要扫描的行数更少（也就是<code>ref</code>的访问方法一般比<code>range</code>好，但这也不总是一定的，也可能采用<code>ref</code>访问方法的那个索引列的值为特定值的行数特别多），所以这里假设优化器决定使用<code>idx_key1</code>索引进行查询，那么整个查询过程可以分为两个步骤：</p><ul><li>步骤1：使用二级索引定位记录的阶段，也就是根据条件<code>key1 = 'abc'</code>从<code>idx_key1</code>索引代表的<code>B+</code>树中找到对应的二级索引记录。</li><li>步骤2：回表阶段，也就是根据上一步骤中找到的记录的主键值进行<code>回表</code>操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件<code>key2 &gt; 1000</code>到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户。</li></ul><p>这里需要特别提醒大家的一点是，<strong>因为二级索引的节点中的记录只包含索引列和主键，所以在步骤1中使用<code>idx_key1</code>索引进行查询时只会用到与<code>key1</code>列有关的搜索条件，其余条件，比如<code>key2 &gt; 1000</code>这个条件在步骤1中是用不到的，只有在步骤2完成回表操作后才能继续针对完整的用户记录中继续过滤。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>需要注意的是，我们说一般情况下执行一个查询只会用到单个二级索引，不过还是有特殊情况的，我们后边会详细唠叨的。<br></code></pre></td></tr></table></figure><h3 id="明确range访问方法使用的范围区间">明确range访问方法使用的范围区间</h3><p>其实对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>区间</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引，具体原因我们在前边的章节中唠叨过了，这里就不赘述了。<br><br>IN操作符的效果和若干个等值匹配操作符`=`之间用`OR`连接起来是一样的，也就是说会产生多个单点区间，比如下边这两个语句的效果是一样的：<br><br>SELECT * FROM single_table WHERE key2 IN (1438, 6328);<br>    <br>SELECT * FROM single_table WHERE key2 = 1438 OR key2 = 6328;<br></code></pre></td></tr></table></figure><p>不过在日常的工作中，一个查询的<code>WHERE</code>子句可能有很多个小的搜索条件，这些搜索条件需要使用<code>AND</code>或者<code>OR</code>操作符连接起来，虽然大家都知道这两个操作符的作用，但我还是要再说一遍：</p><ul><li><code>cond1 AND cond2</code> ：只有当<code>cond1</code>和<code>cond2</code>都为<code>TRUE</code>时整个表达式才为<code>TRUE</code>。</li><li><code>cond1 OR cond2</code>：只要<code>cond1</code>或者<code>cond2</code>中有一个为<code>TRUE</code>整个表达式就为<code>TRUE</code>。</li></ul><p>当我们想使用<code>range</code>访问方法来执行一个查询语句时，重点就是找出该查询可用的索引以及这些索引对应的范围区间。下边分两种情况看一下怎么从由<code>AND</code>或<code>OR</code>组成的复杂搜索条件中提取出正确的范围区间。</p><h4 id="所有搜索条件都可以使用某个索引的情况">所有搜索条件都可以使用某个索引的情况</h4><p>有时候每个搜索条件都可以使用到某个索引，比如下边这个查询语句：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table WHERE key<span class="hljs-number">2</span> &gt; <span class="hljs-number">100</span> AND key<span class="hljs-number">2</span> &gt; <span class="hljs-number">200</span>;<br></code></pre></td></tr></table></figure><p>这个查询中的搜索条件都可以使用到<code>key2</code>，也就是说每个搜索条件都对应着一个<code>idx_key2</code>的范围区间。这两个小的搜索条件使用<code>AND</code>连接起来，也就是要取两个范围区间的交集，在我们使用<code>range</code>访问方法执行查询时，使用的<code>idx_key2</code>索引的范围区间的确定过程就如下图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b843e0fb74ac~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctia5p09rqss4413qq16gdbbj3q.png-44kB"><p><code>key2 &gt; 100</code>和<code>key2 &gt; 200</code>交集当然就是<code>key2 &gt; 200</code>了，也就是说上边这个查询使用<code>idx_key2</code>的范围区间就是<code>(200, +∞)</code>。这东西小学都学过吧，再不济初中肯定都学过。我们再看一下使用<code>OR</code>将多个搜索条件连接在一起的情况：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table WHERE key<span class="hljs-number">2</span> &gt; <span class="hljs-number">100</span> OR key<span class="hljs-number">2</span> &gt; <span class="hljs-number">200</span>;<br></code></pre></td></tr></table></figure><p><code>OR</code>意味着需要取各个范围区间的并集，所以上边这个查询在我们使用<code>range</code>访问方法执行查询时，使用的<code>idx_key2</code>索引的范围区间的确定过程就如下图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a7b8448ea4909c~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctia94i617ihr5ncku4ed1gg247.png-49.1kB"><p>也就是说上边这个查询使用<code>idx_key2</code>的范围区间就是<code>(100， +∞)</code>。</p><h4 id="有的搜索条件无法使用索引的情况">有的搜索条件无法使用索引的情况</h4><p>比如下边这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> common_field = <span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></td></tr></table></figure><p>请注意，这个查询语句中能利用的索引只有<code>idx_key2</code>一个，而<code>idx_key2</code>这个二级索引的记录中又不包含<code>common_field</code>这个字段，所以在使用二级索引<code>idx_key2</code>定位记录的阶段用不到<code>common_field = 'abc'</code>这个条件，这个条件是在回表获取了完整的用户记录后才使用的，而<code>范围区间</code>是为了到索引中取记录中提出的概念，所以在确定<code>范围区间</code>的时候不需要考虑<code>common_field = 'abc'</code>这个条件，我们在为某个索引确定范围区间的时候只需要把用不到相关索引的搜索条件替换为<code>TRUE</code>就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>之所以把用不到索引的搜索条件替换为TRUE，是因为我们不打算使用这些条件进行在该索引上进行过滤，所以不管索引的记录满不满足这些条件，我们都把它们选取出来，待到之后回表的时候再使用它们过滤。<br></code></pre></td></tr></table></figure><p>我们把上边的查询中用不到<code>idx_key2</code>的搜索条件替换后就是这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> <span class="hljs-literal">TRUE</span>;<br></code></pre></td></tr></table></figure><p>化简之后就是这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>也就是说最上边那个查询使用<code>idx_key2</code>的范围区间就是：<code>(100, +∞)</code>。</p><p>再来看一下使用<code>OR</code>的情况：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">OR</span> common_field = <span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></td></tr></table></figure><p>同理，我们把使用不到<code>idx_key2</code>索引的搜索条件替换为<code>TRUE</code>：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">OR</span> <span class="hljs-literal">TRUE</span>;<br></code></pre></td></tr></table></figure><p>接着化简：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> <span class="hljs-literal">TRUE</span>;<br></code></pre></td></tr></table></figure><p>额，这也就说说明如果我们强制使用<code>idx_key2</code>执行查询的话，对应的范围区间就是<code>(-∞, +∞)</code>，也就是需要将全部二级索引的记录进行回表，这个代价肯定比直接全表扫描都大了。也就是说一个使用到索引的搜索条件和没有使用该索引的搜索条件使用<code>OR</code>连接起来后是无法使用该索引的。</p><h4 id="复杂搜索条件下找出范围匹配的区间">复杂搜索条件下找出范围匹配的区间</h4><p>有的查询的搜索条件可能特别复杂，光是找出范围匹配的各个区间就挺烦的，比方说下边这个：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> <br>        (key1 &gt; <span class="hljs-string">&#x27;xyz&#x27;</span> <span class="hljs-keyword">AND</span> key2 = <span class="hljs-number">748</span> ) <span class="hljs-keyword">OR</span><br>        (key1 &lt; <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">AND</span> key1 &gt; <span class="hljs-string">&#x27;lmn&#x27;</span>) <span class="hljs-keyword">OR</span><br>        (key1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%suf&#x27;</span> <span class="hljs-keyword">AND</span> key1 &gt; <span class="hljs-string">&#x27;zzz&#x27;</span> <span class="hljs-keyword">AND</span> (key2 &lt; <span class="hljs-number">8000</span> <span class="hljs-keyword">OR</span> common_field = <span class="hljs-string">&#x27;abc&#x27;</span>)) ;<br></code></pre></td></tr></table></figure><p>我滴个神，这个搜索条件真是绝了，不过大家不要被复杂的表象迷住了双眼，按着下边这个套路分析一下：</p><ul><li><p>首先查看<code>WHERE</code>子句中的搜索条件都涉及到了哪些列，哪些列可能使用到索引。</p><p>这个查询的搜索条件涉及到了<code>key1</code>、<code>key2</code>、<code>common_field</code>这3个列，然后<code>key1</code>列有普通的二级索引<code>idx_key1</code>，<code>key2</code>列有唯一二级索引<code>idx_key2</code>。</p></li><li><p>对于那些可能用到的索引，分析它们的范围区间。</p><ul><li><p>假设我们使用<code>idx_key1</code>执行查询</p><ul><li><p>我们需要把那些用不到该索引的搜索条件暂时移除掉，移除方法也简单，直接把它们替换为<code>TRUE</code>就好了。上边的查询中除了有关<code>key2</code>和<code>common_field</code>列不能使用到<code>idx_key1</code>索引外，<code>key1 LIKE '%suf'</code>也使用不到索引，所以把这些搜索条件替换为<code>TRUE</code>之后的样子就是这样：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">(key1 &gt; <span class="hljs-symbol">&#x27;xyz</span>&#x27; <span class="hljs-keyword">AND</span> <span class="hljs-literal">TRUE</span> ) <span class="hljs-keyword">OR</span><br>(key1 &lt; <span class="hljs-symbol">&#x27;abc</span>&#x27; <span class="hljs-keyword">AND</span> key1 &gt; <span class="hljs-symbol">&#x27;lmn</span>&#x27;) <span class="hljs-keyword">OR</span><br>(<span class="hljs-literal">TRUE</span> <span class="hljs-keyword">AND</span> key1 &gt; <span class="hljs-symbol">&#x27;zzz</span>&#x27; <span class="hljs-keyword">AND</span> (<span class="hljs-literal">TRUE</span> <span class="hljs-keyword">OR</span> <span class="hljs-literal">TRUE</span>))<br></code></pre></td></tr></table></figure><p>化简一下上边的搜索条件就是下边这样：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">key1</span> &gt; &#x27;xyz&#x27;) OR<br>(<span class="hljs-name">key1</span> &lt; &#x27;abc&#x27; AND key1 &gt; &#x27;lmn&#x27;) OR<br>(<span class="hljs-name">key1</span> &gt; &#x27;zzz&#x27;)<br></code></pre></td></tr></table></figure></li><li><p>替换掉永远为<code>TRUE</code>或<code>FALSE</code>的条件</p><p>因为符合<code>key1 &lt; 'abc' AND key1 &gt; 'lmn'</code>永远为<code>FALSE</code>，所以上边的搜索条件可以被写成这样：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">key1</span> &gt; &#x27;xyz&#x27;) OR (<span class="hljs-name">key1</span> &gt; &#x27;zzz&#x27;)<br></code></pre></td></tr></table></figure></li><li><p>继续化简区间</p><p><code>key1 &gt; 'xyz'</code>和<code>key1 &gt; 'zzz'</code>之间使用<code>OR</code>操作符连接起来的，意味着要取并集，所以最终的结果化简的到的区间就是：<code>key1 &gt; xyz</code>。也就是说：上边那个有一坨搜索条件的查询语句如果使用 idx_key1 索引执行查询的话，需要把满足<code>key1 &gt; xyz</code>的二级索引记录都取出来，然后拿着这些记录的id再进行回表，得到完整的用户记录之后再使用其他的搜索条件进行过滤。</p></li></ul></li><li><p>假设我们使用<code>idx_key2</code>执行查询</p><ul><li><p>我们需要把那些用不到该索引的搜索条件暂时使用<code>TRUE</code>条件替换掉，其中有关<code>key1</code>和<code>common_field</code>的搜索条件都需要被替换掉，替换结果就是：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(TRUE <span class="hljs-keyword">AND </span>key2 = <span class="hljs-number">748</span> ) <span class="hljs-keyword">OR</span><br><span class="hljs-keyword"></span>(TRUE <span class="hljs-keyword">AND </span>TRUE) <span class="hljs-keyword">OR</span><br><span class="hljs-keyword"></span>(TRUE <span class="hljs-keyword">AND </span>TRUE <span class="hljs-keyword">AND </span>(key2 &lt; <span class="hljs-number">8000</span> <span class="hljs-keyword">OR </span>TRUE))<br></code></pre></td></tr></table></figure><p>哎呀呀，<code>key2 &lt; 8000 OR TRUE</code>的结果肯定是<code>TRUE</code>呀，也就是说化简之后的搜索条件成这样了：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">key2</span> = <span class="hljs-number">748</span> OR <span class="hljs-literal">TRUE</span><br></code></pre></td></tr></table></figure><p>这个化简之后的结果就更简单了：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-literal">TRUE</span><br></code></pre></td></tr></table></figure><p>这个结果也就意味着如果我们要使用<code>idx_key2</code>索引执行查询语句的话，需要扫描<code>idx_key2</code>二级索引的所有记录，然后再回表，这不是得不偿失么，所以这种情况下不会使用<code>idx_key2</code>索引的。</p></li></ul></li></ul></li></ul><h3 id="索引合并">索引合并</h3><p>我们前边说过<code>MySQL</code>在一般情况下执行一个查询时最多只会用到单个二级索引，但不是还有特殊情况么，在这些特殊情况下也可能在一个查询中使用到多个二级索引，设计<code>MySQL</code>的大叔把这种使用到多个索引来完成一次查询的执行方法称之为：<code>index merge</code>，具体的索引合并算法有下边三种。</p><h4 id="Intersection合并">Intersection合并</h4><p><code>Intersection</code>翻译过来的意思是<code>交集</code>。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下边这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key3 = <span class="hljs-string">&#x27;b&#x27;</span>;<br></code></pre></td></tr></table></figure><p>假设这个查询使用<code>Intersection</code>合并的方式执行的话，那这个过程就是这样的：</p><ul><li>从<code>idx_key1</code>二级索引对应的<code>B+</code>树中取出<code>key1 = 'a'</code>的相关记录。</li><li>从<code>idx_key3</code>二级索引对应的<code>B+</code>树中取出<code>key3 = 'b'</code>的相关记录。</li><li>二级索引的记录都是由<code>索引列 + 主键</code>构成的，所以我们可以计算出这两个结果集中<code>id</code>值的交集。</li><li>按照上一步生成的<code>id</code>值列表进行回表操作，也就是从聚簇索引中把指定<code>id</code>值的完整用户记录取出来，返回给用户。</li></ul><p>这里有同学会思考：为啥不直接使用<code>idx_key1</code>或者<code>idx_key3</code>只根据某个搜索条件去读取一个二级索引，然后回表后再过滤另外一个搜索条件呢？这里要分析一下两种查询执行方式之间需要的成本代价。</p><p>只读取一个二级索引的成本：</p><ul><li>按照某个搜索条件读取一个二级索引</li><li>根据从该二级索引得到的主键值进行回表操作，然后再过滤其他的搜索条件</li></ul><p>读取多个二级索引之后取交集成本：</p><ul><li>按照不同的搜索条件分别读取不同的二级索引</li><li>将从多个二级索引得到的主键值取交集，然后进行回表操作</li></ul><p>虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是<code>顺序I/O</code>，而回表操作是<code>随机I/O</code>，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为<code>回表</code>而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。</p><p><code>MySQL</code>在某些特定的情况下才可能会使用到<code>Intersection</code>索引合并：</p><ul><li><p>情况一：<strong>二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。</strong></p><p>比方说下边这个查询可能用到<code>idx_key1</code>和<code>idx_key_part</code>这两个二级索引进行<code>Intersection</code>索引合并的操作：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;c&#x27;</span>;<br></code></pre></td></tr></table></figure><p>而下边这两个查询就不能进行<code>Intersection</code>索引合并：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 &gt; <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;c&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure><p>第一个查询是因为对<code>key1</code>进行了范围匹配，第二个查询是因为联合索引<code>idx_key_part</code>中的<code>key_part2</code>和<code>key_part3</code>列并没有出现在搜索条件中，所以这两个查询不能进行<code>Intersection</code>索引合并。</p></li><li><p>情况二：<strong>主键列可以是范围匹配</strong></p><p>比方说下边这个查询可能用到主键和<code>idx_key1</code>进行<code>Intersection</code>索引合并的操作：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> id &gt; <span class="hljs-number">100</span> <span class="hljs-built_in">AND</span> key1 = <span class="hljs-comment">&#x27;a&#x27;;</span><br></code></pre></td></tr></table></figure></li></ul><p>为啥呢？凭啥呀？突然冒出这么两个规定让大家一脸懵逼，下边我们慢慢品一品这里头的玄机。这话还得从<code>InnoDB</code>的索引结构说起，你要是记不清麻烦再回头看看。对于<code>InnoDB</code>的二级索引来说，记录先是按照索引列进行排序，如果该二级索引是一个联合索引，那么会按照联合索引中的各个列依次排序。而二级索引的用户记录是由<code>索引列 + 主键</code>构成的，二级索引列的值相同的记录可能会有好多条，这些索引列的值相同的记录又是按照<code>主键</code>的值进行排序的。所以重点来了，之所以在二级索引列都是等值匹配的情况下才可能使用<code>Intersection</code>索引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。</p><p>so？还是没看懂根据二级索引查询出的结果集是按照主键值排序的对使用<code>Intersection</code>索引合并有啥好处？小伙子，别忘了<code>Intersection</code>索引合并会把从多个二级索引中查询出的主键值求交集，如果从各个二级索引中查询的到的结果集本身就是已经按照主键排好序的，那么求交集的过程就很easy啦。假设某个查询使用<code>Intersection</code>索引合并的方式从<code>idx_key1</code>和<code>idx_key2</code>这两个二级索引中获取到的主键值分别是：</p><ul><li>从<code>idx_key1</code>中获取到已经排好序的主键值：1、3、5</li><li>从<code>idx_key2</code>中获取到已经排好序的主键值：2、3、4</li></ul><p>那么求交集的过程就是这样：逐个取出这两个结果集中最小的主键值，如果两个值相等，则加入最后的交集结果中，否则丢弃当前较小的主键值，再取该丢弃的主键值所在结果集的后一个主键值来比较，直到某个结果集中的主键值用完了，如果还是觉得不太明白那继续往下看：</p><ul><li>先取出这两个结果集中较小的主键值做比较，因为<code>1 &lt; 2</code>，所以把<code>idx_key1</code>的结果集的主键值<code>1</code>丢弃，取出后边的<code>3</code>来比较。</li><li>因为<code>3 &gt; 2</code>，所以把<code>idx_key2</code>的结果集的主键值<code>2</code>丢弃，取出后边的<code>3</code>来比较。</li><li>因为<code>3 = 3</code>，所以把<code>3</code>加入到最后的交集结果中，继续两个结果集后边的主键值来比较。</li><li>后边的主键值也不相等，所以最后的交集结果中只包含主键值<code>3</code>。</li></ul><p>别看我们写的啰嗦，这个过程其实可快了，时间复杂度是<code>O(n)</code>，但是如果从各个二级索引中查询出的结果集并不是按照主键排序的话，那就要先把结果集中的主键值排序完再来做上边的那个过程，就比较耗时了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>按照有序的主键值去回表取记录有个专有名词儿，叫：Rowid Ordered Retrieval，简称ROR，以后大家在某些地方见到这个名词儿就眼熟了。<br></code></pre></td></tr></table></figure><p>另外，不仅是多个二级索引之间可以采用<code>Intersection</code>索引合并，索引合并也可以有聚簇索引参加，也就是我们上边写的<code>情况二</code>：在搜索条件中有主键的范围匹配的情况下也可以使用<code>Intersection</code>索引合并索引合并。为啥主键这就可以范围匹配了？还是得回到应用场景里，比如看下边这个查询：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-comment">&#x27;a&#x27; AND id &gt; 100;</span><br></code></pre></td></tr></table></figure><p>假设这个查询可以采用<code>Intersection</code>索引合并，我们理所当然的以为这个查询会分别按照<code>id &gt; 100</code>这个条件从聚簇索引中获取一些记录，在通过<code>key1 = 'a'</code>这个条件从<code>idx_key1</code>二级索引中获取一些记录，然后再求交集，其实这样就把问题复杂化了，没必要从聚簇索引中获取一次记录。别忘了二级索引的记录中都带有主键值的，所以可以在从<code>idx_key1</code>中获取到的主键值上直接运用条件<code>id &gt; 100</code>过滤就行了，这样多简单。所以涉及主键的搜索条件只不过是为了从别的二级索引得到的结果集中过滤记录罢了，是不是等值匹配不重要。</p><p>当然，上边说的<code>情况一</code>和<code>情况二</code>只是发生<code>Intersection</code>索引合并的必要条件，不是充分条件。也就是说即使情况一、情况二成立，也不一定发生<code>Intersection</code>索引合并，这得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过<code>Intersection</code>索引合并后需要回表的记录数大大减少时才会使用<code>Intersection</code>索引合并。</p><h4 id="Union合并">Union合并</h4><p>我们在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是<code>OR</code>关系。有时候<code>OR</code>关系的不同搜索条件会使用到不同的索引，比方说这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">OR</span> key3 = <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p><code>Intersection</code>是交集的意思，这适用于使用不同索引的搜索条件之间使用<code>AND</code>连接起来的情况；<code>Union</code>是并集的意思，适用于使用不同索引的搜索条件之间使用<code>OR</code>连接起来的情况。与<code>Intersection</code>索引合并类似，<code>MySQL</code>在某些特定的情况下才可能会使用到<code>Union</code>索引合并：</p><ul><li><p>情况一：<strong>二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。</strong></p><p>比方说下边这个查询可能用到<code>idx_key1</code>和<code>idx_key_part</code>这两个二级索引进行<code>Union</code>索引合并的操作：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">OR</span> ( key_part1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure><p>而下边这两个查询就不能进行<code>Union</code>索引合并：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 &gt; <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">OR</span> (key_part1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;c&#x27;</span>);<br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">OR</span> key_part1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure><p>第一个查询是因为对<code>key1</code>进行了范围匹配，第二个查询是因为联合索引<code>idx_key_part</code>中的<code>key_part2</code>和<code>key_part3</code>列并没有出现在搜索条件中，所以这两个查询不能进行<code>Union</code>索引合并。</p></li><li><p>情况二：<strong>主键列可以是范围匹配</strong></p></li><li><p>情况三：<strong>使用<code>Intersection</code>索引合并的搜索条件</strong></p><p>这种情况其实也挺好理解，就是搜索条件的某些部分使用<code>Intersection</code>索引合并的方式得到的主键集合和其他方式得到的主键集合取交集，比方说这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key_part1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key_part2 = <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">AND</span> key_part3 = <span class="hljs-string">&#x27;c&#x27;</span> <span class="hljs-keyword">OR</span> (key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key3 = <span class="hljs-string">&#x27;b&#x27;</span>);<br></code></pre></td></tr></table></figure><p>优化器可能采用这样的方式来执行这个查询：</p><ul><li>先按照搜索条件<code>key1 = 'a' AND key3 = 'b'</code>从索引<code>idx_key1</code>和<code>idx_key3</code>中使用<code>Intersection</code>索引合并的方式得到一个主键集合。</li><li>再按照搜索条件<code>key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c'</code>从联合索引<code>idx_key_part</code>中得到另一个主键集合。</li><li>采用<code>Union</code>索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户。</li></ul></li></ul><p>当然，查询条件符合了这些情况也不一定就会采用<code>Union</code>索引合并，也得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过<code>Union</code>索引合并后进行访问的代价比全表扫描更小时才会使用<code>Union</code>索引合并。</p><h4 id="Sort-Union合并">Sort-Union合并</h4><p><code>Union</code>索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下边这个查询就无法使用到<code>Union</code>索引合并：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 &lt; <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">OR</span> key3 &gt; <span class="hljs-string">&#x27;z&#x27;</span><br></code></pre></td></tr></table></figure><p>这是因为根据<code>key1 &lt; 'a'</code>从<code>idx_key1</code>索引中获取的二级索引记录的主键值不是排好序的，根据<code>key3 &gt; 'z'</code>从<code>idx_key3</code>索引中获取的二级索引记录的主键值也不是排好序的，但是<code>key1 &lt; 'a'</code>和<code>key3 &gt; 'z'</code>这两个条件又特别让我们动心，所以我们可以这样：</p><ul><li>先根据<code>key1 &lt; 'a'</code>条件从<code>idx_key1</code>二级索引中获取记录，并按照记录的主键值进行排序</li><li>再根据<code>key3 &gt; 'z'</code>条件从<code>idx_key3</code>二级索引中获取记录，并按照记录的主键值进行排序</li><li>因为上述的两个二级索引主键值都是排好序的，剩下的操作和<code>Union</code>索引合并方式就一样了。</li></ul><p>我们把上述这种先按照二级索引记录的主键值进行排序，之后按照<code>Union</code>索引合并方式执行的方式称之为<code>Sort-Union</code>索引合并，很显然，这种<code>Sort-Union</code>索引合并比单纯的<code>Union</code>索引合并多了一步对二级索引记录的主键值排序的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>为啥有Sort-Union索引合并，就没有Sort-Intersection索引合并么？是的，的确没有Sort-Intersection索引合并这么一说，<br><br>Sort-Union的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高<br><br>而Intersection索引合并的适用场景是单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，合并后可以明显降低回表开销，但是如果加入Sort-Intersection后，就需要为大量的二级索引记录按照主键值进行排序，这个成本可能比回表查询都高了，所以也就没有引入Sort-Intersection这个玩意儿。<br></code></pre></td></tr></table></figure><h4 id="索引合并注意事项">索引合并注意事项</h4><h4 id="联合索引替代Intersection索引合并">联合索引替代Intersection索引合并</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key3 = <span class="hljs-string">&#x27;b&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这个查询之所以可能使用<code>Intersection</code>索引合并的方式执行，还不是因为<code>idx_key1</code>和<code>idx_key3</code>是两个单独的<code>B+</code>树索引，你要是把这两个列搞一个联合索引，那直接使用这个联合索引就把事情搞定了，何必用啥索引合并呢，就像这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ALTER</span> TABLE single_table drop index idx_key<span class="hljs-number">1</span>, idx_key<span class="hljs-number">3</span>, add index idx_key<span class="hljs-number">1</span>_key<span class="hljs-number">3</span>(key<span class="hljs-number">1</span>, key<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>这样我们把没用的<code>idx_key1</code>、<code>idx_key3</code>都干掉，再添加一个联合索引<code>idx_key1_key3</code>，使用这个联合索引进行查询简直是又快又好，既不用多读一棵<code>B+</code>树，也不用合并结果，何乐而不为？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs !">小贴士：<br><br>不过小心有单独对key3列进行查询的业务场景，这样子不得不再把key3列的单独索引给加上。<br></code></pre></td></tr></table></figure><h1>11.连接的原理</h1><p>搞数据库一个避不开的概念就是<code>Join</code>，翻译成中文就是<code>连接</code>。相信很多小伙伴在初学连接的时候有些一脸懵逼，理解了连接的语义之后又可能不明白各个表中的记录到底是怎么连起来的，以至于在使用的时候常常陷入下边两种误区：</p><ul><li>误区一：业务至上，管他三七二十一，再复杂的查询也用在一个连接语句中搞定。</li><li>误区二：敬而远之，上次 DBA 那给报过来的慢查询就是因为使用了连接导致的，以后再也不敢用了。</li></ul><p>所以本章就来扒一扒连接的原理。考虑到一部分小伙伴可能忘了连接是个啥或者压根儿就不知道，为了节省他们百度或者看其他书的宝贵时间以及为了我的书凑字数，我们先来介绍一下 MySQL 中支持的一些连接语法。</p><h2 id="连接简介">连接简介</h2><h3 id="连接的本质">连接的本质</h3><p>为了故事的顺利发展，我们先建立两个简单的表并给它们填充一点数据：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; CREATE TABLE t<span class="hljs-number">1</span> (m<span class="hljs-number">1</span> int, n<span class="hljs-number">1</span> char(<span class="hljs-number">1</span>));<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">02</span> sec)<br><br><span class="hljs-attribute">mysql</span>&gt; CREATE TABLE t<span class="hljs-number">2</span> (m<span class="hljs-number">2</span> int, n<span class="hljs-number">2</span> char(<span class="hljs-number">1</span>));<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">02</span> sec)<br><br><span class="hljs-attribute">mysql</span>&gt; INSERT INTO t<span class="hljs-number">1</span> VALUES(<span class="hljs-number">1</span>, &#x27;a&#x27;), (<span class="hljs-number">2</span>, &#x27;b&#x27;), (<span class="hljs-number">3</span>, &#x27;c&#x27;);<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">3</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">3</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br><span class="hljs-attribute">mysql</span>&gt; INSERT INTO t<span class="hljs-number">2</span> VALUES(<span class="hljs-number">2</span>, &#x27;b&#x27;), (<span class="hljs-number">3</span>, &#x27;c&#x27;), (<span class="hljs-number">4</span>, &#x27;d&#x27;);<br><span class="hljs-attribute">Query</span> OK, <span class="hljs-number">3</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br><span class="hljs-attribute">Records</span>: <span class="hljs-number">3</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们成功建立了<code>t1</code>、<code>t2</code>两个表，这两个表都有两个列，一个是<code>INT</code>类型的，一个是<code>CHAR(1)</code>类型的，填充好数据的两个表长这样：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t1;</span><br><span class="hljs-section">+------+------+</span><br><span class="hljs-section">| m1   | n1   |</span><br><span class="hljs-section">+------+------+</span><br>|    1 | a    |<br>|    2 | b    |<br><span class="hljs-section">|    3 | c    |</span><br><span class="hljs-section">+------+------+</span><br>3 rows in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM t2;</span><br><span class="hljs-section">+------+------+</span><br><span class="hljs-section">| m2   | n2   |</span><br><span class="hljs-section">+------+------+</span><br>|    2 | b    |<br>|    3 | c    |<br><span class="hljs-section">|    4 | d    |</span><br><span class="hljs-section">+------+------+</span><br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><code>连接</code>的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把<code>t1</code>和<code>t2</code>两个表连接起来的过程如下图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3feccc29~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cql4ae7flug1itskat1ojgi7g3m.png-67.4kB"><p>这个过程看起来就是把<code>t1</code>表的记录和<code>t2</code>的记录连起来组成新的更大的记录，所以这个查询过程称之为连接查询。连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为<code>笛卡尔积</code>。因为表<code>t1</code>中有3条记录，表<code>t2</code>中也有3条记录，所以这两个表连接之后的笛卡尔积就有<code>3×3=9</code>行记录。在<code>MySQL</code>中，连接查询的语法也很随意，只要在<code>FROM</code>语句后边跟多个表名就好了，比如我们把<code>t1</code>表和<code>t2</code>表连接起来的查询语句可以写成这样：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SELECT <span class="hljs-symbol">*</span> FROM t1, t2;<br>+------+------+------+------+<br>|<span class="hljs-string"> m1   </span>|<span class="hljs-string"> n1   </span>|<span class="hljs-string"> m2   </span>|<span class="hljs-string"> n2   </span>|<br>+------+------+------+------+<br>|<span class="hljs-string">    1 </span>|<span class="hljs-string"> a    </span>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<br>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<br>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<br>|<span class="hljs-string">    1 </span>|<span class="hljs-string"> a    </span>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<br>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<br>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<br>|<span class="hljs-string">    1 </span>|<span class="hljs-string"> a    </span>|<span class="hljs-string">    4 </span>|<span class="hljs-string"> d    </span>|<br>|<span class="hljs-string">    2 </span>|<span class="hljs-string"> b    </span>|<span class="hljs-string">    4 </span>|<span class="hljs-string"> d    </span>|<br>|<span class="hljs-string">    3 </span>|<span class="hljs-string"> c    </span>|<span class="hljs-string">    4 </span>|<span class="hljs-string"> d    </span>|<br>+------+------+------+------+<br>9 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="连接过程简介">连接过程简介</h3><p>如果我们乐意，我们可以连接任意数量张表，但是如果没有任何限制条件的话，这些表连接起来产生的<code>笛卡尔积</code>可能是非常巨大的。比方说3个100行记录的表连接起来产生的<code>笛卡尔积</code>就有<code>100×100×100=1000000</code>行数据！所以在连接的时候过滤掉特定记录组合是有必要的，在连接查询中的过滤条件可以分成两种：</p><ul><li><p>涉及单表的条件</p><p>这种只涉及单表的过滤条件我们之前都提到过一万遍了，我们之前也一直称为<code>搜索条件</code>，比如<code>t1.m1 &gt; 1</code>是只针对<code>t1</code>表的过滤条件，<code>t2.n2 &lt; 'd'</code>是只针对<code>t2</code>表的过滤条件。</p></li><li><p>涉及两表的条件</p><p>这种过滤条件我们之前没见过，比如<code>t1.m1 = t2.m2</code>、<code>t1.n1 &gt; t2.n2</code>等，这些条件中涉及到了两个表，我们稍后会仔细分析这种过滤条件是如何使用的哈。</p></li></ul><p>下边我们就要看一下携带过滤条件的连接查询的大致执行过程了，比方说下边这个查询语句：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">1</span>, t<span class="hljs-number">2</span> WHERE t<span class="hljs-number">1</span>.m<span class="hljs-number">1</span> &gt; <span class="hljs-number">1</span> AND t<span class="hljs-number">1</span>.m<span class="hljs-number">1</span> = t<span class="hljs-number">2</span>.m<span class="hljs-number">2</span> AND t<span class="hljs-number">2</span>.n<span class="hljs-number">2</span> &lt; &#x27;d&#x27;;<br></code></pre></td></tr></table></figure><p>在这个查询中我们指明了这三个过滤条件：</p><ul><li><code>t1.m1 &gt; 1</code></li><li><code>t1.m1 = t2.m2</code></li><li><code>t2.n2 &lt; 'd'</code></li></ul><p>那么这个连接查询的大致执行过程如下：</p><ol><li><p>首先确定第一个需要查询的表，这个表称之为<code>驱动表</code>。怎样在单表中执行查询语句我们在前一章都唠叨过了，只需要选取代价最小的那种访问方法去执行单表查询语句就好了（就是说从const、ref、ref_or_null、range、index、all这些执行方法中选取代价最小的去执行查询）。此处假设使用<code>t1</code>作为驱动表，那么就需要到<code>t1</code>表中找满足<code>t1.m1 &gt; 1</code>的记录，因为表中的数据太少，我们也没在表上建立二级索引，所以此处查询<code>t1</code>表的访问方法就设定为<code>all</code>吧，也就是采用全表扫描的方式执行单表查询。关于如何提升连接查询的性能我们之后再说，现在先把基本概念捋清楚哈。所以查询过程就如下图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3dfab5ed~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctpnftbge08uf1ek61qor1fh14g.png-23.9kB"><p>我们可以看到，<code>t1</code>表中符合<code>t1.m1 &gt; 1</code>的记录有两条。</p></li><li><p>针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到<code>t2</code>表中查找匹配的记录，所谓<code>匹配的记录</code>，指的是符合过滤条件的记录。因为是根据<code>t1</code>表中的记录去找<code>t2</code>表中的记录，所以<code>t2</code>表也可以被称之为<code>被驱动表</code>。上一步骤从驱动表中得到了2条记录，所以需要查询2次<code>t2</code>表。此时涉及两个表的列的过滤条件<code>t1.m1 = t2.m2</code>就派上用场了：</p><ul><li>当<code>t1.m1 = 2</code>时，过滤条件<code>t1.m1 = t2.m2</code>就相当于<code>t2.m2 = 2</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 2</code>、<code>t2.n2 &lt; 'd'</code>这两个过滤条件，然后到<code>t2</code>表中执行单表查询。</li><li>当<code>t1.m1 = 3</code>时，过滤条件<code>t1.m1 = t2.m2</code>就相当于<code>t2.m2 = 3</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 3</code>、<code>t2.n2 &lt; 'd'</code>这两个过滤条件，然后到<code>t2</code>表中执行单表查询。</li></ul><p>所以整个连接查询的执行过程就如下图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3a02660b~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctrsprar1bbh17lee79le63ls2m.png-49.6kB"><p>也就是说整个连接查询最后的结果只有两条符合过滤条件的记录：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+------+</span>------<span class="hljs-code">+------+</span>------+<br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br>|    2 | b    |    2 | b    |<br><span class="hljs-section">|    3 | c    |    3 | c    |</span><br><span class="hljs-section">+------+------+------+------+</span><br></code></pre></td></tr></table></figure></li></ol><p>从上边两个步骤可以看出来，我们上边唠叨的这个两表连接查询共需要查询1次<code>t1</code>表，2次<code>t2</code>表。当然这是在特定的过滤条件下的结果，如果我们把<code>t1.m1 &gt; 1</code>这个条件去掉，那么从<code>t1</code>表中查出的记录就有3条，就需要查询3次<code>t2</code>表了。也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</p><h3 id="内连接和外连接">内连接和外连接</h3><p>为了大家更好理解后边内容，我们先创建两个有现实意义的表，</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student (<br>    number <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;学号&#x27;</span>,<br>    <span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    major <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;专业&#x27;</span>,<br>    <span class="hljs-keyword">PRIMARY KEY</span> (number)<br>) Engine=InnoDB CHARSET=utf8 <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;学生信息表&#x27;</span>;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> score (<br>    number <span class="hljs-type">INT</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;学号&#x27;</span>,<br>    subject <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;科目&#x27;</span>,<br>    score TINYINT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;成绩&#x27;</span>,<br>    <span class="hljs-keyword">PRIMARY KEY</span> (number, subject)<br>) Engine=InnoDB CHARSET=utf8 <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;学生成绩表&#x27;</span>;<br></code></pre></td></tr></table></figure><p>我们新建了一个学生信息表，一个学生成绩表，然后我们向上述两个表中插入一些数据，为节省篇幅，具体插入过程就不唠叨了，插入后两表中的数据如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM student;</span><br><span class="hljs-section">+----------+-----------+--------------------------+</span><br><span class="hljs-section">| number   | name      | major                    |</span><br><span class="hljs-section">+----------+-----------+--------------------------+</span><br>| 20180101 | 杜子腾    | 软件学院                 |<br>| 20180102 | 范统      | 计算机科学与工程         |<br><span class="hljs-section">| 20180103 | 史珍香    | 计算机科学与工程         |</span><br><span class="hljs-section">+----------+-----------+--------------------------+</span><br>3 rows in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM score;</span><br><span class="hljs-section">+----------+-----------------------------+-------+</span><br><span class="hljs-section">| number   | subject                     | score |</span><br><span class="hljs-section">+----------+-----------------------------+-------+</span><br>| 20180101 | 母猪的产后护理              |    78 |<br>| 20180101 | 论萨达姆的战争准备          |    88 |<br>| 20180102 | 论萨达姆的战争准备          |    98 |<br><span class="hljs-section">| 20180102 | 母猪的产后护理              |   100 |</span><br><span class="hljs-section">+----------+-----------------------------+-------+</span><br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>现在我们想把每个学生的考试成绩都查询出来就需要进表连接了（因为<code>score</code>中没有姓名信息，所以不能单纯只查询<code>score</code>表）。连接过程就是从<code>student</code>表中取出记录，在<code>score</code>表中查找<code>number</code>相同的成绩记录，所以过滤条件就是<code>student.number = socre.number</code>，整个查询语句就是这样：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SELECT <span class="hljs-symbol">*</span> FROM student, score WHERE student.number = score.number;<br>+----------+-----------+--------------------------+----------+-----------------------------+-------+<br>|<span class="hljs-string"> number   </span>|<span class="hljs-string"> name      </span>|<span class="hljs-string"> major                    </span>|<span class="hljs-string"> number   </span>|<span class="hljs-string"> subject                     </span>|<span class="hljs-string"> score </span>|<br>+----------+-----------+--------------------------+----------+-----------------------------+-------+<br>|<span class="hljs-string"> 20180101 </span>|<span class="hljs-string"> 杜子腾    </span>|<span class="hljs-string"> 软件学院                 </span>|<span class="hljs-string"> 20180101 </span>|<span class="hljs-string"> 母猪的产后护理              </span>|<span class="hljs-string">    78 </span>|<br>|<span class="hljs-string"> 20180101 </span>|<span class="hljs-string"> 杜子腾    </span>|<span class="hljs-string"> 软件学院                 </span>|<span class="hljs-string"> 20180101 </span>|<span class="hljs-string"> 论萨达姆的战争准备          </span>|<span class="hljs-string">    88 </span>|<br>|<span class="hljs-string"> 20180102 </span>|<span class="hljs-string"> 范统      </span>|<span class="hljs-string"> 计算机科学与工程         </span>|<span class="hljs-string"> 20180102 </span>|<span class="hljs-string"> 论萨达姆的战争准备          </span>|<span class="hljs-string">    98 </span>|<br>|<span class="hljs-string"> 20180102 </span>|<span class="hljs-string"> 范统      </span>|<span class="hljs-string"> 计算机科学与工程         </span>|<span class="hljs-string"> 20180102 </span>|<span class="hljs-string"> 母猪的产后护理              </span>|<span class="hljs-string">   100 </span>|<br>+----------+-----------+--------------------------+----------+-----------------------------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>字段有点多哦，我们少查询几个字段：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1, score AS s2 WHERE s1.number = s2.number;</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br><span class="hljs-section">| number   | name      | subject                     | score |</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br>| 20180101 | 杜子腾    | 母猪的产后护理              |    78 |<br>| 20180101 | 杜子腾    | 论萨达姆的战争准备          |    88 |<br>| 20180102 | 范统      | 论萨达姆的战争准备          |    98 |<br><span class="hljs-section">| 20180102 | 范统      | 母猪的产后护理              |   100 |</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>从上述查询结果中我们可以看到，各个同学对应的各科成绩就都被查出来了，可是有个问题，<code>史珍香</code>同学，也就是学号为<code>20180103</code>的同学因为某些原因没有参加考试，所以在<code>score</code>表中没有对应的成绩记录。那如果老师想查看所有同学的考试成绩，即使是缺考的同学也应该展示出来，但是到目前为止我们介绍的<code>连接查询</code>是无法完成这样的需求的。我们稍微思考一下这个需求，其本质是想：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。为了解决这个问题，就有了<code>内连接</code>和<code>外连接</code>的概念：</p><blockquote><p>外连接解决的问题是：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。</p></blockquote><ul><li><p>对于<code>内连接</code>的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的<code>内连接</code>。</p></li><li><p>对于<code>外连接</code>的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。</p><p>在<code>MySQL</code>中，根据选取驱动表的不同，外连接仍然可以细分为2种：</p><ul><li><p>左外连接</p><p>选取左侧的表为驱动表。</p></li><li><p>右外连接</p><p>选取右侧的表为驱动表。</p></li></ul></li></ul><p>可是这样仍然存在问题，即使对于外连接来说，有时候我们也并不想把驱动表的全部记录都加入到最后的结果集。这就犯难了，有时候匹配失败要加入结果集，有时候又不要加入结果集，这咋办，有点儿愁啊。。。噫，把过滤条件分为两种不就解决了这个问题了么，所以放在不同地方的过滤条件是有不同语义的：</p><ul><li><p><code>WHERE</code>子句中的过滤条件</p><p><code>WHERE</code>子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合<code>WHERE</code>子句中的过滤条件的记录都不会被加入最后的结果集。</p></li><li><p><code>ON</code>子句中的过滤条件</p><p>对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配<code>ON</code>子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用<code>NULL</code>值填充。</p><p>需要注意的是，这个<code>ON</code>子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把<code>ON</code>子句放到内连接中，<code>MySQL</code>会把它和<code>WHERE</code>子句一样对待，也就是说：内连接中的WHERE子句和ON子句是等价的。</p></li></ul><p>一般情况下，我们都把只涉及单表的过滤条件放到<code>WHERE</code>子句中，把涉及两表的过滤条件都放到<code>ON</code>子句中，我们也一般把放到<code>ON</code>子句中的过滤条件也称之为<code>连接条件</code>。</p><blockquote><p>小贴士： 左外连接和右外连接简称左连接和右连接，所以下边提到的左外连接和右外连接中的<code>外</code>字都用括号扩起来，以表示这个字儿可有可无。</p></blockquote><h4 id="左（外）连接的语法">左（外）连接的语法</h4><p>左（外）连接的语法还是挺简单的，比如我们要把<code>t1</code>表和<code>t2</code>表进行左外连接查询可以这么写：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> t2 <span class="hljs-keyword">ON</span> 连接条件 [<span class="hljs-keyword">WHERE</span> 普通过滤条件];<br></code></pre></td></tr></table></figure><p>其中中括号里的<code>OUTER</code>单词是可以省略的。对于<code>LEFT JOIN</code>类型的连接来说，我们把放在左边的表称之为外表或者驱动表，右边的表称之为内表或者被驱动表。所以上述例子中<code>t1</code>就是外表或者驱动表，<code>t2</code>就是内表或者被驱动表。需要注意的是，对于左（外）连接和右（外）连接来说，必须使用<code>ON</code>子句来指出连接条件。了解了左（外）连接的基本语法之后，再次回到我们上边那个现实问题中来，看看怎样写查询语句才能把所有的学生的成绩信息都查询出来，即使是缺考的考生也应该被放到结果集中：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1 LEFT JOIN score AS s2 ON s1.number = s2.number;</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br><span class="hljs-section">| number   | name      | subject                     | score |</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br>| 20180101 | 杜子腾    | 母猪的产后护理              |    78 |<br>| 20180101 | 杜子腾    | 论萨达姆的战争准备          |    88 |<br>| 20180102 | 范统      | 论萨达姆的战争准备          |    98 |<br>| 20180102 | 范统      | 母猪的产后护理              |   100 |<br><span class="hljs-section">| 20180103 | 史珍香    | NULL                        |  NULL |</span><br><span class="hljs-section">+----------+-----------+-----------------------------+-------+</span><br>5 rows in set (0.04 sec)<br></code></pre></td></tr></table></figure><p>从结果集中可以看出来，虽然<code>史珍香</code>并没有对应的成绩记录，但是由于采用的是连接类型为左（外）连接，所以仍然把她放到了结果集中，只不过在对应的成绩记录的各列使用<code>NULL</code>值填充而已。</p><h4 id="右（外）连接的语法">右（外）连接的语法</h4><p>右（外）连接和左（外）连接的原理是一样一样的，语法也只是把<code>LEFT</code>换成<code>RIGHT</code>而已：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> t2 <span class="hljs-keyword">ON</span> 连接条件 [<span class="hljs-keyword">WHERE</span> 普通过滤条件];<br></code></pre></td></tr></table></figure><p>只不过驱动表是右边的表，被驱动表是左边的表，具体就不唠叨了。</p><h4 id="内连接的语法">内连接的语法</h4><p>内连接和外连接的根本区别就是在驱动表中的记录不符合<code>ON</code>子句中的连接条件时不会把该记录加入到最后的结果集，我们最开始唠叨的那些连接查询的类型都是内连接。不过之前仅仅提到了一种最简单的内连接语法，就是直接把需要连接的多个表都放到<code>FROM</code>子句后边。其实针对内连接，MySQL提供了好多不同的语法，我们以<code>t1</code>和<code>t2</code>表为例瞅瞅：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 [<span class="hljs-keyword">INNER</span> | <span class="hljs-keyword">CROSS</span>] <span class="hljs-keyword">JOIN</span> t2 [<span class="hljs-keyword">ON</span> 连接条件] [<span class="hljs-keyword">WHERE</span> 普通过滤条件];<br></code></pre></td></tr></table></figure><p>也就是说在<code>MySQL</code>中，下边这几种内连接的写法都是等价的：</p><ul><li>SELECT * FROM t1 JOIN t2;</li><li>SELECT * FROM t1 INNER JOIN t2;</li><li>SELECT * FROM t1 CROSS JOIN t2;</li></ul><p>上边的这些写法和直接把需要连接的表名放到<code>FROM</code>语句之后，用逗号<code>,</code>分隔开的写法是等价的：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">1</span>, t<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>现在我们虽然介绍了很多种<code>内连接</code>的书写方式，不过熟悉一种就好了，这里我们推荐<code>INNER JOIN</code>的形式书写内连接（因为<code>INNER JOIN</code>语义很明确嘛，可以和<code>LEFT JOIN</code>和<code>RIGHT JOIN</code>很轻松的区分开）。这里需要注意的是，由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句。</p><p>我们前边说过，连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。不论哪个表作为驱动表，两表连接产生的笛卡尔积肯定是一样的。而对于内连接来说，由于凡是不符合<code>ON</code>子句或<code>WHERE</code>子句中的条件的记录都会被过滤掉，其实也就相当于从两表连接的笛卡尔积中把不符合过滤条件的记录给踢出去，所以对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果。但是对于外连接来说，由于驱动表中的记录即使在被驱动表中找不到符合ON子句条件的记录时也要将其加入到结果集，所以此时驱动表和被驱动表的关系就很重要了，也就是说左外连接和右外连接的驱动表和被驱动表不能轻易互换。</p><h4 id="小结">小结</h4><p>上边说了很多，给大家的感觉不是很直观，我们直接把表<code>t1</code>和<code>t2</code>的三种连接方式写在一起，这样大家理解起来就很easy了：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br>|    2 | b    |    2 | b    |<br><span class="hljs-section">|    3 | c    |    3 | c    |</span><br><span class="hljs-section">+------+------+------+------+</span><br>2 rows in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br>|    2 | b    |    2 | b    |<br>|    3 | c    |    3 | c    |<br><span class="hljs-section">|    1 | a    | NULL | NULL |</span><br><span class="hljs-section">+------+------+------+------+</span><br>3 rows in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM t1 RIGHT JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br>|    2 | b    |    2 | b    |<br>|    3 | c    |    3 | c    |<br><span class="hljs-section">| NULL | NULL |    4 | d    |</span><br><span class="hljs-section">+------+------+------+------+</span><br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="连接的原理">连接的原理</h2><p>上边贼啰嗦的介绍都只是为了唤醒大家对<code>连接</code>、<code>内连接</code>、<code>外连接</code>这些概念的记忆，这些基本概念是为了真正进入本章主题做的铺垫。真正的重点是MySQL采用了什么样的算法来进行表与表之间的连接，了解了这个之后，大家才能明白为啥有的连接查询运行的快如闪电，有的却慢如蜗牛。</p><h3 id="嵌套循环连接（Nested-Loop-Join）">嵌套循环连接（Nested-Loop Join）</h3><p>我们前边说过，对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数。对于内连接来说，选取哪个表为驱动表都没关系，而外连接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表。我们上边已经大致介绍过<code>t1</code>表和<code>t2</code>表执行内连接查询的大致过程，我们温习一下：</p><ul><li>步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。</li><li>步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。</li></ul><p>通用的两表连接过程如下图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3fa0f107~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctsr5ui2cdk1jduqafm7p1d3426.png-129.4kB"><p>如果有3个表进行连接的话，那么<code>步骤2</code>中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上边过程，也就是<code>步骤2</code>中得到的结果集中的每一条记录都需要到<code>t3</code>表中找一找有没有匹配的记录，用伪代码表示一下这个过程就是这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> t1 &#123;   #此处表示遍历满足对t1单表查询结果集中的每一条记录<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> t2 &#123;   #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录<br>    <br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> t3 &#123;   #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">row</span> satisfies <span class="hljs-keyword">join</span> conditions, send <span class="hljs-keyword">to</span> client<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为<code>嵌套循环连接</code>（<code>Nested-Loop Join</code>），这是最简单，也是最笨拙的一种连接查询算法。</p><h3 id="使用索引加快连接速度">使用索引加快连接速度</h3><p>我们知道在<code>嵌套循环连接</code>的<code>步骤2</code>中可能需要访问多次被驱动表，如果访问被驱动表的方式都是全表扫描的话，妈呀，那得要扫描好多次呀～～～ 但是别忘了，查询<code>t2</code>表其实就相当于一次单表扫描，我们可以利用索引来加快查询速度哦。回顾一下最开始介绍的<code>t1</code>表和<code>t2</code>表进行内连接的例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">1</span>, t<span class="hljs-number">2</span> WHERE t<span class="hljs-number">1</span>.m<span class="hljs-number">1</span> &gt; <span class="hljs-number">1</span> AND t<span class="hljs-number">1</span>.m<span class="hljs-number">1</span> = t<span class="hljs-number">2</span>.m<span class="hljs-number">2</span> AND t<span class="hljs-number">2</span>.n<span class="hljs-number">2</span> &lt; &#x27;d&#x27;;<br></code></pre></td></tr></table></figure><p>我们使用的其实是<code>嵌套循环连接</code>算法执行的连接查询，再把上边那个查询执行过程表拉下来给大家看一下：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3a02660b~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctrsprar1bbh17lee79le63ls2m.png-49.6kB"><p>查询驱动表<code>t1</code>后的结果集中有两条记录，<code>嵌套循环连接</code>算法需要对被驱动表查询2次：</p><ul><li><p>当<code>t1.m1 = 2</code>时，去查询一遍<code>t2</code>表，对<code>t2</code>表的查询语句相当于：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">2</span> WHERE t<span class="hljs-number">2</span>.m<span class="hljs-number">2</span> = <span class="hljs-number">2</span> AND t<span class="hljs-number">2</span>.n<span class="hljs-number">2</span> &lt; &#x27;d&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>当<code>t1.m1 = 3</code>时，再去查询一遍<code>t2</code>表，此时对<code>t2</code>表的查询语句相当于：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">2</span> WHERE t<span class="hljs-number">2</span>.m<span class="hljs-number">2</span> = <span class="hljs-number">3</span> AND t<span class="hljs-number">2</span>.n<span class="hljs-number">2</span> &lt; &#x27;d&#x27;;<br></code></pre></td></tr></table></figure></li></ul><p>可以看到，原来的<code>t1.m1 = t2.m2</code>这个涉及两个表的过滤条件在针对<code>t2</code>表做查询时关于<code>t1</code>表的条件就已经确定了，所以我们只需要单单优化对<code>t2</code>表的查询了，上述两个对<code>t2</code>表的查询语句中利用到的列是<code>m2</code>和<code>n2</code>列，我们可以：</p><ul><li><p>在<code>m2</code>列上建立索引，因为对<code>m2</code>列的条件是等值查找，比如<code>t2.m2 = 2</code>、<code>t2.m2 = 3</code>等，所以可能使用到<code>ref</code>的访问方法，假设使用<code>ref</code>的访问方法去执行对<code>t2</code>表的查询的话，需要回表之后再判断<code>t2.n2 &lt; d</code>这个条件是否成立。</p><p>这里有一个比较特殊的情况，就是假设<code>m2</code>列是<code>t2</code>表的主键或者唯一二级索引列，那么使用<code>t2.m2 = 常数值</code>这样的条件从<code>t2</code>表中查找记录的过程的代价就是常数级别的。我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为<code>const</code>，而设计<code>MySQL</code>的大叔把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为：<code>eq_ref</code>。</p></li><li><p>在<code>n2</code>列上建立索引，涉及到的条件是<code>t2.n2 &lt; 'd'</code>，可能用到<code>range</code>的访问方法，假设使用<code>range</code>的访问方法对<code>t2</code>表的查询的话，需要回表之后再判断在<code>m2</code>列上的条件是否成立。</p></li></ul><p>假设<code>m2</code>和<code>n2</code>列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对<code>t2</code>表的查询。当然，建立了索引不一定使用索引，只有在<code>二级索引 + 回表</code>的代价比全表扫描的代价更低时才会使用索引。</p><p>另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部分，这种情况下即使不能使用<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>或者<code>range</code>这些访问方法执行对被驱动表的查询的话，也可以使用索引扫描，也就是<code>index</code>的访问方法来查询被驱动表。所以我们建议在真实工作中最好不要使用<code>*</code>作为查询列表，最好把真实用到的列作为查询列表。</p><h3 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）">基于块的嵌套循环连接（Block Nested-Loop Join）</h3><p>**扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。**现实生活中的表可不像<code>t1</code>、<code>t2</code>这种只有3条记录，成千上万条记录都是少的，几百万、几千万甚至几亿条记录的表到处都是。内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前边记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前边的记录从内存中释放掉。我们前边又说过，采用<code>嵌套循环连接</code>算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个<code>I/O</code>代价就非常大了，所以我们得想办法：<strong>尽量减少访问被驱动表的次数</strong>。</p><p>当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。所以我们可不可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。所以设计<code>MySQL</code>的大叔提出了一个<code>join buffer</code>的概念，<code>join buffer</code>就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个<code>join buffer</code>中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和<code>join buffer</code>中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的<code>I/O</code>代价。使用<code>join buffer</code>的过程如下图所示：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e43ab3e5fa2f6~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1ctuhe3t71ahd10gn19917fo1nft4g.png-57.7kB"><p>最好的情况是<code>join buffer</code>足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。设计<code>MySQL</code>的大叔把这种加入了<code>join buffer</code>的嵌套循环连接算法称之为<code>基于块的嵌套连接</code>（Block Nested-Loop Join）算法。</p><p>这个<code>join buffer</code>的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为<code>262144字节</code>（也就是<code>256KB</code>），最小可以设置为<code>128字节</code>。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大<code>join_buffer_size</code>的值来对连接查询进行优化。</p><p>另外需要注意的是，驱动表的记录并不是所有列都会被放到<code>join buffer</code>中，只有查询列表中的列和过滤条件中的列才会被放到<code>join buffer</code>中，所以再次提醒我们，最好不要把<code>*</code>作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在<code>join buffer</code>中放置更多的记录呢哈。</p><h1>12.基于成本的优化</h1><h2 id="什么是成本">什么是成本</h2><p>我们之前老说<code>MySQL</code>执行一个查询可以有不同的执行方案，它会选择其中成本最低，或者说代价最低的那种方案去真正的执行查询。不过我们之前对<code>成本</code>的描述是非常模糊的，其实在<code>MySQL</code>中一条查询语句的执行成本是由下边这两个方面组成的：</p><ul><li><p><code>I/O</code>成本</p><p>我们的表经常使用的<code>MyISAM</code>、<code>InnoDB</code>存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为<code>I/O</code>成本。</p></li><li><p><code>CPU</code>成本</p><p>读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为<code>CPU</code>成本。</p></li></ul><p>对于<code>InnoDB</code>存储引擎来说，页是磁盘和内存之间交互的基本单位，设计<code>MySQL</code>的大叔规定读取一个页面花费的成本默认是<code>1.0</code>，读取以及检测一条记录是否符合搜索条件的成本默认是<code>0.2</code>。<code>1.0</code>、<code>0.2</code>这些数字称之为<code>成本常数</code>，这两个成本常数我们最常用到，其余的成本常数我们后边再说哈。</p><blockquote><p>小贴士： 需要注意的是，不管读取记录时需不需要检测是否满足搜索条件，其成本都算是0.2。</p></blockquote><h2 id="单表查询的成本">单表查询的成本</h2><h3 id="准备工作-2">准备工作</h3><p>为了故事的顺利发展，我们还得把之前用到的<code>single_table</code>表搬来，怕大家忘了这个表长啥样，再给大家抄一遍：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> single_table (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    key1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key2 <span class="hljs-type">INT</span>,<br>    key3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    common_field <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    KEY idx_key1 (key1),<br>    <span class="hljs-keyword">UNIQUE</span> KEY idx_key2 (key2),<br>    KEY idx_key3 (key3),<br>    KEY idx_key_part(key_part1, key_part2, key_part3)<br>) Engine<span class="hljs-operator">=</span>InnoDB CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p>还是假设这个表里边儿有10000条记录，除<code>id</code>列外其余的列都插入随机值。下边正式开始我们的表演。</p><h3 id="基于成本的优化步骤">基于成本的优化步骤</h3><p>在一条单表查询语句真正执行之前，<code>MySQL</code>的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的<code>执行计划</code>，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：</p><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那一个</li></ol><p>下边我们就以一个实例来分析一下这些步骤，单表查询语句如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> <br>    key1 <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-keyword">AND</span> <br>    key2 &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">AND</span> key2 &lt; <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span> <br>    key3 &gt; key2 <span class="hljs-keyword">AND</span> <br>    key_part1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%hello%&#x27;</span> <span class="hljs-keyword">AND</span><br>    common_field = <span class="hljs-string">&#x27;123&#x27;</span>;<br></code></pre></td></tr></table></figure><p>乍看上去有点儿复杂哦，我们一步一步分析一下。</p><h4 id="1-根据搜索条件，找出所有可能使用的索引">1. 根据搜索条件，找出所有可能使用的索引</h4><p>我们前边说过，对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>范围区间</code>（<code>LIKE</code>匹配字符串前缀也行），也就是说这些搜索条件都可能使用到索引，设计<code>MySQL</code>的大叔把一个查询中可能使用到的索引称之为<code>possible keys</code>。</p><p>我们分析一下上边查询中涉及到的几个搜索条件：</p><ul><li><code>key1 IN ('a', 'b', 'c')</code>，这个搜索条件可以使用二级索引<code>idx_key1</code>。</li><li><code>key2 &gt; 10 AND key2 &lt; 1000</code>，这个搜索条件可以使用二级索引<code>idx_key2</code>。</li><li><code>key3 &gt; key2</code>，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。</li><li><code>key_part1 LIKE '%hello%'</code>，<code>key_part1</code>通过<code>LIKE</code>操作符和以通配符开头的字符串做比较，不可以适用索引。</li><li><code>common_field = '123'</code>，由于该列上压根儿没有索引，所以不会用到索引。</li></ul><p>综上所述，上边的查询语句可能用到的索引，也就是<code>possible keys</code>只有<code>idx_key1</code>和<code>idx_key2</code>。</p><h4 id="2-计算全表扫描的代价">2. 计算全表扫描的代价</h4><p>对于<code>InnoDB</code>存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。由于查询成本=<code>I/O</code>成本+<code>CPU</code>成本，所以计算全表扫描的代价需要两个信息：</p><ul><li>聚簇索引占用的页面数</li><li>该表中的记录数</li></ul><p>这两个信息从哪来呢？设计<code>MySQL</code>的大叔为每个表维护了一系列的<code>统计信息</code>，关于这些统计信息是如何收集起来的我们放在本章后边详细唠叨，现在看看怎么查看这些统计信息哈。设计<code>MySQL</code>的大叔给我们提供了<code>SHOW TABLE STATUS</code>语句来查看表的统计信息，如果要看指定的某个表的统计信息，在该语句后加对应的<code>LIKE</code>语句就好了，比方说我们要查看<code>single_table</code>这个表的统计信息可以这么写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">mysql&gt;</span> <span class="hljs-string">USE</span> <span class="hljs-string">xiaohaizi;</span><br><span class="hljs-string">Database</span> <span class="hljs-string">changed</span><br><br><span class="hljs-string">mysql&gt;</span> <span class="hljs-string">SHOW</span> <span class="hljs-string">TABLE</span> <span class="hljs-string">STATUS</span> <span class="hljs-string">LIKE</span> <span class="hljs-string">&#x27;single_table&#x27;</span><span class="hljs-string">\G</span><br><span class="hljs-string">***************************</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">row</span> <span class="hljs-string">***************************</span><br>           <span class="hljs-attr">Name:</span> <span class="hljs-string">single_table</span><br>         <span class="hljs-attr">Engine:</span> <span class="hljs-string">InnoDB</span><br>        <span class="hljs-attr">Version:</span> <span class="hljs-number">10</span><br>     <span class="hljs-attr">Row_format:</span> <span class="hljs-string">Dynamic</span><br>           <span class="hljs-attr">Rows:</span> <span class="hljs-number">9693</span><br> <span class="hljs-attr">Avg_row_length:</span> <span class="hljs-number">163</span><br>    <span class="hljs-attr">Data_length:</span> <span class="hljs-number">1589248</span><br><span class="hljs-attr">Max_data_length:</span> <span class="hljs-number">0</span><br>   <span class="hljs-attr">Index_length:</span> <span class="hljs-number">2752512</span><br>      <span class="hljs-attr">Data_free:</span> <span class="hljs-number">4194304</span><br> <span class="hljs-attr">Auto_increment:</span> <span class="hljs-number">10001</span><br>    <span class="hljs-attr">Create_time:</span> <span class="hljs-number">2018-12-10 13:37:23</span><br>    <span class="hljs-attr">Update_time:</span> <span class="hljs-number">2018-12-10 13:38:03</span><br>     <span class="hljs-attr">Check_time:</span> <span class="hljs-literal">NULL</span><br>      <span class="hljs-attr">Collation:</span> <span class="hljs-string">utf8_general_ci</span><br>       <span class="hljs-attr">Checksum:</span> <span class="hljs-literal">NULL</span><br> <span class="hljs-attr">Create_options:</span><br>        <span class="hljs-attr">Comment:</span><br><span class="hljs-number">1</span> <span class="hljs-string">row</span> <span class="hljs-string">in</span> <span class="hljs-string">set</span> <span class="hljs-string">(0.01</span> <span class="hljs-string">sec)</span><br></code></pre></td></tr></table></figure><p>虽然出现了很多统计选项，但我们目前只关心两个：</p><ul><li><p><code>Rows</code></p><p>本选项表示表中的记录条数**。对于使用<code>MyISAM</code>存储引擎的表来说，该值是准确的，对于使用<code>InnoDB</code>存储引擎的表来说，该值是一个估计值。**从查询结果我们也可以看出来，由于我们的<code>single_table</code>表是使用<code>InnoDB</code>存储引擎的，所以虽然实际上表中有10000条记录，但是<code>SHOW TABLE STATUS</code>显示的<code>Rows</code>值只有9693条记录。</p></li><li><p><code>Data_length</code></p><p>本选项表示表占用的存储空间字节数。使用<code>MyISAM</code>存储引擎的表来说，该值就是数据文件的大小，对于使用<code>InnoDB</code>存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">Data_length</span> = 聚簇索引的页面数量 x 每个页面的大小<br></code></pre></td></tr></table></figure><p>我们的<code>single_table</code>使用默认<code>16KB</code>的页面大小，而上边查询结果显示<code>Data_length</code>的值是<code>1589248</code>，所以我们可以反向来推导出<code>聚簇索引的页面数量</code>：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">聚簇索引的页面数量 =<span class="hljs-number"> 1589248 </span>÷<span class="hljs-number"> 16 </span>÷<span class="hljs-number"> 1024 </span>= 97<br></code></pre></td></tr></table></figure></li></ul><p>我们现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值，所以就可以计算全表扫描成本了，但是设计<code>MySQL</code>的大叔在真实计算成本时会进行一些<code>微调</code>，这些微调的值是直接硬编码到代码里的，由于没有注释，我也不知道这些微调值是个啥子意思，但是由于这些微调的值十分的小，并不影响我们分析，所以我们也没有必要在这些微调值上纠结了。现在可以看一下全表扫描成本的计算过程：</p><ul><li><p><code>I/O</code>成本</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">97 </span>x <span class="hljs-number">1.0</span> + <span class="hljs-number">1.1</span> = <span class="hljs-number">98.1</span><br></code></pre></td></tr></table></figure><p><code>97</code>指的是聚簇索引占用的页面数，<code>1.0</code>指的是加载一个页面的成本常数，后边的<code>1.1</code>是一个微调值，我们不用在意。</p></li><li><p><code>CPU</code>成本：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9693 </span>x <span class="hljs-number">0.2</span> + <span class="hljs-number">1.0</span> = <span class="hljs-number">1939.6</span><br></code></pre></td></tr></table></figure><p><code>9693</code>指的是统计数据中表的记录数，对于<code>InnoDB</code>存储引擎来说是一个估计值，<code>0.2</code>指的是访问一条记录所需的成本常数，后边的<code>1.0</code>是一个微调值，我们不用在意。</p></li><li><p>总成本：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">98</span>.<span class="hljs-number">1</span> + <span class="hljs-number">1939</span>.<span class="hljs-number">6</span> = <span class="hljs-number">2037</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure></li></ul><p>综上所述，对于<code>single_table</code>的全表扫描所需的总成本就是<code>2037.7</code>。</p><blockquote><p>小贴士： 我们前边说过表中的记录其实都存储在聚簇索引对应B+树的叶子节点中，所以只要我们通过根节点获得了最左边的叶子节点，就可以沿着叶子节点组成的双向链表把所有记录都查看一遍。也就是说全表扫描这个过程其实有的B+树内节点是不需要访问的，但是设计MySQL的大叔们在计算全表扫描成本时直接使用聚簇索引占用的页面数作为计算I/O成本的依据，是不区分内节点和叶子节点的，有点儿简单暴力，大家注意一下就好了。</p></blockquote><h4 id="3-计算使用不同索引执行查询的代价">3. 计算使用不同索引执行查询的代价</h4><p>从第1步分析我们得到，上述查询可能使用到<code>idx_key1</code>和<code>idx_key2</code>这两个索引，我们需要分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能使用到索引合并。这里需要提一点的是，<code>MySQL</code>查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本，所以我们也先分析<code>idx_key2</code>的成本，然后再看使用<code>idx_key1</code>的成本。</p><h5 id="使用idx-key2执行查询的成本分析">使用idx_key2执行查询的成本分析</h5><p><code>idx_key2</code>对应的搜索条件是：<code>key2 &gt; 10 AND key2 &lt; 1000</code>，也就是说对应的范围区间就是：<code>(10, 1000)</code>，使用<code>idx_key2</code>搜索的示意图就是这样子：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16998b505d671d4e~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1d6cb8nolj1714dimrf1iu64l99.png-124.3kB"><p>对于使用<code>二级索引 + 回表</code>方式的查询，设计<code>MySQL</code>的大叔计算这种查询的成本依赖两个方面的数据：</p><ul><li><p>范围区间数量</p><p>不论某个范围区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的<code>I/O</code>成本和读取一个页面是相同的。本例中使用<code>idx_key2</code>的范围区间只有一个：<code>(10, 1000)</code>，所以相当于访问这个范围区间的二级索引付出的<code>I/O</code>成本就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>x <span class="hljs-number">1.0</span> = <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure></li><li><p>需要回表的记录数</p><p>优化器需要计算二级索引的某个范围区间到底包含多少条记录，对于本例来说就是要计算<code>idx_key2</code>在<code>(10, 1000)</code>这个范围区间中包含多少二级索引记录，计算过程是这样的：</p><ul><li><p>步骤1：先根据<code>key2 &gt; 10</code>这个条件访问一下<code>idx_key2</code>对应的<code>B+</code>树索引，找到满足<code>key2 &gt; 10</code>这个条件的第一条记录，我们把这条记录称之为<code>区间最左记录</code>。我们前头说过在<code>B+</code>数树中定位一条记录的过程是贼快的，是常数级别的，所以这个过程的性能消耗是可以忽略不计的。</p></li><li><p>步骤2：然后再根据<code>key2 &lt; 1000</code>这个条件继续从<code>idx_key2</code>对应的<code>B+</code>树索引中找出最后一条满足这个条件的记录，我们把这条记录称之为<code>区间最右记录</code>，这个过程的性能消耗也可以忽略不计的。</p></li><li><p>步骤3：如果<code>区间最左记录</code>和<code>区间最右记录</code>相隔不太远（在<code>MySQL 5.7.21</code>这个版本里，只要相隔不大于10个页面即可），那就可以精确统计出满足<code>key2 &gt; 10 AND key2 &lt; 1000</code>条件的二级索引记录条数。否则只沿着<code>区间最左记录</code>向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就可以了。那么问题又来了，怎么估计<code>区间最左记录</code>和<code>区间最右记录</code>之间有多少个页面呢？解决这个问题还得回到<code>B+</code>树索引的结构中来：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16998b505d7a278a~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cubndfil1i02ddfas1j3brq9m.png-85.3kB"><p>如图，我们假设<code>区间最左记录</code>在<code>页b</code>中，<code>区间最右记录</code>在<code>页c</code>中，那么我们想计算<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就相当于计算<code>页b</code>和<code>页c</code>之间有多少页面，而每一条<code>目录项记录</code>都对应一个数据页，所以计算<code>页b</code>和<code>页c</code>之间有多少页面就相当于计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录。在一个页面中统计两条记录之间有几条记录的成本就贼小了。</p><p>不过还有问题，如果<code>页b</code>和<code>页c</code>之间的页面实在太多，以至于<code>页b</code>和<code>页c</code>对应的目录项记录都不在一个页面中该咋办？继续递归啊，也就是再统计<code>页b</code>和<code>页c</code>对应的目录项记录所在页之间有多少个页面。之前我们说过一个<code>B+</code>树有4层高已经很了不得了，所以这个统计过程也不是很耗费性能。</p></li></ul><p>知道了如何统计二级索引某个范围区间的记录数之后，就需要回到现实问题中来，根据上述算法测得<code>idx_key2</code>在区间<code>(10, 1000)</code>之间大约有<code>95</code>条记录。读取这<code>95</code>条二级索引记录需要付出的<code>CPU</code>成本就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">95 </span>x <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span> = <span class="hljs-number">19.01</span><br></code></pre></td></tr></table></figure><p>其中<code>95</code>是需要读取的二级索引记录条数，<code>0.2</code>是读取一条记录成本常数，<code>0.01</code>是微调。</p><p>在通过二级索引获取到记录之后，还需要干两件事儿：</p><ul><li><p>根据这些记录里的主键值到聚簇索引中做回表操作</p><p>这里需要大家使劲儿睁大自己滴溜溜的大眼睛仔细瞧，设计<code>MySQL</code>的大叔评估回表操作的<code>I/O</code>成本依旧很豪放，他们认为每次回表操作都相当于访问一个页面，也就是说二级索引范围区间有多少记录，就需要进行多少次回表操作，也就是需要进行多少次页面<code>I/O</code>。我们上边统计了使用<code>idx_key2</code>二级索引执行查询时，预计有<code>95</code>条二级索引记录需要进行回表操作，所以回表操作带来的<code>I/O</code>成本就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">95 </span>x <span class="hljs-number">1.0</span> = <span class="hljs-number">95.0</span><br></code></pre></td></tr></table></figure><p>其中<code>95</code>是预计的二级索引记录数，<code>1.0</code>是一个页面的<code>I/O</code>成本常数。</p></li><li><p>回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立</p><p>回表操作的本质就是通过二级索引记录的主键值到聚簇索引中找到完整的用户记录，然后再检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立。因为我们通过范围区间获取到二级索引记录共<code>95</code>条，也就对应着聚簇索引中<code>95</code>条完整的用户记录，读取并检测这些完整的用户记录是否符合其余的搜索条件的<code>CPU</code>成本如下：</p><p>设计<code>MySQL</code>的大叔只计算这个查找过程所需的<code>I/O</code>成本，也就是我们上一步骤中得到的<code>95.0</code>，在内存中的定位完整用户记录的过程的成本是忽略不计的。在定位到这些完整的用户记录后，需要检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立，这个比较过程花费的<code>CPU</code>成本就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">95 </span>x <span class="hljs-number">0.2</span> = <span class="hljs-number">19.0</span><br></code></pre></td></tr></table></figure><p>其中<code>95</code>是待检测记录的条数，<code>0.2</code>是检测一条记录是否符合给定的搜索条件的成本常数。</p></li></ul></li></ul><p>所以本例中使用<code>idx_key2</code>执行查询的成本就如下所示：</p><ul><li><p><code>I/O</code>成本：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">0</span> + <span class="hljs-number">95</span> x <span class="hljs-number">1</span>.<span class="hljs-number">0</span> = <span class="hljs-number">96</span>.<span class="hljs-number">0</span> (范围区间的数量 + 预估的二级索引记录条数)<br></code></pre></td></tr></table></figure></li><li><p><code>CPU</code>成本：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">95 </span>x <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span> + <span class="hljs-number">95</span> x <span class="hljs-number">0.2</span> = <span class="hljs-number">38.01</span> （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）<br></code></pre></td></tr></table></figure></li></ul><p>综上所述，使用<code>idx_key2</code>执行查询的总成本就是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">96</span>.<span class="hljs-number">0</span> + <span class="hljs-number">38</span>.<span class="hljs-number">01</span> = <span class="hljs-number">134</span>.<span class="hljs-number">01</span><br></code></pre></td></tr></table></figure><h5 id="使用idx-key1执行查询的成本分析">使用idx_key1执行查询的成本分析</h5><p><code>idx_key1</code>对应的搜索条件是：<code>key1 IN ('a', 'b', 'c')</code>，也就是说相当于3个单点区间：</p><ul><li><code>['a', 'a']</code></li><li><code>['b', 'b']</code></li><li><code>['c', 'c']</code></li></ul><p>使用<code>idx_key1</code>搜索的示意图就是这样子：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16998b505eab86e6~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cubvsars1i0rvdc11b3118th9830.png-124.1kB"><p>与使用<code>idx_key2</code>的情况类似，我们也需要计算使用<code>idx_key1</code>时需要访问的范围区间数量以及需要回表的记录数：</p><ul><li><p>范围区间数量</p><p>使用<code>idx_key1</code>执行查询时很显然有3个单点区间，所以访问这3个范围区间的二级索引付出的I/O成本就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span>x <span class="hljs-number">1.0</span> = <span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure></li><li><p>需要回表的记录数</p><p>由于使用<code>idx_key1</code>时有3个单点区间，所以每个单点区间都需要查找一遍对应的二级索引记录数：</p><ul><li><p>查找单点区间<code>['a', 'a']</code>对应的二级索引记录数</p><p>计算单点区间对应的二级索引记录数和计算连续范围区间对应的二级索引记录数是一样的，都是先计算<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算它们之间的记录数，具体算法上边都唠叨过了，就不赘述了。最后计算得到单点区间<code>['a', 'a']</code>对应的二级索引记录数是：<code>35</code>。</p></li><li><p>查找单点区间<code>['b', 'b']</code>对应的二级索引记录数</p><p>与上同理，计算得到本单点区间对应的记录数是：<code>44</code>。</p></li><li><p>查找单点区间<code>['c', 'c']</code>对应的二级索引记录数</p><p>与上同理，计算得到本单点区间对应的记录数是：<code>39</code>。</p></li></ul><p>所以，这三个单点区间总共需要回表的记录数就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">35 </span>+ <span class="hljs-number">44</span> + <span class="hljs-number">39</span> = <span class="hljs-number">118</span><br></code></pre></td></tr></table></figure><p>读取这些二级索引记录的<code>CPU</code>成本就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">118 </span>x <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span> = <span class="hljs-number">23.61</span><br></code></pre></td></tr></table></figure><p>得到总共需要回表的记录数之后，就要考虑：</p><ul><li><p>根据这些记录里的主键值到聚簇索引中做回表操作</p><p>所需的<code>I/O</code>成本就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">118 </span>x <span class="hljs-number">1.0</span> = <span class="hljs-number">118.0</span><br></code></pre></td></tr></table></figure></li><li><p>回表操作后得到的完整用户记录，然后再比较其他搜索条件是否成立</p><p>此步骤对应的<code>CPU</code>成本就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">118 </span>x <span class="hljs-number">0.2</span> = <span class="hljs-number">23.6</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p>所以本例中使用<code>idx_key1</code>执行查询的成本就如下所示：</p><ul><li><p><code>I/O</code>成本：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>.<span class="hljs-number">0</span> + <span class="hljs-number">118</span> x <span class="hljs-number">1</span>.<span class="hljs-number">0</span> = <span class="hljs-number">121</span>.<span class="hljs-number">0</span> (范围区间的数量 + 预估的二级索引记录条数)<br></code></pre></td></tr></table></figure></li><li><p><code>CPU</code>成本：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">118 </span>x <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span> + <span class="hljs-number">118</span> x <span class="hljs-number">0.2</span> = <span class="hljs-number">47.21</span> （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）<br></code></pre></td></tr></table></figure></li></ul><p>综上所述，使用<code>idx_key1</code>执行查询的总成本就是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">121</span>.<span class="hljs-number">0</span> + <span class="hljs-number">47</span>.<span class="hljs-number">21</span> = <span class="hljs-number">168</span>.<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h5 id="是否有可能使用索引合并（Index-Merge）">是否有可能使用索引合并（Index Merge）</h5><p>本例中有关<code>key1</code>和<code>key2</code>的搜索条件是使用<code>AND</code>连接起来的，而对于<code>idx_key1</code>和<code>idx_key2</code>都是范围查询，也就是说查找到的二级索引记录并不是按照主键值进行排序的，并不满足使用<code>Intersection</code>索引合并的条件，所以并不会使用索引合并。</p><blockquote><p>小贴士： MySQL查询优化器计算索引合并成本的算法也比较麻烦，所以我们这也就不展开唠叨了。</p></blockquote><h4 id="4-对比各种执行方案的代价，找出成本最低的那一个">4. 对比各种执行方案的代价，找出成本最低的那一个</h4><p>下边把执行本例中的查询的各种可执行方案以及它们对应的成本列出来：</p><ul><li>全表扫描的成本：<code>2037.7</code></li><li>使用<code>idx_key2</code>的成本：<code>134.01</code></li><li>使用<code>idx_key1</code>的成本：<code>168.21</code></li></ul><p>很显然，使用<code>idx_key2</code>的成本最低，所以当然选择<code>idx_key2</code>来执行查询喽。</p><blockquote><p>小贴士： 考虑到大家的阅读体验，为了最大限度的减少大家在理解优化器工作原理的过程中遇到的懵逼情况，这里对优化器在单表查询中对比各种执行方案的代价的方式稍稍的做了简化，不过毕竟大部分同学不需要去看MySQL的源码，把大致的精神传递正确就好了哈。</p></blockquote><h3 id="基于索引统计数据的成本计算">基于索引统计数据的成本计算</h3><p>有时候使用索引执行查询时会有许多单点区间，比如使用<code>IN</code>语句就很容易产生非常多的单点区间，比如下边这个查询（下边查询语句中的<code>...</code>表示还有很多参数）：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> * FROM single_table <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;aa1&#x27;</span>, <span class="hljs-string">&#x27;aa2&#x27;</span>, <span class="hljs-string">&#x27;aa3&#x27;</span>, <span class="hljs-params">...</span> , <span class="hljs-string">&#x27;zzz&#x27;</span>);<br></code></pre></td></tr></table></figure><p>很显然，这个查询可能使用到的索引就是<code>idx_key1</code>，由于这个索引并不是唯一二级索引，所以并不能确定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算。计算方式我们上边已经介绍过了，就是先获取索引对应的<code>B+</code>树的<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。设计<code>MySQL</code>的大叔把这种通过直接访问索引对应的<code>B+</code>树来计算某个范围区间对应的索引记录条数的方式称之为<code>index dive</code>。</p><blockquote><p>小贴士： dive直译为中文的意思是跳水、俯冲的意思，原谅我的英文水平捉急，我实在不知道怎么翻译 index dive，索引跳水？索引俯冲？好像都不太合适，所以压根儿就不翻译了。不过大家要意会index dive就是直接利用索引对应的B+树来计算某个范围区间对应的记录条数。</p></blockquote><p>有零星几个单点区间的话，使用<code>index dive</code>的方式去计算这些单点区间对应的记录数也不是什么问题，可是你架不住有的孩子憋足了劲往<code>IN</code>语句里塞东西呀，我就见过有的同学写的<code>IN</code>语句里有20000个参数的🤣🤣，这就意味着<code>MySQL</code>的查询优化器为了计算这些单点区间对应的索引记录条数，要进行20000次<code>index dive</code>操作，这性能损耗可就大了，搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。设计<code>MySQL</code>的大叔们多聪明啊，他们当然考虑到了这种情况，所以提供了一个系统变量<code>eq_range_index_dive_limit</code>，我们看一下在<code>MySQL 5.7.21</code>中这个系统变量的默认值：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW VARIABLES LIKE &#x27;%dive%&#x27;;</span><br><span class="hljs-section">+---------------------------+-------+</span><br><span class="hljs-section">| Variable_name             | Value |</span><br><span class="hljs-section">+---------------------------+-------+</span><br><span class="hljs-section">| eq_range_index_dive_limit | 200   |</span><br><span class="hljs-section">+---------------------------+-------+</span><br>1 row in set (0.08 sec)<br></code></pre></td></tr></table></figure><p>也就是说如果我们的<code>IN</code>语句中的参数个数小于200个的话，将使用<code>index dive</code>的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话，可就不能使用<code>index dive</code>了，要使用所谓的索引统计数据来进行估算。怎么个估算法？继续往下看。</p><p>像会为每个表维护一份统计数据一样，<code>MySQL</code>也会为表中的每一个索引维护一份统计数据，查看某个表中索引的统计数据可以使用<code>SHOW INDEX FROM 表名</code>的语法，比如我们查看一下<code>single_table</code>的各个索引的统计数据可以这么写：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW INDEX FROM single_table; <span class="hljs-comment"># 在最后+ \G 表示换行</span><br>+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+<br>|<span class="hljs-string"> Table        </span>|<span class="hljs-string"> Non_unique </span>|<span class="hljs-string"> Key_name     </span>|<span class="hljs-string"> Seq_in_index </span>|<span class="hljs-string"> Column_name </span>|<span class="hljs-string"> Collation </span>|<span class="hljs-string"> Cardinality </span>|<span class="hljs-string"> Sub_part </span>|<span class="hljs-string"> Packed </span>|<span class="hljs-string"> Null </span>|<span class="hljs-string"> Index_type </span>|<span class="hljs-string"> Comment </span>|<span class="hljs-string"> Index_comment </span>|<br>+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          0 </span>|<span class="hljs-string"> PRIMARY      </span>|<span class="hljs-string">            1 </span>|<span class="hljs-string"> id          </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">       9693  </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          0 </span>|<span class="hljs-string"> idx_key2     </span>|<span class="hljs-string">            1 </span>|<span class="hljs-string"> key2        </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">       9693  </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          1 </span>|<span class="hljs-string"> idx_key1     </span>|<span class="hljs-string">            1 </span>|<span class="hljs-string"> key1        </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">        968 </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          1 </span>|<span class="hljs-string"> idx_key3     </span>|<span class="hljs-string">            1 </span>|<span class="hljs-string"> key3        </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">        799 </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          1 </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string">            1 </span>|<span class="hljs-string"> key_part1   </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">        9673 </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          1 </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string">            2 </span>|<span class="hljs-string"> key_part2   </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">        9999 </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>|<span class="hljs-string"> single_table </span>|<span class="hljs-string">          1 </span>|<span class="hljs-string"> idx_key_part </span>|<span class="hljs-string">            3 </span>|<span class="hljs-string"> key_part3   </span>|<span class="hljs-string"> A         </span>|<span class="hljs-string">       10000 </span>|<span class="hljs-string">     NULL </span>|<span class="hljs-string"> NULL   </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> BTREE      </span>|<span class="hljs-string">         </span>|<span class="hljs-string">               </span>|<br>+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+<br>7 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>哇唔，竟然有这么多属性，不过好在这些属性都不难理解，我们就都介绍一遍吧：</p><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><code>Table</code></td><td>索引所属表的名称。</td></tr><tr><td><code>Non_unique</code></td><td>索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为<code>0</code>，普通二级索引该列值为<code>1</code>。</td></tr><tr><td><code>Key_name</code></td><td>索引的名称。</td></tr><tr><td><code>Seq_in_index</code></td><td>索引列在索引中的位置，从1开始计数。比如对于联合索引<code>idx_key_part</code>，来说，<code>key_part1</code>、<code>key_part2</code>和<code>key_part3</code>对应的位置分别是1、2、3。</td></tr><tr><td><code>Column_name</code></td><td>索引列的名称。</td></tr><tr><td><code>Collation</code></td><td>索引列中的值是按照何种排序方式存放的，值为<code>A</code>时代表升序存放，为<code>NULL</code>时代表降序存放。</td></tr><tr><td><code>Cardinality</code></td><td>索引列中不重复值的数量。后边我们会重点看这个属性的。</td></tr><tr><td><code>Sub_part</code></td><td>对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前<code>n</code>个字符或字节建立索引，这个属性表示的就是那个<code>n</code>值。如果对完整的列建立索引的话，该属性的值就是<code>NULL</code>。</td></tr><tr><td><code>Packed</code></td><td>索引列如何被压缩，<code>NULL</code>值表示未被压缩。这个属性我们暂时不了解，可以先忽略掉。</td></tr><tr><td><code>Null</code></td><td>该索引列是否允许存储<code>NULL</code>值。</td></tr><tr><td><code>Index_type</code></td><td>使用索引的类型，我们最常见的就是<code>BTREE</code>，其实也就是<code>B+</code>树索引。</td></tr><tr><td><code>Comment</code></td><td>索引列注释信息。</td></tr><tr><td><code>Index_comment</code></td><td>索引注释信息。</td></tr></tbody></table><p>上述属性除了<code>Packed</code>大家可能看不懂以外，应该没有啥看不懂的了，如果有的话肯定是大家看前边文章的时候跳过了啥东西。其实我们现在最在意的是<code>Cardinality</code>属性，<code>Cardinality</code>直译过来就是<code>基数</code>的意思，表示索引列中不重复值的个数。比如对于一个一万行记录的表来说，某个索引列的<code>Cardinality</code>属性是<code>10000</code>，那意味着该列中没有重复的值，如果<code>Cardinality</code>属性是<code>1</code>的话，就意味着该列的值全部是重复的。不过需要注意的是，对于InnoDB存储引擎来说，使用SHOW INDEX语句展示出来的某个索引列的Cardinality属性是一个估计值，并不是精确的。关于这个<code>Cardinality</code>属性的值是如何被计算出来的我们后边再说，先看看它有什么用途。</p><p>前边说道，当<code>IN</code>语句中的参数个数大于或等于系统变量<code>eq_range_index_dive_limit</code>的值的话，就不会使用<code>index dive</code>的方式计算各个单点区间对应的索引记录条数，而是使用索引统计数据，这里所指的<code>索引统计数据</code>指的是这两个值：</p><ul><li><p>使用<code>SHOW TABLE STATUS</code>展示出的<code>Rows</code>值，也就是一个表中有多少条记录。</p><p>这个统计数据我们在前边唠叨全表扫描成本的时候说过很多遍了，就不赘述了。</p></li><li><p>使用<code>SHOW INDEX</code>语句展示出的<code>Cardinality</code>属性。</p><p>结合上一个<code>Rows</code>统计数据，我们可以针对索引列，计算出平均一个值重复多少次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">一个值的重复次数 ≈ <span class="hljs-keyword">Rows</span> ÷ <span class="hljs-keyword">Cardinality</span><br></code></pre></td></tr></table></figure></li></ul><p>以<code>single_table</code>表的<code>idx_key1</code>索引为例，它的<code>Rows</code>值是<code>9693</code>，它对应索引列<code>key1</code>的<code>Cardinality</code>值是<code>968</code>，所以我们可以计算<code>key1</code>列平均单个值的重复次数就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9693 </span>÷ <span class="hljs-number">968</span> ≈ <span class="hljs-number">10</span>（条）<br></code></pre></td></tr></table></figure><p>此时再看上边那条查询语句：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> * FROM single_table <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;aa1&#x27;</span>, <span class="hljs-string">&#x27;aa2&#x27;</span>, <span class="hljs-string">&#x27;aa3&#x27;</span>, <span class="hljs-params">...</span> , <span class="hljs-string">&#x27;zzz&#x27;</span>);<br></code></pre></td></tr></table></figure><p>假设<code>IN</code>语句中有20000个参数的话，就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了，每个参数大约对应<code>10</code>条记录，所以总共需要回表的记录数就是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">20000 </span>x <span class="hljs-number">10</span> = <span class="hljs-number">200000</span><br></code></pre></td></tr></table></figure><p>使用统计数据来计算单点区间对应的索引记录条数可比<code>index dive</code>的方式简单多了，但是它的致命弱点就是：不精确！。使用统计数据算出来的查询成本与实际所需的成本可能相差非常大。</p><blockquote><p>小贴士： 大家需要注意一下，在MySQL 5.7.3以及之前的版本中，eq_range_index_dive_limit的默认值为10，之后的版本默认值为200。所以如果大家采用的是5.7.3以及之前的版本的话，很容易采用索引统计数据而不是index dive的方式来计算查询成本。当你的查询中使用到了IN查询，但是却实际没有用到索引，就应该考虑一下是不是由于 eq_range_index_dive_limit 值太小导致的。</p></blockquote><h2 id="连接查询的成本">连接查询的成本</h2><h3 id="准备工作-3">准备工作</h3><p>连接查询至少是要有两个表的，只有一个<code>single_table</code>表是不够的，所以为了故事的顺利发展，我们直接构造一个和<code>single_table</code>表一模一样的<code>single_table2</code>表。为了简便起见，我们把<code>single_table</code>表称为<code>s1</code>表，把<code>single_table2</code>表称为<code>s2</code>表。</p><h3 id="Condition-filtering介绍">Condition filtering介绍</h3><p>我们前边说过，<code>MySQL</code>中连接查询采用的是<strong>嵌套循环连接算法</strong>，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：</p><ul><li>单次查询驱动表的成本</li><li>多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）</li></ul><p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code>（英文名：<code>fanout</code>）。很显然驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值，有的时候扇出值的计算是很容易的，比如下边这两个查询：</p><ul><li><p>查询一：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">AS</span> s1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> single_table2 <span class="hljs-keyword">AS</span> s2;<br></code></pre></td></tr></table></figure><p>假设使用<code>s1</code>表作为驱动表，很显然对驱动表的单表查询只能使用全表扫描的方式执行，驱动表的扇出值也很明确，那就是驱动表中有多少记录，扇出值就是多少。我们前边说过，统计数据中<code>s1</code>表的记录行数是<code>9693</code>，也就是说优化器就直接会把<code>9693</code>当作在<code>s1</code>表的扇出值。</p></li><li><p>查询二：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table AS s<span class="hljs-number">1</span> INNER JOIN single_table<span class="hljs-number">2</span> AS s<span class="hljs-number">2</span> <br><span class="hljs-attribute">WHERE</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &gt;<span class="hljs-number">10</span> AND s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &lt; <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>仍然假设<code>s1</code>表是驱动表的话，很显然对驱动表的单表查询可以使用<code>idx_key2</code>索引执行查询。此时<code>idx_key2</code>的范围区间<code>(10, 1000)</code>中有多少条记录，那么扇出值就是多少。我们前边计算过，满足<code>idx_key2</code>的范围区间<code>(10, 1000)</code>的记录数是95条，也就是说本查询中优化器会把<code>95</code>当作驱动表<code>s1</code>的扇出值。</p></li></ul><p>事情当然不会总是一帆风顺的，要不然剧情就太平淡了。有的时候扇出值的计算就变得很棘手，比方说下边几个查询：</p><ul><li><p>查询三：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">AS</span> s1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> single_table2 <span class="hljs-keyword">AS</span> s2 <br>    <span class="hljs-keyword">WHERE</span> s1.common_field &gt; <span class="hljs-string">&#x27;xyz&#x27;</span>;<br></code></pre></td></tr></table></figure><p>本查询和<code>查询一</code>类似，只不过对于驱动表<code>s1</code>多了一个<code>common_field &gt; 'xyz'</code>的搜索条件。查询优化器又不会真正的去执行查询，所以它只能<code>猜</code>这<code>9693</code>记录里有多少条记录满足<code>common_field &gt; 'xyz'</code>条件。</p></li><li><p>查询四：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table AS s<span class="hljs-number">1</span> INNER JOIN single_table<span class="hljs-number">2</span> AS s<span class="hljs-number">2</span> <br>    <span class="hljs-attribute">WHERE</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &gt; <span class="hljs-number">10</span> AND s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &lt; <span class="hljs-number">1000</span> AND<br>          <span class="hljs-attribute">s1</span>.common_field &gt; &#x27;xyz&#x27;;<br></code></pre></td></tr></table></figure><p>本查询和<code>查询二</code>类似，只不过对于驱动表<code>s1</code>也多了一个<code>common_field &gt; 'xyz'</code>的搜索条件。不过因为本查询可以使用<code>idx_key2</code>索引，所以只需要从符合二级索引范围区间的记录中猜有多少条记录符合<code>common_field &gt; 'xyz'</code>条件，也就是只需要猜在<code>95</code>条记录中有多少符合<code>common_field &gt; 'xyz'</code>条件。</p></li><li><p>查询五：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">AS</span> s1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> single_table2 <span class="hljs-keyword">AS</span> s2 <br>    <span class="hljs-keyword">WHERE</span> s1.key2 &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">AND</span> s1.key2 &lt; <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span><br>          s1.key1 <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-keyword">AND</span><br>          s1.common_field &gt; <span class="hljs-string">&#x27;xyz&#x27;</span>;<br></code></pre></td></tr></table></figure><p>本查询和<code>查询二</code>类似，不过在驱动表<code>s1</code>选取<code>idx_key2</code>索引执行查询后，优化器需要从符合二级索引范围区间的记录中猜有多少条记录符合下边两个条件：</p><ul><li><code>key1 IN ('a', 'b', 'c')</code></li><li><code>common_field &gt; 'xyz'</code></li></ul><p>也就是优化器需要猜在<code>95</code>条记录中有多少符合上述两个条件的。</p></li></ul><p>说了这么多，其实就是想表达在这两种情况下计算驱动表扇出值时需要靠<code>猜</code>：</p><ul><li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。</li><li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li></ul><p>设计<code>MySQL</code>的大叔把这个<code>猜</code>的过程称之为<code>condition filtering</code>。当然，这个过程可能会使用到索引，也可能使用到统计数据，也可能就是设计<code>MySQL</code>的大叔单纯的瞎猜，整个评估过程挺复杂的，再仔细的唠叨一遍可能引起大家的生理不适，所以我们就跳过了哈。</p><blockquote><p>小贴士： 在MySQL 5.7之前的版本中，查询优化器在计算驱动表扇出时，<strong>如果是使用全表扫描的话，就直接使用表中记录的数量作为扇出值，如果使用索引的话，就直接使用满足范围条件的索引记录条数作为扇出值</strong>。在MySQL 5.7中，设计MySQL的大叔引入了这个condition filtering的功能，就是还要猜一猜剩余的那些搜索条件能把驱动表中的记录再过滤多少条，其实本质上就是为了让成本估算更精确。 我们所说的纯粹瞎猜其实是很不严谨的，设计MySQL的大叔们称之为启发式规则（heuristic），大家有兴趣的可以再深入了解一下哈。</p></blockquote><h3 id="两表连接的成本分析">两表连接的成本分析</h3><p>连接查询的成本计算公式是这样的：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">连接查询总成本 </span>=<span class="hljs-string"> 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</span><br></code></pre></td></tr></table></figure><p>对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：</p><ul><li>分别为驱动表和被驱动表选择成本最低的访问方法。</li></ul><p>可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：</p><ul><li>不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。</li><li>然后分别为驱动表和被驱动表选择成本最低的访问方法。</li></ul><p>很显然，计算内连接查询成本的方式更麻烦一些，下边我们就以内连接为例来看看如何计算出最优的连接查询方案。</p><blockquote><p>小贴士： 左（外）连接和右（外）连接查询在某些特殊情况下可以被优化为内连接查询，我们在之后的章节中会仔细唠叨的，稍安勿躁。</p></blockquote><p>比如对于下边这个查询来说：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM single_table AS s<span class="hljs-number">1</span> INNER JOIN single_table<span class="hljs-number">2</span> AS s<span class="hljs-number">2</span> <br>    <span class="hljs-attribute">ON</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">1</span> = s<span class="hljs-number">2</span>.common_field <br>    <span class="hljs-attribute">WHERE</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &gt; <span class="hljs-number">10</span> AND s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> &lt; <span class="hljs-number">1000</span> AND <br>          <span class="hljs-attribute">s2</span>.key<span class="hljs-number">2</span> &gt; <span class="hljs-number">1000</span> AND s<span class="hljs-number">2</span>.key<span class="hljs-number">2</span> &lt; <span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><p>可以选择的连接顺序有两种：</p><ul><li><code>s1</code>连接<code>s2</code>，也就是<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表。</li><li><code>s2</code>连接<code>s1</code>，也就是<code>s2</code>作为驱动表，<code>s1</code>作为被驱动表。</li></ul><p>查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。我们分别来看一下（定性的分析一下，不像分析单表查询那样定量的分析了）：</p><ul><li><p>使用<code>s1</code>作为驱动表的情况</p><ul><li><p>分析对于驱动表的成本最低的执行方案</p><p>首先看一下涉及<code>s1</code>表单表的搜索条件有哪些：</p><ul><li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 1000</code></li></ul><p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，这个过程我们上边都唠叨过了，很显然使用<code>idx_key2</code>执行查询的成本更低些。</p></li><li><p>然后分析对于被驱动表的成本最低的执行方案</p><p>此时涉及被驱动表<code>s2</code>的搜索条件就是：</p><ul><li><code>s2.common_field = 常数</code>（这是因为对驱动表<code>s1</code>结果集中的每一条记录，都需要进行一次被驱动表<code>s2</code>的访问，此时那些涉及两表的条件现在相当于只涉及被驱动表<code>s2</code>了。）</li><li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li></ul><p>很显然，第一个条件由于<code>common_field</code>没有用到索引，所以并没有什么卵用，此时访问<code>s2</code>表时可用的方案也是全表扫描和使用<code>idx_key2</code>两种，假设使用<code>idx_key2</code>的成本更小。</p></li></ul><p>所以此时使用<code>s1</code>作为驱动表时的总成本就是（暂时不考虑使用<code>join buffer</code>对成本的影响）：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用idx_key2访问<span class="hljs-built_in">s1</span>的成本 + <span class="hljs-built_in">s1</span>的扇出 × 使用idx_key2访问<span class="hljs-built_in">s2</span>的成本<br></code></pre></td></tr></table></figure></li><li><p>使用<code>s2</code>作为驱动表的情况</p><ul><li><p>分析对于驱动表的成本最低的执行方案</p><p>首先看一下涉及<code>s2</code>表单表的搜索条件有哪些：</p><ul><li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li></ul><p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，假设使用<code>idx_key2</code>执行查询的成本更低些。</p></li><li><p>然后分析对于被驱动表的成本最低的执行方案</p><p>此时涉及被驱动表<code>s1</code>的搜索条件就是：</p><ul><li><code>s1.key1 = 常数</code></li><li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 2000</code></li></ul><p>这时就很有趣了，使用<code>idx_key1</code>可以进行<code>ref</code>方式的访问，使用<code>idx_key2</code>可以使用<code>range</code>方式的访问。这是优化器需要从全表扫描、使用<code>idx_key1</code>、使用<code>idx_key2</code>这几个方案里选出一个成本最低的方案。这里有个问题啊，因为<code>idx_key2</code>的范围区间是确定的：<code>(10, 1000)</code>，怎么计算使用<code>idx_key2</code>的成本我们上边已经说过了，可是在没有真正执行查询前，<code>s1.key1 = 常数</code>中的<code>常数</code>值我们是不知道的，怎么衡量使用<code>idx_key1</code>执行查询的成本呢？其实很简单，直接使用索引统计数据就好了（就是索引列平均一个值重复多少次）。一般情况下，<code>ref</code>的访问方式要比<code>range</code>成本更低，这里假设使用<code>idx_key1</code>进行对<code>s1</code>的访问。</p></li></ul><p>所以此时使用<code>s2</code>作为驱动表时的总成本就是：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">使用idx_key2访问<span class="hljs-built_in">s2</span>的成本 + <span class="hljs-built_in">s2</span>的扇出 × 使用idx_key1访问<span class="hljs-built_in">s1</span>的成本<br></code></pre></td></tr></table></figure></li></ul><p>最后优化器会比较这两种方式的最优访问成本，选取那个成本更低的连接顺序去真正的执行查询。从上边的计算过程也可以看出来，连接查询成本占大头的其实是<code>驱动表扇出数 x 单次访问被驱动表的成本</code>，所以我们的优化重点其实是下边这两个部分：</p><ul><li><p>尽量减少驱动表的扇出</p></li><li><p>对被驱动表的访问成本尽量低</p><p>这一点对于我们实际书写连接查询语句时十分有用，我们需要尽量在被驱动表的连接列上建立索引，这样就可以使用<code>ref</code>访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降到更低了。</p></li></ul><h3 id="多表连接的成本分析">多表连接的成本分析</h3><p>首先要考虑一下多表连接时可能产生出多少种连接顺序：</p><ul><li><p>对于两表连接，比如表A和表B连接</p><p>只有 AB、BA这两种连接顺序。其实相当于<code>2 × 1 = 2</code>种连接顺序。</p></li><li><p>对于三表连接，比如表A、表B、表C进行连接</p><p>有ABC、ACB、BAC、BCA、CAB、CBA这么6种连接顺序。其实相当于<code>3 × 2 × 1 = 6</code>种连接顺序。</p></li><li><p>对于四表连接的话，则会有<code>4 × 3 × 2 × 1 = 24</code>种连接顺序。</p></li><li><p>对于<code>n</code>表连接的话，则有 <code>n × (n-1) × (n-2) × ··· × 1</code>种连接顺序，就是n的阶乘种连接顺序，也就是<code>n!</code>。</p></li></ul><p>有<code>n</code>个表进行连接，<code>MySQL</code>查询优化器要每一种连接顺序的成本都计算一遍么？那可是<code>n!</code>种连接顺序呀。其实真的是要都算一遍，不过设计<code>MySQL</code>的大叔们想了很多办法减少计算非常多种连接顺序的成本的方法：</p><ul><li><p>提前结束某种顺序的成本评估</p><p><code>MySQL</code>在计算各种链接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就压根儿不对该连接顺序继续往下分析了。比方说A、B、C三个表进行连接，已经得到连接顺序<code>ABC</code>是当前的最小连接成本，比方说<code>10.0</code>，在计算连接顺序<code>BCA</code>时，发现<code>B</code>和<code>C</code>的连接成本就已经大于<code>10.0</code>时，就不再继续往后分析<code>BCA</code>这个连接顺序的成本了。</p></li><li><p>系统变量<code>optimizer_search_depth</code></p><p>为了防止无穷无尽的分析各种连接顺序的成本，设计<code>MySQL</code>的大叔们提出了<code>optimizer_search_depth</code>系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与<code>optimizer_search_depth</code>值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间。</p></li><li><p>根据某些规则压根儿就不考虑某些连接顺序</p><p>即使是有上边两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以设计<code>MySQL</code>的大叔干脆提出了一些所谓的<code>启发式规则</code>（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。他们提供了一个系统变量<code>optimizer_prune_level</code>来控制到底是不是用这些启发式规则。</p></li></ul><h2 id="调节成本常数">调节成本常数</h2><p>我们前边已经介绍了两个<code>成本常数</code>：</p><ul><li>读取一个页面花费的成本默认是<code>1.0</code></li><li>检测一条记录是否符合搜索条件的成本默认是<code>0.2</code></li></ul><p>其实除了这两个成本常数，<code>MySQL</code>还支持好多呢，它们被存储到了<code>mysql</code>数据库（这是一个系统数据库，我们之前介绍过）的两个表中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW TABLES FROM mysql LIKE &#x27;%cost%&#x27;;<br>+--------------------------+<br>| Tables_in_mysql (%cost%) |<br>+--------------------------+<br>| engine_cost              |<br>| server_cost              |<br>+--------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>我们在第一章中就说过，一条语句的执行其实是分为两层的：</p><ul><li><code>server</code>层</li><li>存储引擎层</li></ul><p>在<code>server</code>层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在<code>server</code>层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的<code>成本常数</code>就存储在了<code>server_cost</code>表中，而依赖于存储引擎的一些操作对应的<code>成本常数</code>就存储在了<code>engine_cost</code>表中。</p><h3 id="mysql-server-cost表">mysql.server_cost表</h3><p><code>server_cost</code>表中在<code>server</code>层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM mysql.server_cost;<br>+------------------------------+------------+---------------------+---------+<br>| cost_name                    | cost_value | last_update         | comment |<br>+------------------------------+------------+---------------------+---------+<br>| disk_temptable_create_cost   |       NULL | 2018-01-20 12:03:21 | NULL    |<br>| disk_temptable_row_cost      |       NULL | 2018-01-20 12:03:21 | NULL    |<br>| key_compare_cost             |       NULL | 2018-01-20 12:03:21 | NULL    |<br>| memory_temptable_create_cost |       NULL | 2018-01-20 12:03:21 | NULL    |<br>| memory_temptable_row_cost    |       NULL | 2018-01-20 12:03:21 | NULL    |<br>| row_evaluate_cost            |       NULL | 2018-01-20 12:03:21 | NULL    |<br>+------------------------------+------------+---------------------+---------+<br>6 rows in set (0.05 sec)<br></code></pre></td></tr></table></figure><p>我们先看一下<code>server_cost</code>各个列都分别是什么意思：</p><ul><li><p><code>cost_name</code></p><p>表示成本常数的名称。</p></li><li><p><code>cost_value</code></p><p>表示成本常数对应的值。如果该列的值为<code>NULL</code>的话，意味着对应的成本常数会采用默认值。</p></li><li><p><code>last_update</code></p><p>表示最后更新记录的时间。</p></li><li><p><code>comment</code></p><p>注释。</p></li></ul><p>从<code>server_cost</code>中的内容可以看出来，目前在<code>server</code>层的一些操作对应的<code>成本常数</code>有以下几种：</p><table><thead><tr><th>成本常数名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>disk_temptable_create_cost</code></td><td><code>40.0</code></td><td>创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td></tr><tr><td><code>disk_temptable_row_cost</code></td><td><code>1.0</code></td><td>向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td></tr><tr><td><code>key_compare_cost</code></td><td><code>0.1</code></td><td>两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升<code>filesort</code>的成本，让优化器可能更倾向于使用索引完成排序而不是<code>filesort</code>。</td></tr><tr><td><code>memory_temptable_create_cost</code></td><td><code>2.0</code></td><td>创建基于内存的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td></tr><tr><td><code>memory_temptable_row_cost</code></td><td><code>0.2</code></td><td>向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td></tr><tr><td><code>row_evaluate_cost</code></td><td><code>0.2</code></td><td>这个就是我们之前一直使用的检测一条记录是否符合搜索条件的成本，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。</td></tr></tbody></table><blockquote><p>小贴士： MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询（比如对于DISTINCT查询可以建一个带有UNIQUE索引的临时表，直接把需要去重的记录插入到这个临时表中，插入完成之后的记录就是结果集了）。在数据量大的情况下可能创建基于磁盘的临时表，也就是为该临时表使用MyISAM、InnoDB等存储引擎，在数据量不大时可能创建基于内存的临时表，也就是使用Memory存储引擎。关于更多临时表的细节我们并不打算展开唠叨，因为展开可能又需要好几万字了，大家知道创建临时表和对这个临时表进行写入和读取的操作代价还是很高的就行了。</p></blockquote><p>这些成本常数在<code>server_cost</code>中的初始值都是<code>NULL</code>，意味着优化器会使用它们的默认值来计算某个操作的成本，如果我们想修改某个成本常数的值的话，需要做两个步骤：</p><ul><li><p>对我们感兴趣的成本常数做更新操作</p><p>比方说我们想把检测一条记录是否符合搜索条件的成本增大到<code>0.4</code>，那么就可以这样写更新语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE mysql.server_cost <br>    SET cost_value = 0.4<br>    WHERE cost_name = &#x27;row_evaluate_cost&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>让系统重新加载这个表的值。</p><p>使用下边语句即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FLUSH OPTIMIZER_COSTS;<br></code></pre></td></tr></table></figure></li></ul><p>当然，在你修改完某个成本常数后想把它们再改回默认值的话，可以直接把<code>cost_value</code>的值设置为<code>NULL</code>，再使用<code>FLUSH OPTIMIZER_COSTS</code>语句让系统重新加载它就好了。</p><h3 id="mysql-engine-cost表">mysql.engine_cost表</h3><p><code>engine_cost表</code>表中在存储引擎层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM mysql.engine_cost;<br>+-------------+-------------+------------------------+------------+---------------------+---------+<br>| engine_name | device_type | cost_name              | cost_value | last_update         | comment |<br>+-------------+-------------+------------------------+------------+---------------------+---------+<br>| default     |           0 | io_block_read_cost     |       NULL | 2018-01-20 12:03:21 | NULL    |<br>| default     |           0 | memory_block_read_cost |       NULL | 2018-01-20 12:03:21 | NULL    |<br>+-------------+-------------+------------------------+------------+---------------------+---------+<br>2 rows in set (0.05 sec)<br></code></pre></td></tr></table></figure><p>与<code>server_cost</code>相比，<code>engine_cost</code>多了两个列：</p><ul><li><p><code>engine_name</code>列</p><p>指成本常数适用的存储引擎名称。如果该值为<code>default</code>，意味着对应的成本常数适用于所有的存储引擎。</p></li><li><p><code>device_type</code>列</p><p>指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，不过在<code>MySQL 5.7.21</code>这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是<code>0</code>。</p></li></ul><p>我们从<code>engine_cost</code>表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：</p><table><thead><tr><th>成本常数名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>io_block_read_cost</code></td><td><code>1.0</code></td><td>从磁盘上读取一个块对应的成本。请注意我使用的是<code>块</code>，而不是<code>页</code>这个词儿。对于<code>InnoDB</code>存储引擎来说，一个<code>页</code>就是一个块，不过对于<code>MyISAM</code>存储引擎来说，默认是以<code>4096</code>字节作为一个块的。增大这个值会加重<code>I/O</code>成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。</td></tr><tr><td><code>memory_block_read_cost</code></td><td><code>1.0</code></td><td>与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本。</td></tr></tbody></table><p>大家看完这两个成本常数的默认值是不是有些疑惑，怎么从内存中和从磁盘上读取一个块的默认成本是一样的，脑子瓦特了？这主要是因为在<code>MySQL</code>目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上，所以设计<code>MySQL</code>的大叔们很粗暴的认为不管这个块有没有加载到内存中，使用的成本都是<code>1.0</code>，不过随着<code>MySQL</code>的发展，等到可以准确预测哪些块在磁盘上，那些块在内存中的那一天，这两个成本常数的默认值可能会改一改吧。</p><blockquote><p>在MySQL8.0+版本中，<code>io_block_read_cost</code>的默认值仍为1，<code>memory_block_read_cost</code>默认值为0.25</p></blockquote><p>与更新<code>server_cost</code>表中的记录一样，我们也可以通过更新<code>engine_cost</code>表中的记录来更改关于存储引擎的成本常数，我们也可以通过为<code>engine_cost</code>表插入新记录的方式来添加只针对某种存储引擎的成本常数：</p><ul><li><p>插入针对某个存储引擎的成本常数</p><p>比如我们想增大<code>InnoDB</code>存储引擎页面<code>I/O</code>的成本，书写正常的插入语句即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO mysql.engine_cost<br>    VALUES (&#x27;InnoDB&#x27;, 0, &#x27;io_block_read_cost&#x27;, 2.0,<br>    CURRENT_TIMESTAMP, &#x27;increase Innodb I/O cost&#x27;);<br></code></pre></td></tr></table></figure></li><li><p>让系统重新加载这个表的值。</p><p>使用下边语句即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FLUSH OPTIMIZER_COSTS;<br></code></pre></td></tr></table></figure></li></ul><h1>13.InnoDB 统计数据是如何收集的</h1><p>我们前边唠叨查询成本的时候经常用到一些统计数据，比如通过<code>SHOW TABLE STATUS</code>可以看到关于表的统计数据，通过<code>SHOW INDEX</code>可以看到关于索引的统计数据，那么这些统计数据是怎么来的呢？它们是以什么方式收集的呢？本章将聚焦于<code>InnoDB</code>存储引擎的统计数据收集策略，看完本章大家就会明白为啥前边老说<code>InnoDB</code>的统计信息是不精确的估计值了（言下之意就是我们不打算介绍<code>MyISAM</code>存储引擎统计数据的收集和存储方式，有想了解的同学自己个儿看看文档哈）。</p><h2 id="两种不同的统计数据存储方式">两种不同的统计数据存储方式</h2><p><code>InnoDB</code>提供了两种存储统计数据的方式：</p><ul><li><p>永久性的统计数据</p><p>这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。</p></li><li><p>非永久性的统计数据</p><p>这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据。</p></li></ul><p>设计<code>MySQL</code>的大叔们给我们提供了系统变量<code>innodb_stats_persistent</code>来控制到底采用哪种方式去存储统计数据。在<code>MySQL 5.6.6</code>之前，<code>innodb_stats_persistent</code>的值默认是<code>OFF</code>，也就是说<code>InnoDB</code>的统计数据默认是存储到内存的，之后的版本中<code>innodb_stats_persistent</code>的值默认是<code>ON</code>，也就是统计数据默认被存储到磁盘中。</p><p>不过<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，也就是说我们可以把某些表的统计数据（以及该表的索引统计数据）存储在磁盘上，把另一些表的统计数据存储在内存中。怎么做到的呢？我们可以在创建和修改表的时候通过指定<code>STATS_PERSISTENT</code>属性来指明该表的统计数据存储方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0);<br><br>ALTER TABLE 表名 Engine=InnoDB, STATS_PERSISTENT = (1|0);<br></code></pre></td></tr></table></figure><p>当<code>STATS_PERSISTENT=1</code>时，表明我们想把该表的统计数据永久的存储到磁盘上，当<code>STATS_PERSISTENT=0</code>时，表明我们想把该表的统计数据临时的存储到内存中。如果我们在创建表时未指定<code>STATS_PERSISTENT</code>属性，那默认采用系统变量<code>innodb_stats_persistent</code>的值作为该属性的值。</p><h2 id="基于磁盘的永久性统计数据">基于磁盘的永久性统计数据</h2><p>当我们选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW TABLES FROM mysql LIKE &#x27;innodb%&#x27;;<br>+---------------------------+<br>| Tables_in_mysql (innodb%) |<br>+---------------------------+<br>| innodb_index_stats        |<br>| innodb_table_stats        |<br>+---------------------------+<br>2 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>可以看到，这两个表都位于<code>mysql</code>系统数据库下边，其中：</p><ul><li><code>innodb_table_stats</code>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li><li><code>innodb_index_stats</code>存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li></ul><p>我们下边的任务就是看一下这两个表里边都有什么以及表里的数据是如何生成的。</p><h3 id="innodb-table-stats">innodb_table_stats</h3><p>直接看一下这个<code>innodb_table_stats</code>表中的各个列都是干嘛的：</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td><code>database_name</code></td><td>数据库名</td></tr><tr><td><code>table_name</code></td><td>表名</td></tr><tr><td><code>last_update</code></td><td>本条记录最后更新时间</td></tr><tr><td><code>n_rows</code></td><td>表中记录的条数</td></tr><tr><td><code>clustered_index_size</code></td><td>表的聚簇索引占用的页面数量</td></tr><tr><td><code>sum_of_other_index_sizes</code></td><td>表的其他索引占用的页面数量</td></tr></tbody></table><p>注意这个表的主键是<code>(database_name,table_name)</code>，也就是innodb_table_stats表的每条记录代表着一个表的统计信息。我们直接看一下这个表里的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM mysql.innodb_table_stats;<br>+---------------+---------------+---------------------+--------+----------------------+--------------------------+<br>| database_name | table_name    | last_update         | n_rows | clustered_index_size | sum_of_other_index_sizes |<br>+---------------+---------------+---------------------+--------+----------------------+--------------------------+<br>| mysql         | gtid_executed | 2018-07-10 23:51:36 |      0 |                    1 |                        0 |<br>| sys           | sys_config    | 2018-07-10 23:51:38 |      5 |                    1 |                        0 |<br>| xiaohaizi     | single_table  | 2018-12-10 17:03:13 |   9693 |                   97 |                      175 |<br>+---------------+---------------+---------------------+--------+----------------------+--------------------------+<br>3 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>可以看到我们熟悉的<code>single_table</code>表的统计信息就对应着<code>mysql.innodb_table_stats</code>的第三条记录。几个重要统计信息项的值如下：</p><ul><li><code>n_rows</code>的值是<code>9693</code>，表明<code>single_table</code>表中大约有<code>9693</code>条记录，注意这个数据是估计值。</li><li><code>clustered_index_size</code>的值是<code>97</code>，表明<code>single_table</code>表的聚簇索引占用97个页面，这个值是也是一个估计值。</li><li><code>sum_of_other_index_sizes</code>的值是<code>175</code>，表明<code>single_table</code>表的其他索引一共占用175个页面，这个值是也是一个估计值。</li></ul><h4 id="n-rows统计项的收集">n_rows统计项的收集</h4><p>为啥老强调<code>n_rows</code>这个统计项的值是估计值呢？现在就来揭晓答案。<code>InnoDB</code>统计一个表中有多少行记录的套路是这样的：</p><ul><li><p>按照一定算法（并不是纯粹随机的）选取几个叶子节点页面，计算每个页面中主键值记录数量，然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的<code>n_rows</code>值。</p><blockquote><p>小贴士： 真实的计算过程比这个稍微复杂一些，不过大致上就是这样的啦～</p></blockquote><p>可以看出来这个<code>n_rows</code>值精确与否取决于统计时采样的页面数量，设计<code>MySQL</code>的大叔很贴心的为我们准备了一个名为<code>innodb_stats_persistent_sample_pages</code>的系统变量来控制使用永久性的统计数据时，计算统计数据时采样的页面数量。该值设置的越大，统计出的<code>n_rows</code>值越精确，但是统计耗时也就最久；该值设置的越小，统计出的<code>n_rows</code>值越不精确，但是统计耗时特别少。所以在实际使用是需要我们去权衡利弊，该系统变量的默认值是<code>20</code>。</p><p>我们前边说过，不过<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，我们也可以单独设置某个表的采样页面的数量，设置方式就是在创建或修改表的时候通过指定<code>STATS_SAMPLE_PAGES</code>属性来指明该表的统计数据存储方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;<br><br>ALTER TABLE 表名 Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;<br></code></pre></td></tr></table></figure><p>如果我们在创建表的语句中并没有指定<code>STATS_SAMPLE_PAGES</code>属性的话，将默认使用系统变量<code>innodb_stats_persistent_sample_pages</code>的值作为该属性的值。</p></li></ul><h4 id="clustered-index-size和sum-of-other-index-sizes统计项的收集">clustered_index_size和sum_of_other_index_sizes统计项的收集</h4><p>统计这两个数据需要大量用到我们之前唠叨的<code>InnoDB</code>表空间的知识，如果大家压根儿没有看那一章，那下边的计算过程大家还是不要看了（看也看不懂）；如果看过了，那大家就会发现<code>InnoDB</code>表空间的知识真是有用啊啊啊！！！</p><p>这两个统计项的收集过程如下：</p><ul><li><p>从数据字典里找到表的各个索引对应的根页面位置。</p><p>系统表<code>SYS_INDEXES</code>里存储了各个索引对应的根页面信息。</p></li><li><p>从根页面的<code>Page Header</code>里找到叶子节点段和非叶子节点段对应的<code>Segment Header</code>。</p><p>在每个索引的根页面的<code>Page Header</code>部分都有两个字段：</p><ul><li><code>PAGE_BTR_SEG_LEAF</code>：表示B+树叶子段的<code>Segment Header</code>信息。</li><li><code>PAGE_BTR_SEG_TOP</code>：表示B+树非叶子段的<code>Segment Header</code>信息。</li></ul></li><li><p>从叶子节点段和非叶子节点段的<code>Segment Header</code>中找到这两个段对应的<code>INODE Entry</code>结构。</p><p>这个是<code>Segment Header</code>结构：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e94d5b165a91f~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cum7dbc812843ac192pfik1raep.png-107.3kB"></li><li><p>从对应的<code>INODE Entry</code>结构中可以找到该段对应所有零散的页面地址以及<code>FREE</code>、<code>NOT_FULL</code>、<code>FULL</code>链表的基节点。</p><p>这个是<code>INODE Entry</code>结构：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e94d5b1e44524~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cum7f49h1beg5uccbq197n1g1b16.png-173.9kB"></li><li><p>直接统计零散的页面有多少个，然后从那三个链表的<code>List Length</code>字段中读出该段占用的区的大小，每个区占用<code>64</code>个页，所以就可以统计出整个段占用的页面。</p><p>这个是链表基节点的示意图：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/167e94d5b17c24e3~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cum7hkiihikm4b88j10461plc1j.png-129.9kB"></li><li><p>分别计算聚簇索引的叶子结点段和非叶子节点段占用的页面数，它们的和就是<code>clustered_index_size</code>的值，按照同样的套路把其余索引占用的页面数都算出来，加起来之后就是<code>sum_of_other_index_sizes</code>的值。</p></li></ul><p>这里需要大家注意一个问题，我们说一个段的数据在非常多时（超过32个页面），会以<code>区</code>为单位来申请空间，这里头的问题是以区为单位申请空间中有一些页可能并没有使用，但是在统计<code>clustered_index_size</code>和<code>sum_of_other_index_sizes</code>时都把它们算进去了，所以说聚簇索引和其他的索引占用的页面数可能比这两个值要小一些。</p><h3 id="innodb-index-stats">innodb_index_stats</h3><p>直接看一下这个<code>innodb_index_stats</code>表中的各个列都是干嘛的：</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td><code>database_name</code></td><td>数据库名</td></tr><tr><td><code>table_name</code></td><td>表名</td></tr><tr><td><code>index_name</code></td><td>索引名</td></tr><tr><td><code>last_update</code></td><td>本条记录最后更新时间</td></tr><tr><td><code>stat_name</code></td><td>统计项的名称</td></tr><tr><td><code>stat_value</code></td><td>对应的统计项的值</td></tr><tr><td><code>sample_size</code></td><td>为生成统计数据而采样的页面数量</td></tr><tr><td><code>stat_description</code></td><td>对应的统计项的描述</td></tr></tbody></table><p>注意这个表的主键是<code>(database_name,table_name,index_name,stat_name)</code>，其中的<code>stat_name</code>是指统计项的名称，也就是说innodb_index_stats表的每条记录代表着一个索引的一个统计项。可能这会大家有些懵逼这个统计项到底指什么，别着急，我们直接看一下关于<code>single_table</code>表的索引统计数据都有些什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM mysql.innodb_index_stats WHERE table_name = &#x27;single_table&#x27;;<br>+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+<br>| database_name | table_name   | index_name   | last_update         | stat_name    | stat_value | sample_size | stat_description                  |<br>+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+<br>| xiaohaizi     | single_table | PRIMARY      | 2018-12-14 14:24:46 | n_diff_pfx01 |       9693 |          20 | id                                |<br>| xiaohaizi     | single_table | PRIMARY      | 2018-12-14 14:24:46 | n_leaf_pages |         91 |        NULL | Number of leaf pages in the index |<br>| xiaohaizi     | single_table | PRIMARY      | 2018-12-14 14:24:46 | size         |         97 |        NULL | Number of pages in the index      |<br>| xiaohaizi     | single_table | idx_key1     | 2018-12-14 14:24:46 | n_diff_pfx01 |        968 |          28 | key1                              |<br>| xiaohaizi     | single_table | idx_key1     | 2018-12-14 14:24:46 | n_diff_pfx02 |      10000 |          28 | key1,id                           |<br>| xiaohaizi     | single_table | idx_key1     | 2018-12-14 14:24:46 | n_leaf_pages |         28 |        NULL | Number of leaf pages in the index |<br>| xiaohaizi     | single_table | idx_key1     | 2018-12-14 14:24:46 | size         |         29 |        NULL | Number of pages in the index      |<br>| xiaohaizi     | single_table | idx_key2     | 2018-12-14 14:24:46 | n_diff_pfx01 |      10000 |          16 | key2                              |<br>| xiaohaizi     | single_table | idx_key2     | 2018-12-14 14:24:46 | n_leaf_pages |         16 |        NULL | Number of leaf pages in the index |<br>| xiaohaizi     | single_table | idx_key2     | 2018-12-14 14:24:46 | size         |         17 |        NULL | Number of pages in the index      |<br>| xiaohaizi     | single_table | idx_key3     | 2018-12-14 14:24:46 | n_diff_pfx01 |        799 |          31 | key3                              |<br>| xiaohaizi     | single_table | idx_key3     | 2018-12-14 14:24:46 | n_diff_pfx02 |      10000 |          31 | key3,id                           |<br>| xiaohaizi     | single_table | idx_key3     | 2018-12-14 14:24:46 | n_leaf_pages |         31 |        NULL | Number of leaf pages in the index |<br>| xiaohaizi     | single_table | idx_key3     | 2018-12-14 14:24:46 | size         |         32 |        NULL | Number of pages in the index      |<br>| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | n_diff_pfx01 |       9673 |          64 | key_part1                         |<br>| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | n_diff_pfx02 |       9999 |          64 | key_part1,key_part2               |<br>| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | n_diff_pfx03 |      10000 |          64 | key_part1,key_part2,key_part3     |<br>| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | n_diff_pfx04 |      10000 |          64 | key_part1,key_part2,key_part3,id  |<br>| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | n_leaf_pages |         64 |        NULL | Number of leaf pages in the index |<br>| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | size         |         97 |        NULL | Number of pages in the index      |<br>+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+<br>20 rows in set (0.03 sec)<br></code></pre></td></tr></table></figure><p>这个结果有点儿多，正确查看这个结果的方式是这样的：</p><ul><li><p>先查看<code>index_name</code>列，这个列说明该记录是哪个索引的统计信息，从结果中我们可以看出来，<code>PRIMARY</code>索引（也就是主键）占了3条记录，<code>idx_key_part</code>索引占了6条记录。</p></li><li><p>针对<code>index_name</code>列相同的记录，<code>stat_name</code>表示针对该索引的统计项名称，<code>stat_value</code>展示的是该索引在该统计项上的值，<code>stat_description</code>指的是来描述该统计项的含义的。我们来具体看一下一个索引都有哪些统计项：</p><ul><li><p><code>n_leaf_pages</code>：表示该索引的叶子节点占用多少页面。</p></li><li><p><code>size</code>：表示该索引共占用多少页面。</p></li><li><p><code>n_diff_pfx**NN**</code>：表示对应的索引列不重复的值有多少。其中的<code>NN</code>长得有点儿怪呀，啥意思呢？</p><p>其实<code>NN</code>可以被替换为<code>01</code>、<code>02</code>、<code>03</code>… 这样的数字。比如对于<code>idx_key_part</code>来说：</p><ul><li><code>n_diff_pfx01</code>表示的是统计<code>key_part1</code>这单单一个列不重复的值有多少。</li><li><code>n_diff_pfx02</code>表示的是统计<code>key_part1、key_part2</code>这两个列组合起来不重复的值有多少。</li><li><code>n_diff_pfx03</code>表示的是统计<code>key_part1、key_part2、key_part3</code>这三个列组合起来不重复的值有多少。</li><li><code>n_diff_pfx04</code>表示的是统计<code>key_part1、key_part2、key_part3、id</code>这四个列组合起来不重复的值有多少。</li></ul><blockquote><p>小贴士： 这里需要注意的是，对于普通的二级索引，并不能保证它的索引列值是唯一的，比如对于idx_key1来说，key1列就可能有很多值重复的记录。此时只有在索引列上加上主键值才可以区分两条索引列值都一样的二级索引记录。对于主键和唯一二级索引则没有这个问题，它们本身就可以保证索引列值的不重复，所以也不需要再统计一遍在索引列后加上主键值的不重复值有多少。比如上边的idx_key1有n_diff_pfx01、n_diff_pfx02两个统计项，而idx_key2却只有n_diff_pfx01一个统计项。</p></blockquote></li></ul></li><li><p>在计算某些索引列中包含多少不重复值时，需要对一些叶子节点页面进行采样，<code>sample_size</code>列就表明了采样的页面数量是多少。</p><blockquote><p>小贴士： 对于有多个列的联合索引来说，采样的页面数量是：innodb_stats_persistent_sample_pages × 索引列的个数。当需要采样的页面数量大于该索引的叶子节点数量的话，就直接采用全表扫描来统计索引列的不重复值数量了。所以大家可以在查询结果中看到不同索引对应的size列的值可能是不同的。</p></blockquote></li></ul><h3 id="定期更新统计数据">定期更新统计数据</h3><p>随着我们不断的对表进行增删改操作，表中的数据也一直在变化，<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表里的统计数据是不是也应该跟着变一变了？当然要变了，不变的话<code>MySQL</code>查询优化器计算的成本可就差老鼻子远了。设计<code>MySQL</code>的大叔提供了如下两种更新统计数据的方式：</p><ul><li><p>开启<code>innodb_stats_auto_recalc</code>。</p><p>系统变量<code>innodb_stats_auto_recalc</code>决定着服务器是否自动重新计算统计数据，它的默认值是<code>ON</code>，也就是该功能默认是开启的。每个表都维护了一个变量，该变量记录着对该表进行增删改的记录条数，如果发生变动的记录数量超过了表大小的<code>10%</code>，并且自动重新计算统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表。不过自动重新计算统计数据的过程是异步发生的，也就是即使表中变动的记录数超过了<code>10%</code>，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。</p><p>再一次强调，<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，我们也可以单独为某个表设置是否自动重新计算统计数的属性，设置方式就是在创建或修改表的时候通过指定<code>STATS_AUTO_RECALC</code>属性来指明该表的统计数据存储方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_AUTO_RECALC = (1|0);<br><br>ALTER TABLE 表名 Engine=InnoDB, STATS_AUTO_RECALC = (1|0);<br></code></pre></td></tr></table></figure><p>当<code>STATS_AUTO_RECALC=1</code>时，表明我们想让该表自动重新计算统计数据，当<code>STATS_AUTO_RECALC=0</code>时，表明不想让该表自动重新计算统计数据。如果我们在创建表时未指定<code>STATS_AUTO_RECALC</code>属性，那默认采用系统变量<code>innodb_stats_auto_recalc</code>的值作为该属性的值。</p></li><li><p>手动调用<code>ANALYZE TABLE</code>语句来更新统计信息</p><p>如果<code>innodb_stats_auto_recalc</code>系统变量的值为<code>OFF</code>的话，我们也可以手动调用<code>ANALYZE TABLE</code>语句来重新计算统计数据，比如我们可以这样更新关于<code>single_table</code>表的统计数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; ANALYZE TABLE single_table;<br>+------------------------+---------+----------+----------+<br>| Table                  | Op      | Msg_type | Msg_text |<br>+------------------------+---------+----------+----------+<br>| xiaohaizi.single_table | analyze | status   | OK       |<br>+------------------------+---------+----------+----------+<br>1 row in set (0.08 sec)<br></code></pre></td></tr></table></figure><p>需要注意的是，ANALYZE TABLE语句会立即重新计算统计数据，也就是这个过程是同步的，在表中索引多或者采样页面特别多时这个过程可能会特别慢，请不要没事儿就运行一下<code>ANALYZE TABLE</code>语句，最好在业务不是很繁忙的时候再运行。</p></li></ul><h3 id="手动更新innodb-table-stats和innodb-index-stats表">手动更新innodb_table_stats和innodb_index_stats表</h3><p>其实<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表就相当于一个普通的表一样，我们能对它们做增删改查操作。这也就意味着我们可以手动更新某个表或者索引的统计数据。比如说我们想把<code>single_table</code>表关于行数的统计数据更改一下可以这么做：</p><ul><li><p>步骤一：更新<code>innodb_table_stats</code>表。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">UPDATE</span> innodb_table_stats <br>    <span class="hljs-keyword">SET</span> n_rows = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">table_name</span> = <span class="hljs-string">&#x27;single_table&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>步骤二：让<code>MySQL</code>查询优化器重新加载我们更改过的数据。</p><p>更新完<code>innodb_table_stats</code>只是单纯的修改了一个表的数据，需要让<code>MySQL</code>查询优化器重新加载我们更改过的数据，运行下边的命令就可以了：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FLUSH TABLE single_table<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><p>之后我们使用<code>SHOW TABLE STATUS</code>语句查看表的统计数据时就看到<code>Rows</code>行变为了<code>1</code>。</p><h2 id="基于内存的非永久性统计数据">基于内存的非永久性统计数据</h2><p>当我们把系统变量<code>innodb_stats_persistent</code>的值设置为<code>OFF</code>时，之后创建的表的统计数据默认就都是非永久性的了，或者我们直接在创建表或修改表时设置<code>STATS_PERSISTENT</code>属性的值为<code>0</code>，那么该表的统计数据就是非永久性的了。</p><p>与永久性的统计数据不同，非永久性的统计数据采样的页面数量是由<code>innodb_stats_transient_sample_pages</code>控制的，这个系统变量的默认值是<code>8</code>。</p><p>另外，由于非永久性的统计数据经常更新，所以导致<code>MySQL</code>查询优化器计算查询成本的时候依赖的是经常变化的统计数据，也就会生成经常变化的执行计划，这个可能让大家有些懵逼。不过最近的<code>MySQL</code>版本都不咋用这种基于内存的非永久性统计数据了，所以我们也就不深入唠叨它了。</p><h2 id="innodb-stats-method的使用">innodb_stats_method的使用</h2><p>我们知道<code>索引列不重复的值的数量</code>这个统计数据对于<code>MySQL</code>查询优化器十分重要，因为通过它可以计算出在索引列中平均一个值重复多少行，它的应用场景主要有两个：</p><ul><li><p>单表查询中单点区间太多，比方说这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">key</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;xx1&#x27;</span>, <span class="hljs-string">&#x27;xx2&#x27;</span>, ..., <span class="hljs-string">&#x27;xxn&#x27;</span>);<br></code></pre></td></tr></table></figure><p>当<code>IN</code>里的参数数量过多时，采用<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量就太耗费性能了，所以直接依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。</p></li><li><p>连接查询时，如果有涉及两个表的等值匹配连接条件，该连接条件对应的被驱动表中的列又拥有索引时，则可以使用<code>ref</code>访问方法来对被驱动表进行查询，比方说这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">JOIN</span> t2 <span class="hljs-keyword">ON</span> t1.column = t2.<span class="hljs-keyword">key</span> <span class="hljs-keyword">WHERE</span> ...;<br></code></pre></td></tr></table></figure><p>在真正执行对<code>t2</code>表的查询前，<code>t1.comumn</code>的值是不确定的，所以我们也不能通过<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量，所以也只能依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。</p></li></ul><p>在统计索引列不重复的值的数量时，有一个比较烦的问题就是索引列中出现<code>NULL</code>值怎么办，比方说某个索引列的内容是这样：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+------+</span><br><span class="hljs-section">| col  |</span><br><span class="hljs-section">+------+</span><br>|    1 |<br>|    2 |<br>| NULL |<br><span class="hljs-section">| NULL |</span><br><span class="hljs-section">+------+</span><br></code></pre></td></tr></table></figure><p>此时计算这个<code>col</code>列中不重复的值的数量就有下边的分歧：</p><ul><li><p>有的人认为<code>NULL</code>值代表一个未确定的值，所以设计<code>MySQL</code>的大叔才认为任何和<code>NULL</code>值做比较的表达式的值都为<code>NULL</code>，就是这样：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT 1 = NULL;</span><br><span class="hljs-section">+----------+</span><br><span class="hljs-section">| 1 = NULL |</span><br><span class="hljs-section">+----------+</span><br><span class="hljs-section">|     NULL |</span><br><span class="hljs-section">+----------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT 1 != NULL;</span><br><span class="hljs-section">+-----------+</span><br><span class="hljs-section">| 1 != NULL |</span><br><span class="hljs-section">+-----------+</span><br><span class="hljs-section">|      NULL |</span><br><span class="hljs-section">+-----------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT NULL = NULL;</span><br><span class="hljs-section">+-------------+</span><br><span class="hljs-section">| NULL = NULL |</span><br><span class="hljs-section">+-------------+</span><br><span class="hljs-section">|        NULL |</span><br><span class="hljs-section">+-------------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT NULL != NULL;</span><br><span class="hljs-section">+--------------+</span><br><span class="hljs-section">| NULL != NULL |</span><br><span class="hljs-section">+--------------+</span><br><span class="hljs-section">|         NULL |</span><br><span class="hljs-section">+--------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>所以每一个<code>NULL</code>值都是独一无二的，也就是说统计索引列不重复的值的数量时，应该把<code>NULL</code>值当作一个独立的值，所以<code>col</code>列的不重复的值的数量就是：<code>4</code>（分别是1、2、NULL、NULL这四个值）。</p></li><li><p>有的人认为其实<code>NULL</code>值在业务上就是代表没有，所有的<code>NULL</code>值代表的意义是一样的，所以<code>col</code>列不重复的值的数量就是：<code>3</code>（分别是1、2、NULL这三个值）。</p></li><li><p>有的人认为这<code>NULL</code>完全没有意义嘛，所以在统计索引列不重复的值的数量时压根儿不能把它们算进来，所以<code>col</code>列不重复的值的数量就是：<code>2</code>（分别是1、2这两个值）。</p></li></ul><p>设计<code>MySQL</code>的大叔蛮贴心的，他们提供了一个名为<code>innodb_stats_method</code>的系统变量，相当于在计算某个索引列不重复值的数量时如何对待<code>NULL</code>值这个锅甩给了用户，这个系统变量有三个候选值：</p><ul><li><p><code>nulls_equal</code>：认为所有<code>NULL</code>值都是相等的。这个值也是<code>innodb_stats_method</code>的默认值。</p><p>如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别多，所以倾向于不使用索引进行访问。</p></li><li><p><code>nulls_unequal</code>：认为所有<code>NULL</code>值都是不相等的。</p><p>如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别少，所以倾向于使用索引进行访问。</p></li><li><p><code>nulls_ignored</code>：直接把<code>NULL</code>值忽略掉。</p></li></ul><p>反正这个锅是甩给用户了，当你选定了<code>innodb_stats_method</code>值之后，优化器即使选择了不是最优的执行计划，那也跟设计<code>MySQL</code>的大叔们没关系了哈～ 当然对于用户的我们来说，最好不在索引列中存放NULL值才是正解。</p><h2 id="总结-5">总结</h2><ul><li><code>InnoDB</code>以表为单位来收集统计数据，这些统计数据可以是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据。</li><li><code>innodb_stats_persistent</code>控制着使用永久性统计数据还是非永久性统计数据；<code>innodb_stats_persistent_sample_pages</code>控制着永久性统计数据的采样页面数量；<code>innodb_stats_transient_sample_pages</code>控制着非永久性统计数据的采样页面数量；<code>innodb_stats_auto_recalc</code>控制着是否自动重新计算统计数据。</li><li>我们可以针对某个具体的表，在创建和修改表时通过指定<code>STATS_PERSISTENT</code>、<code>STATS_AUTO_RECALC</code>、<code>STATS_SAMPLE_PAGES</code>的值来控制相关统计数据属性。</li><li><code>innodb_stats_method</code>决定着在统计某个索引列不重复值的数量时如何对待<code>NULL</code>值。</li></ul><h1>14.基于规则的优化</h1><p>大家别忘了<code>MySQL</code>本质上是一个软件，设计<code>MySQL</code>的大叔并不能要求使用这个软件的人个个都是数据库高高手，就像我写这本书的时候并不能要求各位在学之前就会了里边儿的知识。</p><blockquote><p>吐槽一下：都会了的人谁还看呢，难道是为了精神上受感化？</p></blockquote><p>也就是说我们无法避免某些同学写一些执行起来十分耗费性能的语句。即使是这样，设计<code>MySQL</code>的大叔还是依据一些规则，竭尽全力的把这个很糟糕的语句转换成某种可以比较高效执行的形式，这个过程也可以被称作<code>查询重写</code>（就是人家觉得你写的语句不好，自己再重写一遍）。本章详细唠叨一下一些比较重要的重写规则。</p><h2 id="条件化简">条件化简</h2><p>我们编写的查询语句的搜索条件本质上是一个表达式，这些表达式可能比较繁杂，或者不能高效的执行，<code>MySQL</code>的查询优化器会为我们简化这些表达式。为了方便大家理解，我们后边举例子的时候都使用诸如<code>a</code>、<code>b</code>、<code>c</code>之类的简单字母代表某个表的列名。</p><h3 id="移除不必要的括号">移除不必要的括号</h3><p>有时候表达式里有许多无用的括号，比如这样：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">((<span class="hljs-name">a</span> = <span class="hljs-number">5</span> AND b = c) OR ((<span class="hljs-name">a</span> &gt; c) AND (<span class="hljs-name">c</span> &lt; <span class="hljs-number">5</span>)))<br></code></pre></td></tr></table></figure><p>看着就很烦，优化器会把那些用不到的括号给干掉，就是这样：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(a = 5 and b = c)</span> <span class="hljs-keyword">OR</span> <span class="hljs-comment">(a &gt; c AND c &lt; 5)</span><br></code></pre></td></tr></table></figure><h3 id="常量传递（constant-propagation）">常量传递（constant_propagation）</h3><p>有时候某个表达式是某个列和某个常量做等值匹配，比如这样：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>当这个表达式和其他涉及列<code>a</code>的表达式使用<code>AND</code>连接起来时，可以将其他表达式中的<code>a</code>的值替换为<code>5</code>，比如这样：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">a = <span class="hljs-number">5</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">b</span> &gt; a<br></code></pre></td></tr></table></figure><p>就可以被转换为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = <span class="hljs-number">5</span> AND b &gt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><blockquote><p>小贴士： 为啥用OR连接起来的表达式就不能进行常量传递呢？自己想想哈～</p></blockquote><h3 id="等值传递（equality-propagation）">等值传递（equality_propagation）</h3><p>有时候多个列之间存在等值匹配的关系，比如这样：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">a = <span class="hljs-keyword">b</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">b</span> = c <span class="hljs-keyword">and</span> c = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>这个表达式可以被简化为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = <span class="hljs-number">5</span> and b = <span class="hljs-number">5</span> and c = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="移除没用的条件（trivial-condition-removal）">移除没用的条件（trivial_condition_removal）</h3><p>对于一些明显永远为<code>TRUE</code>或者<code>FALSE</code>的表达式，优化器会移除掉它们，比如这个表达式：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(a &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">and </span><span class="hljs-keyword">b </span>= <span class="hljs-keyword">b) </span><span class="hljs-keyword">OR </span>(a = <span class="hljs-number">6</span> <span class="hljs-keyword">OR </span><span class="hljs-number">5</span> != <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>很明显，<code>b = b</code>这个表达式永远为<code>TRUE</code>，<code>5 != 5</code>这个表达式永远为<code>FALSE</code>，所以简化后的表达式就是这样的：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(a &lt; 1 and TRUE)</span> <span class="hljs-keyword">OR</span> <span class="hljs-comment">(a = 6 OR FALSE)</span><br></code></pre></td></tr></table></figure><p>可以继续被简化为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> &lt; <span class="hljs-number">1</span> OR a = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="表达式计算">表达式计算</h3><p>在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来，比如这个：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = <span class="hljs-number">5</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>因为<code>5 + 1</code>这个表达式只包含常量，所以就会被化简成：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>但是这里需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，就像这样：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ABS</span><span class="hljs-params">(a)</span></span> &gt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">a</span> &lt; -<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>优化器是不会尝试对这些表达式进行化简的。我们前边说过只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，最好让索引列以单独的形式出现在表达式中。</p><h3 id="HAVING子句和WHERE子句的合并">HAVING子句和WHERE子句的合并</h3><p>如果查询语句中没有出现诸如<code>SUM</code>、<code>MAX</code>等等的聚集函数以及<code>GROUP BY</code>子句，优化器就把<code>HAVING</code>子句和<code>WHERE</code>子句合并起来。</p><h3 id="常量表检测">常量表检测</h3><p>设计<code>MySQL</code>的大叔觉得下边这两种查询运行的特别快：</p><ul><li><p>查询的表中一条记录没有，或者只有一条记录。</p><blockquote><p>小贴士： 大家有没有觉得这一条有点儿不对劲，我还没开始查表呢咋就知道这表里边有几条记录呢？哈哈，这个其实依靠的是统计数据。不过我们说过InnoDB的统计数据数据不准确，所以这一条不能用于使用InnoDB作为存储引擎的表，只能适用于使用Memory或者MyISAM存储引擎的表。</p></blockquote></li><li><p>使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。</p></li></ul><p>设计<code>MySQL</code>的大叔觉得这两种查询花费的时间特别少，少到可以忽略，所以也把通过这两种方式查询的表称之为<code>常量表</code>（英文名：<code>constant tables</code>）。优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本，比方说这个查询语句：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM table<span class="hljs-number">1</span> INNER JOIN table<span class="hljs-number">2</span><br>    <span class="hljs-attribute">ON</span> table<span class="hljs-number">1</span>.column<span class="hljs-number">1</span> = table<span class="hljs-number">2</span>.column<span class="hljs-number">2</span> <br>    <span class="hljs-attribute">WHERE</span> table<span class="hljs-number">1</span>.primary_key = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>很明显，这个查询可以使用主键和常量值的等值匹配来查询<code>table1</code>表，也就是在这个查询中<code>table1</code>表相当于<code>常量表</code>，在分析对<code>table2</code>表的查询成本之前，就会执行对<code>table1</code>表的查询，并把查询中涉及<code>table1</code>表的条件都替换掉，也就是上边的语句会被转换成这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> table<span class="hljs-number">1</span>表记录的各个字段的常量值, table<span class="hljs-number">2</span>.* FROM table<span class="hljs-number">1</span> INNER JOIN table<span class="hljs-number">2</span> <br>    <span class="hljs-attribute">ON</span> table<span class="hljs-number">1</span>表column<span class="hljs-number">1</span>列的常量值 = table<span class="hljs-number">2</span>.column<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h2 id="外连接消除">外连接消除</h2><p>我们前边说过，<code>内连接</code>的驱动表和被驱动表的位置可以相互转换，而<code>左（外）连接</code>和<code>右（外）连接</code>的驱动表和被驱动表是固定的。这就导致<code>内连接</code>可能通过优化表的连接顺序来降低整体的查询成本，而<code>外连接</code>却无法优化表的连接顺序。为了故事的顺利发展，我们还是把之前介绍连接原理时用过的<code>t1</code>和<code>t2</code>表请出来，为了防止大家早就忘掉了，我们再看一下这两个表的结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1 (<br>    m1 <span class="hljs-type">int</span>, <br>    n1 <span class="hljs-type">char</span>(<span class="hljs-number">1</span>)<br>) Engine<span class="hljs-operator">=</span>InnoDB, CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t2 (<br>    m2 <span class="hljs-type">int</span>, <br>    n2 <span class="hljs-type">char</span>(<span class="hljs-number">1</span>)<br>) Engine<span class="hljs-operator">=</span>InnoDB, CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p>为了唤醒大家的记忆，我们再把这两个表中的数据给展示一下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t1;</span><br><span class="hljs-section">+------+------+</span><br><span class="hljs-section">| m1   | n1   |</span><br><span class="hljs-section">+------+------+</span><br>|    1 | a    |<br>|    2 | b    |<br><span class="hljs-section">|    3 | c    |</span><br><span class="hljs-section">+------+------+</span><br>3 rows in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM t2;</span><br><span class="hljs-section">+------+------+</span><br><span class="hljs-section">| m2   | n2   |</span><br><span class="hljs-section">+------+------+</span><br>|    2 | b    |<br>|    3 | c    |<br><span class="hljs-section">|    4 | d    |</span><br><span class="hljs-section">+------+------+</span><br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>我们之前说过，外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃。查询效果就是这样：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br>|    2 | b    |    2 | b    |<br><span class="hljs-section">|    3 | c    |    3 | c    |</span><br><span class="hljs-section">+------+------+------+------+</span><br>2 rows in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br>|    2 | b    |    2 | b    |<br>|    3 | c    |    3 | c    |<br><span class="hljs-section">|    1 | a    | NULL | NULL |</span><br><span class="hljs-section">+------+------+------+------+</span><br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>对于上边例子中的（左）外连接来说，由于驱动表<code>t1</code>中<code>m1=1, n1='a'</code>的记录无法在被驱动表<code>t2</code>中找到符合<code>ON</code>子句条件<code>t1.m1 = t2.m2</code>的记录，所以就直接把这条记录加入到结果集，对应的<code>t2</code>表的<code>m2</code>和<code>n2</code>列的值都设置为<code>NULL</code>。</p><blockquote><p>小贴士： 右（外）连接和左（外）连接其实只在驱动表的选取方式上是不同的，其余方面都是一样的，所以优化器会首先把右（外）连接查询转换成左（外）连接查询。我们后边就不再唠叨右（外）连接了。</p></blockquote><p>我们知道<code>WHERE</code>子句的杀伤力比较大，凡是不符合WHERE子句中条件的记录都不会参与连接。只要我们在搜索条件中指定关于被驱动表相关列的值不为<code>NULL</code>，那么外连接中在被驱动表中找不到符合<code>ON</code>子句条件的驱动表记录也就被排除出最后的结果集了，也就是说：在这种情况下：外连接和内连接也就没有什么区别了！比方说这个查询：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.n2 IS NOT NULL;</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br>|    2 | b    |    2 | b    |<br><span class="hljs-section">|    3 | c    |    3 | c    |</span><br><span class="hljs-section">+------+------+------+------+</span><br>2 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>由于指定了被驱动表<code>t2</code>的<code>n2</code>列不允许为<code>NULL</code>，所以上边的<code>t1</code>和<code>t2</code>表的左（外）连接查询和内连接查询是一样一样的。当然，我们也可以不用显式的指定被驱动表的某个列<code>IS NOT NULL</code>，只要隐含的有这个意思就行了，比方说这样：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">|    2 | b    |    2 | b    |</span><br><span class="hljs-section">+------+------+------+------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>在这个例子中，我们在<code>WHERE</code>子句中指定了被驱动表<code>t2</code>的<code>m2</code>列等于<code>2</code>，也就相当于间接的指定了<code>m2</code>列不为<code>NULL</code>值，所以上边的这个左（外）连接查询其实和下边这个内连接查询是等价的：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">| m1   | n1   | m2   | n2   |</span><br><span class="hljs-section">+------+------+------+------+</span><br><span class="hljs-section">|    2 | b    |    2 | b    |</span><br><span class="hljs-section">+------+------+------+------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>我们把这种在外连接查询中，指定的<code>WHERE</code>子句中包含被驱动表中的列不为<code>NULL</code>值的条件称之为<code>空值拒绝</code>（英文名：<code>reject-NULL</code>）。在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。</p><h2 id="子查询优化">子查询优化</h2><p>我们的主题本来是唠叨<code>MySQL</code>查询优化器是如何处理子查询的，但是我还是有一万个担心好多同学连子查询的语法都没掌握全，所以我们就先唠叨唠叨什么是个子查询（当然不会面面俱到啦，只是说个大概哈），然后再唠叨关于子查询优化的事儿。</p><h3 id="子查询语法">子查询语法</h3><p>想必大家都是妈妈生下来的吧，连孙猴子都有妈妈——石头人。怀孕妈妈肚子里的那个东东就是她的孩子，类似的，在一个查询语句里的某个位置也可以有另一个查询语句，这个出现在某个查询语句的某个位置中的查询就被称为<code>子查询</code>（我们也可以称它为宝宝查询哈哈），那个充当“妈妈”角色的查询也被称之为<code>外层查询</code>。不像人们怀孕时宝宝们都只在肚子里，子查询可以在一个外层查询的各种位置出现，比如：</p><ul><li><p><code>SELECT</code>子句中</p><p>也就是我们平时说的查询列表中，比如这样：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT (SELECT m1 FROM t1 LIMIT 1);</span><br><span class="hljs-section">+-----------------------------+</span><br><span class="hljs-section">| (SELECT m1 FROM t1 LIMIT 1) |</span><br><span class="hljs-section">+-----------------------------+</span><br><span class="hljs-section">|                           1 |</span><br><span class="hljs-section">+-----------------------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>其中的<code>(SELECT m1 FROM t1 LIMIT 1)</code>就是我们唠叨的所谓的<code>子查询</code>。</p></li><li><p><code>FROM</code>子句中</p><p>比如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">SELECT m, n FROM (SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 &gt; 2) AS t;</span><br><span class="hljs-section">+------+------+</span><br><span class="hljs-section">| m    | n    |</span><br><span class="hljs-section">+------+------+</span><br>|    4 | c    |<br><span class="hljs-section">|    5 | d    |</span><br><span class="hljs-section">+------+------+</span><br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>这个例子中的子查询是：<code>(SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 &gt; 2)</code>，很特别的地方是它出现在了<code>FROM</code>子句中。<code>FROM</code>子句里边儿不是存放我们要查询的表的名称么，这里放进来一个子查询是个什么鬼？其实这里我们可以把子查询的查询结果当作是一个表，子查询后边的<code>AS t</code>表明这个子查询的结果就相当于一个名称为<code>t</code>的表，这个名叫<code>t</code>的表的列就是子查询结果中的列，比如例子中表<code>t</code>就有两个列：<code>m</code>列和<code>n</code>列。这个放在<code>FROM</code>子句中的子查询本质上相当于一个<code>表</code>，但又和我们平常使用的表有点儿不一样，设计<code>MySQL</code>的大叔把这种由子查询结果集组成的表称之为<code>派生表</code>。</p></li><li><p><code>WHERE</code>或<code>ON</code>子句中</p><p>把子查询放在外层查询的<code>WHERE</code>子句或者<code>ON</code>子句中可能是我们最常用的一种使用子查询的方式了，比如这样：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);</span><br><span class="hljs-section">+------+------+</span><br><span class="hljs-section">| m1   | n1   |</span><br><span class="hljs-section">+------+------+</span><br>|    2 | b    |<br><span class="hljs-section">|    3 | c    |</span><br><span class="hljs-section">+------+------+</span><br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>这个查询表明我们想要将<code>(SELECT m2 FROM t2)</code>这个子查询的结果作为外层查询的<code>IN</code>语句参数，整个查询语句的意思就是我们想找<code>t1</code>表中的某些记录，这些记录的<code>m1</code>列的值能在<code>t2</code>表的<code>m2</code>列找到匹配的值。</p></li><li><p><code>ORDER BY</code>子句中</p><p>虽然语法支持，但没啥子意义，不唠叨这种情况了。</p></li><li><p><code>GROUP BY</code>子句中</p><p>同上～</p></li></ul><h4 id="按返回的结果集区分子查询">按返回的结果集区分子查询</h4><p>因为子查询本身也算是一个查询，所以可以按照它们返回的不同结果集类型而把这些子查询分为不同的类型：</p><ul><li><p>标量子查询</p><p>那些只返回一个单一值的子查询称之为<code>标量子查询</code>，比如这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> (<span class="hljs-keyword">SELECT</span> m1 <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> m1 <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(m2) <span class="hljs-keyword">FROM</span> t2);<br></code></pre></td></tr></table></figure><p>这两个查询语句中的子查询都返回一个单一的值，也就是一个<code>标量</code>。这些标量子查询可以作为一个单一值或者表达式的一部分出现在查询语句的各个地方。</p></li><li><p>行子查询</p><p>顾名思义，就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。比如这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">1</span> WHERE (m<span class="hljs-number">1</span>, n<span class="hljs-number">1</span>) = (SELECT m<span class="hljs-number">2</span>, n<span class="hljs-number">2</span> FROM t<span class="hljs-number">2</span> LIMIT <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>其中的<code>(SELECT m2, n2 FROM t2 LIMIT 1)</code>就是一个行子查询，整条语句的含义就是要从<code>t1</code>表中找一些记录，这些记录的<code>m1</code>和<code>n1</code>列分别等于子查询结果中的<code>m2</code>和<code>n2</code>列。</p></li><li><p>列子查询</p><p>列子查询自然就是查询出一个列的数据喽，不过这个列的数据需要包含多条记录（只包含一条记录就成了标量子查询了）。比如这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> m1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> m2 <span class="hljs-keyword">FROM</span> t2);<br></code></pre></td></tr></table></figure><p>其中的<code>(SELECT m2 FROM t2)</code>就是一个列子查询，表明查询出<code>t2</code>表的<code>m2</code>列的值作为外层查询<code>IN</code>语句的参数。</p></li><li><p>表子查询</p><p>顾名思义，就是子查询的结果既包含很多条记录，又包含很多个列，比如这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">1</span> WHERE (m<span class="hljs-number">1</span>, n<span class="hljs-number">1</span>) IN (SELECT m<span class="hljs-number">2</span>, n<span class="hljs-number">2</span> FROM t<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>其中的<code>(SELECT m2, n2 FROM t2)</code>就是一个表子查询，这里需要和行子查询对比一下，行子查询中我们用了<code>LIMIT 1</code>来保证子查询的结果只有一条记录，表子查询中不需要这个限制。</p></li></ul><h4 id="按与外层查询关系来区分子查询">按与外层查询关系来区分子查询</h4><ul><li><p>不相关子查询</p><p>如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为<code>不相关子查询</code>。我们前边介绍的那些子查询全部都可以看作不相关子查询，所以也就不举例子了哈。</p></li><li><p>相关子查询</p><p>如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为<code>相关子查询</code>。比如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">1</span> WHERE m<span class="hljs-number">1</span> IN (SELECT m<span class="hljs-number">2</span> FROM t<span class="hljs-number">2</span> WHERE n<span class="hljs-number">1</span> = n<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>例子中的子查询是<code>(SELECT m2 FROM t2 WHERE n1 = n2)</code>，可是这个查询中有一个搜索条件是<code>n1 = n2</code>，别忘了<code>n1</code>是表<code>t1</code>的列，也就是外层查询的列，也就是说子查询的执行需要依赖于外层查询的值，所以这个子查询就是一个<code>相关子查询</code>。</p></li></ul><h4 id="子查询在布尔表达式中的使用">子查询在布尔表达式中的使用</h4><p>你说写下边这样的子查询有啥意义：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> (<span class="hljs-keyword">SELECT</span> m1 <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>貌似没啥意义～ 我们平时用子查询最多的地方就是把它作为布尔表达式的一部分来作为搜索条件用在<code>WHERE</code>子句或者<code>ON</code>子句里。所以我们这里来总结一下子查询在布尔表达式中的使用场景。</p><ul><li><p>使用<code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&lt;&gt;</code>、<code>!=</code>、<code>&lt;=&gt;</code>作为布尔表达式的操作符</p><p>这些操作符具体是啥意思就不用我多介绍了吧，如果你不知道的话，那我真的很佩服你是靠着啥勇气一口气看到这里的～ 为了方便，我们就把这些操作符称为<code>comparison_operator</code>吧，所以子查询组成的布尔表达式就长这样：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">操作数 <span class="hljs-selector-tag">comparison_operator</span> (子查询)<br></code></pre></td></tr></table></figure><p>这里的<code>操作数</code>可以是某个列名，或者是一个常量，或者是一个更复杂的表达式，甚至可以是另一个子查询。但是需要注意的是，这里的子查询只能是标量子查询或者行子查询，也就是子查询的结果只能返回一个单一的值或者只能是一条记录。比如这样（标量子查询）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> m1 <span class="hljs-operator">&lt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(m2) <span class="hljs-keyword">FROM</span> t2);<br></code></pre></td></tr></table></figure><p>或者这样（行子查询）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">1</span> WHERE (m<span class="hljs-number">1</span>, n<span class="hljs-number">1</span>) = (SELECT m<span class="hljs-number">2</span>, n<span class="hljs-number">2</span> FROM t<span class="hljs-number">2</span> LIMIT <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>[NOT] IN/ANY/SOME/ALL子查询</p><p>对于列子查询和表子查询来说，它们的结果集中包含很多条记录，这些记录相当于是一个集合，所以就不能单纯的和另外一个操作数使用<code>comparison_operator</code>来组成布尔表达式了，<code>MySQL</code>通过下面的语法来支持某个操作数和一个集合组成一个布尔表达式：</p><ul><li><p><code>IN</code>或者<code>NOT IN</code></p><p>具体的语法形式如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">操作数 <span class="hljs-selector-attr">[NOT]</span> <span class="hljs-selector-tag">IN</span> (子查询)<br></code></pre></td></tr></table></figure><p>这个布尔表达式的意思是用来判断某个操作数在不在由子查询结果集组成的集合中，比如下边的查询的意思是找出<code>t1</code>表中的某些记录，这些记录存在于子查询的结果集中：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM t<span class="hljs-number">1</span> WHERE (m<span class="hljs-number">1</span>, n<span class="hljs-number">1</span>) IN (SELECT m<span class="hljs-number">2</span>, n<span class="hljs-number">2</span> FROM t<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>ANY/SOME</code>（<code>ANY</code>和<code>SOME</code>是同义词）</p><p>具体的语法形式如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">操作数 <span class="hljs-variable">comparison_operator</span> <span class="hljs-variable">ANY</span>/<span class="hljs-function"><span class="hljs-title">SOME</span>(子查询)</span><br></code></pre></td></tr></table></figure><p>这个布尔表达式的意思是只要子查询结果集中存在某个值和给定的操作数做<code>comparison_operator</code>比较结果为<code>TRUE</code>，那么整个表达式的结果就为<code>TRUE</code>，否则整个表达式的结果就为<code>FALSE</code>。比方说下边这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> m1 &gt; <span class="hljs-keyword">ANY</span>(<span class="hljs-keyword">SELECT</span> m2 <span class="hljs-keyword">FROM</span> t2);<br></code></pre></td></tr></table></figure><p>这个查询的意思就是对于<code>t1</code>表的某条记录的<code>m1</code>列的值来说，如果子查询<code>(SELECT m2 FROM t2)</code>的结果集中存在一个小于<code>m1</code>列的值，那么整个布尔表达式的值就是<code>TRUE</code>，否则为<code>FALSE</code>，也就是说只要<code>m1</code>列的值大于子查询结果集中最小的值，整个表达式的结果就是<code>TRUE</code>，所以上边的查询本质上等价于这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> m1 <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(m2) <span class="hljs-keyword">FROM</span> t2);<br></code></pre></td></tr></table></figure><p>另外，=ANY相当于判断子查询结果集中是否存在某个值和给定的操作数相等，它的含义和IN是相同的。</p></li><li><p><code>ALL</code></p><p>具体的语法形式如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">操作数 <span class="hljs-variable">comparison_operator</span> <span class="hljs-function"><span class="hljs-title">ALL</span>(子查询)</span><br></code></pre></td></tr></table></figure><p>这个布尔表达式的意思是子查询结果集中所有的值和给定的操作数做<code>comparison_operator</code>比较结果为<code>TRUE</code>，那么整个表达式的结果就为<code>TRUE</code>，否则整个表达式的结果就为<code>FALSE</code>。比方说下边这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> m1 &gt; <span class="hljs-keyword">ALL</span>(<span class="hljs-keyword">SELECT</span> m2 <span class="hljs-keyword">FROM</span> t2);<br></code></pre></td></tr></table></figure><p>这个查询的意思就是对于<code>t1</code>表的某条记录的<code>m1</code>列的值来说，如果子查询<code>(SELECT m2 FROM t2)</code>的结果集中的所有值都小于<code>m1</code>列的值，那么整个布尔表达式的值就是<code>TRUE</code>，否则为<code>FALSE</code>，也就是说只要<code>m1</code>列的值大于子查询结果集中最大的值，整个表达式的结果就是<code>TRUE</code>，所以上边的查询本质上等价于这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> m1 <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(m2) <span class="hljs-keyword">FROM</span> t2);<br></code></pre></td></tr></table></figure><blockquote><p>小贴士： 觉得ANY和ALL有点晕的同学多看两遍哈～</p></blockquote></li></ul></li><li><p>EXISTS子查询</p><p>有的时候我们仅仅需要判断子查询的结果集中是否有记录，而不在乎它的记录具体是个啥，可以使用把<code>EXISTS</code>或者<code>NOT EXISTS</code>放在子查询语句前边，就像这样：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[NOT]</span> <span class="hljs-selector-tag">EXISTS</span> (子查询)<br></code></pre></td></tr></table></figure><p>我们举一个例子啊：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> t2);<br></code></pre></td></tr></table></figure><p>对于子查询<code>(SELECT 1 FROM t2)</code>来说，我们并不关心这个子查询最后到底查询出的结果是什么，所以查询列表里填<code>*</code>、某个列名，或者其他啥东西都无所谓，我们真正关心的是子查询的结果集中是否存在记录。也就是说只要<code>(SELECT 1 FROM t2)</code>这个查询中有记录，那么整个<code>EXISTS</code>表达式的结果就为<code>TRUE</code>。</p></li></ul><h4 id="子查询语法注意事项">子查询语法注意事项</h4><ul><li><p>子查询必须用小括号扩起来。</p><p>不扩起来的子查询是非法的，比如这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SELECT</span> m1 <span class="hljs-keyword">FROM</span> t1;<br><br>ERROR <span class="hljs-number">1064</span> (<span class="hljs-number">42000</span>): You have an error <span class="hljs-keyword">in</span> your <span class="hljs-keyword">SQL</span> syntax; <span class="hljs-keyword">check</span> the manual that corresponds <span class="hljs-keyword">to</span> your MySQL <span class="hljs-keyword">server</span> <span class="hljs-keyword">version</span> <span class="hljs-keyword">for</span> the right syntax <span class="hljs-keyword">to</span> use near <span class="hljs-string">&#x27;SELECT m1 FROM t1&#x27;</span> at <span class="hljs-type">line</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>在<code>SELECT</code>子句中的子查询必须是标量子查询。</p><p>如果子查询结果集中有多个列或者多个行，都不允许放在<code>SELECT</code>子句中，也就是查询列表中，比如这样就是非法的：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">mysql&gt; SELECT (SELECT m1, n1 FROM t1);<br><br><span class="hljs-keyword">ERROR </span>1241 (21000): Operand should contain 1 column(s)<br></code></pre></td></tr></table></figure></li><li><p>在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用<code>LIMIT 1</code>语句来限制记录数量。</p></li><li><p>对于<code>[NOT] IN/ANY/SOME/ALL</code>子查询来说，子查询中不允许有<code>LIMIT</code>语句。</p><p>比如这样是非法的：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> m1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t2 <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">2</span>);<br><br>ERROR <span class="hljs-number">1235</span> (<span class="hljs-number">42000</span>): This <span class="hljs-keyword">version</span> <span class="hljs-keyword">of</span> MySQL doesn<span class="hljs-string">&#x27;t yet support &#x27;</span><span class="hljs-keyword">LIMIT</span> &amp; <span class="hljs-keyword">IN</span>/<span class="hljs-keyword">ALL</span>/<span class="hljs-keyword">ANY</span>/<span class="hljs-keyword">SOME</span> subquery<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>为啥不合法？人家就这么规定的，不解释～ 可能以后的版本会支持吧。正因为<code>[NOT] IN/ANY/SOME/ALL</code>子查询不支持<code>LIMIT</code>语句，所以子查询中的这些语句也就是多余的了：</p><ul><li><p><code>ORDER BY</code>子句</p><p>子查询的结果其实就相当于一个集合，集合里的值排不排序一点儿都不重要，比如下边这个语句中的<code>ORDER BY</code>子句简直就是画蛇添足：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> m1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> m2 <span class="hljs-keyword">FROM</span> t2 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> m2);<br></code></pre></td></tr></table></figure></li><li><p><code>DISTINCT</code>语句</p><p>集合里的值去不去重也没啥意义，比如这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> m1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> m2 <span class="hljs-keyword">FROM</span> t2);<br></code></pre></td></tr></table></figure></li><li><p>没有聚集函数以及<code>HAVING</code>子句的<code>GROUP BY</code>子句。</p><p>在没有聚集函数以及<code>HAVING</code>子句时，<code>GROUP BY</code>子句就是个摆设，比如这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> m1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> m2 <span class="hljs-keyword">FROM</span> t2 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> m2);<br></code></pre></td></tr></table></figure></li></ul><p>对于这些冗余的语句，查询优化器在一开始就把它们给干掉了。</p></li><li><p>不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。</p><p>比方说这样：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">mysql&gt; DELETE FROM t1 WHERE m1 &lt; (SELECT MAX(m1) FROM t1);<br><br><span class="hljs-keyword">ERROR </span>1093 (HY000): You can&#x27;t specify target table &#x27;t1&#x27; for update in FROM clause<br></code></pre></td></tr></table></figure></li></ul><h3 id="子查询在MySQL中是怎么执行的">子查询在MySQL中是怎么执行的</h3><p>好了，关于子查询的基础语法我们用最快的速度温习了一遍，如果想了解更多语法细节，大家可以去查看一下<code>MySQL</code>的文档哈，现在我们就假设各位都懂了啥是个子查询了喔，接下来就要唠叨具体某种类型的子查询在<code>MySQL</code>中是怎么执行的了，想想就有点儿小激动呢～ 当然，为了故事的顺利发展，我们的例子也需要跟随形势鸟枪换炮，还是要祭出我们用了n遍的<code>single_table</code>表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> single_table (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    key1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key2 <span class="hljs-type">INT</span>,<br>    key3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    key_part3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    common_field <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    KEY idx_key1 (key1),<br>    <span class="hljs-keyword">UNIQUE</span> KEY idx_key2 (key2),<br>    KEY idx_key3 (key3),<br>    KEY idx_key_part(key_part1, key_part2, key_part3)<br>) Engine<span class="hljs-operator">=</span>InnoDB CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p>为了方便，我们假设有两个表<code>s1</code>、<code>s2</code>与这个<code>single_table</code>表的构造是相同的，而且这两个表里边儿有10000条记录，除id列外其余的列都插入随机值。下边正式开始我们的表演。</p><h4 id="小白们眼中子查询的执行方式">小白们眼中子查询的执行方式</h4><p>在我还是一个单纯无知的少年时，觉得子查询的执行方式是这样的：</p><ul><li><p>如果该子查询是不相关子查询，比如下边这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2);<br></code></pre></td></tr></table></figure><p>我年少时觉得这个查询是的执行方式是这样的：</p><ul><li>先单独执行<code>(SELECT common_field FROM s2)</code>这个子查询。</li><li>然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询<code>SELECT * FROM s1 WHERE key1 IN (...)</code>。</li></ul></li><li><p>如果该子查询是相关子查询，比如下边这个查询：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM s<span class="hljs-number">1</span> <br>    <span class="hljs-attribute">WHERE</span> key<span class="hljs-number">1</span> IN (SELECT common_field FROM s<span class="hljs-number">2</span> WHERE s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> = s<span class="hljs-number">2</span>.key<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>这个查询中的子查询中出现了<code>s1.key2 = s2.key2</code>这样的条件，意味着该子查询的执行依赖着外层查询的值，所以我年少时觉得这个查询的执行方式是这样的：</p><ul><li>先从外层查询中获取一条记录，本例中也就是先从<code>s1</code>表中获取一条记录。</li><li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从<code>s1</code>表中获取的那条记录中找出<code>s1.key2</code>列的值，然后执行子查询。</li><li>最后根据子查询的查询结果来检测外层查询<code>WHERE</code>子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li><li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li></ul></li></ul><p>告诉我不只是我一个人是这样认为的，这样认为的同学请举起你们的双手～～～ 哇唔，还真不少～</p><p>其实设计<code>MySQL</code>的大叔想了一系列的办法来优化子查询的执行，大部分情况下这些优化措施其实挺有效的，但是保不齐有的时候马失前蹄，下边我们详细唠叨各种不同类型的子查询具体是怎么执行的。</p><blockquote><p>小贴士： 我们下边即将唠叨的关于MySQL优化子查询的执行方式的事儿都是基于MySQL5.7这个版本的，以后版本可能有更新的优化策略！</p></blockquote><h4 id="标量子查询、行子查询的执行方式">标量子查询、行子查询的执行方式</h4><p>我们经常在下边两个场景中使用到标量子查询或者行子查询：</p><ul><li><code>SELECT</code>子句中，我们前边说过的在查询列表中的子查询必须是标量子查询。</li><li>子查询使用<code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&lt;&gt;</code>、<code>!=</code>、<code>&lt;=&gt;</code>等操作符和某个操作数组成一个布尔表达式，这样的子查询必须是标量子查询或者行子查询。</li></ul><p>对于上述两种场景中的不相关标量子查询或者行子查询来说，它们的执行方式是简单的，比方说下边这个查询语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key1 = (<span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>它的执行方式和年少的我想的一样：</p><ul><li>先单独执行<code>(SELECT common_field FROM s2 WHERE key3 = 'a' LIMIT 1)</code>这个子查询。</li><li>然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询<code>SELECT * FROM s1 WHERE key1 = ...</code>。</li></ul><p>也就是说，对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了。</p><p>对于相关的标量子查询或者行子查询来说，比如下边这个查询：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM s<span class="hljs-number">1</span> WHERE <br>    <span class="hljs-attribute">key1</span> = (SELECT common_field FROM s<span class="hljs-number">2</span> WHERE s<span class="hljs-number">1</span>.key<span class="hljs-number">3</span> = s<span class="hljs-number">2</span>.key<span class="hljs-number">3</span> LIMIT <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>事情也和年少的我想的一样，它的执行方式就是这样的：</p><ul><li>先从外层查询中获取一条记录，本例中也就是先从<code>s1</code>表中获取一条记录。</li><li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从<code>s1</code>表中获取的那条记录中找出<code>s1.key3</code>列的值，然后执行子查询。</li><li>最后根据子查询的查询结果来检测外层查询<code>WHERE</code>子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li><li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li></ul><p>也就是说对于一开始唠叨的两种使用标量子查询以及行子查询的场景中，<code>MySQL</code>优化器的执行方式并没有什么新鲜的。</p><h4 id="IN子查询优化">IN子查询优化</h4><h5 id="物化表的提出">物化表的提出</h5><p>对于不相关的<code>IN</code>子查询，比如这样：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-comment">&#x27;a&#x27;);</span><br></code></pre></td></tr></table></figure><p>我们最开始的感觉就是这种不相关的<code>IN</code>子查询和不相关的标量子查询或者行子查询是一样一样的，都是把外层查询和子查询当作两个独立的单表查询来对待，可是很遗憾的是设计<code>MySQL</code>的大叔为了优化<code>IN</code>子查询倾注了太多心血（毕竟<code>IN</code>子查询是我们日常生活中最常用的子查询类型），所以整个执行过程并不像我们想象的那么简单(&gt;_&lt;)。</p><p>其实说句老实话，对于不相关的<code>IN</code>子查询来说，如果子查询的结果集中的记录条数很少，那么把子查询和外层查询分别看成两个单独的单表查询效率还是蛮高的，但是如果单独执行子查询后的结果集太多的话，就会导致这些问题：</p><ul><li><p>结果集太多，可能内存中都放不下～</p></li><li><p>对于外层查询来说，如果子查询的结果集太多，那就意味着<code>IN</code>子句中的参数特别多，这就导致：</p><ul><li><p>无法有效的使用索引，只能对外层查询进行全表扫描。</p></li><li><p>在对外层查询执行全表扫描时，由于<code>IN</code>子句中的参数太多，这会导致检测一条记录是否符合和<code>IN</code>子句中的参数匹配花费的时间太长。</p><p>比如说<code>IN</code>子句中的参数只有两个：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">IN</span> (a, b);<br></code></pre></td></tr></table></figure><p>这样相当于需要对<code>tbl_name</code>表中的每条记录判断一下它的<code>column</code>列是否符合<code>column = a OR column = b</code>。在<code>IN</code>子句中的参数比较少时这并不是什么问题，如果<code>IN</code>子句中的参数比较多时，比如这样：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> * FROM tbl_name <span class="hljs-keyword">WHERE</span> column <span class="hljs-keyword">IN</span> (a, b, c <span class="hljs-params">...</span>, <span class="hljs-params">...</span>);<br></code></pre></td></tr></table></figure><p>那么这样每条记录需要判断一下它的<code>column</code>列是否符合<code>column = a OR column = b OR column = c OR ...</code>，这样性能耗费可就多了。</p></li></ul></li></ul><p>于是乎设计<code>MySQL</code>的大叔想了一个招：不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里。写入临时表的过程是这样的：</p><ul><li><p>该临时表的列就是子查询结果集中的列。</p></li><li><p>写入临时表的记录会被去重。</p><p>我们说<code>IN</code>语句是判断某个操作数在不在某个集合中，集合中的值重不重复对整个<code>IN</code>语句的结果并没有啥子关系，所以我们在将结果集写入临时表时对记录进行去重可以让临时表变得更小，更省地方～</p><blockquote><p>小贴士： 临时表如何对记录进行去重？这不是小意思嘛，临时表也是个表，只要为表中记录的所有列建立主键或者唯一索引就好了嘛～</p></blockquote></li><li><p>一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用<code>Memory</code>存储引擎的临时表，而且会为该表建立哈希索引。</p><blockquote><p>小贴士： IN语句的本质就是判断某个操作数在不在某个集合里，如果集合中的数据建立了哈希索引，那么这个匹配的过程就是超级快的。 有同学不知道哈希索引是什么？我这里就不展开了，自己上网找找吧，不会了再来问我～</p></blockquote><p>如果子查询的结果集非常大，超过了系统变量<code>tmp_table_size</code>或者<code>max_heap_table_size</code>，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为<code>B+</code>树索引。</p></li></ul><p>设计<code>MySQL</code>的大叔把这个将子查询结果集中的记录保存到临时表的过程称之为<code>物化</code>（英文名：<code>Materialize</code>）。为了方便起见，我们就把那个存储子查询结果集的临时表称之为<code>物化表</code>。正因为物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行<code>IN</code>语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。</p><h5 id="物化表转连接">物化表转连接</h5><p>事情到这就完了？我们还得重新审视一下最开始的那个查询语句：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-comment">&#x27;a&#x27;);</span><br></code></pre></td></tr></table></figure><p>当我们把子查询进行物化之后，假设子查询物化表的名称为<code>materialized_table</code>，该物化表存储的子查询结果集的列为<code>m_val</code>，那么这个查询其实可以从下边两种角度来看待：</p><ul><li><p>从表<code>s1</code>的角度来看待，整个查询的意思其实是：对于<code>s1</code>表中的每条记录来说，如果该记录的<code>key1</code>列的值在子查询对应的物化表中，则该记录会被加入最终的结果集。画个图表示一下就是这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a8dda5369e68c5~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cvfj9up26i518t91li5ooq1r0u2d.png-84.9kB"></li><li><p>从子查询物化表的角度来看待，整个查询的意思其实是：对于子查询物化表的每个值来说，如果能在<code>s1</code>表中找到对应的<code>key1</code>列的值与该值相等的记录，那么就把这些记录加入到最终的结果集。画个图表示一下就是这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16a8dda5394d3903~tplv-t2oaga2asx-watermark.awebp" class="" title="image_1cvfjg3os1oh1e3o5c11dhd1odd2q.png-67.4kB"></li></ul><p>也就是说其实上边的查询就相当于表<code>s1</code>和子查询物化表<code>materialized_table</code>进行内连接：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> s1.* <span class="hljs-keyword">FROM</span> s1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> materialized_table <span class="hljs-keyword">ON</span> key1 = m_val;<br></code></pre></td></tr></table></figure><p>转化成内连接之后就有意思了，查询优化器可以评估不同连接顺序需要的成本是多少，选取成本最低的那种查询方式执行查询。我们分析一下上述查询中使用外层查询的表<code>s1</code>和物化表<code>materialized_table</code>进行内连接的成本都是由哪几部分组成的：</p><ul><li>如果使用<code>s1</code>表作为驱动表的话，总查询成本由下边几个部分组成：<ul><li>物化子查询时需要的成本</li><li>扫描<code>s1</code>表时的成本</li><li>s1表中的记录数量 × 通过<code>m_val = xxx</code>对<code>materialized_table</code>表进行单表访问的成本（我们前边说过物化表中的记录是不重复的，并且为物化表中的列建立了索引，所以这个步骤显然是非常快的）。</li></ul></li><li>如果使用<code>materialized_table</code>表作为驱动表的话，总查询成本由下边几个部分组成：<ul><li>物化子查询时需要的成本</li><li>扫描物化表时的成本</li><li>物化表中的记录数量 × 通过<code>key1 = xxx</code>对<code>s1</code>表进行单表访问的成本（非常庆幸<code>key1</code>列上建立了索引，所以这个步骤是非常快的）。</li></ul></li></ul><p><code>MySQL</code>查询优化器会通过运算来选择上述成本更低的方案来执行查询。</p><h5 id="将子查询转换为semi-join">将子查询转换为semi-join</h5><p>虽然将子查询进行物化之后再执行查询都会有建立临时表的成本，但是不管怎么说，我们见识到了将子查询转换为连接的强大作用，设计<code>MySQL</code>的大叔继续开脑洞：能不能不进行物化操作直接把子查询转换为连接呢？让我们重新审视一下上边的查询语句：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-comment">&#x27;a&#x27;);</span><br></code></pre></td></tr></table></figure><p>我们可以把这个查询理解成：对于<code>s1</code>表中的某条记录，如果我们能在<code>s2</code>表（准确的说是执行完<code>WHERE s2.key3 = 'a'</code>之后的结果集）中找到一条或多条记录，这些记录的<code>common_field</code>的值等于<code>s1</code>表记录的<code>key1</code>列的值，那么该条<code>s1</code>表的记录就会被加入到最终的结果集。这个过程其实和把<code>s1</code>和<code>s2</code>两个表连接起来的效果很像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> s<span class="hljs-number">1</span>.* FROM s<span class="hljs-number">1</span> INNER JOIN s<span class="hljs-number">2</span> <br>    <span class="hljs-attribute">ON</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">1</span> = s<span class="hljs-number">2</span>.common_field <br>    <span class="hljs-attribute">WHERE</span> s<span class="hljs-number">2</span>.key<span class="hljs-number">3</span> = &#x27;a&#x27;;<br></code></pre></td></tr></table></figure><p>只不过我们不能保证对于<code>s1</code>表的某条记录来说，在<code>s2</code>表（准确的说是执行完<code>WHERE s2.key3 = 'a'</code>之后的结果集）中有多少条记录满足<code>s1.key1 = s2.common_field</code>这个条件，不过我们可以分三种情况讨论：</p><ul><li>情况一：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中没有任何记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录自然也不会加入到最后的结果集。</li><li>情况二：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中有且只有1条记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录会被加入最终的结果集。</li><li>情况三：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中至少有2条记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录会被多次加入最终的结果集。</li></ul><p>对于<code>s1</code>表的某条记录来说，由于我们只关心<code>s2</code>表中是否存在记录满足<code>s1.key1 = s2.common_field</code>这个条件，而不关心具体有多少条记录与之匹配，又因为有<code>情况三</code>的存在，我们上边所说的<code>IN</code>子查询和两表连接之间并不完全等价。但是将子查询转换为连接又真的可以充分发挥优化器的作用，所以设计<code>MySQL</code>的大叔在这里提出了一个新概念 — <code>半连接</code>（英文名：<code>semi-join</code>）。将<code>s1</code>表和<code>s2</code>表进行半连接的意思就是：对于<code>s1</code>表的某条记录来说，我们只关心在<code>s2</code>表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留<code>s1</code>表的记录。为了让大家有更直观的感受，我们假设MySQL内部是这么改写上边的子查询的：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> s<span class="hljs-number">1</span>.* FROM s<span class="hljs-number">1</span> SEMI JOIN s<span class="hljs-number">2</span><br>    <span class="hljs-attribute">ON</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">1</span> = s<span class="hljs-number">2</span>.common_field<br>    <span class="hljs-attribute">WHERE</span> key<span class="hljs-number">3</span> = &#x27;a&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>小贴士： semi-join只是在MySQL内部采用的一种执行子查询的方式，MySQL并没有提供面向用户的semi-join语法，所以我们不需要，也不能尝试把上边这个语句放到黑框框里运行，我只是想说明一下上边的子查询在MySQL内部会被转换为类似上边语句的半连接～</p></blockquote><p>概念是有了，怎么实现这种所谓的<code>半连接</code>呢？设计<code>MySQL</code>的大叔准备了好几种办法。</p><ul><li><p>Table pullout （子查询中的表上拉）</p><p>当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表<code>上拉</code>到外层查询的<code>FROM</code>子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中，比如这个</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key2 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> key2 <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-comment">&#x27;a&#x27;);</span><br></code></pre></td></tr></table></figure><p>由于<code>key2</code>列是<code>s2</code>表的唯一二级索引列，所以我们可以直接把<code>s2</code>表上拉到外层查询的<code>FROM</code>子句中，并且把子查询中的搜索条件合并到外层查询的搜索条件中，上拉之后的查询就是这样的：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> s<span class="hljs-number">1</span>.* FROM s<span class="hljs-number">1</span> INNER JOIN s<span class="hljs-number">2</span> <br>    <span class="hljs-attribute">ON</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">2</span> = s<span class="hljs-number">2</span>.key<span class="hljs-number">2</span> <br>    <span class="hljs-attribute">WHERE</span> s<span class="hljs-number">2</span>.key<span class="hljs-number">3</span> = &#x27;a&#x27;;<br></code></pre></td></tr></table></figure><p>为啥当子查询的查询列表处只有主键或者唯一索引列时，就可以直接将子查询转换为连接查询呢？哎呀，主键或者唯一索引列中的数据本身就是不重复的嘛！所以对于同一条<code>s1</code>表中的记录，你不可能找到两条以上的符合<code>s1.key2 = s2.key2</code>的记录呀～</p></li><li><p>DuplicateWeedout execution strategy （重复值消除）</p><p>对于这个查询来说：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-comment">&#x27;a&#x27;);</span><br></code></pre></td></tr></table></figure><p>转换为半连接查询后，<code>s1</code>表中的某条记录可能在<code>s2</code>表中有多条匹配的记录，所以该条记录可能多次被添加到最后的结果集中，为了消除重复，我们可以建立一个临时表，比方说这个临时表长这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tmp (<br>    id <span class="hljs-keyword">PRIMARY</span> KEY<br>);<br></code></pre></td></tr></table></figure><p>这样在执行连接查询的过程中，每当某条<code>s1</code>表中的记录要加入结果集时，就首先把这条记录的<code>id</code>值加入到这个临时表里，如果添加成功，说明之前这条<code>s1</code>表中的记录并没有加入最终的结果集，现在把该记录添加到最终的结果集；如果添加失败，说明之前这条<code>s1</code>表中的记录已经加入过最终的结果集，这里直接把它丢弃就好了，这种使用临时表消除<code>semi-join</code>结果集中的重复值的方式称之为<code>DuplicateWeedout</code>。</p></li><li><p>LooseScan execution strategy （松散扫描）</p><p>大家看这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key3 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> key1 <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key1 &gt; <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">AND</span> key1 &lt; <span class="hljs-string">&#x27;b&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在子查询中，对于<code>s2</code>表的访问可以使用到<code>key1</code>列的索引，而恰好子查询的查询列表处就是<code>key1</code>列，这样在将该查询转换为半连接查询后，如果将<code>s2</code>作为驱动表执行查询的话，那么执行过程就是这样：</p><img src="/dajiangdahe/2021/11/29/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/16ecb503727bb15e~tplv-t2oaga2asx-watermark.awebp" class="" title="img"><p>如图所示，在<code>s2</code>表的<code>idx_key1</code>索引中，值为<code>'aa'</code>的二级索引记录一共有3条，那么只需要取第一条的值到<code>s1</code>表中查找<code>s1.key3 = 'aa'</code>的记录，如果能在<code>s1</code>表中找到对应的记录，那么就把对应的记录加入到结果集。依此类推，其他值相同的二级索引记录，也只需要取第一条记录的值到<code>s1</code>表中找匹配的记录，这种虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为<code>松散扫描</code>。</p></li><li><p>Semi-join Materialization execution strategy</p><p>我们之前介绍的先把外层查询的<code>IN</code>子句中的不相关子查询进行物化，然后再进行外层查询的表和物化表的连接本质上也算是一种<code>semi-join</code>，只不过由于物化表中没有重复的记录，所以可以直接将子查询转为连接查询。</p></li><li><p>FirstMatch execution strategy （首次匹配）</p><p><code>FirstMatch</code>是一种最原始的半连接执行方式，跟我们年少时认为的相关子查询的执行方式是一样一样的，就是说先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上边这个过程。</p></li></ul><p>对于某些使用<code>IN</code>语句的相关子查询，比方这个查询：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM s<span class="hljs-number">1</span> <br>    <span class="hljs-attribute">WHERE</span> key<span class="hljs-number">1</span> IN (SELECT common_field FROM s<span class="hljs-number">2</span> WHERE s<span class="hljs-number">1</span>.key<span class="hljs-number">3</span> = s<span class="hljs-number">2</span>.key<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>它也可以很方便的转为半连接，转换后的语句类似这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> s<span class="hljs-number">1</span>.* FROM s<span class="hljs-number">1</span> SEMI JOIN s<span class="hljs-number">2</span> <br>    <span class="hljs-attribute">ON</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">1</span> = s<span class="hljs-number">2</span>.common_field AND s<span class="hljs-number">1</span>.key<span class="hljs-number">3</span> = s<span class="hljs-number">2</span>.key<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>然后就可以使用我们上边介绍过的<code>DuplicateWeedout</code>、<code>LooseScan</code>、<code>FirstMatch</code>等半连接执行策略来执行查询，当然，如果子查询的查询列表处只有主键或者唯一二级索引列，还可以直接使用<code>table pullout</code>的策略来执行查询，但是需要大家注意的是，由于相关子查询并不是一个独立的查询，所以不能转换为物化表来执行查询。</p><h5 id="semi-join的适用条件">semi-join的适用条件</h5><p>当然，并不是所有包含<code>IN</code>子查询的查询语句都可以转换为<code>semi-join</code>，只有形如这样的查询才可以被转换为<code>semi-join</code>：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> <span class="hljs-params">...</span> FROM outer_tables <br>    <span class="hljs-keyword">WHERE</span> expr <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-params">...</span> FROM inner_tables <span class="hljs-params">...</span>) <span class="hljs-literal">AND</span> <span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>或者这样的形式也可以：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> <span class="hljs-params">...</span> FROM outer_tables <br>    <span class="hljs-keyword">WHERE</span> (oe1, oe2, <span class="hljs-params">...</span>) <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> ie1, ie2, <span class="hljs-params">...</span> FROM inner_tables <span class="hljs-params">...</span>) <span class="hljs-literal">AND</span> <span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>用文字总结一下，只有符合下边这些条件的子查询才可以被转换为<code>semi-join</code>：</p><ul><li>该子查询必须是和<code>IN</code>语句组成的布尔表达式，并且在外层查询的<code>WHERE</code>或者<code>ON</code>子句中出现。</li><li>外层查询也可以有其他的搜索条件，只不过和<code>IN</code>子查询的搜索条件必须使用<code>AND</code>连接起来。</li><li>该子查询必须是一个单一的查询，不能是由若干查询由<code>UNION</code>连接起来的形式。</li><li>该子查询不能包含<code>GROUP BY</code>或者<code>HAVING</code>语句或者聚集函数。</li><li>… 还有一些条件比较少见，就不唠叨啦～</li></ul><h5 id="不适用于semi-join的情况">不适用于semi-join的情况</h5><p>对于一些不能将子查询转位<code>semi-join</code>的情况，典型的比如下边这几种：</p><ul><li><p>外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用<code>OR</code>连接起来</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-comment">&#x27;a&#x27;)</span><br>        <span class="hljs-built_in">OR</span> key2 &gt; <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure></li><li><p>使用<code>NOT IN</code>而不是<code>IN</code>的情况</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-built_in">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-comment">&#x27;a&#x27;)</span><br></code></pre></td></tr></table></figure></li><li><p>在<code>SELECT</code>子句中的IN子查询的情况</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> key1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">FROM</span> s1 ;<br></code></pre></td></tr></table></figure></li><li><p>子查询中包含<code>GROUP BY</code>、<code>HAVING</code>或者聚集函数的情况</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key2 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> key1);<br></code></pre></td></tr></table></figure></li><li><p>子查询中包含<code>UNION</code>的情况</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-string">&#x27;a&#x27;</span> <br>    <span class="hljs-keyword">UNION</span><br>    <span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-string">&#x27;b&#x27;</span><br>);<br></code></pre></td></tr></table></figure></li></ul><p><code>MySQL</code>仍然留了两手绝活来优化不能转为<code>semi-join</code>查询的子查询，那就是：</p><ul><li><p>对于不相关子查询来说，可以尝试把它们物化之后再参与查询</p><p>比如我们上边提到的这个查询：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-built_in">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> common_field <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key3 = <span class="hljs-comment">&#x27;a&#x27;)</span><br></code></pre></td></tr></table></figure><p>先将子查询物化，然后再判断<code>key1</code>是否在物化表的结果集中可以加快查询执行的速度。</p><blockquote><p>小贴士： 请注意这里将子查询物化之后不能转为和外层查询的表的连接，只能是先扫描s1表，然后对s1表的某条记录来说，判断该记录的key1值在不在物化表中。</p></blockquote></li><li><p>不管子查询是相关的还是不相关的，都可以把<code>IN</code>子查询尝试转为<code>EXISTS</code>子查询</p><p>其实对于任意一个IN子查询来说，都可以被转为<code>EXISTS</code>子查询，通用的例子如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">outer_expr <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> inner_expr FROM <span class="hljs-params">...</span> <span class="hljs-keyword">WHERE</span> subquery_where)<br></code></pre></td></tr></table></figure><p>可以被转换为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> inner_expr <span class="hljs-keyword">FROM</span> ... <span class="hljs-keyword">WHERE</span> subquery_where <span class="hljs-keyword">AND</span> outer_expr<span class="hljs-operator">=</span>inner_expr)<br></code></pre></td></tr></table></figure><p>当然这个过程中有一些特殊情况，比如在<code>outer_expr</code>或者<code>inner_expr</code>值为<code>NULL</code>的情况下就比较特殊。因为有<code>NULL</code>值作为操作数的表达式结果往往是<code>NULL</code>，比方说：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SELECT NULL IN (1, 2, 3);</span><br><span class="hljs-section">+-------------------+</span><br><span class="hljs-section">| NULL IN (1, 2, 3) |</span><br><span class="hljs-section">+-------------------+</span><br><span class="hljs-section">|              NULL |</span><br><span class="hljs-section">+-------------------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT 1 IN (1, 2, 3);</span><br><span class="hljs-section">+----------------+</span><br><span class="hljs-section">| 1 IN (1, 2, 3) |</span><br><span class="hljs-section">+----------------+</span><br><span class="hljs-section">|              1 |</span><br><span class="hljs-section">+----------------+</span><br>1 row in set (0.00 sec)<br><br><span class="hljs-section">mysql&gt; SELECT NULL IN (NULL);</span><br><span class="hljs-section">+----------------+</span><br><span class="hljs-section">| NULL IN (NULL) |</span><br><span class="hljs-section">+----------------+</span><br><span class="hljs-section">|           NULL |</span><br><span class="hljs-section">+----------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>而<code>EXISTS</code>子查询的结果肯定是<code>TRUE</code>或者<code>FASLE</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE NULL = 1);<br>+------------------------------------------+<br>| EXISTS (SELECT 1 FROM s1 WHERE NULL = 1) |<br>+------------------------------------------+<br>|                                        0 |<br>+------------------------------------------+<br>1 row in set (0.01 sec)<br><br>mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE 1 = NULL);<br>+------------------------------------------+<br>| EXISTS (SELECT 1 FROM s1 WHERE 1 = NULL) |<br>+------------------------------------------+<br>|                                        0 |<br>+------------------------------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE NULL = NULL);<br>+---------------------------------------------+<br>| EXISTS (SELECT 1 FROM s1 WHERE NULL = NULL) |<br>+---------------------------------------------+<br>|                                           0 |<br>+---------------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>但是幸运的是，我们大部分使用<code>IN</code>子查询的场景是把它放在<code>WHERE</code>或者<code>ON</code>子句中，而<code>WHERE</code>或者<code>ON</code>子句是不区分<code>NULL</code>和<code>FALSE</code>的，比方说：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> s1 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NULL</span>;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> s1 <span class="hljs-keyword">WHERE</span> <span class="hljs-literal">FALSE</span>;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>所以只要我们的<code>IN</code>子查询是放在<code>WHERE</code>或者<code>ON</code>子句中的，那么<code>IN -&gt; EXISTS</code>的转换就是没问题的。说了这么多，为啥要转换呢？这是因为不转换的话可能用不到索引，比方说下边这个查询：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM s<span class="hljs-number">1</span><br>    <span class="hljs-attribute">WHERE</span> key<span class="hljs-number">1</span> IN (SELECT key<span class="hljs-number">3</span> FROM s<span class="hljs-number">2</span> where s<span class="hljs-number">1</span>.common_field = s<span class="hljs-number">2</span>.common_field) <br>        <span class="hljs-attribute">OR</span> key<span class="hljs-number">2</span> &gt; <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>这个查询中的子查询是一个相关子查询，而且子查询执行的时候不能使用到索引，但是将它转为<code>EXISTS</code>子查询后却可以使用到索引：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM s<span class="hljs-number">1</span><br>    <span class="hljs-attribute">WHERE</span> EXISTS (SELECT <span class="hljs-number">1</span> FROM s<span class="hljs-number">2</span> where s<span class="hljs-number">1</span>.common_field = s<span class="hljs-number">2</span>.common_field AND s<span class="hljs-number">2</span>.key<span class="hljs-number">3</span> = s<span class="hljs-number">1</span>.key<span class="hljs-number">1</span>) <br>        <span class="hljs-attribute">OR</span> key<span class="hljs-number">2</span> &gt; <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>转为<code>EXISTS</code>子查询时便可以使用到<code>s2</code>表的<code>idx_key3</code>索引了。</p><p>需要注意的是，如果<code>IN</code>子查询不满足转换为<code>semi-join</code>的条件，又不能转换为物化表或者转换为物化表的成本太大，那么它就会被转换为<code>EXISTS</code>查询。</p><blockquote><p>小贴士： 在MySQL5.5以及之前的版本没有引进semi-join和物化的方式优化子查询时，优化器都会把IN子查询转换为EXISTS子查询，好多同学就惊呼我明明写的是一个不相关子查询，为啥要按照执行相关子查询的方式来执行呢？所以当时好多声音都是建议大家把子查询转为连接，不过随着MySQL的发展，最近的版本中引入了非常多的子查询优化策略，大家可以稍微放心的使用子查询了，内部的转换工作优化器会为大家自动实现。</p></blockquote></li></ul><h5 id="小结一下">小结一下</h5><ul><li><p>如果<code>IN</code>子查询符合转换为<code>semi-join</code>的条件，查询优化器会优先把该子查询转换为<code>semi-join</code>，然后再考虑下边5种执行半连接的策略中哪个成本最低：</p><ul><li>Table pullout</li><li>DuplicateWeedout</li><li>LooseScan</li><li>Materialization</li><li>FirstMatch</li></ul><p>选择成本最低的那种执行策略来执行子查询。</p></li><li><p>如果<code>IN</code>子查询不符合转换为<code>semi-join</code>的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：</p><ul><li>先将子查询物化之后再执行查询</li><li>执行<code>IN to EXISTS</code>转换。</li></ul></li></ul><h4 id="ANY-ALL子查询优化">ANY/ALL子查询优化</h4><p>如果ANY/ALL子查询是不相关子查询的话，它们在很多场合都能转换成我们熟悉的方式去执行，比方说：</p><table><thead><tr><th>原始表达式</th><th>转换为</th></tr></thead><tbody><tr><td>&lt; ANY (SELECT inner_expr …)</td><td>&lt; (SELECT MAX(inner_expr) …)</td></tr><tr><td>&gt; ANY (SELECT inner_expr …)</td><td>&gt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&lt; ALL (SELECT inner_expr …)</td><td>&lt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&gt; ALL (SELECT inner_expr …)</td><td>&gt; (SELECT MAX(inner_expr) …)</td></tr></tbody></table><h4 id="NOT-EXISTS子查询的执行">[NOT] EXISTS子查询的执行</h4><p>如果<code>[NOT] EXISTS</code>子查询是不相关子查询，可以先执行子查询，得出该<code>[NOT] EXISTS</code>子查询的结果是<code>TRUE</code>还是<code>FALSE</code>，并重写原先的查询语句，比如对这个查询来说：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span>) <br>        <span class="hljs-keyword">OR</span> key2 &gt; <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>因为这个语句里的子查询是不相关子查询，所以优化器会首先执行该子查询，假设该EXISTS子查询的结果为<code>TRUE</code>，那么接着优化器会重写查询为：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-literal">TRUE</span> <span class="hljs-keyword">OR</span> key2 &gt; <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>进一步简化后就变成了：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-literal">TRUE</span>;<br></code></pre></td></tr></table></figure><p>对于相关的<code>[NOT] EXISTS</code>子查询来说，比如这个查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> s1.common_field = s2.common_field);<br></code></pre></td></tr></table></figure><p>很不幸，这个查询只能按照我们年少时的那种执行相关子查询的方式来执行。不过如果<code>[NOT] EXISTS</code>子查询中如果可以使用索引的话，那查询速度也会加快不少，比如：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> s1.common_field = s2.key1);<br></code></pre></td></tr></table></figure><p>上边这个<code>EXISTS</code>子查询中可以使用<code>idx_key1</code>来加快查询速度。</p><h4 id="对于派生表的优化">对于派生表的优化</h4><p>我们前边说过把子查询放在外层查询的<code>FROM</code>子句后，那么这个子查询的结果相当于一个<code>派生表</code>，比如下边这个查询：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span>  (<br>        <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">AS</span> d_id,  key3 <span class="hljs-keyword">AS</span> d_key3 <span class="hljs-keyword">FROM</span> s2 <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-comment">&#x27;a&#x27;</span><br>    ) <span class="hljs-keyword">AS</span> derived_s1 <span class="hljs-keyword">WHERE</span> d_key3 = <span class="hljs-comment">&#x27;a&#x27;;</span><br></code></pre></td></tr></table></figure><p>子查询<code>( SELECT id AS d_id, key3 AS d_key3 FROM s2 WHERE key1 = 'a')</code>的结果就相当于一个派生表，这个表的名称是<code>derived_s1</code>，该表有两个列，分别是<code>d_id</code>和<code>d_key3</code>。</p><p>对于含有<code>派生表</code>的查询，<code>MySQL</code>提供了两种执行策略：</p><ul><li><p>最容易想到的就是把派生表物化。</p><p>我们可以将派生表的结果集写到一个内部的临时表中，然后就把这个物化表当作普通表一样参与查询。当然，在对派生表进行物化时，设计<code>MySQL</code>的大叔使用了一种称为<code>延迟物化</code>的策略，也就是在查询中真正使用到派生表时才回去尝试物化派生表，而不是还没开始执行查询呢就把派生表物化掉。比方说对于下边这个含有派生表的查询来说：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> (<br>        <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span><br>    ) <span class="hljs-keyword">AS</span> derived_s1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> s2<br>    <span class="hljs-keyword">ON</span> derived_s1.key1 = s2.key1<br>    <span class="hljs-keyword">WHERE</span> s2.key2 = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>如果采用物化派生表的方式来执行这个查询的话，那么执行时首先会到<code>s2</code>表中找出满足<code>s2.key2 = 1</code>的记录，如果压根儿找不到，说明参与连接的<code>s2</code>表记录就是空的，所以整个查询的结果集就是空的，所以也就没有必要去物化查询中的派生表了。</p></li><li><p>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式</p><p>我们来看这个贼简单的包含派生表的查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">AS</span> derived_s1;<br></code></pre></td></tr></table></figure><p>这个查询本质上就是想查看<code>s1</code>表中满足<code>key1 = 'a'</code>条件的的全部记录，所以和下边这个语句是等价的：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-comment">&#x27;a&#x27;;</span><br></code></pre></td></tr></table></figure><p>对于一些稍微复杂的包含派生表的语句，比如我们上边提到的那个：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> (<br>        <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> s1 <span class="hljs-keyword">WHERE</span> key1 = <span class="hljs-string">&#x27;a&#x27;</span><br>    ) <span class="hljs-keyword">AS</span> derived_s1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> s2<br>    <span class="hljs-keyword">ON</span> derived_s1.key1 = s2.key1<br>    <span class="hljs-keyword">WHERE</span> s2.key2 = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>我们可以将派生表与外层查询的表合并，然后将派生表中的搜索条件放到外层查询的搜索条件中，就像这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM s<span class="hljs-number">1</span> INNER JOIN s<span class="hljs-number">2</span> <br>    <span class="hljs-attribute">ON</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">1</span> = s<span class="hljs-number">2</span>.key<span class="hljs-number">1</span><br>    <span class="hljs-attribute">WHERE</span> s<span class="hljs-number">1</span>.key<span class="hljs-number">1</span> = &#x27;a&#x27; AND s<span class="hljs-number">2</span>.key<span class="hljs-number">2</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这样通过将外层查询和派生表合并的方式成功的消除了派生表，也就意味着我们没必要再付出创建和访问临时表的成本了。可是并不是所有带有派生表的查询都能被成功的和外层查询合并，当派生表中有这些语句就不可以和外层查询合并：</p><ul><li>聚集函数，比如MAX()、MIN()、SUM()啥的</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>LIMIT</li><li>UNION 或者 UNION ALL</li><li>派生表对应的子查询的<code>SELECT</code>子句中含有另一个子查询</li><li>… 还有些不常用的情况就不多说了哈～</li></ul></li></ul><p>所以<code>MySQL</code>在执行带有派生表的时候，优先尝试把派生表和外层查询合并掉，如果不行的话，再把派生表物化掉执行查询。</p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神神鬼鬼</title>
    <link href="/dajiangdahe/2021/11/20/%E3%80%90%E6%95%A3%E6%96%87%E3%80%91God%20ghost%20ghosts/"/>
    <url>/dajiangdahe/2021/11/20/%E3%80%90%E6%95%A3%E6%96%87%E3%80%91God%20ghost%20ghosts/</url>
    
    <content type="html"><![CDATA[<h1>神神鬼鬼（陈平原）</h1><img src="/dajiangdahe/2021/11/20/%E3%80%90%E6%95%A3%E6%96%87%E3%80%91God%20ghost%20ghosts/image-20211120111354124.png" class="" title="image-20211120111354124"><img src="/dajiangdahe/2021/11/20/%E3%80%90%E6%95%A3%E6%96%87%E3%80%91God%20ghost%20ghosts/image-20211120111402751.png" class="" title="image-20211120111402751">]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>散文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单元测试之常用框架</title>
    <link href="/dajiangdahe/2021/11/09/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    <url>/dajiangdahe/2021/11/09/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1>单元测试之常用框架</h1><p>断言机制：将和我们的预期的结果和实际结果进行对比，判断结果是否满足我们的期望</p><hr><p>常用框架：JUnit &amp; Spock</p><p>问题：**JUnit单纯用于测试，不提供mock功能；**JMock或者Mockito提供了mock功能，可以把借口等依赖屏蔽掉，但不提供静态类静态方法的mock；PowerMock或Jmockit虽然提供静态类和方法的mock，但是他们之间需要整合（junit+mockito+powermock）；工具一多，就导致写出的单元测试代码风格迥异；</p><h1>1. JUnit</h1><h2 id="1-导入依赖">1.导入依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--导入依赖--&gt;  <br>&lt;dependency&gt;<br>            &lt;groupId&gt;junit&lt;/groupId&gt;<br>            &lt;artifactId&gt;junit&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">4.12</span>&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="2-案例DEMO">2.案例DEMO</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculate</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a * b;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a / b;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-生成单元测试类">3.生成单元测试类</h2><p>单元测试类可以通过idea的插件<code>TestMe</code>，如果没有可以首先安装<code>TestMe</code>,然后在想要进行单元测试的类使用生成。</p><img src="/dajiangdahe/2021/11/09/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/image-20211109163720421.png" class="" title="image-20211109163720421"><p>点击TestMe，选择想要生成的类型。</p><img src="/dajiangdahe/2021/11/09/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/image-20211109163812587.png" class="" title="image-20211109163812587"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bjut.junitandspockdemo;<br><br><span class="hljs-keyword">import</span> org.junit.Assert;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculateTest</span> </span>&#123;<br>    Calculate calculate = <span class="hljs-keyword">new</span> Calculate();<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> result = calculate.add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>        Assert.assertEquals(<span class="hljs-number">8</span>, result);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> result = calculate.delete(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br>        Assert.assertEquals(<span class="hljs-number">2</span>, result);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMultiply</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> result = calculate.multiply(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        Assert.assertEquals(<span class="hljs-number">1</span>, result);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDivide</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> result = calculate.divide(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        Assert.assertEquals(<span class="hljs-number">1</span>, result);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Generated with love by TestMe :) Please report issues and submit feature requests at: http://weirddev.com/forum#!/testme</span><br></code></pre></td></tr></table></figure><h2 id="4-单元测试规则">4.单元测试规则</h2><blockquote><p>1.<code>@Test</code>修饰</p><p>2.测试方法必须使用<code>public void</code></p><p>3.测试方法不能带参数</p><p>4.测试代码和源代码在不同路径下</p><p>5.测试类的包应该和被测试类保持一致</p><p>6.测试单元中的每个方法可以独立测试</p></blockquote><p><code>assertEquals</code>是一个断言；</p><h2 id="5-常用注解">5.常用注解</h2><blockquote><p><code>@Test(expected=XX.class)</code>------期望出现的异常</p><p><code>@Test(timeout=毫秒)</code></p><p><code>@RunWith</code>更改测试运行器</p></blockquote><h2 id="6-测试套件">6.测试套件</h2><p>如果我们的项目有成千上万个方法，我们需要进行测试类的封装，也就是把测试类嵌套起来，只需要运行测试套件，就能运行所有测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br><br>    Calculate calculate = <span class="hljs-keyword">new</span> Calculate();<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> result = calculate.add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>        Assert.assertEquals(<span class="hljs-number">8</span>, result);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br><br>    Calculate calculate = <span class="hljs-keyword">new</span> Calculate();<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> result = calculate.add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>        Assert.assertEquals(<span class="hljs-number">8</span>, result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>@Suite</code>进行封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.junit.runners.Suite;<br><br><span class="hljs-meta">@RunWith(Suite.class)</span><br><span class="hljs-meta">@Suite</span>.SuiteClasses(&#123;Test1.class,CalculateTest.class&#125;)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuiteTest</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 写一个空类，不包含任何方法</span><br><span class="hljs-comment">    * 更改测试运行容器为Suite.class</span><br><span class="hljs-comment">    * 将测试类作为数组传入到Suite.SuiteClasses(&#123;&#125;)</span><br><span class="hljs-comment">    * */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>参数化配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bjut.junitandspockdemo;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.junit.runners.Parameterized;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.assertEquals;<br><br><span class="hljs-meta">@RunWith(Parameterized.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParameterTest</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> expected = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> input1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> input2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Parameterized</span>.Parameters<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Collection&lt;Object[]&gt; t() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> Object[][]&#123;<br>                &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParameterTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expected, <span class="hljs-keyword">int</span> input1, <span class="hljs-keyword">int</span> input2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.expected = expected;<br>        <span class="hljs-keyword">this</span>.input1 = input1;<br>        <span class="hljs-keyword">this</span>.input2 = input2;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span></span>&#123;<br>        assertEquals(expected,<span class="hljs-keyword">new</span> Calculate().add(input1,input2));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1>2.Spock</h1><p>从行为上规范单测代码，每一种标签对应一种语义，让代码跟具有层次感</p><ul><li>setup：用于定义变量，准备测试数据，构建mock对象等。</li><li>given：输入条件</li><li>when：在这个快中调用测试等方法（mock接口，真实调用）</li><li>then：一般跟在when后面使用，尽可以包含断言语句、异常检查语句、用于检查要测试的方法执行后的结果是否符合预期。</li><li>expect</li><li>where</li><li>with</li><li>and：衔接上标签，补充作用</li><li>cleanup：用户清楚setup块中对环境作出的修改，即当前测试用例中的修改回滚</li></ul><ol><li>单元测试代码开发的成本和效率</li><li>单元测试代码的可读性和后期维护性</li><li>spock自带mock功能</li><li>spring继承spock框架</li></ol><h2 id="1-导入依赖-2">1.导入依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--导入依赖--&gt; <br>&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/org.spockframework/spock-core --&gt;</span><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.spockframework&lt;/groupId&gt;<br>            &lt;artifactId&gt;spock-core&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">2.0</span>-groovy-<span class="hljs-number">3.0</span>&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="2-生成单元测试类">2.生成单元测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bjut.junitandspockdemo<br><br><span class="hljs-keyword">import</span> spock.lang.*<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculateTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Specification</span> </span>&#123;<br>    Calculate calculate = <span class="hljs-keyword">new</span> Calculate()<br><br>    def <span class="hljs-string">&quot;test add&quot;</span>() &#123;<br>        when:<br>        <span class="hljs-keyword">int</span> result = calculate.add(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>        then:<br>        result == <span class="hljs-number">0</span><br>    &#125;<br><br>    def <span class="hljs-string">&quot;test delete&quot;</span>() &#123;<br>        when:<br>        <span class="hljs-keyword">int</span> result = calculate.delete(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>        then:<br>        result == <span class="hljs-number">0</span><br>    &#125;<br><br>    def <span class="hljs-string">&quot;test multiply&quot;</span>() &#123;<br>        when:<br>        <span class="hljs-keyword">int</span> result = calculate.multiply(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>        then:<br>        result == <span class="hljs-number">0</span><br>    &#125;<br><br>    def <span class="hljs-string">&quot;test divide&quot;</span>() &#123;<br>        when:<br>        <span class="hljs-keyword">int</span> result = calculate.divide(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>        then:<br>        result == <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Generated with love by TestMe :) Please report issues and submit feature requests at: http://weirddev.com/forum#!/testme</span><br></code></pre></td></tr></table></figure><h2 id="3-测试结果">3.测试结果</h2><img src="/dajiangdahe/2021/11/09/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/image-20211109171707741.png" class="" title="image-20211109171707741">]]></content>
    
    
    <categories>
      
      <category>插件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUnit &amp; Spock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1>一、网络层次划分</h1><p>计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。因为不同用户的数据终端可能采取的字符集是不同的，两者需要进行通信，必须要在一定的标准上进行。</p><h2 id="1-1-OSI七层网络模型">1.1 OSI七层网络模型</h2><p>为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了”开放系统互联参考模型”，即著名的<strong>OSI/RM模型</strong>（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：<strong>物理层</strong>（Physics Layer）、<strong>数据链路层</strong>（Data Link Layer）、<strong>网络层</strong>（Network Layer）、<strong>传输层</strong>（Transport Layer）、<strong>会话层</strong>（Session Layer）、<strong>表示层</strong>（Presentation Layer）、<strong>应用层</strong>（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。</p><p>除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：</p><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20211103192227336.png" class="" title="image-20211103192227336"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20211103192238025.png" class="" title="image-20211103192238025"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20211103192253822.png" class="" title="image-20211103192253822"><hr><h1>二、物理层</h1><h2 id="2-1-概述">2.1 概述</h2><p><strong>物理层（Physical Layer）</strong>：激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。<strong>该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。</strong></p><ul><li>物理层的任务：<strong>透明地传输比特流</strong>。</li><li>物理层的功能：<strong>为数据段设备提供传送数据通路</strong></li><li>物理层传输单位：<strong>比特</strong></li><li>物理层实现的硬件：<strong>集线器</strong>，<strong>中继器</strong>（Repeater，也叫放大器）</li></ul><hr><h1>三、数据链路层</h1><h2 id="3-1-概述">3.1 概述</h2><p><strong>数据链路层（Data Link Layer）</strong>：在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到<strong>相邻节点的目标机网络层</strong>。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），<strong>帧是数据链路层的传送单位</strong>；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。</p><ul><li>数据链路层的任务：<strong>将网络层传输下来的IP数据报组装成帧</strong>、<strong>物理地址寻址、流量控制、数据的检错、重发</strong>等</li><li>数据链路层的功能：<ul><li><strong>链路连接的建立、拆除和分离</strong></li><li><strong>帧定界和帧同步</strong></li><li><strong>差错检测</strong></li></ul></li><li>物理层传输单位：<strong>帧</strong></li><li>数据链路层实现的硬件：<strong>交换机</strong>、<strong>网桥</strong></li><li>协议：PPP,HDLC、SDLC、STP、ARQ</li></ul><hr><h1>四、网络层</h1><h2 id="4-1-概述">4.1 概述</h2><p><strong>网络层（Network Layer）</strong>：目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果想用尽量少的词来记住网络层，那就是**”路径选择、路由及逻辑寻址”**。</p><p>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。</p><ul><li>网络层的任务：<ul><li>将传输层传下来的报文段<strong>封装成分组</strong></li><li><strong>选择合适的路由</strong>，使得传输层传下来的分组能够交付到目的主机</li></ul></li><li>网络层的功能：<ul><li>为传输层提供服务</li><li>组包和拆包</li><li>路由选择</li><li>拥塞控制</li></ul></li><li>网络层传输单位：<strong>数据段</strong></li><li>网络层实现的硬件：<strong>路由器</strong></li><li>协议：ICMP、ARP、RARP、IP、IGMP、OSPF</li></ul><h2 id="4-2-IP协议">4.2 IP协议</h2><h3 id="IP地址">IP地址</h3><h4 id="概述">概述</h4><p>IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>每个IP地址都包含两部分：<strong>网络ID</strong>和<strong>主机ID</strong>，网络ID标识在同一个物理网络上的所有宿主机，主机ID标识网络上的每一个宿主机，运行TCP/IP的每个计算机都需要唯一的IP地址。</p><p><strong>IPV4</strong></p><p>IPV4有一个<strong>32</strong>位的连接地址，由4个8位字段组成，8位字段称为8位位组，每个8位位组之间用点号隔开，用于标识TCP/IP宿主机。</p><p><strong>IPV6</strong></p><p>IPv6的地址长度为<strong>128位</strong>，是IPv4地址长度的4倍，采用十六进制表示。IPv6有3种表示方法。</p><p>主要使用<strong>冒分十六进制</strong>表示法</p><p>格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：</p><p>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</p><h4 id="IPV4和IPV6的区别">IPV4和IPV6的区别</h4><p>IPv4和IPv6是是目前使用的两种Internet协议版本，IPv4和IPv6协议之间存在各种差异，包括它们的功能，但关键的一点是它生成的地址（地址空间）的数量的区别。</p><ol><li><p>协议地址的区别</p><p>（1）地址长度</p><p>IPv4协议具有32位（4字节）地址长度；IPv6协议具有128位（16字节）地址长度。</p><p>（2）地址的表示方法</p><p>IPv4地址是以小数表示的二进制数。 IPv6地址是以十六进制表示的二进制数。</p><p>（3）地址配置</p><p>IPv4协议的地址可以通过手动或DHCP配置的。</p><p>IPv4协议需要使用Internet控制消息协议版本6（ICMPv6）或DHCPv6的无状态地址自动配置（SLAAC）。</p></li><li><p>数据包的区别</p><p>（1）包的大小</p><p>IPv4协议的数据包需要576个字节，碎片可选 ；IPv6协议的数据包需要1280个字节，不会碎片。</p><p>（2）包头</p><p>IPv4协议的包头的长度为20个字节，不识别用于QoS处理的数据包流，包含checksum，包含最多40个字节的选项字段。</p><p>IPv6协议的包头的长度为40个字节，包含指定QoS处理的数据包流的Flow Label字段，不包含checksum；IPv6协议没有字段，但IPv6扩展标头可用。</p><p>（3）数据包碎片</p><p>IPv4协议的数据包碎片会由转发路由器和发送主机完成。IPv6协议的数据包碎片仅由发送主机完成。</p></li><li><p>DNS记录</p><p>IPv4协议的地址（A）记录，映射主机名；指针（PTR）记录，IN-ADDR.ARPA DNS域。</p><p>IPv6协议的地址（AAAA）记录，映射主机名；指针（PTR）记录，IP6.ARPA DNS域</p></li><li><p>IPSec支持</p><p>IPv4协议的IPSec支持只是可选的；IPv6协议有内置的IPSec支持。</p></li><li><p>地址解析协议</p><p>IPv4协议：地址解析协议（ARP）可用于将IPv4地址映射到MAC地址。</p><p>IPv6协议：地址解析协议（ARP）被邻居发现协议（NDP）的功能所取代。</p></li><li><p>身份验证和加密</p><p>Pv6提供身份验证和加密；但IPv4不提供。</p></li></ol><h4 id="IP分类">IP分类</h4><p>Intenet委员会定义了五种地址类型以适应不同尺寸的网络。地址类型定义网络ID使用哪些位,它也定义了网络的可能数目和每个网络可能的宿主机数目．</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210906221555685.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210906221555685.png" class="" title="image-20210906221555685"></a></p><p>IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。 全0和全1的都保留不用。</p><ul><li>A类：(0.0.0.0-127.255.255.255)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。</li><li>B类：(128.0.0.0-191.255.255.255)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。</li><li>C类：(192.0.0.0-223.255.255.255)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。</li><li>D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户 。</li><li>E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。</li></ul><p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><blockquote><p>255.255.255.255</p><p>该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p><p>注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p></blockquote><blockquote><p>0.0.0.0</p><p>常用于寻找自己的IP地址，例如在RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p></blockquote><blockquote><p>回环地址</p><p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p></blockquote><blockquote><p>A、B、C类私有地址</p><p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p><p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p><p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p></blockquote><h4 id="IP为什么要分类">IP为什么要分类</h4><p>根据IP地址访问终端是通过路由器，路由设备当中有一张路由表，该路由表记录了所有IP地址的位置，这样就可以进行包的转发了，如果我们不区分网络地址，那么这张路由表当中就要保存有所有IP地址的方向，这张路由表就会很大，就像下面说的那样：如果不分网络位和主机位，路由器的路由表就是都是32位的地址，那所有的路由器维护的路由表会很大，转发速度会变慢（因为查询变慢）。而且所有的路由器都要有全Internet的地址，所有人的路由器都要有足够的性能来存下全网地址。估计建造这样的Internet成本是现在的几万倍，甚至更高。</p><p><strong>有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护这个网络地址的方向，就可以找到相应的终端了。</strong></p><h3 id="子网掩码">子网掩码</h3><p>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。</p><p>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p><p>使用子网可以把单个大网分成多个物理网络，并用路由器把它们连接起来。</p><p>子网掩码(Subnet Mask)用于<strong>屏蔽IP地址的一部分，使得TCP/IP能够区别网络ID和宿主机ID</strong>。当TCP/IP宿主机要通信时,子网掩码用于判断一个宿主机是在本地网络还是在远程网络。</p><p>缺省的子网掩码用于不分成子网的TCP/IP网络，对应于网络ID的所有位都置为1，每个8位位组的十进制数是255，对应于宿主机ID的所有位都置为0。</p><p>用于子网掩码的位数决定可能的子网数目和每个子网的宿主机数目，子网掩码的位数越多，则子网越多，但是宿主机也较少。</p><p>例：假设A类地址子网数是14，则所需位数至少为4，用于子网的位为：11111111, 11110000, 00000000, 00000000, 子网掩码为255.240.0.0,每个子网的宿主机数目为2^20-2=1,048, 574个。</p><h4 id="有关子网掩码和网络划分常见的面试考题">有关子网掩码和网络划分常见的面试考题</h4><h5 id="利用子网数来计算">利用子网数来计算</h5><p>在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。</p><p>(1) 将子网数目转化为二进制来表示;</p><p>如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；</p><p>(2) 取得该二进制的位数，为N；</p><p>该二进制为五位数，N = 5</p><p>(3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。</p><p>将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0</p><h5 id="利用主机数来计算">利用主机数来计算</h5><p>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：</p><p>(1) 将主机数目转化为二进制来表示<code>700=1010111100</code>；</p><p>(2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位；该二进制为十位数，N=10；</p><p>(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。</p><p>将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。</p><h5 id="根据每个网络的主机数量进行子网地址的规划计算子网掩码">根据每个网络的主机数量进行子网地址的规划计算子网掩码</h5><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：<code>10＋1＋1＋1＝13</code></p><p><strong>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。</strong></p><p>因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。</p><p>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p><h2 id="4-3-ARP-RARP协议">4.3 ARP/RARP协议</h2><p>**地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。**主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。<strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</strong></p><p>ARP工作流程举例：</p><p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p><p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p><p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><p>（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</p><p>（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</p><p>（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p><p>（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</p><p>（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p><p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong></p><p>比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p><p>RARP协议工作流程：</p><p>（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</p><p>（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</p><p>（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</p><p>（4）如果不存在，RARP服务器对此不做任何的响应；</p><h2 id="4-4-路由选择协议">4.4 路由选择协议</h2><p>常见的路由选择协议有：RIP协议、OSPF协议。</p><p><strong>RIP协议</strong> ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><p><strong>OSPF协议</strong> ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p><hr><h1>五、传输层</h1><h2 id="5-1-概述">5.1 概述</h2><p><strong>传输层（Transport Layer）</strong>：负责将上层数据分段并提供<strong>端到端</strong>的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或<strong>报文</strong>。 <strong>网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。</strong></p><p>传输层的作用包括：<strong>将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题</strong>等。</p><p>传输层重要的设备名称：<strong>网关</strong></p><ul><li>传输层的任务：<strong>负责主机中两个进程（端到端）之间的通信</strong></li><li>传输层的功能：<ul><li>为端到端连接提供可靠的服务</li><li>为端到端连接提供流量控制、差错控制、服务质量等管理服务</li></ul></li><li>传输层传输单位：<strong>报文段</strong>（TCP）或<strong>用户数据报</strong>（UDP）</li><li>传输层实现的硬件：<strong>网关</strong></li><li>协议：TCP、UDP</li></ul><h2 id="5-2-TCP协议">5.2 TCP协议</h2><h3 id="概述-2">概述</h3><p>TCP协议全称: <strong>传输控制协议</strong></p><p>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于<strong>端到端</strong>的通讯。TCP提供的是一种可靠的数据流服务，采用”带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为”滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><p>报头如下，首部大小固定20字节</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210907161940230.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210907161940230.png" class="" title="image-20210907161940230"></a></p><ul><li>源端口号/目的端口号: 表示数据从哪个进程来, 到哪个进程去.</li><li>32位序号:</li><li>4位首部长度: 标识该TCP头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。</li><li>6位保留: 顾名思义, 先保留着, 以防万一</li><li>6位标志位</li><li>URG: 标识紧急指针是否有效<ul><li>ACK: 标识确认序号是否有效，我们称携带ACK标识的TCP报文段为<strong>确认报文</strong>段。</li><li>PSH: 用来提示接收端应用程序立刻将数据从tcp缓冲区读走，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中</li><li>RST: 要求重新建立连接。我们把含有RST标识的报文称为<strong>复位报文</strong>段</li><li>SYN: 请求建立连接。我们把含有SYN标识的报文称为<strong>同步报文</strong>段</li><li>FIN: 通知对端，本端即将关闭.。我们把含有FIN标识的报文称为<strong>结束报文</strong>段</li></ul></li><li>16位窗口大小：是TCP<strong>流量控制</strong>的一个手段。这里说的窗口，指的是<strong>接收通道窗口</strong>（Receiver Window，RWND）。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li><li>16位检验和: 由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。</li><li>16位紧急指针:是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</li><li>选项和数据暂时忽略</li></ul><h3 id="TCP如何保证传输可靠性">TCP如何保证传输可靠性</h3><h4 id="校验和">校验和</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 <br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。</p><ul><li>发送方：在发送数据之前计算检验和，并进行校验和的填充。</li><li>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</li></ul><p>注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210907162918376.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210907162918376.png" class="" title="image-20210907162918376"></a></p><h4 id="确认应答-序列号">确认应答+序列号</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">应用数据被分割成 TCP 认为最适合发送的数据块。<br>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。<br>TCP 的接收端会丢弃重复的数据。<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><ul><li>序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。</li><li>确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</li></ul><p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210907165231469.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210907165231469.png" class="" title="image-20210907165231469"></a></p><h4 id="超时重传">超时重传</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 <br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？</p><p>首先，发送方没有接收到响应的ACK报文原因可能有两点：</p><ul><li>数据在传输过程中由于网络原因等直接全体丢包，接收方没有接收到。</li><li>接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。</li></ul><p>TCP在解决这个问题的时候引入了一个新的机制，叫做<strong>超时重传机制</strong>。简单理解就是发送方在发送完数据后等待一个时间（里面有一个超时计数器），时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。</p><h5 id="一般报文超时是怎么确定的？">一般报文超时是怎么确定的？</h5><p>一刀切的办法就是，我<strong>直接把超时时间设成一个固定值</strong>，比如说 200ms，但这样肯定是有问题的，我们的电脑和很多服务器都有交互，这些服务器位于天南海北，国内国外，延迟差异巨大，所以设置固定值是很不可靠的，<strong>我们要根据网络延迟，动态调整超时时间</strong>，延迟越大，超时时间越长。</p><p>在这里先引入两个概念：</p><ul><li>RTT（Round Trip Time）：往返时延，也就是**数据包从发出去到收到对应 ACK 的时间。**RTT 是针对连接的，每一个连接都有各自独立的 RTT。</li><li>RTO（Retransmission Time Out）：重传超时，也就是前面说的超时时间。</li></ul><p>jacobson算法：</p><p>工作原理是：</p><ol><li>将每条连接TCP都保持一个变量RTT。</li><li>当发送一个数据段时，同时启动连接的定时器。</li><li>如果定时器超时前确认到达，则记录所需的时间。</li><li>修正RTT的值。</li><li>如果定时器超时前没有收到确认，则将RTT的值增加一倍。</li></ol><p>[<img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410175136539.png" class="" title="image-20210410175136539"></p><p>发送一个报文段，设定的重传时间到了，还没有收到确认。于是重传报文段，经过一段时间后：收到了确认报文段。</p><p>现在的问题是：如何判定此报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认？由于重传的报文段和原来的报文段完全一样，所以源主机在接受到确认后，无法做出正确的判断，而正确的判断对确定加权平均RTTs的值关系很大。因此产生了Karn算法，只要报文段重传了，就不采用其往返时间样本</p><p>Karn算法：</p><ol><li>报文段每重传一次，就将重传时间增大一些：</li><li>新的重传时间 = γ×(旧的重传时间)</li><li>系数 γ 的典型值是2 。</li><li>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和重传时间的数值。</li></ol><p>实践证明，这种策略较为合理。</p><h5 id="SYN报文重传间隔时间">SYN报文重传间隔时间</h5><p>在实际情况下，由于SYN报文是TCP连接的第一个报文，如果该报文在传输的过程中丢弃了，那么发送方则无法测量RTT，也就无法根据RTT来计算RTO。因此，SYN重传的算法就要简单一些，SYN重传时间间隔一般根据系统实现的不同稍有差别，windows系统一般将第一次重传超时设为3秒，以后每次超时重传时间为上一次的2倍</p><h5 id="重传次数">重传次数</h5><p>在三次握手时，重传次数时可以确定的。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_syn_retries</span> = <span class="hljs-number">6</span>        <span class="hljs-comment">//for client, 用于在syn发送阶段</span><br>net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_synack_retries</span> = <span class="hljs-number">5</span>     <span class="hljs-comment">//for server, 用于在yn-ack发送阶段</span><br>Copy<br></code></pre></td></tr></table></figure><h5 id="ARQ协议">ARQ协议</h5><p>当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层的错误纠正协议之一。它包括停止等待ARQ协议和连续ARQ协议，错误侦测（Error Detection）、正面确认（Positive Acknowledgment）、逾时重传（Retransmission after Timeout）与负面确认继以重传（Negative Acknowledgment and Retransmission）等机制。</p><h4 id="流量控制">流量控制</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP利用滑动窗口实现流量控制）<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传什么的。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。</p><p>在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，<strong>窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小</strong>。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p><p>注：16位的窗口大小最大能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16为窗口字段的值左移M位。每移一位，扩大两倍。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210406215601482.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210406215601482.png" class="" title="image-20210406215601482"></a></p><h5 id="可变滑动窗口">可变滑动窗口</h5><p><a href="https://blog.csdn.net/yao5hed/article/details/81046945">https://blog.csdn.net/yao5hed/article/details/81046945</a></p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410181120147.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410181120147.png" class="" title="image-20210410181120147"></a></p><h5 id="流量控制引发的死锁？怎么避免死锁的发生？">流量控制引发的死锁？怎么避免死锁的发生？</h5><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</p><p>为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p><h4 id="拥塞控制">拥塞控制</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">当网络拥塞时，减少数据的发送。<br><br>发送方有拥塞窗口，发送数据前比对接收方发过来的接收窗口，取小<br><br>慢启动、拥塞避免、拥塞发送、快速恢复<br>应用数据被分割成TCP认为最适合发送的数据块。TCP的接收端会丢弃重复的数据。 <br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">发送方维持一个拥塞窗口 cwnd ( congestion <span class="hljs-keyword">window</span> )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。<br><br>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h5 id="慢启动">慢启动</h5><p>所以TCP引入了<strong>慢启动</strong>的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，<strong>首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。</strong></p><ul><li>算法流程<ul><li>连接建好的开始先初始化cwnd = 1(窗口)，表明可以传一个<strong>MSS</strong>（最大报文段长度）大小的数据</li><li>每当收到一个<strong>ACK</strong>，cwnd++，线性上升</li><li>每当过了一个<strong>RTT</strong>，cwnd = cwnd*2， 呈指数上升。</li><li>ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”</li></ul></li></ul><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410194920966.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410194920966.png" class="" title="image-20210410194920966"></a></p><h5 id="拥塞避免">拥塞避免</h5><p>拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设<strong>置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长</strong>。</p><ul><li>一般来说ssthresh的值是65535字节(2的16次方)，当cwnd达到这个值时后</li><li>算法流程<ul><li>收到一个ACK时，cwnd = cwnd + 1/cwnd</li><li>每过一个RTT时，cwnd = cwnd + 1</li></ul></li></ul><h5 id="阻塞发生">阻塞发生</h5><p>一旦出现网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。</p><p>当丢包的时候，有两种情况</p><ul><li>等到RTO超时，重传数据包，TCP认为该情况太糟糕了<ul><li>sshthreash = swnd / 2</li><li>cwnd 重置为1</li><li>进入<strong>慢启动算法</strong></li></ul></li></ul><p>[<img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210406221637813.png" class="" title="image-20210406221637813"></p><ul><li>快速重传算法，即收到3个重复的ACK就开始重传，无需等待RTO超时<ul><li>TCP Tahoe（代表版本）的实现和RTO超时一样。</li><li>TCP Reno的实现：<ul><li>cwnd = cwnd / 2</li><li>sshthresh = cwnd</li><li>进入<strong>快速恢复算法</strong>——Fast Recovery</li></ul></li></ul></li></ul><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410200127345.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410200127345.png" class="" title="image-20210410200127345"></a></p><p>拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。</p><h5 id="快重传和快恢复">快重传和快恢复</h5><p><strong>快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认</strong>。</p><p>接收方成功的接受了发送方发送来的M1、M2并且分别给发送了ACK，现在接收方没有收到M3，而接收到了M4，显然接收方不能确认M4，因为M4是失序的报文段。如果根据可靠性传输原理接收方什么都不做，但是按照快速重传算法，在收到M4、M5等报文段的时候，不断重复的向发送方发送M2的ACK，如果接收方一连收到三个重复的ACK，那么发送方不必等待重传计时器到期，由发送方尽早重传未被确认的报文段。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410201904592.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210410201904592.png" class="" title="image-20210410201904592"></a></p><p>与快重传配合使用的还有<strong>快恢复</strong>算法，其过程有以下两个要点：</p><ul><li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</li><li>由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ul><blockquote><p>也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p></blockquote><blockquote><h2 id="流量控制和阻塞控制的区别">流量控制和阻塞控制的区别</h2><ul><li>流量控制：流量控制是控制<strong>端到端的速率</strong>，作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</li><li>拥塞控制：拥塞控制是控制<strong>全局网络的速率</strong>，作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</li></ul><p>流量，而拥塞控制。<br>举个例子，<br>1.宽带速率1Gb/s，网络只有两台机器，从一台主机传送数据到另一台，这需要流量控制，以保证接收方能正常接收数据。<br>2.宽带速率1Gb/s，网络中有成千上万台机器，几万台主机发送到另外几万台，这需要拥塞控制，不然网络会瘫痪。<br>所以折中一下，在连接数较少的情况下可能需要流量控制，配合拥塞控制。</p><h2 id="阻塞控制题目">阻塞控制题目</h2><p>设 TCP 的 ssthresh （慢开始门限）的初始值为 8 （单位为报文段）。当拥塞窗口上升到 12 时网络发生了超时， TCP 使用慢开始和拥塞避免。试分别求出第 1 次到第 15 次传输的各拥塞窗口大小。</p><table><thead><tr><th>次数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>拥塞窗口大小</td><td>1</td><td>2</td><td>4</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>1</td><td>2</td><td>4</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></blockquote><h4 id="连接管理">连接管理</h4><h5 id="三次握手">三次握手</h5><ul><li><p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</p></li><li><p>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</p></li><li><p>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</p></li><li><p>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</p></li><li><p>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</p><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210330145507987.png" class="" title="image-20210330145507987"></li></ul><h5 id="为什么不能两次握手">为什么不能两次握手</h5><p>主要是<strong>为了防止已经失效的连接请求报文突然又传送到了服务器</strong>，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的费。<br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h5 id="四次挥手">四次挥手</h5><ul><li><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 <strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号</strong>。</p></li><li><p>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p></li><li><p>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p></li><li><p>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p></li><li><p>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p></li><li><p><strong>服务器只要收到了客户端发出的确认，立即进入CLOSED状态</strong>。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210330145711359.png" class="" title="image-20210330145711359"></li></ul><h5 id="为什么客户端最后还要等待2MSL？">为什么客户端最后还要等待2MSL？</h5><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h3 id="TCP提高性能的机制">TCP提高性能的机制</h3><ul><li><p>滑动窗口（上面写了）</p></li><li><p>快速重传（上面写了）</p></li><li><p>延迟应答</p><ul><li><p>如果接收数据的主机立刻返回ACK应答, 这时候返回的窗口可能比较小。<br>假设接收端缓冲区为1M. 一次收到了500K的数据，如果立刻应答, 返回的窗口大小就是500K。但实际上可能处理端处理的速度很快, 10ms之内就把500K数据从缓冲区消费掉了。在这种情况下, 接收端处理还远没有达到自己的极限, 即使窗口再放大一些, 也能处理过来，如果接收端稍微等一会儿再应答，比如等待200ms再应答, 那么这个时候返回的窗口大小就是1M。</p></li><li><p>不是所有的数据包都可以延迟应答，有两个限制</p><ul><li>数量限制: 每隔N个包就应答一次</li><li>时间限制: 超过最大延迟时间就应答一次</li></ul><blockquote><p>一般 N 取2, 最大延迟时间取200ms</p></blockquote></li></ul></li><li><p>捎带应答</p><ul><li>客户端和服务器在应用层也是 “一发一收” 的，意味着客户端给服务器说了 “How are you”，服务器也会给客户端回一个 “Fine, thank you”。那么这个时候ACK就可以搭顺风车, 和服务器回应的 “Fine, thank you” 一起发送给客户端</li></ul></li></ul><h3 id="TCP-粘包-拆包的原因及解决方法">TCP 粘包/拆包的原因及解决方法</h3><p>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</p><p>首先要明确，粘包问题中的 “包”，是指应用层的数据包。在TCP的协议头中,，没有如同UDP一样的 “报文长度” 字段，但是有一个序号字段。<br>站在传输层的角度，TCP是一个一个报文传过来的，按照序号排好序放在缓冲区中。<br>站在应用层的角度，看到的只是一串连续的字节数据。<br>那么应用程序看到了这一连串的字节数据，就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包。此时数据之间就没有了边界, 就产生了粘包问题</p><p>TCP粘包/分包的原因：</p><p>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</p><p>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</p><p>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。</p><p>解决方法</p><p><strong>消息定长</strong>：FixedLengthFrameDecoder类</p><p>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder</p><p>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</p><p>**对于UDP协议来说, 是否也存在 “粘包问题” **</p><p>对于UDP, 如果还没有向上层交付数据, UDP的报文长度仍然存在.同时, UDP是一个一个把数据交付给应用层的, 就有很明确的数据边界.<br>站在应用层的角度, 使用UDP的时候, 要么收到完整的UDP报文, 要么不收.不会出现收到 “半个” 的情况.</p><h3 id="半连接攻击和全连接攻击">半连接攻击和全连接攻击</h3><p>tcp通信是一个面向连接的过程，客户端要和服务端连接，必须进行连接才能进行通信。在tcp连接中，有两种连接攻击方式，是半连接攻击机和全连接攻击。</p><h4 id="半连接攻击（syn泛洪）">半连接攻击（syn泛洪）</h4><p>半连接攻击是一种攻击协议栈的攻击方式，坦白说就是攻击主机的一种攻击方式。通过将主机的资源消耗殆尽，从而导致应用层的程序无资源可用，导致无法运行。在正常情况下，客户端连接服务端需要通过三次握手，首先客户端构造一个SYN连接数据包发送至服务端，自身进入SYN_SEND状态，当服务端收到客户端的SYN包之后，为其分配内存核心内存，并将其放置在半连接队列中，服务端接收客户SYN包并会向客户端发送一个SYN包和ACK包，此刻服务端进入SYN_RECV态。客户端收到包之后，再次向服务端发送ACK确认包。至此连接建立完成，双方都进入ESTABLSHEDZ状态。半连接就是通过不断地构造客户端的SYN连接数据包发向服务端，等到服务端的半连接队列满的时候，后续的正常用户的连接请求将会被丢弃，从而无法连接到服务端。此为半连接攻击方式。根据服务端的半连接队列的大小，不同主机的抵抗这种SYN攻击的能力也是不一样。</p><p>如何来解决半连接攻击？</p><p>可以通过拓展半连接队列的大小，来进行补救，但缺点是，不能无限制的增加，这样会耗费过多的服务端资源，导致服务端性能地下。这种方式几乎不可取。现主要通syn cookie或者syn中继机制来防范半连接攻，部位半连接分配核心内存的方式来防范。</p><h4 id="全连接攻击">全连接攻击</h4><p>全连接攻击是通过消费服务端进程数和连接数，只连接而不进行发送数据的一种攻击方式。当客户端连接到服务端，仅仅只是连接，此时服务端会为每一个连接创建一个进程来处理客户端发送的数据。但是客户端只是连接而不发送数据，此时服务端会一直阻塞在recv或者read的状态，如此一来，多个连接，服务端的每个连接都是出于阻塞状态从而导致服务端的崩溃。</p><p>如何来解决全连接攻击？</p><p>可以通过不为全连接分配进程处理的方式来防范全连接攻击，具体的情况是当收到数据之后，在为其分配一个处理线程。具体的处理方式在accept返回之前是不分配处理线程的。直到接收相关的数据之后才为之提供一个处理过程。例如在apache服务中，是通过预创建一定量的子进程作为处理连接继承。所有的自己进程都继承父进程的sockfd，每当有一个连接过来时，只有当accept返回是，才会为该链接分配一个进程来处理连接请求。负责，子进程一直处于等待状态。如果出现值是连接存在，而始终不放数据，该链接的状态是SYN_RECV，在协议栈中，提供一个保活期给该链接，如果超过保活期还没有数据到来，服务端协议栈将会断开该链接。如果没有该保活期，虽然避免了ESTABLESHED状态的数量，但是SYN_RECV的数据量的增长仍旧是不可估算的，所以需要利用保活期来监控该链接是需要清除断开。</p><h2 id="5-3-Socket">5.3 Socket</h2><h3 id="如何使用socket实现可靠连接">如何使用socket实现可靠连接</h3><p>sockets（套接字）编程有三种：流式套接字（SOCK_STREAM），数据报套接字（SOCK_DGRAM），原始套接字（SOCK_RAW）；基于TCP的socket编程是采用的流式套接字。</p><ul><li>服务器端编程的步骤</li></ul><p>（1）加载套接字库，创建套接字(WSAStartup()/socket())；</p><p>（2）绑定套接字到一个IP地址和一个端口上(bind())；</p><p>（3）将套接字设置为监听模式等待连接请求(listen())；</p><p>（4）请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字(accept())；</p><p>（5）用返回的套接字和客户端]进行通信(send()/recv())；</p><p>（6）返回，等待另一连接请求；</p><p>（7）关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。</p><ul><li>客户端编程的步骤：</li></ul><p>（1）加载套接字库，创建套接字(WSAStartup()/socket())；</p><p>（2）向服务器发出连接请求(connect())；</p><p>（3）和服务器端进行通信(send()/recv())；</p><p>（4）关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。</p><hr><h1>六、会话层</h1><h2 id="6-1-概述">6.1 概述</h2><p><strong>会话层</strong>：会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p><ul><li>会话层的任务：不同主机上各进程间的对话</li><li>会话层的功能：管理主机间的会话进程，包括建立、管理以及终止进程间的会话。是一种<strong>端到端</strong>的服务</li></ul><hr><h1>七、表示层</h1><h2 id="7-1-概述">7.1 概述</h2><p><strong>表示层</strong>：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p><p>负责处理在两个内部数据表示结构不同的通信系统之间交换信息的表示格式，为数据加密和解密以及为提高传输效率提供必需的数据压缩以及解压等功能。</p><hr><h1>八、应用层</h1><h2 id="8-1-概述">8.1 概述</h2><p><strong>应用层</strong>：为操作系统或网络应用程序提供访问网络服务的接口。</p><ul><li>应用层的任务：提供系统与用户的接口</li><li>应用层的功能：<ul><li>文件传输</li><li>访问和管理</li><li>电子邮件服务</li></ul></li><li>协议：FTP、SMTP、POP3、HTTP、DNS、TELnet</li></ul><h2 id="8-2-从输入URL到浏览器显示页面的流程">8.2 从输入URL到浏览器显示页面的流程</h2><h3 id="URL解析">URL解析</h3><h4 id="1、地址解析">1、地址解析</h4><p>浏览器会根据你的输入来判断该输入是一条合法的URL，还是需要被搜索的关键词。并且根据你输入的内容进行自动完成、字符编码等操作。</p><h4 id="2、其他操作">2、其他操作</h4><p>目前大部分浏览器都会<strong>强制客户端使用HTTPS协议</strong>以保证信息传输的安全性。同时还会进行一些额外的操作，比如安全检查、访问限制等。</p><h4 id="3、缓存检查">3、缓存检查</h4><p>有时候博客在gitee上进行了更新，但是通过谷歌浏览器查看博客时，仍是更新前的博客，这是因为浏览器中缓存了之前的博客界面。</p><p>浏览器会先检测是否缓存了目标URL的页面，如果有且缓存未过期，则直接展示缓存页面，无需再向服务器进行请求</p><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210415185211636.png" class="" title="image-20210415185211636"><h3 id="DNS解析">DNS解析</h3><p><strong>DNS解析是寻找所需要的资源的IP地址的过程</strong>。因为互联网中每一台连网的机器都有<strong>唯一IP作为标识</strong>，但是它是一串数字，记忆太过困难。所以就需要将网址和IP地址进行转换，也就是DNS解析。其具体步骤如下。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210415185234770.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210415185234770.png" class="" title="image-20210415185234770"></a></p><h4 id="第一步：检查浏览器缓存中是否缓存过该域名对应的IP地址">第一步：检查浏览器缓存中是否缓存过该域名对应的IP地址</h4><p>用户通过浏览器浏览过某网站之后，浏览器就会自动缓存该网站域名对应的地址，当用户再次访问的时候，浏览器就会从缓存中查找该域名对应的IP地址，因为缓存不仅是有大小限制，而且还有时间限制（域名被缓存的时间通过属性来设置），所以存在域名对应的找不到的情况。当浏览器从缓存中找到了该网站域名对应的地址，那么整个解析过程结束，如果没有找到，将进行下一步骤。对于的缓存时间问题，不宜设置太长的缓存时间，时间太长，如果域名对应的发生变化，那么用户将在一段时间内无法正常访问到网站，如果太短，那么又造成频繁解析域名。</p><h4 id="第二步：如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP">第二步：如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP</h4><p>如果第一个步骤没有完成对域名的解析过程，那么浏览器会去系统缓存中查找系统是否缓存过这个域名对应的地址，也可以理解为系统自己也具备域名解析的基本能力。在系统中，可以通过设置文件来将域名手动绑定到某上，文件位置在。对于普通用户，并不推荐自己手动绑定域名和，对于开发者来说，通过绑定域名和，可以轻松切换环境，可以从测试环境切换到开发环境，方便开发和测试。在系统中，黑客常常修改他的电脑的文件，将用户常常访问的域名绑定到他指定的上，从而实现了本地解析，导致这些域名被劫持。在或者系统中，文件在，修改该文件也可以实现同样的目的。</p><ul><li>查找<strong>路由器缓存</strong>，通过路由器看看有没有DNS缓存</li></ul><p>前两步都是在本机上完成的，所以没有在上面示例图上展示出来，从第三步开始，才正在地向远程DNS服务器发起解析域名的请求。</p><h4 id="第三步：向本地域名解析服务系统发起域名解析的请求">第三步：向本地域名解析服务系统发起域名解析的请求</h4><p>如果在本机上无法完成域名的解析，那么系统只能请求本地域名解析服务系统进行解析，本地域名系统一般都是本地区的域名服务器，比如你连接的校园网，那么域名解析系统就在你的校园机房里，如果你连接的是电信、移动或者联通的网络，那么本地域名解析服务器就在本地区，由各自的运营商来提供服务。对于本地服务器地址，系统使用命令就可以查看，在和系统下，直接使用命令来查看服务地址。一般都缓存了大部分的域名解析的结果，当然缓存时间也受域名失效时间控制，大部分的解析工作到这里就差不多已经结束了，负责了大部分的解析工作。</p><h4 id="第四步：向根域名解析服务器发起域名解析请求">第四步：向根域名解析服务器发起域名解析请求</h4><p>本地域名解析器还没有完成解析的话，那么本地域名解析服务器将向根域名服务器发起解析请求。</p><h4 id="第五步：根域名服务器返回gTLD（通用顶级域名）域名解析服务器地址">第五步：根域名服务器返回gTLD（通用顶级域名）域名解析服务器地址</h4><p>本地域名解析向根域名服务器发起解析请求，根域名服务器返回的是所查域的通用顶级域（）地址，常见的通用顶级域有cn、com、edu等。</p><h4 id="第六步：向gTLD服务器发起解析请求">第六步：向gTLD服务器发起解析请求</h4><p>本地域名解析服务器向gTLD服务器发起请求。</p><h4 id="第七步：gTLD服务器接收请求并返回Name-Server服务器">第七步：gTLD服务器接收请求并返回Name Server服务器</h4><p>服务器接收本地域名服务器发起的请求，并根据需要解析的域名，找到该域名对应的域名服务器，通常情况下，这个服务器就是你注册的域名服务器，那么你注册的域名的服务商的服务器将承担起域名解析的任务。</p><h4 id="第八步：Name-Server服务器返回IP地址给本地服务器">第八步：Name Server服务器返回IP地址给本地服务器</h4><p>服务器查找域名对应的地址，将地址连同值返回给本地域名服务器。</p><h4 id="第九步：本地域名服务器缓存解析结果">第九步：本地域名服务器缓存解析结果</h4><p>本地域名服务器缓存解析后的结果，缓存时间由时间来控制。</p><blockquote><p>概述版：</p><ul><li>查询缓存</li></ul><p>我们的浏览器、操作系统、路由器都会缓存一些URL对应的IP地址，统称为<strong>DNS高速缓存</strong>。这是为了加快DNS解析速度，使得不必每次都到根域名服务器中去查询。</p><ul><li>递归解析</li></ul><p>输入<code>www.baidu.com</code>网址后，首先在高速缓存中查找，没找到去根域名服务器查找，没有再去<code>com</code>顶级域名服务器查找，依次类推，直到找到IP地址，然后把它记录在本地告诉缓存中，供下次使用。</p><p>大致过程就是<code>.</code>-&gt; <code>.com</code> -&gt;<code>baidu.com.</code> -&gt; <code>www.baidu.com.</code></p><p>其中<code>.</code>代表根域名服务器。</p><ul><li>DNS负载均衡</li></ul><p>访问<code>baidu.com</code>的时候，每次响应的可能并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，DNS可以返回一个<strong>合适的机器的IP</strong>给用户，例如可以<strong>根据每台机器的负载量，该机器离用户地理位置的距离</strong>等等，这种过程就是DNS负载均衡。</p></blockquote><h3 id="建立TCP连接">建立TCP连接</h3><p>TCP/IP 分为四层，在发送数据时，<strong>每层都要对数据进行封装</strong></p><p>[<img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/20201209141851.png" class="" title="img"></p><h3 id="发送HTTPS请求">发送HTTPS请求</h3><p><strong>大致过程如下</strong></p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921110642708.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921110642708.png" class="" title="image-20210921110642708"></a></p><h3 id="查询MAC地址">查询MAC地址</h3><p>这一步主要负责为打包好的<code>数据+TCP首部+IP首部</code>寻找传输路线，<strong>找到IP对应的物理机</strong>，这里会用到ARP协议。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/#arp">ARP协议</a></p><h3 id="请求在Tomcat中的处理流程">请求在Tomcat中的处理流程</h3><p>Web 容器以<strong>进程</strong>的方式在计算机上运行，<strong>它主要负责接收请求，并将其投送至特定的应用</strong>，但Web容器并不属于计算机网络的组成部分。接下来将以Tomcat为例介绍Web容器的核心组件。</p><h4 id="Tomcat的核心组件">Tomcat的核心组件</h4><p>Tomcat的核心组件主要有：<strong>Server、Service、Connector、Engine、Host和Context</strong>。</p><p><strong>一个Server可以包含多个Service，一个Service可以包含多个Connector，但只能包含一个Engine，一个Engine可以包含多个Host，一个Host可以包含多个Context</strong>。</p><p><strong>它们之间的关系如下图所示</strong></p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921111523133.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921111523133.png" class="" title="image-20210921111523133"></a></p><p><strong>配置文件的结构如下</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Server&gt;</span>                              <br>    <span class="hljs-section">&lt;Service&gt;</span><br>        <span class="hljs-section">&lt;Engine&gt;</span><br>            <span class="hljs-section">&lt;Host&gt;</span><br>                <span class="hljs-section">&lt;Context /&gt;</span><br>            <span class="hljs-section">&lt;/Host&gt;</span><br>            <span class="hljs-section">&lt;Host&gt;</span><br>                <span class="hljs-section">&lt;Context /&gt;</span><br>            <span class="hljs-section">&lt;/Host&gt;</span><br>        <span class="hljs-section">&lt;/Engine&gt;</span>  <br>        <span class="hljs-section">&lt;Connector /&gt;</span><br>        <span class="hljs-section">&lt;Connector /&gt;</span><br>    <span class="hljs-section">&lt;/Service&gt;</span><br><span class="hljs-section">&lt;/Server&gt;</span><br><span class="hljs-attribute">Copy</span><br></code></pre></td></tr></table></figure><h5 id="Server">Server</h5><p>Server 是整个配置文件的<strong>唯一根元素</strong>，代表整个 Tomcat 容器。Server 内部可以包含多个 Service，其主要职责就是管理多个 Service，对外提供给客户端访问，同时维护所有 Service 的生命周期，包括初始化服务、结束服务、定位客户端要访问的 Service 等等。</p><h5 id="Service">Service</h5><p>Service 的主要职责就是将 Engine 与 Connector 装配在一起对外提供服务。一个 Service 可以包含多个 Connector，但只能包含一个 Engine，<strong>其中 Connector 负责从客户端接收请求，Engine 负责处理 Connector 接收进来的请求。</strong></p><h5 id="Connector">Connector</h5><p><strong>Connector是主要负责接收请求的组件</strong>。</p><p><strong>Tomcat有以下两种工作模式</strong></p><ul><li>作为Web服务器，直接接收客户端的请求</li><li>作为Java Web服务器，接收前置Web服务器的请求</li></ul><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921111734338.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921111734338.png" class="" title="image-20210921111734338"></a></p><p>每个 Service 可以有一个或多个 Connector，不同工作模式下，Tomcat 需要为各种类型的请求分别定义相应的 Connector，这样才能正确接收客户端对应协议的请求。定义 Connector 可以使用多种属性，某些属性只适用于某种特定的 Connector 类型。</p><p>一般说来，常见的 Connector 有 4 种类型</p><ul><li><strong>HTTP</strong></li><li><strong>HTTPS</strong></li><li><strong>AJP</strong></li><li><strong>Proxy</strong></li></ul><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921111805468.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921111805468.png" class="" title="image-20210921111805468"></a></p><p>Connector作为通信接口，<strong>它为其所属特定的 Service 接收外部客户端请求，以及回送应答至外部客户端</strong>。具体职责包括创建 Request、Response 对象用于跟外部客户端交换数据，并<strong>将 Request 交给配套的 Engine 来处理</strong>。</p><h5 id="Engine">Engine</h5><p>Engine 是 Service 组件中<strong>负责请求处理的组件</strong>，其内部可以包含多个 Host。Engine 从一个或多个 Connector 中接收请求并处理，并将处理结果封装成应答交给 Connector，最终回传给外部客户端。</p><h5 id="Host">Host</h5><p><strong>Host 代表一个虚拟主机，它对应计算机网络上的一个实体</strong>。即某个在 DNS 服务器上注册过的域名或者 IP 地址，例如：<code>www.baidu.com</code>或 201.187.10.21。Host 内部可以包含多个 Context，<strong>每个 Context 表示一个 Web 应用</strong>。Host 负责安装、展开、启动和结束每个 Web 应用。</p><p>客户端在填写目标地址时会通过主机名来标识它希望访问的服务器，Tomcat 将从 HTTP 请求头的 Host 字段提取主机名，然后再匹配对应的虚拟主机。如果没有找到匹配的，HTTP 请求将被发送至默认主机 defaultHost。</p><h5 id="Context">Context</h5><p>Context 代表在特定虚拟主机上运行的一个 Web 应用，<strong>负责处理某个特定 Web 应用的所有请求</strong>。</p><h4 id="Tomcat处理HTTP请求">Tomcat处理HTTP请求</h4><p>当以 HTTP 请求到达Tomcat服务器（Server）以后，Tomcat会进行以下几个步骤，将请求交给对应的Web应用进行处理</p><ul><li>根据协议类型和端口号选定 Service 和 Engine<ul><li>Connector 主要负责接收请求。当 Connector 接收到特定协议和特定端口的请求后，<strong>其所属的 Service 和 Service 下的 Engine 也就确定了</strong></li></ul></li><li>根据域名或 IP 地址选定 Host<ul><li>Engine一旦确定了，就会根据 IP 来选择对应的虚拟主机Host来处理请求。如果匹配失败了，则会使用默认虚拟主机来处理请求</li></ul></li><li>根据 URI 选定 Context<ul><li>URI 中的 context-path 指定了 HTTPS 请求将要访问的 Web 应用</li><li>当请求抵达时，Tomcat 将根据 Context 的属性 path 取值与 URI 中的 context-path 的匹配程度来选择 Web 应用处理相应请求</li></ul></li></ul><hr><h3 id="请求在Web应用中的处理流程">请求在Web应用中的处理流程</h3><p>请求被 Web 容器中的 Connector 捕获，选取对应的 Server 中的 Engine ，Engine 再根据IP选择对应的虚拟主机，虚拟主机根据URI将请求交给对应的Web应用进行处理。接下来将介绍请求在Web请求中的处理过程。</p><p>介绍处理过程前，先对Web应用的基本组件进行简单介绍。</p><h4 id="Web应用核心组件">Web应用核心组件</h4><h5 id="Listener">Listener</h5><p>监听器 Listener 主要用于监听 Application、Session、Request 等对象的变化，每当这些对象发生变化就会回调用对应的监听方法。</p><h5 id="Filter">Filter</h5><p>过滤器 Filter 负责对请求做<strong>预处理</strong>，接着将请求交给 Servlet 进行处理并生成响应，最后 Filter 再对响应进行后处理。</p><p>从请求的处理过程来看，Filter 主要参与以下几个环节</p><ul><li>在 HttpServletRequest <strong>到达 Servlet 之前，拦截客户的 HttpServletRequest</strong></li><li>根据需要检查 HttpServletRequest，也可以修改 HttpServletRequest 报文头和数据</li><li>在 Servlet 生成的 HttpServletResponse <strong>抵达客户端之前，拦截 HttpServletResponse</strong></li><li>根据需要检查 HttpServletResponse，也可以修改 HttpServletResponse 报文头和数据</li></ul><p><strong>简单来说就是在真正处理请求以及返回响应之前，通过过滤器对内容再进行一些修改</strong></p><h5 id="Servlet">Servlet</h5><p><strong>Servlet 负责处理客户端访问动态资源的 HTTP 请求</strong>，接口 javax.servlet.Servlet 定义了所有 Servlet 必须要实现的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Servlet</span> </span>&#123;<br>    <span class="hljs-comment">// 由 Servlet 容器调用，完成 Servlet 初始化，启动对外服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig var1)</span> <span class="hljs-keyword">throws</span> ServletException</span>;<br><br>    <span class="hljs-comment">// 获取 Servlet 初始化和启动时参数的配置信息对象 ServletConfig</span><br>    <span class="hljs-function">ServletConfig <span class="hljs-title">getServletConfig</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 由 Servlet 容器调用，让 Servlet 处理某个 HTTP 请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest var1, ServletResponse var2)</span> <span class="hljs-keyword">throws</span> ServletException, IOException</span>;<br><br>    <span class="hljs-comment">// 获取 Servlet 的说明信息，包括：作者、版本和版权等等</span><br>    <span class="hljs-function">String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 由 Servlet 容器调用，用于关闭停止 Servlet 提供的服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>从 HTTP 请求的处理过程来看，Servlet 主要参与以下几个环节</p><ul><li>接收请求<ul><li>客户端请求会被封装成 HttpServletRequest 对象，包含报文头参数和报文体等信息</li></ul></li><li>处理请求<ul><li>通常调用 Servlet 的方法 service、doPost 或 doGet 等方法处理请求，并<strong>进一步调用业务层相应逻辑对其进行处理等</strong></li></ul></li><li>反回响应<ul><li>处理完请求后，可以转发（forward）、重定向（redirect）到某个视图页面或者直接返回结果数据</li></ul></li></ul><h4 id="Web应用处理HTTP请求流程">Web应用处理HTTP请求流程</h4><p>Web 应用处理 HTTP 请求的流程主要是<strong>穿越 Listener 和多个 Filters，最终抵达 Servlet 的过程</strong>，Servlet再进行下一步的处理。</p><p><strong>具体流程如下图</strong></p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921112418359.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921112418359.png" class="" title="image-20210921112418359"></a></p><hr><h3 id="请求在Spring-Web应用中的处理流程">请求在Spring Web应用中的处理流程</h3><p>因为使用 SSM 框架，所以 Spring MVC 中的 DispatcherServlet 充当了 Web 应用中的 Serlvet，负责将任务分配给对应的Controller，并将最终视图返回给 Web 容器。</p><h4 id="Spring-MVC的核心组件">Spring MVC的核心组件</h4><h5 id="DispatcherServlet">DispatcherServlet</h5><p>DispatcherServlet 是整个流程<strong>控制的中心</strong>，由它来<strong>接收请求并调用其它组件处理用户的请求</strong>，同时还负责响应结果。DispatcherServlet的存在降低了组件之间的耦合性。</p><h5 id="HandlerMapping">HandlerMapping</h5><p>HandlerMapping 负责<strong>根据用户请求映射获得对应的 Handler和 HandlerInterceptor</strong>。处理方法为从 URL 获得 URI，在通过 URI 从 HandlerMapping 中找到对应的 Handler 和 HandlerInterceptor，即处理器和拦截器。</p><h5 id="HandlerAdapter">HandlerAdapter</h5><p>HandlerAdapter 负责按照特定规则去执行 Handler。</p><p>如果 Handler 有对应的 HandlerAdapater，<strong>HandlerAdapater 则会在调用 Handler 之前执行 HandlerInterceptor 的 preHandler() 方法对 Handler 进行拦截</strong>。</p><h5 id="HandlerInterceptor">HandlerInterceptor</h5><p>HandlerInterceptor 主要负责在执行 Handler 前对其进行拦截。HandlerInterceptor 中的 preHandler() 方法将会提取 HTTP 请求中的数据填充到处理器 Handler 的中。</p><h5 id="Handler">Handler</h5><p>Handler <strong>即Controller ，是处理业务代码的核心器件</strong>。这部分由程序员自行编写，一般的SSM框架中，其下层还有Service和Dao。</p><h4 id="Spring-MVC处理请求流程">Spring MVC处理请求流程</h4><p>当 Web 容器中的 Host 会选择对应的 Web应用来处理请求，这里将请求交给了 Spring MVC 中的 DispatcherServlet 来进一步处理请求。</p><ul><li>DispatcherServlet 通过解析 HTTP 请求的 URL 获得 URI，再根据该 URI <strong>从 HandlerMapping 当中获得该请求对应的 Handler 和 HandlerInterceptor</strong></li><li>DispatcherServlet 根据获得的 Handler 选择合适的 HandlerAdapter。如果成功获得 HandlerAdapter，<strong>HandlerAdapater 则会在调用 Handler 之前执行 HandlerInterceptor 的 preHandler() 方法对 Handler 进行拦截</strong></li><li>Handler 即 Controller 会进行请求的处理，并向下调用 Service 和 Dao 来处理请求</li><li>Hander 处理完成请求后会返回模型数据，模型数据由 DispatcherServlet 封装后返回给Web 容器</li></ul><p><strong>处理的流程图如下</strong></p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921112655885.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921112655885.png" class="" title="image-20210921112655885"></a></p><hr><h3 id="返回过程">返回过程</h3><p>Web 应用处理完请求并将结果返回给 Web 容器后，容器会将响应结果返回给客户端，这是上面流程的逆过程。浏览器收到响应结果后，会对结果进行解析和渲染。这样我们就能看到浏览器给我们显示的网页了。</p><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921113017358.png" class="" title="image-20210921113017358"><hr><h2 id="8-3-HTTP协议">8.3 HTTP协议</h2><h3 id="概述-3">概述</h3><p>HTTP（HyperText Transfer Protocol）：<strong>超文本传输协议</strong>，HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><p>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。</p><ul><li>超文本：超文本指的是HTML，css，JavaScript和图片等，HTTP的出现是为了接收和发布HTML页面，经过不断的发展也可以用于接收一些音频，视频，文件等内容。</li></ul><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210910145213312.png" class="" title="image-20210910145213312"><hr><h3 id="报文结构">报文结构</h3><p>报文结构：<strong>起始行 + 头部 + 空行 + 实体</strong></p><blockquote><p>http <code>请求报文</code>和<code>响应报文</code>是有一定区别</p></blockquote><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915150323696.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915150323696.png" class="" title="image-20210915150323696"></a></p><h4 id="起始行">起始行</h4><h5 id="请求行">请求行</h5><ul><li>请求报文 GET /home HTTP/1.1，也就是<strong>方法 + 路径 + http版本</strong></li></ul><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/#http%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">HTTP请求方法</a></p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/#uri%E4%B8%8Eurl">URI与URL</a></p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/#http%E7%89%88%E6%9C%AC">HTTP版本</a></p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1625556960701-67d07a26-61ea-4708-b378-a33ce98e5907.webp"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1625556960701-67d07a26-61ea-4708-b378-a33ce98e5907.webp" class="" title="img"></a></p><h5 id="状态行">状态行</h5><ul><li>响应报文 HTTP/1.1 200 OK ，由<strong>http版本、状态码和原因</strong>三部分组成</li></ul><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/#http%E7%89%88%E6%9C%AC">HTTP版本</a></p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/#http%E7%8A%B6%E6%80%81%E7%A0%81">HTTP状态码</a></p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1625556999909-c5905faf-64de-41a8-a43b-780207247fa8.webp"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1625556999909-c5905faf-64de-41a8-a43b-780207247fa8.webp" class="" title="img"></a></p><blockquote><p>在起始行中，每两个部分之间用<strong>空格</strong>隔开，最后一个部分后面应该接一个<strong>换行</strong>，严格遵循<code>ABNF</code>语法规范。</p></blockquote><h4 id="头部">头部</h4><h5 id="请求头">请求头</h5><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915151245871.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915151245871.png" class="" title="image-20210915151245871"></a></p><p>Cache-Control：</p><ul><li><strong>private：</strong> 仅浏览器可以缓存</li><li><strong>public：</strong> 浏览器和代理服务器都可以缓存（对于private和public，前端可以认为一样，不用深究</li><li><strong>max-age=xxx</strong> 过期时间（重要）</li><li><strong>no-cache</strong> 不进行强缓存（重要）,使用任何缓存前都要向服务器验证</li><li><strong>no-store</strong> 真正的不缓存</li></ul><h5 id="响应头">响应头</h5><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915151401084.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915151401084.png" class="" title="image-20210915151401084"></a></p><p>Content-Type：</p><p>常见的媒体格式：text/html,text/plain,image/gif</p><p>application开头的媒体格式类型：application/xml, appliation/json</p><p>multipart/form-data</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915151540851.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915151540851.png" class="" title="image-20210915151540851"></a></p><h4 id="实体">实体</h4><h5 id="请求体">请求体</h5><h5 id="响应体">响应体</h5><hr><h3 id="HTTP-请求方法">HTTP 请求方法</h3><p><code>http/1.1</code>规定了以下请求方法(注意，都是大写):</p><ul><li>GET: 通常用来获取资源</li><li>HEAD: 获取资源的元信息</li><li>POST: 提交数据，即上传数据</li><li>PUT: 修改数据</li><li>DELETE: 删除资源(几乎用不到)</li><li>CONNECT: 建立连接隧道，用于代理服务器</li><li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li><li>TRACE: 追踪请求-响应的传输路径</li></ul><h4 id="get请求与post请求的区别">get请求与post请求的区别</h4><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li><li><strong>GET请求只能进行url编码，而POST支持多种编码方式</strong>。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li><strong>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</strong>。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li><li>从<strong>幂等性</strong>的角度，<code>GET</code>是<strong>幂等</strong>的，而<code>POST</code>不是。(<code>幂等</code>表示执行相同的操作，结果也是相同的)</li></ul><hr><h3 id="HTTP-版本">HTTP 版本</h3><h4 id="HTTP1-0">HTTP1.0</h4><ul><li>HTTP 1.0 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个TCP连接</li></ul><h4 id="HTTP1-1">HTTP1.1</h4><ul><li>新增Connection字段，用于<strong>支持提供TCP持久连接</strong> Connection: keep-alive<ul><li>即TCP连接默认不关闭，可以被多个请求复用</li><li>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。（<strong>HTTP队头阻塞</strong>）</li></ul></li><li>增加更多请求头和响应头来完善功能</li><li>新增 Host 字段，用于支持虚拟主机</li><li>缓存策略：If-Match，If-None-Match</li><li>添加了新的请求方法 put, delete, options</li></ul><blockquote><p>队头阻塞</p><p>”队头阻塞“与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。</p><p>因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。</p><p>队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</p><p>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</p></blockquote><p>因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解</p><ul><li>这在 HTTP 里就是“并发连接”（concurrent connections），也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。但这种方式也存在缺陷。如果每个客户端都想自己快，建立很多个连接，用户数×并发数就会是个天文数字。服务器的资源根本就扛不住，或者被服务器认为是恶意攻击，反而会造成“拒绝服务”。所以，HTTP 协议建议客户端使用并发，但不能“滥用”并发。RFC2616 里明确限制每个客户端最多并发 2 个连接。不过实践证明这个数字实在是太小了，众多浏览器都“无视”标准，把这个上限提高到了 6~8。后来修订的 RFC7230 也就“顺水推舟”，取消了这个“2”的限制。</li><li>“域名分片”（domain sharding）技术，还是用数量来解决质量的思路。HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 <a href="http://shard1.chrono.com">shard1.chrono.com</a>、<a href="http://shard2.chrono.com">shard2.chrono.com</a>，而这些域名都指向同一台服务器 <a href="http://www.chrono.xn--com%2C-gp7i66a065axd527gosbxw3cvxfw3lxu1d087ewca058bk9s1zd/">www.chrono.com，这样实际长连接的数量就又上去了</a></li></ul><h4 id="HTTP2-0">HTTP2.0</h4><ul><li><p><strong>支持服务端推送</strong></p><ul><li>允许服务端推送资源给客户端，在响应一个页面请求中，可以把需要的其他资源一起发给客户端，免得需要再次发送请求，适合加载静态资源，比如请求html时，把css也传过去</li></ul></li><li><p><strong>支持TCP连接IO多路复用</strong></p><ul><li>在一个连接里，客户端和服务器都可以同时发送多个请求或回应，避免队头阻塞</li></ul></li><li><p><strong>二进制分帧（而非文本格式）</strong></p><ul><li>支持多个连接穿插执行，避免队头阻塞</li></ul></li><li><p>首部压缩：HPACK算法</p><ul><li><p>首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把</p><p>索引</p><p>(比如0，1，2，…)传给对方即可，对方拿到索引查表就行了。这种</p><p>传索引</p><p>的方式，可以说让请求头字段得到极大程度的精简和复用。废除了起始行的概念。</p><ul><li>HTTP2.0当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个”:”前缀，用来和其它请求头区分开。</li><li>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</li></ul></li></ul></li></ul><hr><h3 id="HTTP-状态码">HTTP 状态码</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></p><p>RFC 规定 HTTP 的状态码为<strong>三位数</strong>，被分为五类:</p><ul><li><p><strong>1xx</strong>: 表示目前是协议处理的中间状态，还需要后续操作。</p><ul><li><strong>100 Continue</strong>：迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</li><li><strong>101 Switching Protocols</strong>：在<code>HTTP</code>升级为<code>WebSocket</code>的时候，如果服务器同意变更（切换协议），就会发送状态码 101。</li><li><strong>102 Processing</strong>：服务器已收到并正在处理该请求，但没有响应可用</li></ul></li><li><p><strong>2xx</strong>: 表示成功状态。</p><ul><li><strong>200 OK</strong>：请求成功。</li><li><strong>201 Created</strong>：该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。</li><li><strong>202 Accepted</strong>：请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。</li><li><strong>204 No Content</strong>：含义与 200 相同，但响应头后没有 body 数据。</li><li><strong>206 Partial Content</strong>：表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段<code>Content-Range</code>。</li></ul></li><li><p><strong>3xx</strong>: 重定向状态，资源位置发生变动，需要重新请求。</p><ul><li><p><strong>301 Moved Permanently</strong>：永久重定向，求的URL已被移除时使用</p><p>比如网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回<code>301</code>，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。</p></li><li><p><strong>302 Found</strong>：临时重定向，请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p></li><li><p><strong>304 Not Modified</strong>: 当协商缓存命中时会返回这个状态码。如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p></li></ul></li><li><p><strong>4xx</strong>: 请求报文有误。</p><ul><li><strong>400 Bad Request</strong>:<ul><li>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</li><li>2、请求参数有误。</li></ul></li><li><strong>401 Unauthorized</strong>：未授权，当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。</li><li><strong>403 Forbidden</strong>：服务器已经理解请求，但是拒绝执行它。这并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。</li><li><strong>404 Not Found</strong>：资源未找到，表示没在服务器上找到相应的资源。</li><li><strong>405 Method Not Allowed</strong>：请求方法不被服务器端允许。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。</li><li><strong>406 Not Acceptable</strong>: 资源无法满足客户端的条件。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</li><li><strong>408 Request Timeout</strong>：服务器等待了太长时间。请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</li><li><strong>409 Conflict</strong>：多个请求发生了冲突。</li><li><strong>413 Request Entity Too Large</strong>：请求体的数据过大。</li><li><strong>414 Request-URI Too Long</strong>：请求行里的 URI 太大。</li><li><strong>429 Too Many Request</strong>：客户端发送的请求过多。</li><li><strong>431 Request Header Fields Too Large</strong>：请求头的字段内容太大。</li></ul></li><li><p><strong>5xx</strong>: 服务器端发生错误。</p><ul><li><strong>500 Internal Server Error</strong>：服务器遇到了不知道如何处理的情况。</li><li><strong>501 Not Implemented</strong>：客户端请求的功能还不支持。此请求方法不被服务器支持且无法被处理。只有<code>GET</code>和<code>HEAD</code>是要求服务器支持的，它们必定不会返回此错误代码。</li><li><strong>502 Bad Gateway</strong>：此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。服务器自身是正常的，但访问的时候出错了。</li><li><strong>503 Service Unavailable</strong>：服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。</li><li><strong>504 Gateway Timeout</strong>：当服务器作为网关，不能及时得到响应时返回此错误代码。</li><li><strong>505 HTTP Version Not Supported</strong>：服务器不支持请求中所使用的HTTP协议版本。</li></ul></li></ul><hr><h3 id="URI与URL">URI与URL</h3><ul><li><strong>URI</strong>：Uniform Resource Identifier，统一资源标识符</li><li><strong>URL</strong>：Uniform Resource Locator，统一资源定位符，不仅标识了资源，还指定了操作或者获取方式，同时指出了主要访问机制和网络位置；</li><li><strong>URN</strong>：Uniform Resource Name，统一资源名称，用特定命名空间的名字标识资源，使用URN可以在不知道其网络位置及访问方式的情况下讨论资源。</li></ul><h4 id="URI结构">URI结构</h4><p>URI 真正最完整的结构是这样的。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915233628185.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210915233628185.png" class="" title="image-20210915233628185"></a></p><ul><li><strong>scheme</strong> 表示协议名，比如<code>http</code>, <code>https</code>, <code>file</code>等等。后面必须和<code>://</code>连在一起。</li><li><strong>user:passwd</strong>@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</li><li><strong>host:port</strong>表示主机名和端口。</li><li><strong>path</strong>表示请求路径，标记资源所在位置。</li><li><strong>query</strong>表示查询参数，为<code>key=val</code>这种形式，多个键值对之间用<code>&amp;</code>隔开。</li><li><strong>fragment</strong>表示 URI 所定位的资源内的一个<strong>锚点</strong>，浏览器可以根据这个锚点跳转到对应的位置。</li></ul><p>URI 只能使用<code>ASCII</code>, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。</p><p>因此，URI 引入了<code>编码</code>机制，将所有<strong>非 ASCII 码字符</strong>和<strong>界定符</strong>转为十六进制字节值，然后在前面加个<code>%</code>。</p><p>如，空格被转义成了<code>%20</code>。</p><p>URI允许统一识别资源。URI另外被分组为定位符，名称或两者，这意味着它可以描述URL，URN或两者。</p><blockquote><p><strong>URL和URN都是URI的子集</strong>。换而言之，URL和URN都是URI，但是URI不一定是URL或者URN。</p></blockquote><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/640"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/640" class="" title="图片"></a></p><p>举例如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">构造一个URI<br>http:*<span class="hljs-regexp">//</span>bitpoetry.io<span class="hljs-regexp">/posts/</span>hello.html<span class="hljs-comment">#intro</span><br><br>其中<br>   http:<span class="hljs-regexp">//</span>  <span class="hljs-regexp">//</span> 是定义如何访问资源的方式<br>   bitpoetry.io<span class="hljs-regexp">/posts/</span>hello.html  <span class="hljs-regexp">//</span> 是资源存放的位置<br>   <span class="hljs-comment">#intro  // 是资源</span><br>   <br>URL是URI的一个子集，告诉我们访问资源位置的方式。在例子中，URL应该如下所示：   <br>    http:<span class="hljs-regexp">//</span>bitpoetry.io<span class="hljs-regexp">/posts/</span>hello.html<br>    <br>URN是URI的子集，包括名字（给定的命名空间内），但是不包括访问方式。在例子中，URN如下所示：  <br> bitpoetry.io<span class="hljs-regexp">/posts/</span>hello.html<span class="hljs-comment">#intro</span><br>Copy<br></code></pre></td></tr></table></figure><hr><h3 id="HTTP-传输定长和不定长的数据">HTTP 传输定长和不定长的数据</h3><h4 id="定长数据">定长数据</h4><ul><li><p>对于定长包体而言，发送端在传输的时候一般会带上</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Content-<span class="hljs-built_in">Length</span><br></code></pre></td></tr></table></figure><p>, 来指明包体的长度</p><ul><li>用一个<code>nodejs</code>服务器来模拟一下:</li></ul></li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br>const server = http.createServer();<br><br>server.<span class="hljs-literal">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(req.url === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>    res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/plain&#x27;</span>);<br>    res.setHeader(<span class="hljs-string">&#x27;Content-Length&#x27;</span>, <span class="hljs-number">10</span>);<br>    res.write(<span class="hljs-string">&quot;helloworld&quot;</span>);<br>  &#125;<br>&#125;)<br><br>server.listen(<span class="hljs-number">8081</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;成功启动&quot;</span>);<br>&#125;)<br>Copy<br></code></pre></td></tr></table></figure><p>启动后访问: <strong>localhost:8081</strong>。</p><p>浏览器中显示如下:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">helloworld<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>这是长度正确的情况，那不正确的情况是如何处理的呢</p><p>我们试着把这个长度设置的小一些:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">res.setHeader(<span class="hljs-string">&#x27;Content-Length&#x27;</span>, <span class="hljs-number">8</span>);<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>重启服务，再次访问，现在浏览器中内容如下:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">hellowor<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>那后面的<code>ld</code>哪里去了呢？实际上在 http 的响应体中直接被截去了。</p><p>然后我们试着将这个长度设置得大一些:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">res.setHeader(<span class="hljs-string">&#x27;Content-Length&#x27;</span>, <span class="hljs-number">12</span>);<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>此时浏览器显示如下：</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210916161841752.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210916161841752.png" class="" title="image-20210916161841752"></a></p><p>直接无法显示了。可以看到<code>Content-Length</code>对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。</p><h4 id="不定长包体">不定长包体</h4><p>上述是针对于<code>定长包体</code>，那么对于<code>不定长包体</code>而言是如何传输的呢？</p><p>这里就必须介绍另外一个 http 头部字段了:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Transfer-<span class="hljs-keyword">Encoding</span>: chunked<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>表示分块传输数据，设置这个字段后会自动产生两个效果:</p><ul><li>Content-Length 字段会被忽略</li><li>基于长连接持续推送动态内容</li></ul><p>我们依然以一个实际的例子来模拟分块传输，nodejs 程序如下:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br>const server = http.createServer();<br><br>server.<span class="hljs-literal">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(req.url === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>    res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf8&#x27;</span>);<br>    res.setHeader(<span class="hljs-string">&#x27;Content-Length&#x27;</span>, <span class="hljs-number">10</span>);<br>    res.setHeader(<span class="hljs-string">&#x27;Transfer-Encoding&#x27;</span>, <span class="hljs-string">&#x27;chunked&#x27;</span>);<br>    res.write(<span class="hljs-string">&quot;&lt;p&gt;来啦&lt;/p&gt;&quot;</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      res.write(<span class="hljs-string">&quot;第一次传输&lt;br/&gt;&quot;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      res.write(<span class="hljs-string">&quot;第二次传输&quot;</span>);<br>      res.end()<br>    &#125;, <span class="hljs-number">2000</span>);<br>  &#125;<br>&#125;)<br><br>server.listen(<span class="hljs-number">8009</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;成功启动&quot;</span>);<br>&#125;)<br>Copy<br></code></pre></td></tr></table></figure><p>访问效果入下:</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210917105352387.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210917105352387.png" class="" title="image-20210917105352387"></a></p><hr><h3 id="传输过程">传输过程</h3><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921105357172.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921105357172.png" class="" title="image-20210921105357172"></a></p><hr><h2 id="8-4-HTTPS协议">8.4 HTTPS协议</h2><p>顾名思义，就是在HTTP（超文本传输协议）的基础上再加一层TLS（传输层安全性协议）或者SSL（安全套接层），说白了就是为了应付HTTP是明文传输的缺点，容易被中间人窃听或者篡改，导致隐私和信息安全出现问题的解决方案。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918144054923.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918144054923.png" class="" title="image-20210918144054923"></a></p><h3 id="通信过程">通信过程</h3><h4 id="Client-Hello">Client Hello</h4><p>握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 <strong>Random1</strong>、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918151748632.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918151748632.png" class="" title="image-20210918151748632"></a></p><h4 id="Server-Hello">Server Hello</h4><p>第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 <strong>Random2</strong>。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918151908297.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918151908297.png" class="" title="image-20210918151908297"></a></p><h4 id="Certificate">Certificate</h4><p>这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152228237.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152228237.png" class="" title="image-20210918152228237"></a></p><h4 id="Certificate-Verify">Certificate Verify</h4><p>客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 <strong>Random3</strong>，再用服务端公钥非对称加密 <strong>Random3</strong> 生成 <strong>PreMaster Key</strong>。</p><h4 id="Client-Key-Exchange">Client Key Exchange</h4><p>上面客户端根据服务器传来的公钥生成了 <strong>PreMaster Key</strong>，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 <strong>PreMaster Key</strong> 得到客户端生成的 <strong>Random3</strong>。至此，客户端和服务端都拥有 <strong>Random1</strong> + <strong>Random2</strong> + <strong>Random3</strong>，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。客户端将 <strong>PreMaster Key</strong> 传给服务端的过程如下图所示：</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152355695.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152355695.png" class="" title="image-20210918152355695"></a></p><h4 id="Encrypted-Handshake-Message-Client">Encrypted Handshake Message(Client)</h4><p>这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152438216.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152438216.png" class="" title="image-20210918152438216"></a></p><h4 id="Change-Cipher-Spec-Server">Change Cipher Spec(Server)</h4><p>这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。</p><h4 id="Encrypted-Handshake-Message-Server">Encrypted Handshake Message(Server)</h4><p>这一步对应的是 Server Finish 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152522642.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918152522642.png" class="" title="image-20210918152522642"></a></p><h4 id="Application-Data">Application Data</h4><p>到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。</p><hr><h3 id="传输过程-2">传输过程</h3><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921105440452.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921105440452.png" class="" title="image-20210921105440452"></a></p><ul><li><strong>HTTPS传输过程最多会比HTTP多7个RTT</strong></li></ul><p>step1：正常的TCP连接三次握手，这不必说</p><p>step2：然后链接会跳转到HTTPS的网站，毕竟协议都不同，考虑到不可能人会把网址打全，所以还需要跳转一步。</p><p>step3：又是TCP连接，这里需要又一步TCP连接是因为HTTPS的传输端口不同（这个是传输层的，http是80，https是443）。</p><p>step4：完成加密套件的协商和证书的身份确认，这次交互客户端和服务端会协商出相同的密钥交换算法、对称加密算法、内容一致性校验算法、证书签名算法等等。浏览器获取到证书之后，也要验证证书的有效性，是否过期是否撤销。</p><p>step5：浏览器获取CA域名，如果没有命中CA域名的缓存，还需要进行DNS解析，又需要多一次交互。</p><p>step6：解析成功解析ip之后，需要和CA网站进行tcp三次握手。</p><p>step7：这里OCSP请求，全称是Online Certificate Status Protocol，在线证书状态协议，顾名思义用来获取证书状态的请求，这里的状态包括有效、过期、未知。并且可以宽限一段客户端访问证书的时间。</p><p>step8：主要进行密钥协商。</p><hr><h3 id="CA证书">CA证书</h3><ul><li>CA是Certificate Authority的缩写，也叫“证书授权中心”。它是负责管理和签发证书的第三方机构，作用是检查证书持有者身份的合法性，并签发证书，以防证书被伪造或篡改。</li><li>CA 证书就是CA颁发的证书。 CA证书也就我们常说的数字证书，包含证书拥有者的身份信息，CA机构的签名，公钥和私钥。身份信息用于证明证书持有者的身份；CA签名用于保证身份的真实性；公钥和私钥用于通信过程中加解密，从而保证通讯信息的安全性。</li></ul><h4 id="CA证书内容">CA证书内容</h4><ul><li>颁发者</li><li>使用者</li><li>版本</li><li>签名算法</li><li>签名哈希算法</li><li>使用者</li><li>公钥</li><li>指纹</li><li>指纹算法</li></ul><hr><h1>九、其它</h1><h2 id="9-1-Cookie与Session">9.1 Cookie与Session</h2><h3 id="区别">区别</h3><ol><li>存储位置不同：<strong>cookie存放于客户端；session存放于服务端</strong>。</li><li>存储容量不同：单个cookie保存的数据&lt;=4KB，一个站点最多保存20个cookie；而session并没有上限。</li><li>存储方式不同：cookie只能保存ASCII字符串，并需要通过编码当时存储为Unicode字符或者二进制数据；session中能够存储任何类型的数据，例如字符串、整数、集合等。</li><li>隐私策略不同：cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的；session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</li><li>生命周期不同：可以通过设置cookie的属性，达到cookie长期有效的效果；session依赖于名为JSESSIONID的cookie，而该cookie的默认过期时间为-1，只需关闭窗口该session就会失效，因此session不能长期有效。</li><li>服务器压力不同：cookie保存在客户端，不占用服务器资源；session保管在服务器上，每个用户都会产生一个session，如果并发量大的话，则会消耗大量的服务器内存。</li><li>浏览器支持不同：cookie是需要浏览器支持的，如果客户端禁用了cookie，则会话跟踪就会失效；运用session就需要使用URL重写的方式，所有用到session的URL都要进行重写，否则session会话跟踪也会失效。</li><li>跨域支持不同：cookie支持跨域访问，session不支持跨域访问。</li></ol><h3 id="Cookie">Cookie</h3><h4 id="Cookie-属性">Cookie 属性</h4><h5 id="生存周期">生存周期</h5><p>Cookie 的有效期可以通过<strong>Expires</strong>和<strong>Max-Age</strong>两个属性来设置。</p><ul><li><strong>Expires</strong>即<code>过期时间</code></li><li><strong>Max-Age</strong>用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。</li></ul><p>若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。</p><h5 id="作用域">作用域</h5><p>关于作用域也有两个属性: <strong>Domain</strong>和<strong>path</strong>, 给 <strong>Cookie</strong> 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，<code>/</code>表示域名下的任意路径都允许使用 Cookie。</p><h5 id="安全相关">安全相关</h5><p>如果带上<code>Secure</code>，说明只能通过 HTTPS 传输 cookie。</p><p>如果 cookie 字段带上<code>HttpOnly</code>，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</p><p>相应的，对于 CSRF 攻击的预防，也有<code>SameSite</code>属性。</p><p><code>SameSite</code>可以设置为三个值，<code>Strict</code>、<code>Lax</code>和<code>None</code>。</p><p><strong>a.</strong> 在<code>Strict</code>模式下，浏览器完全禁止第三方请求携带Cookie。比如请求<code>sanyuan.com</code>网站只能在<code>sanyuan.com</code>域名当中请求才能携带 Cookie，在其他网站请求都不能。</p><p><strong>b.</strong> 在<code>Lax</code>模式，就宽松一点了，但是只能在 <code>get 方法提交表单</code>况或者<code>a 标签发送 get 请求</code>的情况下可以携带 Cookie，其他情况均不能。</p><p><strong>c.</strong> 在<code>None</code>模式下，也就是默认模式，请求会自动携带上 Cookie。</p><h4 id="Cookie-的缺点">Cookie 的缺点</h4><ol><li>容量缺陷。Cookie 的体积上限只有<code>4KB</code>，只能用来存储少量的信息。</li><li>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过<code>Domain</code>和<code>Path</code>指定<strong>作用域</strong>来解决。</li><li>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在<code>HttpOnly</code>为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</li></ol><hr><h2 id="9-2-跨域">9.2 跨域</h2><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918143407829.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210918143407829.png" class="" title="image-20210918143407829"></a></p><h3 id="跨域问题出现原因">跨域问题出现原因</h3><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p><p><strong>同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互</strong>。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</p><h3 id="非同源限制">非同源限制</h3><ul><li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</li><li>无法接触非同源网页的 DOM</li><li>无法向非同源地址发送 AJAX 请求</li></ul><h3 id="解决方法">解决方法</h3><p><a href="https://igotcha.gitee.io/2021/06/03/JavaWeb/SpringBoot%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F/">后端解决方式</a></p><hr><h2 id="9-3-XSS、CSRF">9.3 XSS、CSRF</h2><h3 id="XSS">XSS</h3><h4 id="概述-4">概述</h4><p>XSS：跨站脚本攻击（Cross Site Scripting），攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID等，进而危害数据安全。</p><p>XSS分为存储型XSS、反射型XSS、DOM型XSS</p><ul><li>存储型XSS的恶意代码存在数据库里</li><li>反射型XSS的恶意代码存在URL里。</li><li>DOM型XSS属于前端JavaScript自身的安全漏洞，</li></ul><h4 id="危害">危害</h4><ul><li>窃取cookies</li><li>配合其他漏洞，如CSRF</li><li>插入广告</li></ul><h4 id="防范">防范</h4><p>防止 HTML 中出现注入，防止 JavaScript 执行时，执行恶意代码。</p><p>存储型XSS、反射型XSS</p><ul><li>纯前端渲染，但是还是要注意避免DOM型XSS漏洞（onload事件和href中的javascript:xxx）</li><li>转义HTML</li><li>白名单过滤</li></ul><p>DOM型XSS</p><ul><li>如果不使用框架，避免直接使用innerHTML，尽量使用.textContent、.setAttribute</li><li>避免内联事件（onClick,onLoad）等</li><li>set-cookies设置Http-Only</li></ul><h3 id="CSRF">CSRF</h3><h4 id="概述-5">概述</h4><p>CSRF：跨站请求伪造（Cross-site request forgery），挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p><h4 id="危害-2">危害</h4><p>攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：<strong>个人隐私泄露以及财产安全</strong>。</p><h4 id="原理">原理</h4><p><a href="https://igotcha.gitee.io/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921115900826.png"><img src="/dajiangdahe/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20210921115900826.png" class="" title="image-20210921115900826"></a></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ul><li>登录受信任网站A，并在本地生成Cookie。</li><li>在不登出A的情况下，访问危险网站B。</li></ul><h4 id="避免">避免</h4><ul><li>cookies不随着跨域请求发送</li><li>请求头中的Referer请求头来判断请求来源</li><li>使用Token</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>需要在@Transactional注解指定rollbackFor或者在方法中显示的rollback</title>
    <link href="/dajiangdahe/2021/11/03/@Transactional%E4%B8%AD%E7%9A%84rollback%E6%83%85%E5%86%B5/"/>
    <url>/dajiangdahe/2021/11/03/@Transactional%E4%B8%AD%E7%9A%84rollback%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<h1>需要在@Transactional注解指定rollbackFor或者在方法中显示的rollback</h1><p>每次写代码的时候，只要不显示的写出rollback，阿里巴巴开发规范就会提示你这个地方是需要显示的写出rollback的。</p><h2 id="swig￼1"><img src="/dajiangdahe/2021/11/03/@Transactional%E4%B8%AD%E7%9A%84rollback%E6%83%85%E5%86%B5/image-20211103143731171.png" class="" title="image-20211103143731171"></h2><ul><li>可查的异常（checked exceptions）:Exception下除了RuntimeException外的异常</li><li>不可查的异常（unchecked exceptions）:RuntimeException及其子类和错误（Error）</li></ul><p>如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。<br>如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。</p><p><strong>非运行时异常</strong>是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及<strong>用户自定义的Exception异常</strong>。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。<strong>所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常.</strong></p><p>**Spring框架的事务基础架构代码将默认地只在抛出<code>RuntimeException</code> 和<code>unchecked exceptions</code>时才标识事务回滚。**也就是说，当抛出个<code>RuntimeException</code>或其子类例的实例时。（<code>Errors</code> 也一样 - 默认地 - 标识事务回滚。）从事务方法中抛出的Checked exceptions将 不 被标识进行事务回滚。</p><p>1 让checked例外也回滚：在整个方法前加上 @Transactional(rollbackFor=Exception.class)</p><p>2 让unchecked例外不回滚： @Transactional(notRollbackFor=RunTimeException.class)</p><p>3 不需要事务管理的(只查询的)方法：@Transactional(propagation=Propagation.NOT_SUPPORTED)</p><p><strong>注意： 如果异常被try｛｝catch｛｝了，事务就不回滚了，如果想让事务回滚必须再往外抛try｛｝catch｛throw Exception｝。</strong></p><p><strong>注意：</strong></p><ul><li><p>Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因此，请接受Spring团队的建议并且在具体的类上使用 @Transactional 注解。</p></li><li><p>@Transactional 注解标识的方法，处理过程尽量的简单。尤其是带锁的事务方法，能不放在事务里面的最好不要放在事务里面。可以将常规的数据库查询操作放在事务前面进行，而事务内进行增、删、改、加锁查询等操作。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 商户资质申请</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> merchantId  商人id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> merchantDTO 商人dto</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> BusinessException 业务异常</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-meta">@Transactional(rollbackFor = BusinessException.class)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyMerchant</span><span class="hljs-params">(Long merchantId, MerchantDTO merchantDTO)</span> <span class="hljs-keyword">throws</span> BusinessException </span>&#123;<br><br>       <span class="hljs-comment">//接收商户资质，注册到商户表中</span><br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == merchantId || <span class="hljs-keyword">null</span> == merchantDTO) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(CommonErrorCode.E_200201);<br>       &#125;<br>       <span class="hljs-comment">//根据商户ID查询商户</span><br>       Merchant merchant = <span class="hljs-keyword">null</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           merchant = merchantMapper.selectById(merchantId);<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(CommonErrorCode.E_200227);<br>       &#125;<br>       <span class="hljs-comment">//数据流转换</span><br>       Merchant merchantNew = MerchantCovert.instance.dtoToEntity(merchantDTO);<br>       <span class="hljs-comment">//正在审核中</span><br>       merchantNew.setAuditStatus(<span class="hljs-string">&quot;1&quot;</span>);<br>       merchantNew.setTenantId(merchant.getTenantId());<br><br>       <span class="hljs-keyword">try</span> &#123;<br>           merchantMapper.updateById(merchantNew);<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;更新商户出错&quot;</span>);<br>       &#125;<br><br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你当像鸟飞往你的山</title>
    <link href="/dajiangdahe/2021/11/02/%E3%80%90%E5%B0%8F%E8%AF%B4%E3%80%91%E4%BD%A0%E5%BD%93%E5%83%8F%E9%B8%9F%E9%A3%9E%E5%BE%80%E4%BD%A0%E7%9A%84%E5%B1%B1/"/>
    <url>/dajiangdahe/2021/11/02/%E3%80%90%E5%B0%8F%E8%AF%B4%E3%80%91%E4%BD%A0%E5%BD%93%E5%83%8F%E9%B8%9F%E9%A3%9E%E5%BE%80%E4%BD%A0%E7%9A%84%E5%B1%B1/</url>
    
    <content type="html"><![CDATA[<h1>你当像鸟飞往你的山（塔拉·韦斯特弗）</h1><hr><h2 id="◆-序">◆ 序</h2><blockquote><p>我只有七岁，但我懂得相比其他任何事，最令我们家与众不同的是这个事实：我们不去上学。<br>爸爸担心政府会强制我们去上学，但并没有，因为政府压根儿不知道我们的存在。我们家有七个孩子，其中四个没有出生证明。我们没有医疗记录，因为我们都是在家里出生的，从未去医院看过医生或护士。￼我们没有入学记录，因为我们从未踏进教室一步。我九岁时才会有一张延期出生证明，但在这一刻，对爱达荷州和联邦政府而言，我不存在。</p></blockquote><p>塔拉给我一种非常淡然，平静的叙述。</p><h2 id="◆-阿帕奇女人">◆ 阿帕奇女人</h2><blockquote><p>在我看来，这个微笑既带着困惑，又饶有兴致，似乎在说：我说得对吧，没有比现实生活更有意思的了。</p></blockquote><h2 id="◆-诚实的污垢">◆ 诚实的污垢</h2><blockquote><p>从一九九一年秋到一九九二年春末，泰勒一整年都在上学。他学了代数，代数之于他的大脑就如空气之于他的肺一样自然。</p></blockquote><blockquote><p>当树叶开始变色，从夏天的杜松绿变成秋天的石榴红和古铜金，我用手指无数次摩挲那枚银币，即使在最暗的光线下，它仍幽幽地闪着微光。这种原始的身体活动给我安慰，让我确信如果银币是真的，泰勒就不会离开。</p></blockquote><p>前面，当“我”摩挲着硬币的时候，“我”认为泰勒会永远站在我这边，当“我”突然意识到他想要什么的时候，“我”觉得他背叛了“我”。</p><blockquote><p>有那么一刻，我在想难道这就是泰勒想要的：漂亮的房子，漂亮的卫生间，漂亮的妹妹。也许他离开就是为了这个。想到这里我就对他心生怨恨。</p></blockquote><h2 id="◆-大小盾牌">◆ 大小盾牌</h2><blockquote><p>人总是希望奇迹发生。”她对我说，“如果能给他们带来希望，让他们相信自己正在好转，他们就什么都信，什么都吃。但是世界上根本没有魔法这种东西。营养、锻炼和钻研草药特性，这才是全部。但人们生病受罪时，你说这个他们不接受。”</p></blockquote><p>希望是最后一颗稻草，这也正是奇迹的含义</p><blockquote><p>理查德就会把书凑到鼻子边，在黑暗中看书。他就是如此痴迷，如此想看那本百科全书。</p></blockquote><p>这是一种反抗，一种认知体系构建过程中书籍传递出的信息与父亲信息相悖的结果。</p><h2 id="◆-耶和华必预备">◆ 耶和华必预备</h2><blockquote><p>我想象爸爸仰望苍穹，高声祈祷，然后把儿子抱上卡车，让他坐在驾驶座上。爸爸挂上挡，卡车开动。车子开得够快了，卢克紧握方向盘。爸爸从行驶的卡车上跳了下来，重重摔在地上，滚了一圈，然后跑回火边。火势越烧越旺，火苗越蹿越高。他高呼着“耶和华必预备”，脱下衬衫，开始与火焰战斗。</p></blockquote><p>他高呼着“耶和华必预备”，准备与自己的信仰去战斗，所幸卢克身上的火被扑灭，所幸卢克的性命得以保存，所幸他的信仰不灭，否则我真的难以想象后面的情节和他接下来的变化。</p><h2 id="◆-羽毛盾牌">◆ 羽毛盾牌</h2><blockquote><p>身旁的那个人就是肖恩，我看着他，但看不透他。我不知道我看到了什么——在那极其暴力又富有同情心的行为背后，我到底召唤出了什么生物——但我想我看到了父亲，或者我所希望的父亲的样子，一位我渴望已久的守护者，一名想象出来的斗士，一个不会把我扔进暴风雪中的人，一个当我受了伤，能让我重新变得完整的人。</p></blockquote><h2 id="◆-直觉">◆ 直觉</h2><blockquote><p>它们是来自另一个世界的无情又强大的化身。骑上它们就是放弃自己的立足点，进入它们的领地，冒着一去不回的危险。</p></blockquote><h2 id="◆-鱼眼睛">◆ 鱼眼睛</h2><blockquote><p>这一刻定义了我对那一晚的记忆，以及之后长达十年之久很多类似的夜晚的记忆。在这样的记忆中，我看到的是一个坚不可摧、像石头一样难以对付的自己。起初我仅仅是让自己相信这一点，直到有一天它变成了现实。然后我才能坦诚地告诉自己，这对我没有影响，他没有影响到我，因为没有什么可以影响我。我不明白我的这种正确是多么病态，不明白自己是如何掏空了自己。尽管我一直被那晚的后果所困扰，但我误解了最重要的事实：它没有影响我，这本身就是它的影响。</p></blockquote><p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p><p>转：“暴风雨结束后，你不会记得自己是怎样活下来的。你甚至不确定暴风雨真的结束了。但有一件事是确定的:当你穿过了暴风雨，你就不再是原来那个人。这就是关于暴风雨的一切。”<br>——《海边的卡夫卡》</p><h2 id="◆-沉默的教堂">◆ 沉默的教堂</h2><blockquote><p>泰勒起身要走。“外面有一个世界，塔拉，”他说，“一旦爸爸不再在你耳边灌输他的观点，世界就会看起来大不一样。”</p></blockquote><p>打破你认知体系的唯一办法就是外界主动注入。</p><h2 id="◆-不再是孩子">◆ 不再是孩子</h2><blockquote><p>她把目光转向我。我已多年未感受到她目光的力量了，为此我惊呆了。“在我所有的孩子中，”她说，“我原以为你才是那个穿越熊熊大火冲出这里的人。我从没料到会是泰勒——那令人意外——而不是你。你不要留下。走吧。不要让任何事阻止你走。”</p></blockquote><p>（转）如果有一天：你不再寻找爱情，只是去爱；不再渴望成功，只是去做；你不再追求空泛的成长，只是开始修养自己的性情；你的人生，才真正开始。</p><p>​ — 纪伯伦</p><blockquote><p>我们俩都是鱼眼睛。</p></blockquote><p>都是可怜人儿</p><h2 id="◆-不忠的人，违逆的天堂">◆ 不忠的人，违逆的天堂</h2><p>恭喜你，塔拉，勇敢的迈出这一步，尽管这一步代表了恐惧、期待、决裂 它仍是你最勇敢的一步。</p><h2 id="◆-父辈的吟诵">◆ 父辈的吟诵</h2><blockquote><p>“像腐烂的植物。”<br>我耸了耸肩。</p></blockquote><p>习惯了</p><blockquote><p>有的人反对平等的大潮；有的人必须从某些人那里夺取自由。</p></blockquote><h2 id="◆-我们的低语，我们的尖叫">◆ 我们的低语，我们的尖叫</h2><blockquote><p>对我来说重要的不是爱情或友情，而是我自欺欺人的能力：相信自己很坚强。查尔斯知道我并非如此，因此我永远不会原谅他。</p></blockquote><h2 id="◆-毕业">◆ 毕业</h2><blockquote><p>“如果你在美国，”他低声说，“无论你在哪个角落，我们都可以去找你。我在地下埋了一千加仑汽油。世界末日来临时我可以去接你，带你回家，让你平平安安的。但要是你去了大洋彼岸……”</p></blockquote><h2 id="◆-悲剧之后的闹剧">◆ 悲剧之后的闹剧</h2><blockquote><p>面对现实是痛苦的，她写道，意识到有丑恶的东西存在，而我对此视而不见。</p></blockquote><h2 id="◆-事物的本质">◆ 事物的本质</h2><blockquote><p>你会选择这样的刀进行一场杀戮，在猎物的心脏停止跳动的那一刻，感受鲜血从掌心流过：那不是农夫的刀，甚至不是屠夫的刀。它是一把愤怒的刀。</p></blockquote><h2 id="◆-两双挥舞的手臂">◆ 两双挥舞的手臂</h2><blockquote><p>我在乎的是他的想法；他才是我要失去的人。</p></blockquote><h2 id="◆-守望野牛">◆ 守望野牛</h2><blockquote><p>但我知道，一旦走进那扇门，将有什么心照不宣的协定等着我。我可以得到母爱，但有一些条件，和三年前他们给我开出的条件一样：用我的现实来交换他们的现实，将自己的见解埋葬，让它在大地中腐烂。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS系统每次更新系统后missing Xcrun</title>
    <link href="/dajiangdahe/2021/10/30/xcrun/"/>
    <url>/dajiangdahe/2021/10/30/xcrun/</url>
    
    <content type="html"><![CDATA[<h1>mac系统每次更新系统后missing xcrun at:/Library/Developer/CommandLineTools/usr/bin/xcrun</h1><hr><p>昨日Mac由 big sur 升级到 Monterey 后，部署blog，出现fatal error。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) guolonghang@guolonghangdeMacBook-Pro blog % hexo d<br>INFO  Validating config<br>INFO  Deploying: git<br>INFO  Clearing .deploy_git folder...<br>INFO  Copying files from public folder...<br>INFO  Copying files from extend dirs...<br>xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun<br>FATAL &#123;<br>  err: Error: Spawn failed<br>      at ChildProcess.&lt;anonymous&gt; (/Users/guolonghang/Documents/blog/node_modules/hexo-util/lib/spawn.js:51:21)<br>      at ChildProcess.emit (node:events:390:28)<br>      at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12) &#123;<br>    code: 1<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>【原因】</strong></p><p>系统升级后，默认是不会安装Command Line Tools的，而在很多时候都会使用到Command Line Tools。实际原因很简单是缺少相关的可执行文件导致的，此处虽然hexo执行失败，但是核心是git执行失败。</p><p><strong>【解决】</strong></p><blockquote><p>xcode-select --install</p></blockquote><p>这个会触发softwareupdate，等待安装完就OK了。如果有些工具在安装完依然报错，可以尝试重启。</p>]]></content>
    
    
    <categories>
      
      <category>MacOS系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper从入门到放弃</title>
    <link href="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <url>/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    
    <content type="html"><![CDATA[<hr><h1>1. zookeeper入门</h1><h2 id="1-1-概述">1.1 概述</h2><p>zookeeper是一个开源的分布式的，为分布式框架提<strong>供协调服务</strong>的Apache项目</p><h2 id="1-2-工作机制">1.2 工作机制</h2><p>Zookeeper从设计模式角度来理解：是一个<strong>基于观察者模式</strong>设计的分布式服务管理框架，它<strong>负责存储和管理</strong>大家都关心的数据，然后<strong>接受观察者的注册</strong>， 一旦这些数据的状态发生变化，Zookeeper 就将<strong>负责通知已经在Zookeeper上注册的那些观察者</strong>做出相应的反应。</p><ol><li>基于观察者模式设计的框架</li><li>负责存储和管理的数据</li><li>接受观察者（服务）的注册</li><li>负责通知已经在zookeeper上注册的观察者（服务）</li></ol><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023222918327.png" class="" title="image-20211023222918327"><ol><li>服务端启动时去注册信息（创建都是临时节点）</li><li>客户端从zookeeper获取当前在线服务器列表，并且注册监听</li><li>if 服务器节点下线</li><li>zookeeper通知客户端服务器节点上下线</li><li>客户端再次获取在线服务器列表，并注册监听</li></ol><h2 id="1-3-zookeeper特点">1.3 zookeeper特点</h2><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023223955588.png" class="" title="image-20211023223955588"><ol><li>Zookeeper：<strong>一个领导者</strong>（Leader），<strong>多个跟随者</strong>（Follower）组成的集群。</li><li>集群中只要有<strong>半数以上节点存活</strong>，Zookeeper集群就能正常服务。所以Zookeeper适合<strong>安装奇数台服务器</strong>。</li><li>全局数据一致：每个<strong>Server保存一份相同的数据副本</strong>，Client无论连接到哪个Server，数据都是一致的。</li><li><strong>更新请求顺序执行</strong>，来自同一个Client的更新请求按其发送顺序依次执行。</li><li>单一Client 数<strong>据更新原子性</strong>，一次数据更新要么成功，要么失败。</li><li><strong>实时性</strong>，在一定时间范围内，Client能读到最新数据。</li></ol><h2 id="1-4-数据结构">1.4 数据结构</h2><p>ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是<strong>一棵树</strong>，每个 节点称做一个 <strong>ZNode</strong>。每一个 ZNode 默认能够<strong>存储 1MB</strong> 的数据，每个 ZNode 都可以通<strong>过其路径唯一标识</strong>。</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023224426987.png" class="" title="image-20211023224426987"><h2 id="1-5-应用场景">1.5 应用场景</h2><ol><li><p><strong>统一命名服务</strong></p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023224814675.png" class="" title="image-20211023224814675"></li><li><p><strong>统一配置管理</strong></p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023225045932.png" class="" title="image-20211023225045932"></li><li><p><strong>统一集群管理</strong></p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023225313620.png" class="" title="image-20211023225313620"></li><li><p><strong>服务器节点动态上下线</strong></p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023225524570.png" class="" title="image-20211023225524570"></li><li><p><strong>软负载均衡</strong></p></li></ol><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023225737241.png" class="" title="image-20211023225737241"><h1>2. zookeeper安装</h1><h2 id="2-1-本地安装以及目录解读">2.1 本地安装以及目录解读</h2><p><strong>zookeeper目录</strong></p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023232208355.png" class="" title="image-20211023232208355"><p><strong>zookeeper/bin 目录结构</strong></p><p>其中<strong><a href="http://zkCli.sh">zkCli.sh</a></strong> 是作为客户端启动</p><p>其中<strong><a href="http://zkServer.sh">zkServer.sh</a></strong> 是作为服务端启动</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023232835716.png" class="" title="image-20211023232835716"><p><strong>zookeeper/conf 目录结构</strong></p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023233200810.png" class="" title="image-20211023233200810"><p>其中 <strong>zoo_sample.cfg</strong> 是zookeeper配置文件，是示例配置文件，本套课程中修改为zoo.cfg。</p><p>由于/tmp为Linux临时储存地址（会被清理清理），所以将其默认dataDir地址改成自己新建的zkData文件夹下。</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211025095457555.png" class="" title="image-20211025095457555"><p>一般我们将zookeeper的数据文件放到<strong>zookeeper/zkData</strong>下</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211025095409917.png" class="" title="image-20211025095409917"><p>启动时</p><ul><li>先启动zkServer</li><li>在启动zkclient</li></ul><h2 id="2-2-参数配置解析">2.2 参数配置解析</h2><p>1）<strong>tickTime = 2000</strong>：通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023235631976.png" class="" title="image-20211023235631976"><p>2）<strong>initLimit = 10</strong>：LF初始通信时限</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023235701539.png" class="" title="image-20211023235701539"><p>3）<strong>syncLimit = 5</strong>：LF同步通信时限</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211023235734230.png" class="" title="image-20211023235734230"><p>4）<strong>dataDir</strong>：保存Zookeeper中的数据 注意：<strong>默认的tmp目录，容易被Linux系统定期删除</strong>，所以一般不用默认的tmp目录。</p><p>5）<strong>clientPort = 2181</strong>：客户端连接端口，通常不做修改。</p><h1>3. zookeeper集群操作</h1><h2 id="3-1-服务器集群配置">3.1 服务器集群配置</h2><ol><li><p>在/opt/module/zookeeper-3.5.7/zkData 目录下创建一个 myid 的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi myid<br></code></pre></td></tr></table></figure></li><li><p>在文件中添加与 server 对应的编号（注意：上下不要有空行，左右不要有空格）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2<br></code></pre></td></tr></table></figure></li><li><p>拷贝配置好的 zookeeper 到其他机器上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">xsync zookeeper-3.5.7<br></code></pre></td></tr></table></figure><p>分别在其他服务器上，进行server编号更改（3，4）</p></li><li><p>在zoo.cfg配置文件下进行集群配置</p><figure class="highlight plaintext"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs she">#######################cluster##########################<br>server.2=hadoop102:2888:3888<br>server.3=hadoop103:2888:3888<br>server.4=hadoop104:2888:3888<br></code></pre></td></tr></table></figure><p>配置解读 <strong>server.A=B:C:D</strong></p><ul><li>其中A数字表示第几台服务器。<strong>集群模式下配置一个文件 myid，这个文件在 dataDir目录下，这个文件里面有一个数据就是 A 的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个 server。</strong></li><li>B是这个服务器的地址</li><li>C是这个服务器Follower与集群中Leader 服务器交换信息的端口</li><li>D是万一这个集群中的Leader挂了，需要一个端口进行重新选举，这个端口就是用来执行选举时，实现服务器之间消息互通的端口</li></ul></li><li><p>分发配置完成后（xsync命令），启动服务器，<strong>bin/zkServer.sh start</strong></p><ul><li><p><strong>注意1：客户端命令行末尾没有start</strong></p></li><li><p><strong>注意2：如果在启动服务器集群时，并没有start数量超过半数，则会报error错误，不符合集群工作的原理（有半数以上节点启动 ，集群才开始工作）</strong></p></li></ul></li></ol><h2 id="3-2-选举机制">3.2 选举机制</h2><h3 id="3-2-1-zookeeper集群第一次启动时">3.2.1 zookeeper集群第一次启动时</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211025102232854.png" class="" title="image-20211025102232854"><ul><li>总结：一般来说，第一次启动时，leader为server编号（start+end）/2。</li></ul><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211025103218805.png" class="" title="image-20211025103218805"><ul><li>客户端对于集群的写操作，主要通过是三个ID号来标志访问的节点，分别是SID、ZXID、Epoch。</li></ul><h3 id="3-2-2-zookeeper集群非第一次启动时">3.2.2 zookeeper集群非第一次启动时</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211025104410548.png" class="" title="image-20211025104410548"><h2 id="3-3-客户端命令行操作">3.3 客户端命令行操作</h2><h3 id="3-3-1-启动客户端和znode参数信息">3.3.1 启动客户端和znode参数信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/zkCli.sh --server name:xxxx //此方式可以指定服务器等名字<br></code></pre></td></tr></table></figure><ol><li>czxid：**创建节点的事务  zxid每次修改 ZooKeeper 状态都会产生一个 ZooKeeper 事务 ID。**事务 ID 是 ZooKeeper 中所 有修改总的次序。每次修改都有唯一的 zxid，如果 zxid1 小于 zxid2，那么 zxid1 在 zxid2 之 前发生。</li><li>ctime：znode 被<strong>创建</strong>的毫秒数（从 1970 年开始）</li><li>mzxid：znode 最后<strong>更新</strong>的事务 zxid</li><li>mtime：znode 最后<strong>修改</strong>的毫秒数（从 1970 年开始）</li><li>pZxid：znode 最后<strong>更新的子节点</strong> zxid</li><li>cversion：znode 子节点变化号，znode 子节点<strong>修改次数</strong></li><li>dataversion：znode <strong>数据变化号</strong></li><li>aclVersion：znode 访问<strong>控制列表的变化号</strong></li><li>ephemeralOwner：如果是<strong>临时节点</strong>，这个是  znode 拥有者的 session id。如果不是临时节点则是 0。</li><li>dataLength：znode 的<strong>数据长度</strong></li><li>numChildren：znode <strong>子节点数量</strong></li></ol><h3 id="3-3-2-znode节点类型">3.3.2 znode节点类型</h3><ol><li><p>持久节点：当客户端与服务器断开链接时，创建的节点不会被删除</p><ol><li>持久节点不带顺序编号</li><li>持久节点带顺序编号，只是zookeeper会给该节点进行编号而已，顺序号由父节点维护</li></ol><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026214405461.png" class="" title="image-20211026214405461"></li><li><p>短暂节点：当客户端与服务器断开连接时，创建的节点会自己删除</p><ol><li>临时节点不带顺序编号</li><li>临时节点带顺序编号，只是zookeeper会给该节点进行编号而已</li></ol></li><li><p>带序号节点 vs 不带序号节点</p><ol><li>不带序号节点只可以创建一个，带序号节点可以创建多个+序列号</li></ol></li></ol><h4 id="3-3-2-1-创建永久节点">3.3.2.1 创建永久节点</h4><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026214711434.png" class="" title="image-20211026214711434"><h4 id="3-3-2-2-获取节点值与其属性">3.3.2.2 获取节点值与其属性</h4><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026214817531.png" class="" title="image-20211026214817531"><h4 id="3-3-2-3-创建持久带序号的节点">3.3.2.3 创建持久带序号的节点</h4><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026215051736.png" class="" title="image-20211026215051736"><h4 id="3-3-2-4-创建短暂节点">3.3.2.4 创建短暂节点</h4><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026215720659.png" class="" title="image-20211026215720659"><h4 id="3-3-2-5-创建短暂带序号节点">3.3.2.5 创建短暂带序号节点</h4><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026215806271.png" class="" title="image-20211026215806271"><h4 id="3-3-2-6-修改节点">3.3.2.6 修改节点</h4><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026215848192.png" class="" title="image-20211026215848192"><h3 id="3-3-4-监听器原理">3.3.4 监听器原理</h3><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、节点删除、子目 录节点增加删除）时，ZooKeeper 会通知客户端。监听机制保证 ZooKeeper 保存的任何的数 据的任何改变都能快速的响应到监听了该节点的应用程序。</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026220152902.png" class="" title="image-20211026220152902"><h4 id="3-3-4-1-节点的值变化监听">3.3.4.1 节点的值变化监听</h4><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026220610359.png" class="" title="image-20211026220610359"><h4 id="3-3-4-2-节点的子节点变化监听">3.3.4.2 节点的子节点变化监听</h4><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026220849104.png" class="" title="image-20211026220849104"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026220910133.png" class="" title="image-20211026220910133"><h4 id="3-3-4-3-节点的删除与查看">3.3.4.3 节点的删除与查看</h4><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026221008642.png" class="" title="image-20211026221008642"><h3 id="3-3-5-客户端API操作">3.3.5 客户端API操作</h3><h4 id="3-3-5-1-初始化zookeeper">3.3.5.1 初始化zookeeper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 初始化</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException ioexception</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Before</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>       <span class="hljs-comment">//string多台服务器地址之间不允许有空格</span><br>       String coonectString = <span class="hljs-string">&quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;</span>;<br>       <span class="hljs-keyword">int</span> sessionTimeout = <span class="hljs-number">2000</span>;<br>       zkClient = <span class="hljs-keyword">new</span> ZooKeeper(coonectString, sessionTimeout, <span class="hljs-keyword">new</span> Watcher() &#123;<br>           <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * 这是监听线程，观察服务器集群中是否有新的节点变化</span><br><span class="hljs-comment">            *</span><br><span class="hljs-comment">            * <span class="hljs-doctag">@param</span> watchedEvent 关注的事件</span><br><span class="hljs-comment">            */</span><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>               List&lt;String&gt; children = <span class="hljs-keyword">null</span>;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   children = zkClient.getChildren(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-keyword">true</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>                   e.printStackTrace();<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>               <span class="hljs-keyword">for</span> (String child : children) &#123;<br>                   System.out.println(<span class="hljs-string">&quot;子节点：&quot;</span> + child);<br>               &#125;<br>           &#125;<br>       &#125;);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-5-2-创建节点">3.3.5.2 创建节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>        String nodeCreated = zkClient.create(<span class="hljs-string">&quot;/atguigu&quot;</span>, <span class="hljs-string">&quot;ss.avi&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-5-3-查询子节点">3.3.5.3 查询子节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 监听子节点</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getChildNode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>       List&lt;String&gt; children = zkClient.getChildren(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-keyword">true</span>);<br>       <span class="hljs-keyword">for</span> (String child : children) &#123;<br>           System.out.println(<span class="hljs-string">&quot;子节点：&quot;</span> + child);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-5-4-判断节点是否存在">3.3.5.4 判断节点是否存在</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 判断节点是否存在</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exist</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>       Stat stat = zkClient.exists(<span class="hljs-string">&quot;/atguigu&quot;</span>, <span class="hljs-keyword">false</span>);<br>       System.out.println(stat == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;not exist&quot;</span> : <span class="hljs-string">&quot;exist&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-客户端向服务器端写数据流程">3.4 客户端向服务器端写数据流程</h2><ol><li><p><strong>向leader节点写数据流程</strong></p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026225528071.png" class="" title="image-20211026225528071"><p>实际上当服务器集群中<strong>超过半数的节点</strong>完成write操作，就由leader返回ack通知</p></li><li><p><strong>向follower节点写数据流程</strong></p></li></ol><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211026225541675.png" class="" title="image-20211026225541675"><p>​当数据流向follower时，<strong>follower不会先进行write操作，而是先进行write请求转发到leader</strong>，再由leader进行write请求分发，可谓等级森严。<strong>当流向follower完成write操作时，返回ack给client，而不是由leader返回。</strong></p><h1>4. 服务器动态上下线监听案例</h1><h2 id="4-1-需求">4.1 需求</h2><p>在分布式系统中，主节点可以用多台，可以动态上下线，任意一台客户端都能实时感受到主节点服务器的上下线</p><h2 id="4-2-需求分析">4.2 需求分析</h2><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211027094852005.png" class="" title="image-20211027094852005"><p>zookeeper集群中 主要分两大类，一类是服务器，一类是客户端，服务器主要用作create节点，客户端主要用作get节点。</p><h2 id="4-3-具体代码">4.3 具体代码</h2><ol><li><p>在服务器集群中 create /server “servers”</p></li><li><p>服务器端向zookeeper注册代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> bjut.kengkeng.test;<br><br><span class="hljs-keyword">import</span> org.apache.zookeeper.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分发服务器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guolonghang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021-10-27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistributeServer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * zk服务器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> ZooKeeper zkServer;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 会话超时</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sessionTimeout;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 连接地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String connString;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args arg游戏</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException          ioexception</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException 中断异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> KeeperException      门将例外</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;<br><br>        DistributeServer server = <span class="hljs-keyword">new</span> DistributeServer();<br>        <span class="hljs-comment">//1.获取zk集群</span><br>        server.getConnect();<br>        <span class="hljs-comment">//2.注册服务器到集群中</span><br>        server.registry(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//3.启动业务</span><br>        server.business();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException 中断异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">business</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hostname 主机名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException 中断异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> KeeperException      门将例外</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registry</span><span class="hljs-params">(String hostname)</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>String path = <span class="hljs-string">&quot;/servers/&quot;</span>+hostname;<br>      String status = zkServer.create(path, hostname.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br>        System.out.println(status);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得连接</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException ioexception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getConnect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        connString = <span class="hljs-string">&quot;&quot;</span>;<br>        sessionTimeout = <span class="hljs-number">0</span>;<br>        zkServer = <span class="hljs-keyword">new</span> ZooKeeper(connString, sessionTimeout, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> bjut.kengkeng.test;<br><br><span class="hljs-keyword">import</span> org.apache.zookeeper.KeeperException;<br><span class="hljs-keyword">import</span> org.apache.zookeeper.WatchedEvent;<br><span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher;<br><span class="hljs-keyword">import</span> org.apache.zookeeper.ZooKeeper;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分配客户</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guolonghang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021-10-27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistributeClient</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 康涅狄格州的字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String connString;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 会话超时</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sessionTimeout;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * zk的客户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> ZooKeeper zkClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主要</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args arg游戏</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException          ioexception</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException 中断异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> KeeperException      门将例外</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;<br><br>        DistributeClient client = <span class="hljs-keyword">new</span> DistributeClient();<br>        <span class="hljs-comment">//1.获取zk连接</span><br>        client.getConnect();<br>        <span class="hljs-comment">//2.监听/servers节点路径的变化(监听器的编写)</span><br>        client.getServerList(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//3.业务逻辑</span><br>        client.business();<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException 中断异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">business</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取服务器列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path 路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException 中断异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> KeeperException      门将例外</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getServerList</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>        List&lt;String&gt; children = zkClient.getChildren(path, <span class="hljs-keyword">true</span>);<br>        ArrayList&lt;String&gt; serverChildren = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String child : children) &#123;<br>            <span class="hljs-keyword">byte</span>[] data = zkClient.getData(path + child, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>            serverChildren.add(data.toString());<br>        &#125;<br>        System.out.println(serverChildren);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得连接</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException ioexception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getConnect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        connString = <span class="hljs-string">&quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;</span>;<br>        sessionTimeout = <span class="hljs-number">0</span>;<br>        zkClient = <span class="hljs-keyword">new</span> ZooKeeper(connString, sessionTimeout, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="4-4-测试">4.4 测试</h2><p>//todo</p><h1>5. zookeeper分布式锁案例</h1><p><strong>什么叫做分布式锁呢？</strong><br>比如说&quot;进程   1&quot;在使用该资源的时候，会先去获得锁，&quot;进程   1&quot;获得锁以后会对该资源保持独占，这样其他进程就无法访问资源，&quot;进程 1&quot;用完该资源以后就将锁释放掉，让其他进程来获得锁，那么通过这个锁机制，我们就能保证了分布式系统中多个进程能够有序的访问该临界资源。那么我们把这个分布式环境下的这个锁叫作分布式锁。</p><h2 id="5-1-原生zookeeper分布式锁案例">5.1 原生zookeeper分布式锁案例</h2><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211027104946833.png" class="" title="image-20211027104946833"><ol><li>当多台客户端同时访问zookeeper集群时，zookeeper集群会将所有的client都创建一个临时顺序节点，其目录为/locks</li><li>在locks中的节点按照其编号顺序进行取锁访问，处理业务。</li><li>处理完毕后，delete释放锁，进行下一个节点的业务处理。</li><li>有点像AQS中悲观锁的思想，先进先出。</li></ol><h3 id="5-1-1-zookeeper分布式锁实现">5.1.1 zookeeper分布式锁实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//全局变量</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * zookeeper集群连接地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String connString;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 会话超时</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sessionTimeout;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * zk服务器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZooKeeper zkServer;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 看路</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String watchPath;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 倒计时门闩</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 观察等待</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> CountDownLatch watchAwait = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造器</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分布式锁 构造器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException          ioexception</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException 中断异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> KeeperException      门将例外</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DistributeLock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;<br>        <span class="hljs-comment">//1.获取连接</span><br>        zkServer = <span class="hljs-keyword">new</span> ZooKeeper(connString, sessionTimeout, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>                <span class="hljs-comment">//如果连接上zookeeper需要释放countDownLatch</span><br>                <span class="hljs-keyword">if</span> (watchedEvent.getState()== Event.KeeperState.SyncConnected)&#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>                <span class="hljs-comment">//节点路径变化需要释放watchAwait</span><br>                <span class="hljs-keyword">if</span> (watchedEvent.getType()==Event.EventType.NodeDeleted&amp;&amp;watchedEvent.getPath().equals(watchAwait))&#123;<br>                    watchAwait.countDown();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//等待zk创建成功</span><br>        countDownLatch.await();<br>        <span class="hljs-comment">//2.判断根节点/locks是否存在</span><br>        Stat stat = zkServer.exists(<span class="hljs-string">&quot;/locks&quot;</span>, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == stat) &#123;<br>            <span class="hljs-comment">//服务器创建带序列号带临时节点</span><br>            zkServer.create(<span class="hljs-string">&quot;/locks&quot;</span>, <span class="hljs-string">&quot;locks&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//加锁</span><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * zk锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zkLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//客户端创建临时带序号节点</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            String currNode = zkServer.create(<span class="hljs-string">&quot;/locks/&quot;</span> + <span class="hljs-string">&quot;seq-&quot;</span>, <span class="hljs-keyword">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br><br>            <span class="hljs-comment">//查看/locks目录下的节点</span><br>            List&lt;String&gt; children = zkServer.getChildren(<span class="hljs-string">&quot;/locks&quot;</span>, <span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">//判断当前节点是否为当前目录下最小序号节点，是：获取到锁，否：监听前一个节点</span><br>            <span class="hljs-keyword">if</span> (children.size() == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//排序</span><br>                Collections.sort(children);<br>                <span class="hljs-comment">//获取当前节点名</span><br>                String currNodeName = currNode.substring(<span class="hljs-string">&quot;/locks/&quot;</span>.length());<br>                <span class="hljs-comment">//找到当前集合位置</span><br>                <span class="hljs-keyword">int</span> currNodeIndex = children.indexOf(currNodeName);<br>                <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == currNodeIndex) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;数据异常&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == currNodeIndex) &#123;<br>                    <span class="hljs-comment">//只有一个节点，就直接获取锁</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//监听前一个节点</span><br>                    watchPath = <span class="hljs-string">&quot;/locks/&quot;</span> + children.get(currNodeIndex - <span class="hljs-number">1</span>);<br>                    zkServer.getData(watchPath, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">//确保监听</span><br>                    watchAwait.await();<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//解锁</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * zk解锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zkUnlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//删除节点</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            zkServer.delete(<span class="hljs-string">&quot;/locks/&quot;</span>,-<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>总结：zookeeper原生分布式锁实现主要是依托<strong>创建一个子节点目录群</strong>实现</p><ol><li>当多个client访问zookeeper集群时，服务器端会在/locks/文件下为每个client创建一个带序号的临时节点，这就是zkLock加锁</li><li>每个client按照节点顺序去执行。当业务逻辑执行完成后，删除自己的临时节点。</li><li>其中<strong>countDownLatch</strong>的作用是为了保证代码的健壮性，既确保可以连接到zookeeper集群以及可以监听到“当前节点”</li></ol><h3 id="5-1-2-zookeeper分布式锁测试">5.1.2 zookeeper分布式锁测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> bjut.kengkeng.test;<br><br><span class="hljs-keyword">import</span> org.apache.zookeeper.KeeperException;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistributedLockTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException, KeeperException </span>&#123;<br>        <span class="hljs-keyword">final</span> DistributeLock lock1 = <span class="hljs-keyword">new</span> DistributeLock();<br>        <span class="hljs-keyword">final</span> DistributeLock lock2 = <span class="hljs-keyword">new</span> DistributeLock();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 获取锁对象 </span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    lock1.zkLock();<br>                    System.out.println(<span class="hljs-string">&quot;线程 1获取锁&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);<br>                    lock1.zkUnlock();<br>                    System.out.println(<span class="hljs-string">&quot;线程 1释放锁&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br><br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock2.zkLock();<br>                System.out.println(<span class="hljs-string">&quot;线程 1获取锁&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);<br>                lock2.zkUnlock();<br>                System.out.println(<span class="hljs-string">&quot;线程 1释放锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br><br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-Curator-框架实现分布式锁案例">5.2 Curator 框架实现分布式锁案例</h2><h3 id="5-2-1-原生API存在的问题">5.2.1 原生API存在的问题</h3><ol><li>会话连接是异步的，需要自己去处理。比如使用  CountDownLatch</li><li>Watch 需要重复注册，不然就不能生效</li><li>开发的复杂性还是比较高的</li><li>不支持多节点删除和创建。需要自己去递归</li></ol><h3 id="5-2-2-代码示例">5.2.2 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> bjut.kengkeng.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 馆长锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guolonghang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021-10-27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CuratorLock</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主要</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args arg游戏</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建分布式锁1</span><br>        InterProcessMutex lock1 = <span class="hljs-keyword">new</span> InterProcessMutex(getCuratorFramework(), <span class="hljs-string">&quot;/locks&quot;</span>);<br>        <span class="hljs-comment">//创建分布式锁2</span><br>        InterProcessMutex lock2 = <span class="hljs-keyword">new</span> InterProcessMutex(getCuratorFramework(), <span class="hljs-string">&quot;/locks&quot;</span>);<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock1.acquire();<br>                System.out.println(<span class="hljs-string">&quot;线程1获取锁&quot;</span>);<br>                lock1.release();<br>                System.out.println(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>                lock1.acquire();<br>                System.out.println(<span class="hljs-string">&quot;线程1再次获取锁&quot;</span>);<br>                lock1.release();<br>                System.out.println(<span class="hljs-string">&quot;再次释放锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock2.acquire();<br>                System.out.println(<span class="hljs-string">&quot;线程2获取锁&quot;</span>);<br>                lock2.release();<br>                System.out.println(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>                lock2.acquire();<br>                System.out.println(<span class="hljs-string">&quot;线程2再次获取锁&quot;</span>);<br>                lock2.release();<br>                System.out.println(<span class="hljs-string">&quot;再次释放锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>            &#125;<br>        &#125;).start();<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到馆长框架</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> CuratorFramework&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CuratorFramework <span class="hljs-title">getCuratorFramework</span><span class="hljs-params">()</span> </span>&#123;<br>        ExponentialBackoffRetry retry = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">3000</span>, <span class="hljs-number">3</span>);<br>        CuratorFramework curatorFramework = CuratorFrameworkFactory.builder().connectString(<span class="hljs-string">&quot;hadoop102:2181&quot;</span>)<br>                .sessionTimeoutMs(<span class="hljs-number">2000</span>)<br>                .connectionTimeoutMs(<span class="hljs-number">2000</span>)<br>                .retryPolicy(retry).build();<br><br>        <span class="hljs-comment">//启动客户端</span><br>        curatorFramework.start();<br>        <span class="hljs-keyword">return</span> curatorFramework;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1>6. 企业面试真题</h1><h2 id="6-1-选举机制">6.1 选举机制</h2><p>半数机制，超过半数的投票通过，即通过。</p><ol><li><p>第一次启动选举规则：<br>投票过半数时，服务器  id 大的胜出</p></li><li><p>第二次启动选举规则：<br>①EPOCH 大的直接胜出<br>②EPOCH 相同，事务 id 大的胜出 ③事务 id 相同，服务器 id 大的胜出</p></li></ol><h2 id="6-2-生产集群安装多少zk合适">6.2 生产集群安装多少zk合适</h2><p>安装奇数台。<br>生产经验：<br>⚫         10 台服务器：3 台 zk；<br>⚫         20 台服务器：5 台 zk；<br>⚫         100 台服务器：11 台 zk；<br>⚫         200 台服务器：11 台 zk<br>服务器台数多：好处，提高可靠性；坏处：提高通信延时</p><h2 id="6-3-常用命令">6.3 常用命令</h2><p>ls、get、create、delete</p><h1>7.算法基础</h1><h2 id="7-1-拜占庭将军问题">7.1 拜占庭将军问题</h2><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211027162834105.png" class="" title="image-20211027162834105"><h2 id="7-2-Paxos算法">7.2 Paxos算法</h2><p><strong>Paxos算法</strong>：一种基于消息传递且具有高度容错特性的一致性算法。</p><p><strong>Paxos算法解决的问题</strong>：如何快速正确的在一个分布<code>式系统中实现数据的一致性，并且保证</code>不论发生什么异常，都不会破坏整个系统的一致性</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211028100509787.png" class=""><h3 id="7-2-1-算法描述">7.2.1 算法描述</h3><p>在一个Paxos系统中，将所有的节点划分成了Proposer（提议者）、Acceptor（接受者）、learner（学习者）。每个节点都可以身兼数职。</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211028102420149.png" class="" title="image-20211028102420149"><p>一个完整的Paxos算法流程分为三个阶段：</p><ol><li>prepare准备阶段<ol><li>Proposer向多个Acceptor发出propose请求promise（承诺）。</li><li>Acceptor对收到的propose进行promise（承诺）</li></ol></li><li>Accept接收阶段<ol><li>Proposer收到多数Acceptor的promise后，向Acceptor发出propose请求</li><li>Acceptor针对收到的promise进行accept处理</li></ol></li><li>Learn学习阶段：Proposer将形成的决议发给全部Learner</li></ol><h3 id="7-2-2-算法流程">7.2.2 算法流程</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211028104555482.png" class="" title="image-20211028104555482"><ol><li><strong>Prepare</strong>: Proposer生成全局唯一旦递增的Proposal 1D，向所有Acceptor发送Propose请求，这里无需携带提案内容，只携<br>带Proposal ID即可</li><li><strong>Promise</strong>: Acceptor收到Propose请求后，做出“两个承诺，一个应答”<ol><li>不再接收Proposal ID小于等于（注意：这里是＜二）当前请求的Propose请求。</li><li>不再接收Proposal ID小于（注意：这里是＜）当前请求的Accept请求。</li><li>不违背以前做出的承诺下，回复己经Accept过的提案中Proposal ID最大的那个提案的Value 和Proposal DD，没有则<br>返回空值</li></ol></li><li><strong>Propose</strong>：Proposer收到多数Acceptor的Promnise应答后，从应答中选择Proposal ID最大的提案的Value，作为本次要发起的<br>提案。如果所有应答的提案Value均为空值，则可以自己随意决定提案Value。然后携带当前Proposal ID，向所有Acceptor发送<br>Propose请求。</li><li><strong>Accept</strong>: Acceptor收到Propose请求后，在不违背自己之前做出的承诺下，接受并持久化当 前ProposalID和提家Value。</li><li><strong>Learn</strong>: Proposer收到多数Acceptor的Accept后，决议形成，将形成的决议发送给所有Learner。</li></ol><h3 id="7-2-3-举例">7.2.3 举例</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211028105528384.png" class="" title="image-20211028105528384"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211028105601544.png" class="" title="image-20211028105601544"><p>Paxos 算法缺陷：在网络复杂的情况下，一个应用  Paxos 算法的分布式系统，可能很久 无法收敛，甚至陷入活锁的情况。</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211028145240380.png" class="" title="image-20211028145240380"><p>造成这种情况的原因是系统中有一个以上的 Proposer，多 个 Proposers 相互争夺 Acceptor， 造成迟迟无法达成一致的情况。**针对这种情况，一种改进的 Paxos 算法被提出：从系统中选 出一个节点作为 Leader，只有 Leader 能够发起提案。**这样，一次 Paxos 流程中只有一个 Proposer，不会出现活锁的情况，此时只会出现例子中第一种情况。</p><h2 id="7-3-ZAB算法">7.3 ZAB算法</h2><h3 id="7-3-1-什么是ZAB算法">7.3.1 什么是ZAB算法</h3><p>Zab 借鉴了 Paxos 算法，是特别为 Zookeeper 设计的<strong>支持崩溃恢复的原子广播协议</strong>。基 于该协议，Zookeeper 设计为**只有一台客户端（Leader）**负责处理外部的写事务请求，然后 Leader 客户端将数据同步到其他 Follower 节点。<strong>即 Zookeeper 只有一个 Leader 可以发起提 案。</strong></p><h3 id="7-3-2-ZAB协议内容">7.3.2 ZAB协议内容</h3><p>Zab 协议包括两种基本的模式：消息广播、崩溃恢复。</p><h4 id="7-3-2-1-消息广播模式">7.3.2.1 消息广播模式</h4><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211028151529925.png" class="" title="image-20211028151529925"><ol><li>客户端发起一个写操作请求。</li><li>Leader服务器<strong>将客户端的请求转化为事务Proposal 提案</strong>，同时<strong>为每个Proposal 分配一个全局的1D，即zxid.</strong></li><li>Leader服务器<strong>为每个Follower服务器分配一个单独的队列</strong>，然后将需要广播的 Proposal依次放到队列中去，<strong>并且根据FIFO策略进行消息发送。</strong></li><li>Follower接收到Proposal后，会首先<strong>将其以事务日志的方式写入本地磁盘</strong>中，写入成功后<strong>向Leader反馈一个Ack响应消息</strong></li><li>Ieader接收到<strong>超过半数以上Follower的Ack响应消息</strong>后，即认为消息发送成功，可以发送commit消息。</li><li>Leader向所有Follower广播commit消息，同时自身也会完成事务提交。Follower 接收到commit消息后，会将上一条事务提交。</li><li>zookeeper采用Zab协议的核心，就是只要有一台服务器提交了Proposal，就要确保所有的服务器最终都能正确提交Proposal。</li></ol><p><strong>【问题】</strong></p><p>ZAB协议针对于事务请求的操作类似于一个两段式提交操作。</p><p>（1）广播事务阶段</p><p>（2）广播提交阶段</p><p>（1）但是当Leader提交一个proposal后，就接着宕机了，Follower都没有办法完成proposal</p><p>（2）Leader收到半数的ACK后，还没有来的及commit，就宕机了，Follower也没有办法完成proposal</p><h4 id="7-3-2-2-崩溃恢复">7.3.2.2 崩溃恢复</h4><p>一旦Leader出现了崩溃现象或者因为网络问题与过半的follower失去了连接，Leader就会进入崩溃恢复模式。</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211028152824245.png" class="" title="image-20211028152824245"><ol><li>假设两种服务器异常情况：<ol><li>假设一个事务 在Ieader提出之后，Leader挂了。</li><li>一个事务在Ieader上提交了，并且过半的Follower都响应Ack了，但是Leader在Commit消息发出之前挂了。</li></ol></li><li>zab协议崩溃恢复要求满足以下两个要求：<ol><li>确保已经被Ieader提交的提案Proposal，必须最终被所有的Follower服务器提交。</li><li>确保丢弃已经被Icader提出的，但是没有被提交的Proposal。（丢弃胎死腹中的提案）<br>（己经产生的提案，Follower必须执行)</li></ol></li></ol><p>崩溃恢复主要包括两个阶段即：<strong>【Leader选举】和【数据恢复】</strong></p><p><strong>【Leader选举】</strong></p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211028153512643.png" class="" title="image-20211028153512643"><p>Leader选举:根据上述要求，Zab协议需要保证选举出来的Leader需要要满足以下条件:</p><p>(1)新选举出来的Leader不能包含未提交的Proposal。<strong>即新Leader必须都是已经提交了Proposal的Follower服务器节点。</strong></p><p>(2)新选举的Leader节点中含有最大的zxid。<strong>这样做的好处是可以近避免Leader服务器检查Proposal的提交和丢弃工作。</strong></p><p><strong>【数据恢复】</strong></p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211028153957554.png" class="" title="image-20211028153957554"><p>Zab如何数据同步:</p><p>(1)完成Leader选举后，在正式开始工作之前(接收事务请求，然后提出新的Proposal)，Leader服务器会<strong>首先确认事务日志中的所有的Proposal 是否已经被集群中过半的服务器Commit。</strong></p><p>(2)**Leader服务器需要确保所有的Follower服务器能够接收到每条事务的Proposal，并且能将所有已经提交的事务Proposal，应用到内存数据中。**等到Follower将所有尚未同步的事务Proposal都在Leader服务器上同步过，并且应用到内存数据中以后，Leader才会把该Follower加入到真正可用的Follower列表中。</p><h2 id="7-4-CAP理论">7.4 CAP理论</h2><p>CAP理论告诉我们，一个分布式系统不可能同时满足以下三种</p><ul><li><strong>一致性(C:Consistency)</strong></li><li><strong>可用性(A:Available)</strong></li><li><strong>分区容错性(P:Partition Tolerance)</strong></li></ul><p>这三个基本需求，最多只能同时满足其中的两项，<strong>因为P是必须的，因此往往选择就在CP或者AP中。</strong></p><ol><li>一致性(C:Consistency)：在分布式环境中，<strong>一致性是指数据在多个副本之间是否能够保持数据一致的特性</strong>。在一致性的需求下，<strong>当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。</strong></li><li>可用性(A:Available)：<strong>可用性是指系统提供的服务必须一直处于可用的状态</strong>，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</li><li>分区容错性(P:Partition Tolerance)：<strong>分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务</strong>，除非是整个网络环境都发生了故障。</li><li><strong>ZooKeeper保证的是CP</strong></li><li>ZooKeeper不能保证每次服务请求的可用性。(注:在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要<br>重新请求才能获得结果)。所以说，ZooKeeper不能保证服务可用性。</li><li>进行Leader选举时集群都是不可用。</li></ol><h1>8. 源码详解</h1><h2 id="8-1-辅助源码">8.1 辅助源码</h2><h3 id="8-1-1-持久化源码">8.1.1 持久化源码</h3><p>Leader和follower的数据会在内存和磁盘各保存一份，所以需要将内存中的数据持久化到磁盘里</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029094728816.png" class="" title="image-20211029094728816"><p>（1）：SnapShot源码：快照的源码一般就是序列化和反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SnapShot</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * deserialize a data tree from the last valid snapshot and </span><br><span class="hljs-comment">     * return the last zxid that was deserialized</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dt the datatree to be deserialized into</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sessions the sessions to be deserialized into</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the last zxid that was deserialized from the snapshot</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * 反序列化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">deserialize</span><span class="hljs-params">(DataTree dt, Map&lt;Long, Integer&gt; sessions)</span> </span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * persist the datatree and the sessions into a persistence storage</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dt the datatree to be serialized</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sessions </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * 序列化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(DataTree dt, Map&lt;Long, Integer&gt; sessions, </span></span><br><span class="hljs-params"><span class="hljs-function">            File name)</span> </span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * find the most recent snapshot file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the most recent snapshot file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * 找到最近的快照</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">File <span class="hljs-title">findMostRecentSnapshot</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * free resources from this snapshot immediately</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * 关闭</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><p>（2）TxnLog 日志源码：一般就是对日志的增删改查或者一些定制化的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TxnLog</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Setter for ServerStats to monitor fsync threshold exceed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serverStats used to update fsyncThresholdExceedCount</span><br><span class="hljs-comment">     * 设置服务器的状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setServerStats</span><span class="hljs-params">(ServerStats serverStats)</span></span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * roll the current</span><br><span class="hljs-comment">     * log being appended to</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException </span><br><span class="hljs-comment">     * 回滚日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rollLog</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Append a request to the transaction log</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hdr the transaction header</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the transaction itself</span><br><span class="hljs-comment">     * returns true iff something appended, otw false </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * 追加日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">append</span><span class="hljs-params">(TxnHeader hdr, Record r)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Start reading the transaction logs</span><br><span class="hljs-comment">     * from a given zxid</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> zxid</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> returns an iterator to read the </span><br><span class="hljs-comment">     * next transaction in the logs.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * 根据对应的事务ID读取日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TxnIterator <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">long</span> zxid)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * the last zxid of the logged transactions.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the last zxid of the logged transactions.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * 得到最后一个日志事务ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getLastLoggedZxid</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * truncate the log to get in sync with the </span><br><span class="hljs-comment">     * leader.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> zxid the zxid to truncate at.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException </span><br><span class="hljs-comment">     * 删除</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">truncate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> zxid)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * the dbid for this transaction log. </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the dbid for this transaction log.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * 获取BDID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getDbId</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * commit the transaction and make sure</span><br><span class="hljs-comment">     * they are persisted</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * 提交</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> transaction log&#x27;s elapsed sync time in milliseconds</span><br><span class="hljs-comment">     * 获取同步时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getTxnLogSyncElapsedTime</span><span class="hljs-params">()</span></span>;<br>   <br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * close the transactions logs</span><br><span class="hljs-comment">     * 关闭</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * an iterating interface for reading </span><br><span class="hljs-comment">     * transaction logs. </span><br><span class="hljs-comment">     * 读取日志的接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TxnIterator</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * return the transaction header.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> return the transaction header.</span><br><span class="hljs-comment">         * 获取头信息</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function">TxnHeader <span class="hljs-title">getHeader</span><span class="hljs-params">()</span></span>;<br>        <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * return the transaction record.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> return the transaction record.</span><br><span class="hljs-comment">         * 获取传输的内容</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function">Record <span class="hljs-title">getTxn</span><span class="hljs-params">()</span></span>;<br>     <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * go to the next transaction record.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">         * 下一条资源</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>        <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * close files and release the </span><br><span class="hljs-comment">         * resources</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">         * 关闭</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>        <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Get an estimated storage space used to store transaction records</span><br><span class="hljs-comment">         * that will return by this iterator</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">         * 获取存储的大小</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getStorageSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>（3）处理持久化的核心类</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029100817877.png" class="" title="image-20211029100817877"><h3 id="8-1-2-序列化源码">8.1.2 序列化源码</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029100855921.png" class="" title="image-20211029100855921"><p>（1）序列化和反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Interface that is implemented by generated classes.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@InterfaceAudience</span>.Public<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Record</span> </span>&#123;<br>  <span class="hljs-comment">// 序列化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(OutputArchive archive, String tag)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException</span>;<br>  <span class="hljs-comment">// 反序列化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deserialize</span><span class="hljs-params">(InputArchive archive, String tag)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>（2）迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Interface that acts as an iterator for deserializing maps.</span><br><span class="hljs-comment"> * The deserializer returns an instance that the record uses to</span><br><span class="hljs-comment"> * read vectors and maps. An example of usage is as follows:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;code&gt;</span><br><span class="hljs-comment"> * Index idx = startVector(...);</span><br><span class="hljs-comment"> * while (!idx.done()) &#123;</span><br><span class="hljs-comment"> *   .... // read element of a vector</span><br><span class="hljs-comment"> *   idx.incr();</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * &lt;/code&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Index</span> </span>&#123;<br>    <span class="hljs-comment">// 结束</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">done</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 下一个</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incr</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>(3) 序列化支持的数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Interface that alll the serializers have to implement.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OutputArchive</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeByte</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBool</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeLong</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeFloat</span><span class="hljs-params">(<span class="hljs-keyword">float</span> f, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeDouble</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeString</span><span class="hljs-params">(String s, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuffer</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> buf[], String tag)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeRecord</span><span class="hljs-params">(Record r, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startRecord</span><span class="hljs-params">(Record r, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endRecord</span><span class="hljs-params">(Record r, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startVector</span><span class="hljs-params">(List&lt;?&gt; v, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endVector</span><span class="hljs-params">(List&lt;?&gt; v, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startMap</span><span class="hljs-params">(TreeMap&lt;?,?&gt; v, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endMap</span><span class="hljs-params">(TreeMap&lt;?,?&gt; v, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>(4) 反序列化支持的数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Interface that all the Deserializers have to implement.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InputArchive</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span> <span class="hljs-title">readByte</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readBool</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">readInt</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">readLong</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">readFloat</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">readDouble</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readString</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] readBuffer(String tag) <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readRecord</span><span class="hljs-params">(Record r, String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startRecord</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endRecord</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Index <span class="hljs-title">startVector</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endVector</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Index <span class="hljs-title">startMap</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endMap</span><span class="hljs-params">(String tag)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="8-2-ZK-服务端初始化源码解析">8.2 ZK 服务端初始化源码解析</h2><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029101916331.png" class="" title="image-20211029101916331"><h3 id="8-2-1-ZK-服务端启动脚本分析">8.2.1 ZK 服务端启动脚本分析</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029102200208.png" class="" title="image-20211029102200208"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029102302273.png" class="" title="image-20211029102302273"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029102414373.png" class="" title="image-20211029102414373"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029102508800.png" class="" title="image-20211029102508800"><h3 id="8-2-2-ZK-服务端启动入口">8.2.2 ZK 服务端启动入口</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029103021012.png" class="" title="image-20211029103021012"><ol><li>首先是创建了一个QuorumPeerMain实例对象，然后执行QuorumPeerMain.initializeAndRun()方法</li></ol><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029103145824.png" class="" title="image-20211029103145824"><ol start="2"><li>其中initializeAndRun方法用来管理zk的配置信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeAndRun</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> ConfigException, IOException, AdminServerException</span><br><span class="hljs-function">    </span>&#123;<br>  <span class="hljs-comment">// 1. 新建一个配置对象</span><br>        QuorumPeerConfig config = <span class="hljs-keyword">new</span> QuorumPeerConfig();<br>        <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-comment">// 解析参数，获取zoo.cfg myid</span><br>            config.parse(args[<span class="hljs-number">0</span>]);<br>        &#125;<br><br>        <span class="hljs-comment">//  2. 启动定时任务，对过期的快照，执行删除（默认该功能关闭）</span><br>        DatadirCleanupManager purgeMgr = <span class="hljs-keyword">new</span> DatadirCleanupManager(config<br>                .getDataDir(), config.getDataLogDir(), config<br>                .getSnapRetainCount(), config.getPurgeInterval());<br>        purgeMgr.start();<br><span class="hljs-comment">// 3  启动集群</span><br>        <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span> &amp;&amp; config.isDistributed()) &#123;<br>            runFromConfig(config);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Either no config or no quorum defined in config, running &quot;</span><br>                    + <span class="hljs-string">&quot; in standalone mode&quot;</span>);<br>            <span class="hljs-comment">// there is only server in the quorum -- run as standalone</span><br>            ZooKeeperServerMain.main(args);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-3-解析参数-zoo-cfg-和-myid">8.2.3 解析参数 zoo.cfg 和 myid</h3><ol><li>解析zoo.cfg 和 myid</li></ol><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029103735304.png" class="" title="image-20211029103735304"><ol start="4"><li>根据路径解析zoo.cfg 然后将其转换为properties文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> ConfigException </span>&#123;<br>       LOG.info(<span class="hljs-string">&quot;Reading configuration from: &quot;</span> + path);<br>      <br>       <span class="hljs-keyword">try</span> &#123;<br>           File configFile = (<span class="hljs-keyword">new</span> VerifyingFileFactory.Builder(LOG)<br>               .warnForRelativePath()<br>               .failForNonExistingPath()<br>               .build()).create(path);<br>               <br>           Properties cfg = <span class="hljs-keyword">new</span> Properties();<br>           FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(configFile);<br>           <span class="hljs-keyword">try</span> &#123;<br>               cfg.load(in);<br>               configFileStr = path;<br>           &#125; <span class="hljs-keyword">finally</span> &#123;<br>               in.close();<br>           &#125;<br>           <span class="hljs-comment">// 构造成properties类型文件</span><br>           parseProperties(cfg);<br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigException(<span class="hljs-string">&quot;Error processing &quot;</span> + path, e);<br>       &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigException(<span class="hljs-string">&quot;Error processing &quot;</span> + path, e);<br>       &#125;   <br></code></pre></td></tr></table></figure><ol start="5"><li>解析properties文件。<strong>zoo.cfg配置文件–&gt;properties文件–&gt;map集合</strong> 根据zoo.cfg配置文件对实例对象进行setter设置。完成初始化。</li></ol><ol start="6"><li>设置myid和QuorumPeerConfig</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setupMyId</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File myIdFile = <span class="hljs-keyword">new</span> File(dataDir, <span class="hljs-string">&quot;myid&quot;</span>);<br>        <span class="hljs-comment">// standalone server doesn&#x27;t need myid file.</span><br>        <span class="hljs-keyword">if</span> (!myIdFile.isFile()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(myIdFile));<br>        String myIdString;<br>        <span class="hljs-keyword">try</span> &#123;<br>            myIdString = br.readLine();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            br.close();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            serverId = Long.parseLong(myIdString);<br>            MDC.put(<span class="hljs-string">&quot;myid&quot;</span>, myIdString);<br>        &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;serverid &quot;</span> + myIdString<br>                    + <span class="hljs-string">&quot; is not a number&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupQuorumPeerConfig</span><span class="hljs-params">(Properties prop, <span class="hljs-keyword">boolean</span> configBackwardCompatibilityMode)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, ConfigException </span>&#123;<br>        quorumVerifier = parseDynamicConfig(prop, electionAlg, <span class="hljs-keyword">true</span>, configBackwardCompatibilityMode);<br>        setupMyId();<br>        setupClientPort();<br>        setupPeerType();<br>        checkValidity();<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>小结<ol><li>首先是创建了一个<strong>QuorumPeerMain</strong>实例对象，然后执行QuorumPeerMain.i**nitializeAndRun()**方法</li><li>其中initializeAndRun方法用来管理zk的配置信息</li><li>解析<strong>zoo.cfg</strong> 和 <strong>myid</strong></li><li>根据路径解析zoo.cfg 然后将其转换为properties文件</li><li>解析properties文件。<strong>zoo.cfg配置文件–&gt;properties文件–&gt;map集合</strong> 根据zoo.cfg配置文件对实例对象进行setter设置。完成初始化。</li><li>设置myid和QuorumPeerConfig</li></ol></li></ol><h3 id="8-2-4-过期快照删除">8.2.4  过期快照删除</h3><p>可以启动定时任务，对过期的快照，执行删除。默认该功能时关闭的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeAndRun</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> ConfigException, IOException, AdminServerException</span><br><span class="hljs-function">    </span>&#123;<br>        QuorumPeerConfig config = <span class="hljs-keyword">new</span> QuorumPeerConfig();<br>        <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span>) &#123;<br>            config.parse(args[<span class="hljs-number">0</span>]);<br>        &#125;<br><br>        <span class="hljs-comment">// 启动定时任务</span><br>        DatadirCleanupManager purgeMgr = <span class="hljs-keyword">new</span> DatadirCleanupManager(config<br>                .getDataDir(), config.getDataLogDir(), config<br>                .getSnapRetainCount(), config.getPurgeInterval());<br>        purgeMgr.start();<br><br>        <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">1</span> &amp;&amp; config.isDistributed()) &#123;<br>            runFromConfig(config);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Either no config or no quorum defined in config, running &quot;</span><br>                    + <span class="hljs-string">&quot; in standalone mode&quot;</span>);<br>            <span class="hljs-comment">// there is only server in the quorum -- run as standalone</span><br>            ZooKeeperServerMain.main(args);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> snapRetainCount = <span class="hljs-number">3</span>; <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> purgeInterval = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029105415327.png" class="" title="image-20211029105415327"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (PurgeTaskStatus.STARTED == purgeTaskStatus) &#123;<br>            LOG.warn(<span class="hljs-string">&quot;Purge task is already running.&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>   <span class="hljs-comment">// //  默认情况  purgeInterval=0，该任务关闭，直接返回</span><br>        <span class="hljs-comment">// Don&#x27;t schedule the purge task with zero or negative purge interval.</span><br>        <span class="hljs-keyword">if</span> (purgeInterval &lt;= <span class="hljs-number">0</span>) &#123;<br>            LOG.info(<span class="hljs-string">&quot;Purge task is not scheduled.&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-comment">//  创建一个定时器</span><br>        timer = <span class="hljs-keyword">new</span> Timer(<span class="hljs-string">&quot;PurgeTask&quot;</span>, <span class="hljs-keyword">true</span>);<br>   <span class="hljs-comment">//  创建一个清理快照任务</span><br>        TimerTask task = <span class="hljs-keyword">new</span> PurgeTask(dataLogDir, snapDir, snapRetainCount);<br>   <span class="hljs-comment">//  如果  purgeInterval 设置的值是 1，表示  1 小时检查一次，判断是否有过期快照， 有则删除</span><br>        timer.scheduleAtFixedRate(task, <span class="hljs-number">0</span>, TimeUnit.HOURS.toMillis(purgeInterval));<br><br>        purgeTaskStatus = PurgeTaskStatus.STARTED;<br>    &#125;<br><br> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PurgeTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TimerTask</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> File logsDir;<br>        <span class="hljs-keyword">private</span> File snapsDir;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> snapRetainCount;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PurgeTask</span><span class="hljs-params">(File dataDir, File snapDir, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>            logsDir = dataDir;<br>            snapsDir = snapDir;<br>            snapRetainCount = count;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>          <span class="hljs-comment">//  清理过期的数据</span><br>            LOG.info(<span class="hljs-string">&quot;Purge task started.&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                PurgeTxnLog.purge(logsDir, snapsDir, snapRetainCount);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LOG.error(<span class="hljs-string">&quot;Error occurred while purging.&quot;</span>, e);<br>            &#125;<br>            LOG.info(<span class="hljs-string">&quot;Purge task completed.&quot;</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//PurgeTxnLog类中的方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">purge</span><span class="hljs-params">(File dataDir, File snapDir, <span class="hljs-keyword">int</span> num)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(COUNT_ERR_MSG);<br>        &#125;<br><br>        FileTxnSnapLog txnLog = <span class="hljs-keyword">new</span> FileTxnSnapLog(dataDir, snapDir);<br><br>        List&lt;File&gt; snaps = txnLog.findNRecentSnapshots(num);<br>        <span class="hljs-keyword">int</span> numSnaps = snaps.size();<br>        <span class="hljs-keyword">if</span> (numSnaps &gt; <span class="hljs-number">0</span>) &#123;<br>            purgeOlderSnapshots(txnLog, snaps.get(numSnaps - <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-5-初始化通信组件">8.2.5  初始化通信组件</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029105918689.png" class="" title="image-20211029105918689"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029105934464.png" class="" title="image-20211029105934464"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029105954513.png" class="" title="image-20211029105954513"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029110018034.png" class="" title="image-20211029110018034"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211029110033262.png" class="" title="image-20211029110033262"><h2 id="8-3-ZK-服务端加载数据源码解析">8.3 ZK 服务端加载数据源码解析</h2><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030212621640.png" class="" title="image-20211030212621640"><ol><li>zk 中的数据模型，是一棵树，DataTree，每个节点，叫做 DataNode</li><li>zk 集群中的 DataTree 时刻保持状态同步</li><li>Zookeeper 集群中每个 zk 节点中，数据在内存和磁盘中都有一份完整的数据。<ol><li>内存数据：DataTree</li><li>磁盘数据：快照文件   + 编辑日志</li></ol></li></ol><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030212738023.png" class="" title="image-20211030212738023"><h3 id="8-3-1-冷启动数据恢复快照数据">8.3.1 冷启动数据恢复快照数据</h3><p>（1） 启动集群</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030212915995.png" class="" title="image-20211030212915995"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030212935913.png" class="" title="image-20211030212935913"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030212958876.png" class="" title="image-20211030212958876"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213013216.png" class="" title="image-20211030213013216"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213026552.png" class="" title="image-20211030213026552"><h3 id="8-3-2-冷启动恢复数据">8.3.2 冷启动恢复数据</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213100808.png" class="" title="image-20211030213100808"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213138996.png" class="" title="image-20211030213138996"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213227375.png" class="" title="image-20211030213227375"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213244097.png" class="" title="image-20211030213244097"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213258817.png" class="" title="image-20211030213258817"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213342877.png" class="" title="image-20211030213342877"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213357497.png" class="" title="image-20211030213357497"><h3 id="8-3-3-冷启动数据恢复编辑日志">8.3.3  冷启动数据恢复编辑日志</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213731826.png" class="" title="image-20211030213731826"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213748259.png" class="" title="image-20211030213748259"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213803310.png" class="" title="image-20211030213803310"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213907481.png" class="" title="image-20211030213907481"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030213920741.png" class="" title="image-20211030213920741"><h2 id="8-4-ZK选举机制源码解析">8.4 ZK选举机制源码解析</h2><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030214158626.png" class="" title="image-20211030214158626"><p>QuorumPeer类包含两个部分：1.快速选举选择部分。2.通信部分</p><ol><li>首先生成选举算法（生成 选票）</li><li>将选票放入到sendqueue中（发送选票缓冲池）</li><li>通过WorkerSender处理选票，将其发送给通信部分的recvQueue</li><li>当ZK2的sid比自己的sid大的时候<ol><li>通过快速选举部分的WorkerReceiver将选票放入到recequeue中（处理投票缓冲池）</li><li>进行选票生成并通过通信部分的Listener（监听器）的handleConnection中的queueSendMap中选择发送给的对应sid的服务器。然后通过handleConnection中的SendWorkerMap进行选票的接收与发送。实现与其他节点进行通信。</li></ol></li></ol><h3 id="8-4-1-选举准备">8.4.1 选举准备</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030214859394.png" class="" title="image-20211030214859394"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030214912240.png" class="" title="image-20211030214912240"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030214939573.png" class="" title="image-20211030214939573"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215014397.png" class="" title="image-20211030215014397"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215034395.png" class="" title="image-20211030215034395"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215046337.png" class="" title="image-20211030215046337"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215056946.png" class="" title="image-20211030215056946"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215107302.png" class="" title="image-20211030215107302"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215118265.png" class="" title="image-20211030215118265"><h3 id="8-4-2-选举执行">8.4.2 选举执行</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215249974.png" class="" title="image-20211030215249974"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215348106.png" class="" title="image-20211030215348106"><p>1）执行 super.start();就相当于执行 QuorumPeer.java 类中的  run()方法</p><p>2）当 Zookeeper 启动后，首先都是 Looking 状态，通过选举，让其中一台服务器成为 Leader， 其他的服务器成为 Follower。</p><p>QuorumPeer.java类</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215429881.png" class="" title="image-20211030215429881"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215444136.png" class="" title="image-20211030215444136"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215459890.png" class="" title="image-20211030215459890"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215511802.png" class="" title="image-20211030215511802"><p>2）ctrl+alt+b 点击 lookForLeader()的实现类 FastLeaderElection.java</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215529162.png" class="" title="image-20211030215529162"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215542587.png" class="" title="image-20211030215542587"><p>3）点击 sendNotifications，广播选票，把自己的选票发给其他服务器</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215600689.png" class="" title="image-20211030215600689"><p>4）在 FastLeaderElection.java 类中查找 WorkerSender 线程。</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215625746.png" class="" title="image-20211030215625746"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215638853.png" class="" title="image-20211030215638853"><p>5）如果数据是发送给自己的，添加到自己的接收队列</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215654633.png" class="" title="image-20211030215654633"><p>6）数据添加到发送队列</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215710145.png" class="" title="image-20211030215710145"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215722219.png" class="" title="image-20211030215722219"><p>7）与要发送的服务器节点建立通信连接</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215741633.png" class="" title="image-20211030215741633"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215802592.png" class="" title="image-20211030215802592"><p>8）创建并启动发送器线程和接收器线程</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215821268.png" class="" title="image-20211030215821268"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215833919.png" class="" title="image-20211030215833919"><p>9）点击 SendWorker，并查找该类下的 run 方法</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215852138.png" class="" title="image-20211030215852138"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215902615.png" class="" title="image-20211030215902615"><p>10）点击 RecvWorker，并查找该类下的 run 方法</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215920441.png" class="" title="image-20211030215920441"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215931808.png" class="" title="image-20211030215931808"><p>11）在  FastLeaderElection.java 类中查找 WorkerReceiver 线程。</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215947280.png" class="" title="image-20211030215947280"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030215957762.png" class="" title="image-20211030215957762"><h2 id="8-5-Follower-和-Leader-状态同步源码">8.5 Follower 和  Leader 状态同步源码</h2><p>当选举结束后，每个节点都需要根据自己的角色更新自己的状态。选举出的  Leader 更 新自己状态为 Leader，其他节点更新自己状态为  Follower。<br>Leader 更新状态入口：leader.lead()<br>Follower 更新状态入口：follower.followerLeader()</p><p>注意：</p><p>（1）follower 必须要让  leader 知道自己的状态：epoch、zxid、sid 必须要找出谁是 leader；<br>发起请求连接 leader； 发送自己的信息给 leader；<br>leader 接收到信息，必须要返回对应的信息给 follower。<br>（2）当 leader得知 follower的状态了，就确定需要做何种方式的数据同步 DIFF、TRUNC、SNAP<br>（3）执行数据同步<br>（4）当  leader 接收到超过半数  follower 的  ack 之后，进入正常工作状态，集群启动完成了。</p><p>最终总结同步的方式：<br>（1）DIFF 咱两一样，不需要做什么<br>（2）TRUNC follower 的 zxid 比  leader 的  zxid 大，所以  Follower 要回滚<br>（3）COMMIT leader 的 zxid 比  follower 的  zxid 大，发送  Proposal 给 foloower 提交执行<br>（4）如果  follower 并没有任何数据，直接使用  SNAP 的方式来执行数据同步（直接把数据全部序列到 follower）</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220245513.png" class="" title="image-20211030220245513"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220257505.png" class="" title="image-20211030220257505"><h3 id="8-5-1-Leader-lead-等待接收-follower-的状态同步申请">8.5.1 Leader.lead()等待接收 follower 的状态同步申请</h3><p>1）在 Leader.java 种查找  lead()方法</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220621010.png" class="" title="image-20211030220621010"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220645569.png" class="" title="image-20211030220645569"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220658893.png" class="" title="image-20211030220658893"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220709319.png" class="" title="image-20211030220709319"><p>其中  ss 的初始化是在创建 Leader 对象时，创建的  socket</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220731560.png" class="" title="image-20211030220731560"><h3 id="8-5-2-Follower-lead-查找并连接-Leader">8.5.2 Follower.lead()查找并连接 Leader</h3><p>1）在 Follower.java 种查找  followLeader()方法</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220802936.png" class="" title="image-20211030220802936"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220816526.png" class="" title="image-20211030220816526"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220828497.png" class="" title="image-20211030220828497"><h3 id="8-5-3-Leader-lead-创建-LearnerHandler">8.5.3 Leader.lead()创建 LearnerHandler</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220853998.png" class="" title="image-20211030220853998"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220904550.png" class="" title="image-20211030220904550"><p>由于  public class LearnerHandler extends ZooKeeperThread{}，说明 LearnerHandler 是一 个线程。所以 fh.start()执行的是  LearnerHandler 中的  run()方法。</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220921577.png" class="" title="image-20211030220921577"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220933993.png" class="" title="image-20211030220933993"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220945549.png" class="" title="image-20211030220945549"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030220956473.png" class="" title="image-20211030220956473"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221007757.png" class="" title="image-20211030221007757"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221018867.png" class="" title="image-20211030221018867"><h3 id="8-5-4-Follower-lead-创建-registerWithLeader">8.5.4 Follower.lead()创建 registerWithLeader</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221045608.png" class="" title="image-20211030221045608"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221057508.png" class="" title="image-20211030221057508"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221109212.png" class="" title="image-20211030221109212"><h3 id="8-5-5-Leader-lead-接收-Follwer-状态，根据同步方式发送同步消息">8.5.5 Leader.lead()接收 Follwer 状态，根据同步方式发送同步消息</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221133892.png" class="" title="image-20211030221133892"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221147124.png" class="" title="image-20211030221147124"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221200410.png" class="" title="image-20211030221200410"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221213079.png" class="" title="image-20211030221213079"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221224433.png" class="" title="image-20211030221224433"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221235376.png" class="" title="image-20211030221235376"><h3 id="8-5-6-Follower-lead-应答-Leader-同步结果">8.5.6 Follower.lead()应答 Leader 同步结果</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221302556.png" class="" title="image-20211030221302556"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221313344.png" class="" title="image-20211030221313344"><h3 id="8-5-7-Leader-lead-应答-Follower">8.5.7 Leader.lead()应答 Follower</h3><p>由于  public class LearnerHandler extends ZooKeeperThread{}，说明 LearnerHandler 是一个线程。所以 fh.start()执行的是  LearnerHandler 中的  run()方法。</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221456812.png" class="" title="image-20211030221456812"><h2 id="8-6-服务端-Leader-启动">8.6 服务端  Leader 启动</h2><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221600403.png" class="" title="image-20211030221600403"><p>Leader.java</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221630700.png" class="" title="image-20211030221630700"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221641139.png" class="" title="image-20211030221641139"><p>LeaderZooKeeperServer.java</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221716803.png" class="" title="image-20211030221716803"><p>ZookeeperServer.java</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221732734.png" class="" title="image-20211030221732734"><p>点击  PrepRequestProcessor，并查找它的  run 方法</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221755242.png" class="" title="image-20211030221755242"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221814625.png" class="" title="image-20211030221814625"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221826191.png" class="" title="image-20211030221826191"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221840829.png" class="" title="image-20211030221840829"><h2 id="8-7-服务端-Follower-启动">8.7 服务端  Follower 启动</h2><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221913656.png" class="" title="image-20211030221913656"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221935387.png" class="" title="image-20211030221935387"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030221950327.png" class="" title="image-20211030221950327"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222000679.png" class="" title="image-20211030222000679"><h2 id="8-8-客户端启动">8.8 客户端启动</h2><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222020324.png" class="" title="image-20211030222020324"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222208842.png" class="" title="image-20211030222208842"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222224429.png" class="" title="image-20211030222224429"><p>在 <a href="http://ZkCli.sh">ZkCli.sh</a> 启动 Zookeeper 时，会调用 ZooKeeperMain.java Ctrl + n  查找 ZooKeeperMain，找到程序的入口 main()方法</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222247705.png" class="" title="image-20211030222247705"><h3 id="8-8-1-创建-ZookeeperMain">8.8.1  创建  ZookeeperMain</h3><p>连接  zk</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222326239.png" class="" title="image-20211030222326239"><p>创建 ZooKeeperAdmin 对象</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222349163.png" class="" title="image-20211030222349163"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222400599.png" class="" title="image-20211030222400599"><h3 id="8-8-2-初始化监听器">8.8.2  初始化监听器</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222428088.png" class="" title="image-20211030222428088"><h3 id="8-8-3-解析连接地址">8.8.3  解析连接地址</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222455728.png" class="" title="image-20211030222455728"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222514022.png" class="" title="image-20211030222514022"><h3 id="8-8-4-创建通信">8.8.4  创建通信</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222550649.png" class="" title="image-20211030222550649"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222608264.png" class="" title="image-20211030222608264"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222623896.png" class="" title="image-20211030222623896"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222641142.png" class="" title="image-20211030222641142"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222656757.png" class="" title="image-20211030222656757"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222708109.png" class="" title="image-20211030222708109"><p>ctrl + alt +B  查找  connect 实现类，ClientCnxnSocketNIO.java</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222833428.png" class="" title="image-20211030222833428"><p>ctrl + alt +B  查找  doTransport 实现类，ClientCnxnSocketNIO.java</p><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222854939.png" class="" title="image-20211030222854939"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222908968.png" class="" title="image-20211030222908968"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222922391.png" class="" title="image-20211030222922391"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030222932871.png" class="" title="image-20211030222932871"><h3 id="8-8-5-执行-run">8.8.5  执行  run()</h3><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030223009732.png" class="" title="image-20211030223009732"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030223023920.png" class="" title="image-20211030223023920"><img src="/dajiangdahe/2021/10/23/zookeeper%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/image-20211030223036400.png" class="" title="image-20211030223036400">]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python暴力破解压缩包</title>
    <link href="/dajiangdahe/2021/10/22/%E7%A0%B4%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%8C%85/"/>
    <url>/dajiangdahe/2021/10/22/%E7%A0%B4%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1>1.Mac破解zip压缩包</h1><h5 id="使用fcrackzip来破解zip类型压缩文件">使用fcrackzip来破解zip类型压缩文件</h5><p>fcrackzip是一款专门破解zip类型压缩文件密码的工具，工具破解速度还是可以的，能用字典和指定字符集破解，适用于Linux、Mac OS 系统。</p><h6 id="如果你的电脑没有安装brew，需要执行下面命令行"><strong>如果你的电脑没有安装brew，需要执行下面命令行</strong></h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; <br></code></pre></td></tr></table></figure><h5 id="安装fcrackzip">安装fcrackzip</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install fcrackzip<br></code></pre></td></tr></table></figure><h5 id="使用-fcrackzip-h来查看相关命令帮助">使用 <code>fcrackzip -h</code>来查看相关命令帮助</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">fcrackzip version 1.0, a fast/free zip password cracker<br>written by Marc Lehmann &lt;pcg@goof.com&gt; You can find more info on<br>http://www.goof.com/pcg/marc/<br><br>USAGE: fcrackzip<br>          [-b|--brute-force]            use brute force algorithm<br>          [-D|--dictionary]             use a dictionary<br>          [-B|--benchmark]              execute a small benchmark<br>          [-c|--charset characterset]   use characters from charset<br>          [-h|--help]                   show this message<br>          [--version]                   show the version of this program<br>          [-V|--validate]               sanity-check the algortihm<br>          [-v|--verbose]                be more verbose<br>          [-p|--init-password string]   use string as initial password/file<br>          [-l|--length min-max]         check password with length min to max<br>          [-u|--use-unzip]              use unzip to weed out wrong passwords<br>          [-m|--method num]             use method number &quot;num&quot; (see below)<br>          [-2|--modulo r/m]             only calculcate 1/m of the password<br>          file...                    the zipfiles to crack<br><br>methods compiled in (* = default):<br><br> 0: cpmask<br> 1: zip1<br>*2: zip2, USE_MULT_TAB<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">c 指定字符集，字符集 格式是 -c &#x27;aA1!:&#x27;<br>表示小写字母 a-z<br>表示大写字母 A-Z<br>表示数字 0-9<br>感叹号表示特殊字符 !:$%&amp;/()=?&#123;&#125;[]+*~#<br>表示包含冒号之后的字符（不能为二进制的空字符）例如  a1:$%  表示 字符集包含小写字母、数字、$字符和%百分号<br></code></pre></td></tr></table></figure><h5 id="尝试破解">尝试破解</h5><p>有一个文件名叫<code>doubi.zip</code>，密码为doubi的弱密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 先要cd到文件所在文件夹位置<br>fcrackzip -b -c &#x27;aA1!&#x27; -l 1-10 -u doubi.zip<br>PASSWORD FOUND!!!!: pw == doubi<br>// 参数<br>-b 表示使用暴力破解的方式<br>-c &#x27;aA1!&#x27; 表示使用大小写字母加数字和符号的混合破解方式<br>-l 1-10 表示需要破解的密码长度1到10位<br>-u 表示只显示破解出来的密码，其他错误的密码不显示<br></code></pre></td></tr></table></figure><h5 id="可以使用字典破解">可以使用字典破解</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">fcrackzip -D -p pwd.txt -u doubi.zip<br>PASSWORD FOUND!!!!: pw == doubi<br>// 参数<br>-D 表示要使用字典破解<br>-p 表示要使用哪个字典破解<br></code></pre></td></tr></table></figure><h1>2.Mac破解rar压缩包</h1><p>找了半天没有找到好用的rar压缩包的破解软件以及破解方法，最后找到了一个亲测可行的暴力破解程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> rarfile<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIterator</span>():</span><br>    letters = <span class="hljs-string">&#x27;`1234567890-=/*-qwertyuiop[]\|asdfghjkl;zxcvbnm,.?&gt;&lt;&#123;&#125;:QERWTYUIOPLKJHGFDSAZXCVBNM!@#$%^&amp;*()+&#x27;</span>  <span class="hljs-comment"># 键盘上所有可能输入的字符</span><br>    min_digits = <span class="hljs-number">0</span><br>    max_digits = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, min_digits, max_digits</span>):</span><br>        <span class="hljs-keyword">if</span> min_digits &lt; max_digits:<br>            self.min_digits = min_digits<br>            self.max_digits = max_digits<br>        <span class="hljs-keyword">else</span>:<br>            self.min_digits = max_digits<br>            self.max_digits = min_digits<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span>(<span class="hljs-params">self</span>):</span><br>        rst = <span class="hljs-built_in">str</span>()<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, random.randrange(self.min_digits, self.max_digits + <span class="hljs-number">1</span>)):<br>            rst += random.choice(MyIterator.letters)<br>        <span class="hljs-keyword">return</span> rst<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract</span>(<span class="hljs-params">path</span>):</span><br>    start_time = time.time()<br>    zfile = rarfile.RarFile(path)<br>    <span class="hljs-comment"># 解压文件地址</span><br><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> MyIterator(<span class="hljs-number">4</span>, <span class="hljs-number">10</span>):  <span class="hljs-comment"># 4到10位密码</span><br>        <span class="hljs-keyword">try</span>:<br>            zfile.extractall(path=<span class="hljs-string">&quot;.&quot;</span>, pwd=<span class="hljs-built_in">str</span>(p).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>            <span class="hljs-comment"># 文件地址这里用.代表上述zfile地址</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;the password is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(p))<br>            now_time = time.time()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;spend time is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(now_time - start_time))<br>            sys.exit(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;error&#x27;</span>, p)<br>            <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    extract(<span class="hljs-string">&quot;/Users/guolonghang/Documents/kafka/kafka/软件文档/课程资料（1）.rar&quot;</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>脚本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>破解压缩包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>校招高频算法</title>
    <link href="/dajiangdahe/2021/10/22/%E6%A0%A1%E6%8B%9B%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95/"/>
    <url>/dajiangdahe/2021/10/22/%E6%A0%A1%E6%8B%9B%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1>1.二维数组中的查找</h1><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;&amp;tqId=11154&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;&amp;tqId=11154&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类似于二叉树的思想，从右上角开始进行查找,时间复杂度为o(n+n)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> [][] array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j=array[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;array.length&amp;&amp;j&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(array[i][j]&gt;target)&#123;<br>                j--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[i][j]&lt;target)&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&gt;=array.length||j&lt;<span class="hljs-number">0</span>)&#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;     <br>        <span class="hljs-keyword">if</span>(target==array[i][j])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在每一轮都用二分查找，时间复杂度为o(nlgn * n)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">Find2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[][] array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (array.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array[<span class="hljs-number">0</span>].length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (search(array[i],target,<span class="hljs-number">0</span>,array[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>)==target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left = low;<br>        <span class="hljs-keyword">int</span> right = high;<br>        <span class="hljs-keyword">while</span> (left&lt;=right)&#123;<br>            <span class="hljs-keyword">int</span> mid = (left+right);<br>            <span class="hljs-keyword">if</span> (nums[mid]&gt;target)&#123;<br>                right = mid-<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid]&lt;target)&#123;<br>                left = mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br></code></pre></td></tr></table></figure><h1>2.替换空格</h1><p><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;&amp;tqId=11155&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;&amp;tqId=11155&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(StringBuffer str)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> str.toString().replace(<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;%20&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>3.从尾到头打印链表</h1><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;&amp;tqId=11156&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;&amp;tqId=11156&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;<br>       ArrayList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>       ListNode temp = listNode;<br>       <span class="hljs-keyword">while</span> (temp != <span class="hljs-keyword">null</span>) &#123;<br>           res.add(temp.val);<br>           temp = temp.next;<br>       &#125;<br><br>       Collections.reverse(res);<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure><h1>4.根据前序遍历和中序遍历重建二叉树</h1><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;&amp;tqId=11157&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;&amp;tqId=11157&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><p>1、先序遍历的结果中第一个元素一定是根节点<br>2、先序遍历结果= 根节点+左子树先序结构+右子树先序结果<br>3、中序遍历结果= 左子树的中序结果+根节点+右子树的中序结果</p><img src="/dajiangdahe/2021/10/22/%E6%A0%A1%E6%8B%9B%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95/20200427152711770.png" class="" title="重建二叉树"><p><strong>根据上图，3为根节点，根据中序遍历9是3的左子树而且只有一个节点，先序中9后面的20就是3的右子树的根节点，然后再看中序遍历，15在20的左侧7在20右侧，得15是20的左子树7是20的右子树。最后构建出的树如下图：</strong></p><img src="/dajiangdahe/2021/10/22/%E6%A0%A1%E6%8B%9B%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95/20200427153240659.png" class=""><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">myBuildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> preorder_left, <span class="hljs-keyword">int</span> preorder_right, <span class="hljs-keyword">int</span> inorder_left, <span class="hljs-keyword">int</span> inorder_right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preorder_left &gt; preorder_right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//前序遍历中第一个节点就是根节点</span><br>        <span class="hljs-keyword">int</span> preorder_root = preorder_left;<br>        <span class="hljs-comment">//在中序遍历里定位根节点</span><br>        <span class="hljs-keyword">int</span> inorder_root = indexMap.get(preorder[preorder_root]);<br>        <span class="hljs-comment">//创建根节点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[preorder_root]);<br>        <span class="hljs-comment">//得到左子树的结点个数</span><br>        <span class="hljs-keyword">int</span> size_left_subTree = inorder_root - inorder_left;<br>        <span class="hljs-comment">// 递归地构造左子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br>        root.left = myBuildTree(preorder,inorder,preorder_left+<span class="hljs-number">1</span>,preorder_left+size_left_subTree,inorder_left,inorder_root-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 递归地构造右子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br>        root.right = myBuildTree(preorder,inorder,preorder_left+size_left_subTree+<span class="hljs-number">1</span>,preorder_right,inorder_root+<span class="hljs-number">1</span>,inorder_right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = preorder.length;<br>        <span class="hljs-comment">// 构造哈希映射，帮助我们快速定位根节点</span><br>        indexMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            indexMap.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h1>5.用两个栈实现队列</h1><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;&amp;tqId=11158&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;&amp;tqId=11158&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>       stack1.push(node);<br>       <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stack1.empty()&amp;&amp;stack2.empty())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(stack2.empty())&#123;<br>            <span class="hljs-keyword">while</span>(!stack1.empty())&#123;<br>               stack2.push(stack1.pop()); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack2.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>6.旋转数组的最小值</h1><p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;&amp;tqId=11159&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;&amp;tqId=11159&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//流式运算</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(array).min().getAsInt();<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//二分变种思想，由于旋转后，必然在旋转点看来，前面有序，后面也有序，故可以二分。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> high = array.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(low+<span class="hljs-number">1</span>&lt;high)&#123;<br>            <span class="hljs-keyword">int</span> mid = low + (high - low)/<span class="hljs-number">2</span>; <span class="hljs-comment">//mid条件可以写成循环类型，防止出错。</span><br>            <span class="hljs-keyword">if</span>(array[mid]&lt;array[high])&#123;<br>                high = mid;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[mid] == array[high])&#123;<br>                high = high-<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                low = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(array[low],array[high]);<br>    &#125;<br></code></pre></td></tr></table></figure><h1>7.斐波那契数列</h1><p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;&amp;tqId=11160&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;&amp;tqId=11160&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一：递归思想</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>||n==<span class="hljs-number">1</span>)<br>              <span class="hljs-keyword">return</span> n;<br>            <br>        <span class="hljs-keyword">return</span> Fibonacci(n-<span class="hljs-number">1</span>)+Fibonacci(n-<span class="hljs-number">2</span>);<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法二：动态规划</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>||n==<span class="hljs-number">1</span>)<br>              <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>       <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>,q=<span class="hljs-number">1</span>,sum = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>           sum = p + q;<br>           p = q;<br>           q = sum;<br>       &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><h1>8.跳台阶</h1><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;&amp;tqId=11161&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;&amp;tqId=11161&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归思想 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">1</span>||target==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;       <br>        <span class="hljs-keyword">return</span> jumpFloor(target-<span class="hljs-number">1</span>)+jumpFloor(target-<span class="hljs-number">2</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target+<span class="hljs-number">1</span>]; <br>       dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>       dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>;i&lt;dp.length;i++)&#123;<br>           dp[i] = dp[i-<span class="hljs-number">1</span>]+dp[i-<span class="hljs-number">2</span>];<br>       &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br></code></pre></td></tr></table></figure><h1>9.变态跳台阶</h1><p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;&amp;tqId=11162&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;&amp;tqId=11162&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> target;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>;i&lt;dp.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>                dp[i] += dp[i-j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br></code></pre></td></tr></table></figure><h1>10.矩形覆盖</h1><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rectCover</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>||target==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> target;<br>        &#125;<br>        <span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>,q=<span class="hljs-number">1</span>,sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=target;i++)&#123;<br>            sum = p+q;<br>            p = q;<br>            q = sum;<br>        &#125;<br>       <span class="hljs-keyword">return</span> sum;<br>    &#125;<br></code></pre></td></tr></table></figure><h1>11.二进制中1的个数</h1><p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;&amp;tqId=11164&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;&amp;tqId=11164&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Inetger类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> Integer.bitCount(n);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>举个例子</strong>：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。</p><p>这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            count++;<br>            n = n &amp; (n-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br></code></pre></td></tr></table></figure><h1>12.整数的N次方</h1><p><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;&amp;tqId=11165&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;&amp;tqId=11165&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> res = base;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;Math.abs(exponent);i++)&#123;<br>            res = base*res;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(exponent&gt;<span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-keyword">return</span> res;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exponent&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>/res;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>快速幂（二进制角度）</strong>：对于任何十进制正整数n，舎其二进制位“bm…b3 b2 b1”(bi为为进制某位置)：</p><ul><li>二进制转十进制：n = 1*b1 + 2*b2 + 4*b3 + … + 2^m-1*bm</li><li>幂的二进制展开：x^n = x ^  1*b1 + 2*b2 + 4*b3 + … + 2^m-1*bm</li><li>当bi=0时：x^bi*2^^^i-1^ = 1;</li><li>当bi =1时：x^bi*2^^^i-1^  = x^2^^^i-1^</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> b = n;<br>        <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">if</span>(b &lt; <span class="hljs-number">0</span>) &#123;<br>            x = <span class="hljs-number">1</span> / x;<br>            b = -b;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>((b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) res *= x;<br>            x *= x;<br>            b &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h1>13.调整数组顺序使奇数位位于偶数位前面</h1><p><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;&amp;tqId=11166&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;&amp;tqId=11166&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;<br>       <span class="hljs-keyword">if</span>(nums.length&lt;=<span class="hljs-number">1</span>)&#123;<br>           <span class="hljs-keyword">return</span> nums;<br>       &#125;<br>       <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>       <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>           <span class="hljs-keyword">if</span>(nums[i]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>               res[low++] = nums[i];<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>           <span class="hljs-keyword">if</span>(nums[i]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>               res[low++] = nums[i];<br>           &#125;<br>       &#125;<br>       nums = res;<br>       <span class="hljs-keyword">return</span> nums;<br>   &#125;<br></code></pre></td></tr></table></figure><h1>14.链表中倒数第K个结点</h1><p><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;&amp;tqId=11167&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;&amp;tqId=11167&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode head,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode temp = head;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">while</span>(temp!=<span class="hljs-keyword">null</span>)&#123;<br>            len++;<br>            temp = temp.next;<br>        &#125;<br>        temp = head;<br>        <span class="hljs-keyword">if</span>(k&gt;len||k&lt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len - k;i++)&#123;<br>            temp = temp.next;<br>        &#125; <br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br></code></pre></td></tr></table></figure><h1>15.反转链表</h1><p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;&amp;tqId=11168&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;&amp;tqId=11168&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode temp = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-keyword">null</span>)&#123;<br>            temp = head.next;<br>            head.next = res.next;<br>            res.next = head;<br>            head = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br></code></pre></td></tr></table></figure><h1>16.合并两个有序链表</h1><p><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;&amp;tqId=11169&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;&amp;tqId=11169&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode list1,ListNode list2)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(list1==<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> list2;<br>       &#125;<br>        <span class="hljs-keyword">if</span>(list2==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode temp  = res;<br>        <span class="hljs-keyword">while</span>(list1!=<span class="hljs-keyword">null</span>&amp;&amp;list2!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list1.val&lt;list2.val)&#123;<br>                temp.next = list1;<br>                list1 = list1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                temp.next = list2;<br>                list2 = list2.next;<br>            &#125;<br>            temp = temp.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list1!=<span class="hljs-keyword">null</span>)&#123;<br>            temp.next = list1;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(list2!=<span class="hljs-keyword">null</span>)&#123;<br>            temp.next = list2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next; <br>    &#125;<br></code></pre></td></tr></table></figure><h1>17.树的 子结构</h1><p><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;&amp;tqId=11170&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;&amp;tqId=11170&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> (A != <span class="hljs-keyword">null</span> &amp;&amp; B != <span class="hljs-keyword">null</span>) &amp;&amp; (isSame(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span>  <span class="hljs-title">isSame</span><span class="hljs-params">(TreeNode A, TreeNode B)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(B == <span class="hljs-keyword">null</span>) <br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>       <span class="hljs-keyword">if</span>(A == <span class="hljs-keyword">null</span> || A.val != B.val) <br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       <span class="hljs-keyword">return</span> isSame(A.left,B.left)&amp;&amp;isSame(A.right,B.right);<br>   &#125;<br></code></pre></td></tr></table></figure><h1>18.二叉树的镜像</h1><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        TreeNode temp = root.left;<br>        root.left = root.right;<br>        root.right = temp;<br>        mirrorTree(root.left);<br>        mirrorTree(root.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><h1></h1>]]></content>
    
    
    <categories>
      
      <category>JavaInterview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>校招</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据一致性</title>
    <link href="/dajiangdahe/2021/10/22/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/dajiangdahe/2021/10/22/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1>1.数据一致性</h1><p>​在数据有多分副本的情况下，如果网络、服务器或者软件出现故障，会导致部分副本写入成功，部分副本写入失败。这就造成各个副本之间的数据不一致，数据内容冲突。 实践中，导致数据不一致的情况有很多种，表现样式也多种多样，比如数据更新返回操作失败，事实上数据在存储服务器已经更新成功。</p><h1>2.CAP理论</h1><p>CAP定理是2000年，由 Eric Brewer 提出来的。Brewer认为在分布式的环境下设计和部署系统时，有3个核心的需求，以一种特殊的关系存在。这里的分布式系统说的是在物理上分布的系统，比如我们常见的web系统。<br>  这3个核心的需求是：Consistency，Availability和Partition Tolerance，赋予了该理论另外一个名字 － CAP。<br>  <strong>Consistency</strong>：一致性，这个和数据库ACID的一致性类似，但这里关注的所有数据节点上的数据一致性和正确性，而数据库的ACID关注的是在在一个事务内，对数据的一些约束。系统在执行过某项操作后仍然处于一致的状态。在分布式系统中，更新操作执行成功后所有的用户都应该读取到最新值。<br>  <strong>Availability</strong>：可用性，每一个操作总是能够在一定时间内返回结果。需要注意“一定时间”和“返回结果”。“一定时间”是指，系统结果必须在给定时间内返回。“返回结果”是指系统返回操作成功或失败的结果。<br>  <strong>Partition Tolerance</strong>：分区容忍性，是否可以对数据进行分区。这是考虑到性能和可伸缩性。<br>  CAP定理认为，一个提供数据服务的存储系统无法同事满足数据一致性、数据可用性、分区容忍性。<br>  为什么不能完全保证这个三点了，个人觉得主要是因为一旦进行分区了，就说明了必须节点之间必须进行通信，涉及到通信，就无法确保在有限的时间内完成指定的行文，如果要求两个操作之间要完整的进行，因为涉及到通信，肯定存在某一个时刻只完成一部分的业务操作，在通信完成的这一段时间内，数据就是不一致性的。如果要求保证一致性，那么就必须在通信完成这一段时间内保护数据，使得任何访问这些数据的操作不可用。<br>  如果想保证一致性和可用性，那么数据就不能够分区。一个简单的理解就是所有的数据就必须存放在一个数据库里面，不能进行数据库拆分。这个对于大数据量，高并发的互联网应用来说，是不可接受的。<br>  在大型网站应用中，数据规模总是快速扩张的，因此可伸缩性即分区容忍性必不可少，规模变大以后，机器数量也会变得庞大，这是网络和服务器故障会频繁出现，要想保证应用可用，就必须保证分布式处理系统的高可用性。所以在大型网站中，通常会选择强化分布式存储系统的可用性(A)和伸缩性§，在某种程度上放弃一致性©。一般来说，数据不一致通常出现在系统高并发写操作或者集群状态不稳（故障恢复、集群扩容等）的情况下，应用系统需要对分布式数据处理系统的数据不一致性有所了解并进行某种意义上的补偿和纠错，以避免出现应用系统数据不正确。</p><h1>3.数据一致性模型</h1><p>一些分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同的副本存放在不同的机器，由于维护数据副本的一致性代价高，因此许多系统采用弱一致性来提高性能，一些不同的一致性模型也相继被提出。</p><ul><li>强一致性： 要求无论更新操作实在哪一个副本执行，之后所有的读操作都要能获得最新的数据。</li><li>弱一致性：用户读到某一操作对系统特定数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。</li><li>最终一致性：是弱一致性的一种特例，保证用户最终能够读取到某操作对系统特定数据的更新。</li></ul><h1>4.分布式事务的数据一致性问题（多用于单一数据库集群问题）</h1><p>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p><h2 id="1-TC"><a href="http://1.TC">1.TC</a></h2><img src="/dajiangdahe/2021/10/22/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/dist-tx-1.png" class="" title="img"><img src="/dajiangdahe/2021/10/22/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/dist-yzx-1.png" class="" title="img"><p>如上图，在XA协议中分为两阶段：</p><p>第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</p><p>第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。</p><p>优点：</p><ul><li>尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。</li></ul><p>缺点：</p><ul><li>单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li><li>同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</li><li>数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li></ul><p>总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发依然是其最大的弱点。</p><h2 id="2-TCC">2.TCC</h2><p>关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC事务机制相比于上面介绍的XA，解决了其几个缺点：</p><ol><li><p>解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。</p></li><li><p>同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。</p></li><li><p>数据一致性，有了补偿机制之后，由业务活动管理器控制一致性。</p><img src="/dajiangdahe/2021/10/22/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/dist-tx-2.png" class="" title="img"></li></ol><img src="/dajiangdahe/2021/10/22/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/dist-yzx-2.png" class="" title="img"><p>如上图，对于TCC的解释：</p><ul><li>Try阶段：尝试执行,完成所有业务检查（一致性），预留必须业务资源（准隔离性）。</li><li>Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。</li><li>Cancel阶段：取消执行，释放Try阶段预留的业务资源 Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。</li></ul><p>举个简单的例子如果你用100元买了一瓶水，在Try阶段你需要向你的钱包检查是否够100元并锁住这100元，水也是一样的。如果有一个失败，则进行cancel(释放这100元和这一瓶水)，如果cancel失败不论什么失败都进行重试cancel，所以需要保持幂等。如果都成功，则进行confirm,确认这100元扣，和这一瓶水被卖，如果confirm失败无论什么失败则重试(会依靠活动日志进行重试)。</p><p>对于TCC来说适合以下场景：</p><ul><li>强隔离性，严格一致性要求的活动业务。</li><li>执行时间较短的业务。</li></ul><h1>5.Redis和MySQL的数据一致性问题</h1><h2 id="1-一致性问题">1.一致性问题</h2><p>读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存和数据库间的数据一致性问题。不管是先写数据库，再删除缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举个例子：</p><p>1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p><p>2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p><p>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。如何解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。</p><h2 id="2-解决方法-延迟双删">2.解决方法----延迟双删</h2><p><strong>一、 同步延时双删策略</strong></p><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。具体步骤是：</p><p>1）先删除缓存</p><p>2）再写数据库</p><p>3）休眠500毫秒（根据具体的业务时间来定）</p><p>4）再次删除缓存。</p><img src="/dajiangdahe/2021/10/22/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/1306964-20210526181836508-1439022605.png" class="" title="img"><p>【<strong>休眠时间确定</strong>】</p><p>需要评估自己的项目的读数据<strong>业务逻辑的耗时</strong>。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p><p>当然，这种策略还要考虑 <strong>redis 和数据库主从同步的耗时</strong>。最后的写数据的休眠时间：则在读数据业务逻辑的耗时的基础上，加上几百ms即可。比如：休眠1秒。</p><p><strong>二、设置缓存的过期时间</strong></p><p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存</p><p>结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</p><p><strong>三、异步延迟双删策略，借用MQ</strong></p><p>上述的方案有一个缺点，那就是操作完数据库后，由于种种原因删除缓存失败，这时，可能就会出现数据不一致的情况。这里，我们需要提供一个保障重试的方案。</p><p><strong>1、方案一具体流程</strong></p><p>（1）更新数据库数据；</p><p>（2）缓存因为种种问题删除失败；</p><p>（3）将需要删除的key发送至<strong>消息队列；</strong></p><p>（4）自己消费消息，获得需要删除的key；</p><p>（5）继续重试删除操作，直到成功。</p><p>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p><p><strong>2、方案二具体流程</strong></p><p>（1）更新数据库数据；</p><p>（2）数据库会将操作信息写入binlog日志当中；</p><p>（3）订阅程序提取出所需要的数据以及key；</p><p>（4）另起一段非业务代码，获得该信息；</p><p>（5）尝试删除缓存操作，发现删除失败；</p><p>（6）将这些信息发送至消息队列；</p><p>（7）重新从消息队列中获得该数据，重试操作。</p><img src="/dajiangdahe/2021/10/22/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/1306964-20210526181839323-1134717675.png" class="" title="img">]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/dajiangdahe/2021/10/22/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/dajiangdahe/2021/10/22/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1>1.布隆过滤器</h1><h2 id="场景">场景</h2><p>在项目开发中，我们经常会遇到去重问题：判断一个人有没有浏览过一篇文章，判断一个ip是否发过一个请求，判断一个人当天是否登陆过某个系统</p><p>常见的解决办法：</p><p>​（1）：set。缺点：当数据量过大时，set会非常消耗内存，性能也不高。</p><p>​（2）：bitmap。缺点：Bitmap可以提高性能，但是bitmap仍然比较消耗内存，尤其是在数据比较稀疏的情况下。</p><p>​（3）：布隆过滤器。</p><h2 id="原理">原理</h2><p>布隆过滤器与BitMap类似，底层也是一个位数组。1表示有，0表示无。但布隆过滤器比BitMap需要更少的内存，它是怎么办到的呢？答案是多个hash。</p><p>我们知道hash算法，是把一个数从较大范围的值，映射到较小范围值。比如我们有一个10位的数组，使用某个hash算法及其数组上的表示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hash</span>(“xy”) = <span class="hljs-number">3</span>;<br><br><span class="hljs-attribute">hash</span>(“aa”) = <span class="hljs-number">5</span>;<br><br><span class="hljs-attribute">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这样我们就可以快速的知道一个字符串是不是存在一个集合里面。</p><p>但是会出现hash冲突</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">hash(“xy”) = <span class="hljs-number">3</span><span class="hljs-comment">;</span><br><br>hash(“aa”) = <span class="hljs-number">3</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>解决办法：1.再hash法</p><p>​  2.链地址法</p><p>​  3.开放定址法</p><p>但是在布隆过滤器中选择的是使用（1），采用多个hash算法。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">h1</span>(“xy”) = <span class="hljs-number">3</span>, h<span class="hljs-number">2</span>(“xy”) = <span class="hljs-number">5</span>, h<span class="hljs-number">3</span>(“xy”) = <span class="hljs-number">7</span>;<br><br><span class="hljs-attribute">h1</span>(“aa”) = <span class="hljs-number">5</span>, h<span class="hljs-number">2</span>(“aa”) = <span class="hljs-number">6</span>, h<span class="hljs-number">3</span>(“aa”) = <span class="hljs-number">7</span>;<br><br><span class="hljs-attribute">h1</span>(“xy的aa”) = <span class="hljs-number">3</span>, h<span class="hljs-number">2</span>(“xy的aa”) = <span class="hljs-number">6</span>, h<span class="hljs-number">3</span>(“xy的aa”) = <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure><p>最开始的时候 ，集合里没有元素，所有位都是0：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>然后，插入“xy”，利用多次hash，把每次hash的结果下标3, 5, 7都插入到相应的地方：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>然后，插入“aa”，利用多次hash，把每次hash的结果下标5, 6, 7都插入到相应的地方，已经是1的下标不变:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>当我们判断“xy”是否在集合中，只需要使用同样的 3个hash算法，来计算出下标是3,5,7的位置上是否为1，如果为1，则证明“xy“在集合中。如果发现有下标为0，则说明string不在集合中。</p><h2 id="误差">误差</h2><p>由于是多个hash函数散列而来，必然会存在一些误差。有可能某个元素并没有在集合中，但是它对应位数组为1.这样就产生了误差。</p><p>以布隆过滤器不能删除，因为一旦删除（即将相应的位置为0），就很大可能会影响其他元素。</p><p>如果使用布隆过滤器判断一个函数是否存在于一个集合，如果它返回true，则代表可能存在。如果它返回false，则代表一定不存在。</p><p>由此可见，布隆过滤器适合于一些需要去重，但不一定要完全精确的场景。比如：</p><ul><li>判断一个用户访问了一篇文章</li><li>判断一个ip访问了本网站</li><li>判断一个key是否被访问过</li></ul><p>相应的，布隆过滤器不适合一些要求零误差的场景，比如：</p><ul><li>判断一个用户是否收藏了一篇文章</li><li>判断一个用户是否订购了一个课程</li></ul><h2 id="使用技巧">使用技巧</h2><p>如果空间越大，hash函数越多，结果就越精确，但是空间效率和查询效率就会越低。</p><img src="/dajiangdahe/2021/10/22/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OTnNzMDMyRklTZzVvREY3eWtnVUxqSUhvZWQ5Vm1wZGlhbWtKVGdMTVhzTnRFTEhyVFF4MDYwc1k2bjdPN0NVaWNUd1VpYzlGMWdGRXQ1d2R4UUdpY05pYmd3LzY0MA" class="" title="img"><p>后面4列中的数据就是发生误差的数量。可见，空间大小和集合大小不变的情况下，增加hash函数可以显著减小误差。但一旦集合大小达到空间大小的25%左右后，增加hash函数带来的提神效果并不明显。这个时候应该增加空间大小。</p><h2 id="Redis中的布隆过滤器">Redis中的布隆过滤器</h2><p>Redis的布隆过滤器不是原生自带的，而是要通过module加载进去。Redis在4.0的版本中加入了module功能。具体使用可以直接看RedisBloom github的README：<a href="https://github.com/RedisBloom/RedisBloom%E3%80%82%E4%B8%8A%E9%9D%A2%E6%9C%89docker%E4%B8%80%E9%94%AE%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%88%E6%96%B9%E4%BE%BF%E5%9C%B0%E5%AE%9E%E9%AA%8C%E3%80%82%E4%B9%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E4%B8%BB%E6%B5%81%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5%EF%BC%8C%E6%AF%94%E5%A6%82Java%E8%AF%AD%E8%A8%80%E7%9A%84JReBloom%E3%80%82%E6%9C%89%E5%85%B4%E8%B6%A3%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%8F%AF%E4%BB%A5%E8%87%AA%E8%A1%8C%E4%BA%86%E8%A7%A3%E3%80%82">https://github.com/RedisBloom/RedisBloom。上面有docker一键启动命令，可以很方便地实验。也有几种主流语言的客户端库的链接，比如Java语言的JReBloom。有兴趣的朋友可以自行了解。</a></p><p>Redis的布隆过滤器主要有两个命令：</p><ul><li><code>bf.add</code> 添加元素到布隆过滤器中：<code>bf.add strs xy</code></li><li><code>bf.exists</code> 判断某个元素是否在过滤器中：<code>bf.exists strs xy</code></li></ul><p>Redis中有一个命令可以来设置布隆过滤器的准确率：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bf</span>.reserve strs <span class="hljs-number">0</span>.<span class="hljs-number">01</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>三个参数的含义：</p><ul><li>第一个值是过滤器的名字。</li><li>第二个值为<code>error_rate</code>的值：允许布隆过滤器的错误率。</li><li>第三个值为<code>initial_size</code>的值：初始化位数组的大小。</li></ul><h2 id="扩展学习">扩展学习</h2><h3 id="Java实现的布隆过滤器">Java实现的布隆过滤器</h3><p>如果你的项目没有使用Redis，那可以使用一些开源库，基于代码实现，直接存放在内存。比如Google的guava包中提供了<code>BloomFilter</code>类，有兴趣的读者可以去了解一下，研究研究源码和使用。</p><h3 id="布谷鸟过滤器">布谷鸟过滤器</h3><p>RedisBloom模块还实现了布谷鸟过滤器，它算是对布隆过滤器的增强版。解决了布隆过滤器的一些比较明显的缺点，比如：不能删除元素，不能计数等。除此之外，布谷鸟过滤器不用使用多个hash函数，所以查询性能更高。除此之外，在相同的误判率下，布谷鸟过滤器的空间利用率要明显高于布隆，空间上大概能节省40%多。</p><p>笔者个人觉得，对于大多数场景来说，布隆过滤器足以解决我们的问题。</p><p>掘金上有一篇深度分析布谷鸟过滤器的文章，有兴趣的读者可以去了解一下：<a href="https://juejin.im/post/5cfb9c74e51d455d6d5357db%E3%80%82">https://juejin.im/post/5cfb9c74e51d455d6d5357db。</a></p><h2 id="面试题">面试题</h2><h3 id="1-给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url">1.给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?</h3><p>1.采用布隆过滤器，假设布隆过滤器的错误率为0.01，则位数组大小m约为输入元素个数n的13倍，此时需要的哈希函数k约为8个。</p><p>元素个数：5G</p><p>位数组大小：m = 5g x 13 = 65G = 650亿bit</p><p>我们的内存是 4g x 8bit = 32G = 320亿bit。按此错误率大于0.01</p><p>2.采用分治的思想</p><img src="/dajiangdahe/2021/10/22/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/20191023182333584.jpg" class="" title="img"><p>Step1：遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0,a1,…,a999，每个小文件约300M);</p><p>Step2:遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,…,b999);</p><p>巧妙之处：这样处理后，所有可能相同的url都被保存在对应的小文件(a0vsb0,a1vsb1,…,a999vsb999)中，不对应的小文件不可能有相同的url。然后我们只要求出这个1000对小文件中相同的url即可。</p><p>Step3：求每对小文件ai和bi中相同的url时，可以把ai的url存储到hash_set/hash_map中。然后遍历bi的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p><h2 id="【补充】">【补充】</h2><h3 id="为什么使用hash？">为什么使用hash？</h3><p>是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><h2 id="【注】">【注】</h2><p>1、Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中的情况，即这里采用的是mod1000算法，那么相同的url在hash取模后，只可能落在同一个文件中，不可能被分散的。因为如果两个url相等，那么经过Hash(url)之后的哈希值是相同的，将此哈希值取模（如模1000），必定仍然相等。</p><p>2、那到底什么是hash映射呢？简单来说，就是为了便于计算机在有限的内存中处理big数据，从而通过一种映射散列的方式让数据均匀分布在对应的内存位置(如大数据通过取余的方式映射成小树存放在内存中，或大文件映射成多个小文件)，而这个映射散列方式便是我们通常所说的hash函数，设计的好的hash函数能让数据均匀分布而减少冲突。尽管数据映射到了另外一些不同的位置，但数据还是原来的数据，只是代替和表示这些原始数据的形式发生了变化而已。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解读基金</title>
    <link href="/dajiangdahe/2021/10/22/%E3%80%90%E7%BB%8F%E6%B5%8E%E3%80%91%E8%A7%A3%E8%AF%BB%E5%9F%BA%E9%87%91/"/>
    <url>/dajiangdahe/2021/10/22/%E3%80%90%E7%BB%8F%E6%B5%8E%E3%80%91%E8%A7%A3%E8%AF%BB%E5%9F%BA%E9%87%91/</url>
    
    <content type="html"><![CDATA[<h1>解读基金（季凯帆）</h1><h2 id="1-投资的准备">1.投资的准备</h2><ol><li>投资周期的确定：这笔投资的目的是用来干什么的？长期投资？中期投资？短期投资？</li><li>投资本钱：这笔钱能够确保不会影响我的日常生活以及轻微事故发生。</li><li>基金如何盈利的模式以及部分基本概念等，如夏普比，回撤率，波动率等。</li><li>关于自己对于风险承担能力的评估</li></ol><h2 id="2-投资目标的确定">2.投资目标的确定</h2><ol><li>了解基金的风险和盈利能力</li><li>复利计算法则：72法则，115法则等等<ol><li>本金番一倍和翻两倍的计算公式，除年化率即可（在不计算通货膨胀的情况下）</li></ol></li></ol><h2 id="3-基金品种的选择">3.基金品种的选择</h2><ol><li>基金评价网站：晨星。<ol><li>通过选择一家好的基金公司和一个好的基金经理比选择一只好的基金更重要</li><li>在股市摸爬滚打了好多年的基金经理远比一个刚毕业的学生更会打理你的钱财</li></ol></li><li>资产配置比率<ol><li>资产配置：股票和债券的配比，这是与你的投资周期是确定的，投资周期长，股票比例高，当接近投资周期的末期时，债券比例提升，股票比例下降。（基金的激进性）</li><li>资产配置：核心资产和非核心资产以及瘟鸡：1.核心资产跟随投资周期选定，一般设置债券或者波动较小的基金组合或者大盘，中盘，小盘，采用核心+卫星的方式2.卫星作为非核心资产可以选择单一指数产品，非混合型。3.瘟鸡则是具有发展潜力，但是目前仍未显现的。</li><li>资产配置：保证每只基金的独立性。这样能够避免板块论调的风险。</li></ol></li><li>调控高净值下的手段：通过基金拆开和分红来解决</li><li>新基金和老基金的抉择：老基金</li><li>FOF和“生命周期”基金</li><li>分散投资和再平衡。</li></ol><h2 id="4-操作方法的实施">4.操作方法的实施</h2><ol><li>分红方式的选择：红利再投资</li><li>基金A类和C类的区别：前端收费还是后端收费，大于3年，A类，小于3年，C类</li><li>不要进行波段操作和预测市场</li><li>一次性投资和定投技术和分步进场<ol><li>一次性投资就是一次性在低点全部投资进去</li><li>定投就是每周或者每月寻求低点投入，或选择智能定投，可以平滑掉市场的短期波动</li><li>分步进场就是根据总金额，进行分层投资。一步步入场</li></ol></li><li>持有基金的最优策略就是长期持有</li><li>基金赎回<ol><li>达到投资周期目标</li><li>基本面受到改变，如基金的持仓情况、基金经理人的变化等</li><li>当市场非常狂热的时候</li></ol></li></ol><h2 id="5-投资实践">5.投资实践</h2><ol><li>绝对不能使用杠杆投资，一定是闲钱</li><li>我们的目的是降低风险，获取回报，而不是追求最大利益<ol><li>我们的目的是降低风险，获取回报，而不是追求最大利益</li></ol></li><li>坚持长期持有</li><li>绝对不能进行波段操作</li><li>股市不会创造投资，我们赚的钱是企业发展的钱，是时代的钱。</li><li>对短期的震荡不要太过在意，记住这是一件长期持有的事情</li><li>积极进攻和被动防御<ol><li>对一组由股票、债券和基金构成的动态投资组合，进行不断的研究，筛选和调控</li><li>以某种自动的方式，创建一个恒久的投资组合，不再付出更多的努力</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经济</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指数基金投资指南</title>
    <link href="/dajiangdahe/2021/10/22/%E3%80%90%E7%BB%8F%E6%B5%8E%E3%80%91%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97/"/>
    <url>/dajiangdahe/2021/10/22/%E3%80%90%E7%BB%8F%E6%B5%8E%E3%80%91%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1>指数基金投资指南（雪球）</h1><h2 id="1-初识指数基金">1.初识指数基金</h2><ol><li>指数基金定义：根据指数编制方案，选择相应的成分股。是一篮子股票。</li><li>指数基金分类：（1）场内和场外基金：区别：场内基金具备股票性质，T+0交易。场外基金T+1交易。（2）大中小盘股：按照市值划分。（3）宽窄基：跟踪标的覆盖范围。（4）指数增强型：按照复制程度。（5）A和C类：按照收费形式不同，分为前端收费和后端收费。（6）加权基金：按以某种策略对其市值因子进行加权。</li><li>指数基金优点：1.具备优胜劣汰的功能。2.永久存在，无需考虑公司退市或倒闭的风险。3.持仓透明，无惧基金经纪人的道德风险。4.无需担心基金经理的能力不足。5.成本和费率优势。</li><li>指数基金缺点：1.无法获得超额收益。2.弱市行情的抗风险能力不足。</li><li>历史：2002年，华安基金发行上证180指数增强型基金。</li></ol><h2 id="2-如何挑选指数基金">2.如何挑选指数基金</h2><ol><li>指数分类<ol><li>综合指数：反映出某个市场的情况。表征市场作用，投资功能较弱。如上证综指，沪深综指</li><li>综合指数：反映出某个市场的情况。表征市场作用，投资功能较弱。如上证综指，沪深综指</li><li>行业指数：根据《XXX分类标准》进行划分，将营收&gt;50%的划入其中。分为一级二级三级四级行业。需要有非常专业的知识。如中证能源，中证材料。</li><li>主题指数：自上而下的投资方式（主动投资）。通过评估社会的形态结构，确认某些领域的变革趋势和驱动因素。投资时间长把握中长期趋势。是行业的集合体。如：新能源主题，先进制造主题。</li><li>风格指数：成长型和价值型风格和稳定性。通过市净率，市盈率划分。分为大中小盘股。稳定性用于衡量股价对市场环境变化的敏感度。如300成长，300价值。成长型更激进，价值型更稳健。</li><li>策略指数：通过人为的调整这个部分符合特征条件的银子，目的是获取超额收益。编制方式采取了非市值加权的方式。包括基本面加权、波动率加权等。受益方向可以做多，也可以做空。不是单边的。</li></ol></li><li>指数选择纵向<ol><li>指数点位法：通过大盘的估值进行选择。（如上证综指3500为高，2000为低。）<ol><li>优点：简单明了，适合小白。此点位代表股价，也代表估值。</li><li>缺点：成分股不断变化，业绩也不是一成不变。局限性大，可作为观察指标</li></ol></li><li>市盈率法：股价/每股收益。或者市值/净利润，本益比。代表这一阶段的盈利水平。适用于较为稳健的行业，短期业绩波动一般不大的。如消费行业，公用事业。周期较强的容易失真：汽车行业、钢铁煤炭行业。<ol><li>优点：单只股票的异常波动影响较低。具有较好的参考性。</li><li>缺点：如果大批量成分股出现异常波动，就会失真。</li></ol></li><li>市净率法：所有成分股的市值之和/与净资产之和，是一种相对静态的估值方法。适用于一定资产规模的行业。不适合互联网广告、游戏、影视行业。<ol><li>优点：更加稳定，不容易失真。</li></ol></li><li>相对估值百分位法：评估当前估值在历史上的水平。高估、低估区等。<ol><li>优点：简单易懂，实用性强，直观。</li><li>缺点：对于成立时间较晚的指数，缺乏数据，容易失真。</li></ol></li><li>价格指数和全收益指数：现金分红和红利再投资的区别。长期来看选择红利再投资较好。论证过于复杂。类似于微定投。（现金分红调整，市值降低。）<ol><li>我们可以得出的结论是，指数成份股股本量、股息率与全收益指数超额收益率呈正相关关系，股本越大、股息率越高，全收益指数相对价格指数的超额收益率越高。全收益指数收益率与指数波动率呈负相关关系，波动率越低的指数，其全收益指数相对价格指数的超额收益率越高。</li></ol></li></ol></li><li>指数选择横向<ol><li>基金规模：小众基金5~20亿。热门基金百亿较好。</li><li>综合费率：分为前端收费和后端收费：大于3年选择A类，小于3年选择C类。</li><li>跟踪误差：指数基金净值收益率与标的之间收益率直接的偏差。指标：日均跟踪偏离度绝对值，年化跟踪误差。误差越小越好。</li><li>流动性：升贴水率往往是流动性的重要参考指标。佳哥便宜净值幅度越低，流动性越好。（交易价格高于净值，升水，反之贴水。）</li></ol></li><li>资金配置方案<ol><li>时间等分法：投资金额/投资月数、年、周等。</li><li>二八分割法：投资金额/投资月数=A，M为每个月定投比例，1-M为备用金。 Y（计划）=AxM+Ax(1-M),增强型即为备用金用不上，就攒到下个月投。<ol><li>优点：应对突发情况更强</li></ol></li></ol></li><li>定投买入策略<ol><li>基金定投取得成功的关键在于制定合适的定投策略与纪律性地执行策略。</li><li>定期定额法<ol><li>优点：简单省心，金额、期限可控。</li><li>缺点：出现大幅下跌时，不能更好的平摊成本。大幅上涨时，会拉高成本。</li></ol></li></ol></li></ol><h2 id="3-定投买入策略">3.定投买入策略</h2><ol><li><p>基金定投取得成功的关键在于制定合适的定投策略与纪律性地执行</p></li><li><p>本次策略上分为上涨市、下跌市、先涨后跌市、先跌后涨市。其中每个策略进行过模拟、和已存在的基金进行回测。</p></li><li><p>1.定期定额法</p><ol><li>根据资金划分n期，平均分到n期上。<ol><li>优点：定期定额法的优点是省心、简单易懂、金额可控、期限可控、风险平滑。只要在系统里设置好定投周期和每期的定投金额，剩下的就交给时间。对工薪阶层而言，定期定额的金额可控，可以合理地安排每个月的开支。</li><li>缺点：当然，定期定额法也存在很大的缺陷。例如，当市场出现大幅下跌后，有较大的把握可以判断市场处于底部阶段，但定期定额法依旧只能买入相同的金额，此时摊低成本的效果较差。当市场出现上涨时，也会拉高投资者的持仓成本。</li><li>适用人群：任意</li><li>适用人群：任意</li></ol></li><li>目标点位系数法<ol><li>核心逻辑为：低位多买、高位少买。投资者以标的指数的点位作为参照物，心中给定一个目标点位，这个目标点位是投资者认为市场进入高位还是低位的临界点。例如：上证指数3400为参照物，高于3400即为高位入市，低于为低位入市。</li><li>申购金额：（目标指数点/当前指数点位）^n x 基础金额。n的选择根据自己，用来控制指数涨跌的幅度。一般10即可<ol><li>优点：（1）具有出色的成本控制能力，回本周期极短。（2）收益率始终跑赢普通定投。（3）非常适合下跌市和先跌后涨市。</li><li>缺点：（1）需要投资者对目标点位作出相对准确的评估，增加了投资难度。（2）指数的成份股是动态变化的，单纯看指数点位有刻舟求剑之意。（3）在单边上涨趋势中，过于追求收益率会使得总投入的绝对金额过低，导致总盈利绝对金额较少。（4）每期定投金额不可控，无法提前预知，对投资者的资金量要求极高。（5）幂次方n的取值决定了收益率的弹性，虽然取值越高，成本控制越好、收益率越高，但每期定投金额也会相应变大，后期市场一旦进入下跌趋势，定投金额会非常高</li><li>适用人群：有大量闲散资金的投资者，有足够意志力和忍耐力的投资者</li></ol></li></ol></li><li>阶梯点位系数法<ol><li>核心逻辑：阶梯点位系数法是目标点位系数法的简化版，它同样以标的指数的点位作为参照物，不同之处在于，阶梯点位系数法以标的指数的点位区间作为决策依据。当指数点位处于某个区间内，其申购金额是固定的。只有当标的指数的点位脱离该区间并进入另外一个区间时，申购金额才会发生变化。例如3000点为参照物。3000-3100：系数为0.5。2900-3000：系数为1.5</li><li>申购金额：Mx基础金额。M为系数<ol><li>优点：（1）与普通定投法相比，阶梯点位系数法具有强大的收益率优势，在任何时候收益均不低于普通定投法，亏损比例比普通定投法少。（2）与目标点位系数法相比，阶梯点位系数法的定投金额相对可控。在阶梯点位系数法下，投资者可根据自己的风险偏好和资金情况适当调整M系数来调整每期的申购金额，每期最大的投资金额与最小投资金额事先已经知道，可做到心中有底。</li><li>缺点：（1）在熊市阶段，随着指数点位的走低，每期投入的资金会逐渐加大，对投资者的现金流会构成较大压力。（2）如果在刚买入基金后出现持续性牛市，阶梯点位系数法M系数的取值会自动下降，导致每期投入金额减少，未来盈利的绝对额也较少。（3）系数M的取值取决于每个投资者对指数点位的把控，需要投资者有较强的市场敏感度，对专业性要求较高，适用人群相应变窄。（4）指数的成份股定期调仓，指数点位也会不断变化，单纯参考历史行情来判断点位的高低有刻舟求剑之意。</li><li>适用人群：一定资金量，适当变化定投金额的投资者。 较高风险偏好和忍受较大的亏损和长久的等待。 空闲时间多的投资者。</li></ol></li></ol></li><li>成本偏离法<ol><li>核心逻辑：偏离定投法，是指投资者预先选定某个指数的均线，这条均线可以是短期均线or长期均线，作为参照物。当指数点位出狱该均线下方时，投资者增加定投金额，位于上方，则减少定投金额。例如：支付宝的智能定投，选用的是中证500均线。</li><li>申购金额：成本偏离度x基础金额。（上期末持仓单位成本/本期预估单位净值）^n x 基础金额。<ol><li>优点：（1）成本偏离法与目标点位系数法、阶梯点位系数法一样，对持仓成本的控制能力相当出色，可以获得比普通定投法更高的收益率。（2）具有较短的回本周期。（3）特别适合下跌市和先跌后涨市，适合“牛短熊长”的市场。</li><li>缺点：（1）与目标点位系数法相似，成本偏离法无法提前预知下一期的定投金额。（2）在市场处于上涨阶段，特别是牛市初期时，成本偏离法会自动降低成本偏离度系数，最终令投资者投入金额较低，赚到的绝对金额较少。（3）在市场处于底部横盘震荡阶段，市场往往较为低迷，容易出现低波动的行情，此时持仓成本与基金净值之间的偏离幅度较小，使得投入金额较低，最终可能错过大行情。（4）幂次方n的取值决定了收益率的弹性，虽然取值越高，成本控制越好，收益率越高，但需要投资者不断测试合适的数值，操作较为麻烦且专业性要求较高。（5）下跌市场中投入金额会不断增大，而且呈几何式增长，当申购金额与基础金额偏离过大时，容易对投资者构成现金流压力，造成定投断供的局面发生。（6）没有考虑市场估值，可能存在买贵的现象。</li><li>适用人群：有大量闲钱的投资者。承受风险能力较高的投资者。专业能力较强的投资者。</li></ol></li></ol></li><li>估值百分位法<ol><li>核心逻辑：基于估值贵贱程度。这种方法的核心逻辑是在市场估值低时多买，估值高时少买。估值百分位，顾名思义，即当期的估值占某个指标的分位数，通常是以当期的估值占历史估值数据样本的百分位。如果估值百分位为10%，即代表当期的估值分位数在历史所有估值数据中处于前10%的位置，或者可以理解为当前的估值比历史上90%的时候要高或低。估值指标可以根据投资者的喜好自行选择，如市盈率、市净率、市销率等</li><li>申购金额：（1/（1-心里临界值）+估值百分位）^n x 基础金额<ol><li>优点：（1）估值百分位法在控制持仓成本方面有较强的优势。（2）考虑了基本面情况，可避免在过于昂贵时买入资产，为投资者提供一定的安全边际。（3）该方法以估值为锚，避免以刻板的指数点位作为参照依据，更加客观合理。</li><li>缺点：（1）估值百分位法并不适用于所有指数。指数成立时间过短、指数底层资产的估值逻辑过于复杂，都有可能导致该方法失效。（2）估值百分位法需要选取合适的估值指标，指标数据和百分位均需要手动进行统计，操作过于复杂。（3）该方法需要投资者预估合理的心理临界值和幂次方n，投资者的专业性要求较高。（4）该方法可能存在指数点位与估值指标不能同向波动的情况。比如指数点位越低，估值指标反而越高，此情况下可能存在严重的形势误判，导致高位买入较多，低位买入较少，容易出现亏损。（5）估值百分位法对投资者的现金流要求极高，如果没有足够的资金量和充足的心理准备，容易出现定投停止，断供则会使浮亏变成真实亏损，导致前功尽弃。</li><li>适用人群：大量闲散资金的投资者。风险能力承受较高。专业能力强。专注于基本面的投资。</li></ol></li></ol></li><li>6.改进价值平均策略<ol><li>核心逻辑：价值平均策略则完全摒弃了本金，而以目标市值作为投资目标，当目标市值等于持仓市值时，该方法的目标便达成了。所谓目标市值，指的是随着时间的推移，投资者期望得到的资产市值，也有人将目标市值称为“目标价值”。例如，投资者期望股市里的持仓市值每月递增1 000元，定投10个月后，持仓市值只要达到10 000元即被视为完成目标。</li><li>申购金额：市值差额系数x基础金额。（本期目标市值/本期预估基金单位净值x上期持仓份额）x 基础金额。<ol><li>优点：（1）弥补了传统价值平均策略由于高抛低吸导致的本金投入水平过低的缺陷。（2）与普通定投法相比，改进价值平均策略有着强大的成本控制能力，收益率优势显著。</li><li>缺点：（1）牛市阶段投入与产出的绝对值可能跑输普通定投法。（2）每期申购金额波动范围较大，对投资者的现金流构成较大压力。（3）需要人为设置目标市值及目标市值每期的递增金额，如果目标市值的设定过于离谱，容易对投资者的现金流构成较大压力。另外，操作也相对烦琐，需要定期审视目标市值与持仓市值的差额。（4）未考虑底层资产的估值与性价比。</li><li>适用人群：专业性极强</li></ol></li></ol></li><li>恒定亏损比例策略<ol><li>核心逻辑：无论基金净值如何波动，投资者定投基金的最大亏损不能低于一个恒定的数值，该数值是投资者可以承受的最大亏损比例。当定投收益率低于该数值时，通过测算得出需要追加买入的资金量，令收益率回升至投资者可以承受的最大亏损幅度。</li><li>申购金额：每一期投入金额的时候，需保证当月收益维持在可以最大亏损幅度的底线。例如一直维持-10%<ol><li>优点：（1）极强的成本控制能力。恒定亏损比例策略有着无与伦比的成本控制能力，在本书所有定投策略中，该策略对持仓成本的控制能力首屈一指。只要投资者的资金量足够充裕，并合理设定各项参数，该策略几乎可以帮助投资者将亏损幅度控制在自己想要的任何水平。（2）极短的回本周期。恒定亏损比例策略平抑波动的方式来自当期申购前总收益率R&lt;恒定亏损比例Y时，该策略的疯狂加码买入拉低了持仓成本；当R&gt;0时，恒定亏损比例策略停止买入压制住持仓成本的上行，因此持仓成本只会下降不会上涨，极大地缩短了回本周期。（3）天然适用于熊长牛短的市场。</li><li>缺点：（1）适用人群极其狭窄。由于在熊市阶段恒定亏损比例策略的定投金额会呈现几何级爆炸增长，对投资者的资金量要求非常苛刻，需要投资者有足够的资金储备。该策略适用人群极其狭窄，广大工薪阶层未必适合该策略。（2）该策略需要投资者具备钢铁般的意志与纪律性，特别是在熊市阶段，如果出现断供，中途退出导致的绝对损失将十分庞大。（3）该策略在牛市时收益率同样超越普通定投法，但投入本金的绝对值可能存在过低的风险。如果本金投入过低，为投资者赚取的绝对回报也将减少。（4）该策略需要投资者设定合理的恒定亏损比例参数、基础金额参数，以及挑选合适的进场时机，对投资者的专业性提出极高的要求，操作较为烦琐。</li><li>适用人群：极其专业人员。超大量资金人员</li></ol></li></ol></li></ol></li><li><p>定投止盈策略</p><ol><li>卖出公式有三种：一次性止盈公式、等额分批止盈公式、非等额分批止盈公式。</li><li>也是依据在上涨市、下跌市、先跌后涨市、先涨后跌市下的模拟与回测。</li><li>目标收益率法：核心逻辑：<strong>达到心中的预计收益率卖出</strong><ol><li>优点：应用广泛、操作简单。</li><li>缺点：当行情波动较为复杂，实际收益率能够达到投资者预计的目标收益率存在较大的不确定性。一旦设定目标夸张，容易盈利回吐甚至亏损。</li><li>适用人群：任意</li></ol></li><li>目标估值法：核心逻辑：标的估值达到投资者预估的合理估值上限后进行止盈，与收益率无关。例如上证3700选择止盈。<ol><li>优点：考虑到了底层资产的基本面情况。资产的跪着被纳入决策系统，更加客观、合理</li><li>缺点：操作略微复杂，标的指数的估值波动于标的的指数点位并非时时对应。适用于相对稳定的市场。（个人感觉美股/长期利好行业。）</li><li>适用人群：具备基本知识面投资和一定的专业能力</li></ol></li><li>均线止盈法：核心逻辑：党目标物跌破参照物时，触发止盈。这里的参照物是指投资者预估的某条均线。例如30日均线。60日均线等。<ol><li>优点：直观、易懂。具备K线基础知识即可轻松驾驭。</li><li>缺点：市场是随机的波动的，历史不一定会重复。</li><li>适用人群：适用于大部分投资者和一定技术分析能力的投资者。</li></ol></li><li>回撤止盈法：核心逻辑：价格回落到均线位置，直至跌破该均线后认定市场已经击穿某一关键位置，此时便可止盈。例如击穿箱体的一刻。或者回撤率达到15%的时候选择止盈。<ol><li>优点：具备基本K线知识即可掌握。</li><li>缺点：需要频繁盯盘，合理预估可承受最大回撤值。容易错过大行情or被套。个人建议10%-20%回撤。</li><li>适用人群：闲暇时间多者。</li></ol></li><li>可转债转股止盈法（了解）、斜率偏离法（通过判断通道来判断是否止盈，触及通道顶部止盈。）</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经济</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>共同基金</title>
    <link href="/dajiangdahe/2021/10/22/%E3%80%90%E7%BB%8F%E6%B5%8E%E3%80%91%E5%85%B1%E5%90%8C%E5%9F%BA%E9%87%91/"/>
    <url>/dajiangdahe/2021/10/22/%E3%80%90%E7%BB%8F%E6%B5%8E%E3%80%91%E5%85%B1%E5%90%8C%E5%9F%BA%E9%87%91/</url>
    
    <content type="html"><![CDATA[<h1>共同基金常识（投资圣经）</h1><h2 id="1-投资策略">1.投资策略</h2><h3 id="1-长期投资：强斯与花园">1.长期投资：强斯与花园</h3><ol><li>一个分散化的投资组合可将风险降低至股票和债券市场的平均水平，从而使持有单只证券的风险最小化。</li><li>当我们信心低迷时，市场估值很可能具有吸引力。我们完全可以称其为“投资的悖论”。<ol><li>投资悖论出现的时候，正是价值投资布局的开始</li></ol></li><li>花园历经季节的循环变化，与经济和金融市场的周期类似。<ol><li>我们中的很多人忘记了自然界与人类社会的相通之处。正如自然界一样，从长期来看，我们的经济体系保持着稳定和理性，这就是我们不必害怕自然规律的原因……我们坦然迎接不可避免的季节更替，却为经济的周期变动而烦恼，我们是多么愚蠢啊！”</li></ol></li><li>若想投资成功，你必须成为一个长期投资者。<ol><li>时间越长，年平均回报率的波动越小。投资者不应该低估时间跨度。</li><li>风险不是短期的波动，因为长期投资者可以忽略短期波动。而且，并不存在任何预定的回报率，而仅仅可能是一个无法实现的期望回报率，风险是这样一种可能性。在长期，股票的回报可能很差。</li><li>我们的经济就像一个健康肥沃的花园，那么收获长期回报的最佳方式是：如同怀着期望播下增长的种子一样，投资于普通股。但是，你必须也要做好准备以应对不可预料的寒冬侵袭。那时，债券将扮演关键角色。</li><li>长期投资者应当将债券纳入其投资组合，将其作为针对股票短期波动的不足的弥补。这样的一种平衡投资策略将在第3章详细讨论。无论市场上涨或下跌，选择一个包括股票和债券的理性平衡组合，并坚定地持有它，你不仅可以积累收益并且可抵抗逆境。</li><li>如果长期投资的理想是构造一个在股票和债券间分散投资的合理平衡组合，无论市场如何变迁都始终持有它，并力争将成本保持在最低。这应该成为共同基金经理和投资者一致崇尚的原则。</li></ol></li><li>不管历史记录是多么牢靠，过去的经验仍然无法保证未来的成功。然而，对过去的探究，加之使人自律的常识，这依然是一个聪明投资者最可依靠的方法。</li><li>仔细关注我们可以控制的投资要素：风险、成本和时间，那么，一个长期的投资计划必将在未来获益。<ol><li>比较有意思的是 三大要素里面没有收益，而像我这种小白最开始考虑的是 收益与风险。逐利性摆放在最前面就意味着遮挡了一些重要的信息 比如这里提出的风险 成本 时间。换句话说 只有当你控制好了以上三大要素 收益是自然而然就会到来的。</li><li>基金选择的关键不在于只关注未来的回报，因为这是投资者所不能控制的，而应关注风险、成本和时间这些投资者能够控制的因素</li></ol></li><li>我们不能仅依靠情感，更要依赖理智，去洞察具有创造力和创新性的美国经济在长期中如何增长。</li><li>黄金不像股票和债券，它不能产生内部价值；而股票可以通过盈利增长和股利分红产生内部价值；债券则可通过利息支付取得内部价值。</li><li>投资的目的在于积累实际财富，这表现为不断提高对商品和服务的购买能力，因而长期投资的最终目标一定是实际回报率而非名义回报率。</li><li>标准差：衡量年回报率范围的指标<ol><li>从学术角度看，标准差是一个公认的测度变异性的指标。在给定的时间范围内，它指出了投资回报的变动范围。例如，如果某项投资的平均年回报率为10%，且年回报率有2/3可能会处在–5%～+25%的范围以内（在上下任何一个方向上都有15%的变化），则年回报率的标准差为15%。而两倍标准差将涵盖95%的年回报率的变动范围。</li></ol></li><li>馅饼理论：面对市场这个馅饼，你赚取超过平均值的回报率就是较不成功的人的回报率与平均值的差额。（不计算成本）这就是较成功的投资者。<ol><li>如果将这个回报率视作一个扁平的圆形平面，比如一张馅饼，根据定义，11%就是那张全部市场参与者能够分配的馅饼。如果我们汇总所有表现较好的投资者的回报率，其回报率一定会被所有表现较差的投资者的总回报率所抵消。准确地讲，抵消的幅度相等。这就是那张扣减成本前的总馅饼。</li></ol></li><li>在任何逐月甚至逐年的短期基础上，市场完全不可预测。我们既不应当指望它变得可预测，也不应当根据传统观念所引发的冲动做出投资决策。无论这些号召来自权威刊物的头条，还是来自我们日常的希望和恐惧，它们通常会让我们关注短期，模糊我们对长期的认识。</li><li>除去我所引用的一些“表现最佳”的共同基金（那些遵从相对稳定的低换手率策略者），共同基金业现在正走向一条只能创造更少价值的道路。<ol><li>我们需要去寻找稳定的低换手率策略者所持有的优秀基金，并且坚定的相信他。</li><li>绝大多数基金只要仅仅在年初持有其投资组合不变，并在随后的12个月中不采取任何操作，都能获得更高的回报率。</li><li>市场择时只是失败的策略之一；投资组合的高换手率亦是最无效的。无论是对基金还是基金投资者而言，换手率不断提高所导致的高成本和高税收，注定将使情况更糟糕。<ol><li>不能盲目择时</li><li>投资的组合不能高换手率</li></ol></li><li>无论市场潮起潮落，都持有一个股票和债券保持合理均衡的投资组合，并达到合理的平衡。<ol><li>给予你的投资组合足够的时间，让它受益于复利的魔力，并使你的成本最低。</li></ol></li></ol></li><li>巴菲特先生描绘其不同寻常的有效投资方法为：保持“我们所主要持有的大多数股票，不管其价格相对于其（当前的）内在价值是多少……至死不渝……我们一直在找寻确信在未来一二十年仍有巨大潜力的企业。作为投资者，对于动荡的行业，我们应像对待太空探险一样，为努力而喝彩，但我们宁愿置身其外”。</li><li>市场上投机行为的强势地位，来自投资者持有股票数量的不断增长，而这些投资者“毫无专业投资知识……而传统的股票定价方法，是基于大量无知个体的群体心理”。专业投资者及证券行业专家的意见将不能抵消群体的观点，于是他们将试图去预测公众对股票估值的变化。</li><li>生存法则<ol><li>你必须投资</li><li>时间是你的朋友</li><li>冲动是你的敌人</li><li>掌握基本的算术</li><li>坚持简单化并且坚持到底</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经济</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奶牛的秘密生活</title>
    <link href="/dajiangdahe/2021/10/22/%E3%80%90%E6%95%A3%E6%96%87%E3%80%91%E5%A5%B6%E7%89%9B%E7%9A%84%E7%A7%98%E5%AF%86%E7%94%9F%E6%B4%BB/"/>
    <url>/dajiangdahe/2021/10/22/%E3%80%90%E6%95%A3%E6%96%87%E3%80%91%E5%A5%B6%E7%89%9B%E7%9A%84%E7%A7%98%E5%AF%86%E7%94%9F%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<h1><strong>《奶牛的秘密生活》（罗莎曼德 扬）</strong></h1><p>这本书最值的思考的一个地方就是，如果我们爱他（无论是友情、爱情、亲情）我们都应该积极的参与他们的生活，观察他们的喜好。这不仅仅是我们表达爱意的一种方式，更是一种我可以换位思考，处在对方的角度去思考问题的理解。</p><p>令：这本散文书并不没有全部的看完，实际上随着年龄和阅读理解的增长，看这种类型的书，一部分就能够明白作者要讲述什么内容，也就没有全部看完的必要。（主要是对散文实在不感冒，就像村上春树的《大萝卜和难挑的鳄梨》，或者陈平原《神神鬼鬼》、或者钱理群《说东道西》）倒是觉得这种散文类型的书像是厕所读书，他只应该呆在厕所的架子上，陪伴自己度过“美妙”的一段时间。</p><p>摘1：合适的食物是健康的起点和终点。</p><p>今日2021.3.21，体重138，最近一周并没有管住自己的口腹之欲，导致为期一周的200min+时长浪费了。自律果然是最难的，以后要分成一周一周去管理时间（事实上也很难），管理饮食，这样就躲避了连续几个月想象不到的痛苦和折磨（吃的时候其实并没有那么折磨，这减肥路上的绊脚石是真滴多）（好吃的也太多了）</p><p>摘2：关于奶牛你应该知道的二十件事（懒的打出来了，截图吧）</p><img src="/dajiangdahe/2021/10/22/%E3%80%90%E6%95%A3%E6%96%87%E3%80%91%E5%A5%B6%E7%89%9B%E7%9A%84%E7%A7%98%E5%AF%86%E7%94%9F%E6%B4%BB/clipboard.png" class="" title="img"><p>摘3：关于绵羊你应该知道的二十件事</p><img src="/dajiangdahe/2021/10/22/%E3%80%90%E6%95%A3%E6%96%87%E3%80%91%E5%A5%B6%E7%89%9B%E7%9A%84%E7%A7%98%E5%AF%86%E7%94%9F%E6%B4%BB/clipboard-1631537089379.png" class="" title="img"><p>摘4：关于母鸡你应该知道的二十件事</p><img src="/dajiangdahe/2021/10/22/%E3%80%90%E6%95%A3%E6%96%87%E3%80%91%E5%A5%B6%E7%89%9B%E7%9A%84%E7%A7%98%E5%AF%86%E7%94%9F%E6%B4%BB/clipboard-1631537104447.png" class="" title="img"><p>摘5：关于猪你应该知道的二十件事</p><img src="/dajiangdahe/2021/10/22/%E3%80%90%E6%95%A3%E6%96%87%E3%80%91%E5%A5%B6%E7%89%9B%E7%9A%84%E7%A7%98%E5%AF%86%E7%94%9F%E6%B4%BB/clipboard-1631537118561.png" class="" title="img"><p>令2：关于我自己的二十件你必须知道的事情</p><p>1.你必须知道我好看</p><p>2.你必须知道我有趣</p><p>3.你必须知道我喜欢吃好吃的</p><p>4.你必须承认我有魅力</p><p>5.虽然很不爱卫生，但是出门前一定收拾的很利索</p><p>6.我每天早上都会对着镜子笑一笑</p><p>7.吃饭的时候必须看武林外传</p><p>8.喜欢浅色系衣服</p><p>9.喜欢时而可爱，时而躁动的美女，你不美可以，但得漂亮</p><p>10.我不高兴的时候就只想躺在床上</p><p>11.我喜欢出去玩，一个人也很喜欢</p><p>12.我承认自己有时候很废柴</p><p>13.我非常暴躁，但是我能有一群可爱的朋友</p><p>14.如果引起了争辩，我会拿出十二分精神来，请不要说这是“开玩笑”…</p><p>15.你必须直接用你的专业素养击败我。</p><p>16.我会承认比我强的人，我也不会嫉妒他们，会学着打败他们</p><p>17.我每天都需要睡午觉，这是脾气最差的时候</p><p>18.很讨厌不明确某个“概念”的人对我进行指导，因为我这就是这样的人</p><p>19.我会关心人</p><p>20.看完的人可以给我介绍女朋友了</p>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>散文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论自由</title>
    <link href="/dajiangdahe/2021/10/22/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%91%E8%AE%BA%E8%87%AA%E7%94%B1/"/>
    <url>/dajiangdahe/2021/10/22/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%91%E8%AE%BA%E8%87%AA%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h1>论自由（约翰·穆勒）</h1><h2 id="1-导读">1.导读</h2><img src="/dajiangdahe/2021/10/22/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%91%E8%AE%BA%E8%87%AA%E7%94%B1/image-20211226230618684.png" class="" title="image-20211226230618684"><h2 id="2-引论">2.引论</h2><img src="/dajiangdahe/2021/10/22/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%91%E8%AE%BA%E8%87%AA%E7%94%B1/image-20211226230641574.png" class="" title="image-20211226230641574"><img src="/dajiangdahe/2021/10/22/%E3%80%90%E6%94%BF%E6%B2%BB%E3%80%91%E8%AE%BA%E8%87%AA%E7%94%B1/image-20211226230652998.png" class="" title="image-20211226230652998">]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>政治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis集群模式</title>
    <link href="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>从宏观角度回顾一下Redis实现高可用相关的技术。它们包括：持久化、复制、哨兵和集群，其主要作用和解决的问题是：</p><ul><li>持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。</li><li>复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</li><li>哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。</li><li>集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。</li></ul><h1>1.Redis主从复制</h1><h2 id="概念">概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p><p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><h2 id="作用">作用</h2><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，从节点提供读服务，分担服务器压力；在多读少写的场景下，通过多个从节点进行分担负载，可以大大的提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群实现的基础。</li></ol><h2 id="如何使用主从复制">如何使用主从复制</h2><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/a6c2adcacf3c3ebebd2853021a02ca32.png" class="" title="img"><p><strong>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</strong></p><ol><li><p>开启主从复制</p><ul><li>在slave 直接执行命令：slaveof <masterip> <masterport></li><li>在 slave 配置文件中加入：slaveof <masterip> <masterport></li><li>使用启动命令：–slaveof <masterip> <masterport></li></ul><p>注：在 Redis 5.0 之后，slaveof 相关命令和配置已经被替换成 replicaof，例如 replicaof <masterip> <masterport>。为了兼容旧版本，通过配置的方式仍然支持 slaveof，但是通过命令的方式则不行了。</p></li><li><p>建立socket连接</p><p>slave 将根据指定的 IP 地址和端口，向 master 发起套接字（socket）连接，master 在接受accept）slave 的套接字连接之后，为该套接字创建相应的客户端状态，此时连接建立完成。</p></li><li><p>发送Ping命令</p><p>slave 向 master 发送一个 PING 命令，以检査套接字的读写状态是否正常、 master 能否正常处理命令请求。</p></li><li><p>身份验证</p><p>slave 向 master 发送 AUTH password 命令来进行身份验证。</p></li><li><p>发送端口信息</p><p>在身份验证通过后后， slave 将向 master 发送自己的监听端口号， master 收到后记录在 slave 所对应的客户端状态的 slave_listening_port 属性中。</p></li><li><p>发送IP地址</p><p>如果配置了 slave_announce_ip，则 slave 向 master 发送 slave_announce_ip 配置的 IP 地址， master 收到后记录在 slave 所对应的客户端状态的 slave_ip 属性。</p><p>该配置是用于解决服务器返回内网 IP 时，其他服务器无法访问的情况。可以通过该配置直接指定公网 IP。</p></li><li><p>发送CAPA</p><p>CAPA 全称是 capabilities，这边表示的是同步复制的能力。slave 会在这一阶段发送 capa 告诉 master 自己具备的（同步）复制能力， master 收到后记录在 slave 所对应的客户端状态的 slave_capa 属性。</p></li><li><p>数据同步</p><p>slave 将向 master 发送 PSYNC 命令， master 收到该命令后判断是进行部分重同步还是完整重同步，然后根据策略进行数据的同步。</p><p>需要注意的是，在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p></li><li><p>命令传播</p><p>当完成了同步之后，就会进入命令传播阶段，这时 master 只要一直将自己执行的写命令发送给 slave ，而 slave 只要一直接收并执行 master 发来的写命令，就可以保证 master 和 slave 一直保持一致了。</p><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。由于心跳机制的原理涉及部分复制，因此将在介绍了部分复制的相关内容后单独介绍该心跳机制。</p><p><strong>【延迟与不一致】</strong></p><p>需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。</p><p>repl-disable-tcp-nodelay no：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。</p><p>一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p><p><strong>【优化措施】</strong></p><ul><li><p>优化主从节点之间的网络环境（如在同机房部署）</p></li><li><p>监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据</p></li><li><p>使用集群同时扩展写负载和读负载</p></li></ul></li></ol><h2 id="示例">示例</h2><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/image-20210924143457687.png" class="" title="image-20210924143457687"><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/image-20210924143508264.png" class="" title="image-20210924143508264"><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/image-20210924143519389.png" class="" title="image-20210924143519389"><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/image-20210924143551169.png" class="" title="image-20210924143551169"><h2 id="【数据同步阶段】全量复制和部分复制">【数据同步阶段】全量复制和部分复制</h2><ol><li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li><li>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li></ol><h3 id="全量复制">全量复制</h3><p>Redis通过psync命令进行全量复制的过程如下：</p><p>（1）从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制；具体判断过程需要在讲述了部分复制原理后再介绍。</p><p>（2）主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</p><p>（3）主节点的bgsave执行完成后，将RDB文件发送给从节点；<strong>从节点首先清除自己的旧数据，然后载入接收的RDB文件</strong>，将数据库状态更新至主节点执行bgsave时的数据库状态</p><p>（4）主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态</p><p>（5）如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态</p><p>通过全量复制的过程可以看出，全量复制是非常重型的操作：</p><p>（1）主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；关于bgsave的性能问题。</p><p>（2）主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</p><p>（3）从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗</p><p><strong>【示例】</strong></p><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/image-20210924152335494.png" class="" title="image-20210924152335494"><h3 id="部分复制">部分复制</h3><p>由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p><p>部分复制的实现，依赖于三个重要的概念：</p><h4 id="（1）复制偏移量">（1）复制偏移量</h4><p>主节点和从节点分别维护一个复制偏移量（offset），代表的是<strong>主节点向从节点传递的字节数</strong>；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。</p><p>offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p><h4 id="（2）复制积压缓冲区">（2）复制积压缓冲区</h4><p>复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；当主节点开始有从节点时创建，其作用是<strong>备份主节点最近发送给从节点的数据</strong>。注意，<strong>无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</strong></p><p>在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p><p>由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p><p>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</p><ul><li>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</li><li>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</li></ul><h4 id="（3）服务器运行ID-runid">（3）服务器运行ID(runid)</h4><p>每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid：</p><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/1174710-20180628011537662-712436367.png" class="" title="img"><p>主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：</p><ul><li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li><li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li></ul><p><strong>【示例】</strong></p><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/image-20210924155035634.png" class="" title="image-20210924155035634"><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/image-20210924155043945.png" class="" title="image-20210924155043945"><h2 id="【命令传播阶段】心跳机制">【命令传播阶段】心跳机制</h2><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于<strong>主从复制的超时判断、数据安全</strong>等有作用。</p><h3 id="1-主-从：PING">1.主-&gt;从：PING</h3><p>每隔指定的时间，<strong>主节点会向从节点发送PING命令</strong>，这个PING命令的作用，主要是为了让从节点进行超时判断。</p><p>PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。</p><p>关于该PING命令究竟是由主节点发给从节点，还是相反，有一些争议；因为在Redis的官方文档中，对该参数的注释中说明是从节点向主节点发送PING命令，如下图所示：</p><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/1174710-20180628011653835-25800141.png" class="" title="img"><p>但是根据该参数的名称(含有ping-slave)，以及代码实现，我认为该PING命令是主节点发给从节点的。相关代码如下：</p><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/1174710-20180628011700171-401488218.png" class="" title="img"><h3 id="2-从-主：REPLCONF-ACK">2. 从-&gt;主：REPLCONF ACK</h3><p>在命令传播阶段，**从节点会向主节点发送REPLCONF ACK命令，**频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量。REPLCONF ACK命令的作用包括：</p><p>（1）实时监测主从节点网络状态：该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1，如下图所示：</p><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/1174710-20180628011708219-1385546367.png" class="" title="img"><p>（2）检测命令丢失：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。<strong>注意，offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</strong></p><p>（3）辅助保证从节点的数量和延迟：Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</p><h2 id="【部分事故场景】">【部分事故场景】</h2><h3 id="1-复制超时问题">1.复制超时问题</h3><p>（1）数据同步阶段：在主从节点进行全量复制bgsave时，主节点需要首先fork子进程将当前数据保存到RDB文件中，然后再将RDB文件通过网络传输到从节点。如果RDB文件过大，主节点在fork子进程+保存RDB文件时耗时过多，可能会导致从节点长时间收不到数据而触发超时；此时从节点会重连主节点，然后再次全量复制，再次超时，再次重连……这是个悲伤的循环。为了避免这种情况的发生，除了注意Redis单机数据量不要过大，另一方面就是适当增大repl-timeout值，具体的大小可以根据bgsave耗时来调整。</p><p>（2）命令传播阶段：如前所述，在该阶段主节点会向从节点发送PING命令，频率由repl-ping-slave-period控制；该参数应明显小于repl-timeout值(后者至少是前者的几倍)。否则，如果两个参数相等或接近，网络抖动导致个别PING命令丢失，此时恰巧主节点也没有向从节点发送数据，则从节点很容易判断超时。</p><p>（3）慢查询导致的阻塞：如果主节点或从节点执行了一些慢查询（如keys *或者对大数据的hgetall等），导致服务器阻塞；阻塞期间无法响应复制连接中对方节点的请求，可能导致复制超时。</p><h3 id="2-复制缓冲区溢出问题">2.复制缓冲区溢出问题</h3><p>主从节点超时是复制中断的原因之一，除此之外，还有其他情况可能导致复制中断，其中最主要的是复制缓冲区溢出问题。</p><p>前面曾提到过，在全量复制阶段，主节点会将执行的写命令放到复制缓冲区中，该缓冲区存放的数据包括了以下几个时间段内主节点执行的写命令：bgsave生成RDB文件、RDB文件由主节点发往从节点、从节点清空老数据并载入RDB文件中的数据。当主节点数据量较大，或者主从节点之间网络延迟较大时，可能导致该缓冲区的大小超过了限制，此时主节点会断开与从节点之间的连接；这种情况可能引起全量复制-&gt;复制缓冲区溢出导致连接中断-&gt;重连-&gt;全量复制-&gt;复制缓冲区溢出导致连接中断……的循环。</p><p>复制缓冲区的大小由client-output-buffer-limit slave {hard limit} {soft limit} {soft seconds}配置，默认值为client-output-buffer-limit slave 256MB 64MB 60，其含义是：如果buffer大于256MB，或者连续60s大于64MB，则主节点会断开与该从节点的连接。该参数是可以通过config set命令动态配置的（即不重启Redis也可以生效）。</p><p>当复制缓冲区溢出时，主节点打印日志如下所示：</p><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/1174710-20180628012000540-1190099498.png" class="" title="img"><p><strong>需要注意的是，复制缓冲区是客户端输出缓冲区的一种，主节点会为每一个从节点分别分配复制缓冲区；而复制积压缓冲区则是一个主节点只有一个，无论它有多少个从节点。</strong></p><h3 id="3-第一次建立复制选择">3.第一次建立复制选择</h3><p>此时全量复制不可避免，但仍有几点需要注意：如果主节点的数据量较大，应该尽量避开流量的高峰期，避免造成阻塞；如果有多个从节点需要建立对主节点的复制，可以考虑将几个从节点错开，避免主节点带宽占用过大。此外，如果从节点过多，也可以调整主从复制的拓扑结构，由一主多从结构变为树状结构（中间的节点既是其主节点的从节点，也是其从节点的主节点）；但使用树状结构应该谨慎：虽然主节点的直接从节点减少，降低了主节点的负担，但是多层从节点的延迟增大，数据一致性变差；且结构复杂，维护相当困难。</p><h3 id="4-主节点重启">4.主节点重启</h3><p>主节点重启可以分为两种情况来讨论，一种是故障导致宕机，另一种则是有计划的重启。</p><p><strong>主节点宕机</strong></p><p>主节点宕机重启后，runid会发生变化，因此不能进行部分复制，只能全量复制。</p><p>实际上在主节点宕机的情况下，应进行故障转移处理，将其中的一个从节点升级为主节点，其他从节点从新的主节点进行复制；且故障转移应尽量的自动化，后面文章将要介绍的哨兵便可以进行自动的故障转移。</p><p><strong>安全重启：debug reload</strong></p><p>在一些场景下，可能希望对主节点进行重启，例如主节点内存碎片率过高，或者希望调整一些只能在启动时调整的参数。如果使用普通的手段重启主节点，会使得runid发生变化，可能导致不必要的全量复制。</p><p>为了解决这个问题，Redis提供了debug reload的重启方式：<strong>重启后，主节点的runid和offset都不受影响，避免了全量复制</strong>。</p><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/1174710-20180628012018427-1532559550.png" class="" title="img"><p>但debug reload是一柄双刃剑：<strong>它会清空当前内存中的数据，重新从RDB文件中加载</strong>，这个过程会导致主节点的阻塞，因此也需要谨慎。</p><h3 id="5-网络中断">5.网络中断</h3><p>如果主从节点之间出现网络问题，造成短时间内网络中断，可以分为多种情况讨论。</p><p>第一种情况：网络问题时间极为短暂，只造成了短暂的丢包，主从节点都没有判定超时（未触发repl-timeout）；此时只需要通过REPLCONF ACK来补充丢失的数据即可。</p><p>第二种情况：网络问题时间很长，主从节点判断超时（触发了repl-timeout），且丢失的数据过多，超过了复制积压缓冲区所能存储的范围；此时主从节点无法进行部分复制，只能进行全量复制。为了尽可能避免这种情况的发生，应该根据实际情况适当调整复制积压缓冲区的大小；此外及时发现并修复网络中断，也可以减少全量复制。</p><p>第三种情况：介于前述两种情况之间，主从节点判断超时，且丢失的数据仍然都在复制积压缓冲区中；此时主从节点可以进行部分复制。</p><h3 id="6-单机内存大小的限制">6.单机内存大小的限制</h3><p>fork操作对Redis单机内存大小的限制。实际上在Redis的使用中，限制单机内存大小的因素非常之多，下面总结一下在主从复制中，单机内存过大可能造成的影响：</p><p>（1）切主：当主节点宕机时，一种常见的容灾策略是将其中一个从节点提升为主节点，并将其他从节点挂载到新的主节点上，此时这些从节点只能进行全量复制；如果Redis单机内存达到10GB，一个从节点的同步时间在几分钟的级别；如果从节点较多，恢复的速度会更慢。如果系统的读负载很高，而这段时间从节点无法提供服务，会对系统造成很大的压力。</p><p>（2）从库扩容：如果访问量突然增大，此时希望增加从节点分担读负载，如果数据量过大，从节点同步太慢，难以及时应对访问量的暴增。</p><p>（3）缓冲区溢出：（1）和（2）都是从节点可以正常同步的情形（虽然慢），但是如果数据量过大，导致全量复制阶段主节点的复制缓冲区溢出，从而导致复制中断，则主从节点的数据同步会全量复制-&gt;复制缓冲区溢出导致复制中断-&gt;重连-&gt;全量复制-&gt;复制缓冲区溢出导致复制中断……的循环。</p><p>（4）超时：如果数据量过大，全量复制阶段主节点fork+保存RDB文件耗时过大，从节点长时间接收不到数据触发超时，主从节点的数据同步同样可能陷入全量复制-&gt;超时导致复制中断-&gt;重连-&gt;全量复制-&gt;超时导致复制中断……的循环。</p><p>此外，主节点单机内存除了绝对量不能太大，其占用主机内存的比例也不应过大：最好只使用50%-65%的内存，留下30%-45%的内存用于执行bgsave命令和创建复制缓冲区等。</p><h2 id="【总结】">【总结】</h2><p>1、主从复制的作用：宏观的了解主从复制是为了解决什么样的问题，即数据冗余、故障恢复、读负载均衡等。</p><p>2、主从复制的操作：即slaveof命令。</p><p>3、主从复制的原理：主从复制包括了连接建立阶段、数据同步阶段、命令传播阶段；其中数据同步阶段，有全量复制和部分复制两种数据同步方式；命令传播阶段，主从节点之间有PING和REPLCONF ACK命令互相进行心跳检测。</p><p>4、应用中的问题：包括读写分离的问题（数据不一致问题、数据过期问题、故障切换问题等）、复制超时问题、复制中断问题等，然后总结了主从复制相关的配置，其中repl-timeout、client-output-buffer-limit slave等对解决Redis主从复制中出现的问题可能会有帮助。</p><p>主从复制虽然解决或缓解了数据冗余、故障恢复、读负载均衡等问题，但其缺陷仍很明显：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制；这些问题的解决，需要哨兵和集群的帮助</p><h1>2.Redis哨兵</h1><h2 id="【概念】">【概念】</h2><p>Redis Sentinel，即Redis哨兵，在Redis 2.8版本开始引入。**哨兵的核心功能是主节点的自动故障转移。**下面是Redis官方文档对于哨兵功能的描述：</p><ul><li>监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。</li><li>自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li>配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li>通知（Notification）：哨兵可以将故障转移的结果发送给客户端。</li></ul><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/1174710-20180908182924632-1069251418.png" class="" title="img"><p>它由两部分组成，哨兵节点和数据节点：</p><ul><li>哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。</li><li>数据节点：主节点和从节点都是数据节点。</li></ul><h2 id="【故障转移】">【故障转移】</h2><p><a href="https://www.cnblogs.com/kismetv/p/9609938.html">https://www.cnblogs.com/kismetv/p/9609938.html</a></p><p>哨兵系统的搭建过程，有几点需要注意：</p><p>（1）哨兵系统中的主从节点，与普通的主从节点并没有什么区别，故障发现和转移是由哨兵来控制和完成的。</p><p>（2）哨兵节点本质上是redis节点。</p><p>（3）每个哨兵节点，只需要配置监控主节点，便可以自动发现其他的哨兵节点和从节点。</p><p>（4）在哨兵节点启动和故障转移阶段，各个节点的配置文件会被重写(config rewrite)。</p><p>（5）本章的例子中，一个哨兵只监控了一个主节点；实际上，一个哨兵可以监控多个主节点，通过配置多条sentinel monitor即可实现。</p><h2 id="【基本原理】">【基本原理】</h2><p>关于哨兵的原理，关键是了解以下几个概念。</p><p>（1）定时任务：每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：</p><ul><li>通过向主从节点发送info命令获取最新的主从结构；</li><li>通过发布订阅功能获取其他哨兵节点的信息；</li><li>通过向其他节点发送ping命令进行心跳检测，判断是否下线。</li></ul><p>（2）主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线；与主观下线相对应的是客观下线。</p><p>（3）客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。</p><p><strong>需要特别注意的是，客观下线是主节点才有的概念；如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。</strong></p><p>（4）选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。</p><p>监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程这里不做详细描述，一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。</p><p>（5）故障转移：选举出的领导者哨兵，开始进行故障转移操作，该操作大体可以分为3个步骤：</p><ul><li><p>在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。</p></li><li><p>更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。</p></li><li><p>将已经下线的主节点(即6379)设置为新的主节点的从节点，当6379重新上线后，它会成为新的主节点的从节点。</p><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/1174710-20180909004056625-1501495024.png" class="" title="img"></li></ul><h2 id="【实践建议】">【实践建议】</h2><p>1）哨兵节点的数量应不止一个，一方面增加哨兵节点的冗余，避免哨兵本身成为高可用的瓶颈；另一方面减少对下线的误判。此外，这些不同的哨兵节点应部署在不同的物理机上。</p><p>（2）哨兵节点的数量应该是奇数，便于哨兵通过投票做出“决策”：领导者选举的决策、客观下线的决策等。</p><p>（3）各个哨兵节点的配置应一致，包括硬件、参数等；此外，所有节点都应该使用ntp或类似服务，保证时间准确、一致。</p><p>（4）哨兵的配置提供者和通知客户端功能，需要客户端的支持才能实现，如前文所说的Jedis；如果开发者使用的库未提供相应支持，则可能需要开发者自己实现。</p><p>（5）当哨兵系统中的节点在docker（或其他可能进行端口映射的软件）中部署时，应特别注意端口映射可能会导致哨兵系统无法正常工作，因为哨兵的工作基于与其他节点的通信，而docker的端口映射可能导致哨兵无法连接到其他节点。例如，哨兵之间互相发现，依赖于它们对外宣称的IP和port，如果某个哨兵A部署在做了端口映射的docker中，那么其他哨兵使用A宣称的port无法连接到A。</p><h2 id="【总结】-2">【总结】</h2><p>本文首先介绍了哨兵的作用：监控、故障转移、配置提供者和通知；然后讲述了哨兵系统的部署方法，以及通过客户端访问哨兵系统的方法；再然后简要说明了哨兵实现的基本原理；最后给出了关于哨兵实践的一些建议。</p><p>在主从复制的基础上，哨兵引入了主节点的自动故障转移，进一步提高了Redis的高可用性；但是哨兵的缺陷同样很明显：哨兵无法对从节点进行自动故障转移，在读写分离场景下，从节点故障会导致读服务不可用，需要我们对从节点做额外的监控、切换操作。</p><p>此外，哨兵仍然没有解决写操作无法负载均衡、及存储能力受到单机限制的问题</p><h1>3.集群</h1><h2 id="【作用】">【作用】</h2><p>集群，即Redis Cluster，是Redis 3.0开始引入的分布式存储方案。</p><p>集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。</p><p>集群的作用，可以归纳为两点：</p><p>1、数据分区：数据分区(或称数据分片)是集群最核心的功能。</p><p>集群将数据分散到多个节点，一方面突破了Redis单机内存大小的限制，存储容量大大增加；另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。</p><p>Redis单机内存大小受限问题，在介绍持久化和主从复制时都有提及；例如，如果单机内存太大，bgsave和bgrewriteaof的fork操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出……。</p><p>2、高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。</p><h2 id="【集群方案设计】">【集群方案设计】</h2><p>设计集群方案时，至少要考虑以下因素：</p><p>（1）高可用要求：根据故障转移的原理，至少需要3个主节点才能完成故障转移，且3个主节点不应在同一台物理机上；每个主节点至少需要1个从节点，且主从节点不应在一台物理机上；因此高可用集群至少包含6个节点。</p><p>（2）数据量和访问量：估算应用需要的数据量和总访问量(考虑业务发展，留有冗余)，结合每个主节点的容量和能承受的访问量(可以通过benchmark得到较准确估计)，计算需要的主节点数量。</p><p>（3）节点数量限制：Redis官方给出的节点数量限制为1000，主要是考虑节点间通信带来的消耗。在实际应用中应尽量避免大集群；如果节点数量不足以满足应用对Redis数据量和访问量的要求，可以考虑：(1)业务分割，大集群分为多个小集群；(2)减少不必要的数据；(3)调整数据过期策略等。</p><p>（4）适度冗余：Redis可以在不影响集群服务的情况下增加节点，因此节点数量适当冗余即可，不用太大。</p><h2 id="【基本原理】-2">【基本原理】</h2><p><strong>集群最核心的功能是数据分区，因此首先介绍数据的分区规则；然后介绍集群实现的细节：通信机制和数据结构；最后以cluster meet(节点握手)、cluster addslots(槽分配)为例，说明节点是如何利用上述数据结构和通信机制实现集群命令的。</strong></p><h3 id="1-数据分区方案">1.数据分区方案</h3><p>数据分区有顺序分区、哈希分区等，其中哈希分区由于其天然的随机性，使用广泛；集群的分区方案便是哈希分区的一种。</p><p>哈希分区的基本思路是：对数据的特征值（如key）进行哈希，然后根据哈希值决定数据落在哪个节点。常见的哈希分区包括：</p><ul><li><p>哈希取余分区</p></li><li><p>一致性哈希分区</p></li><li><p>带虚拟节点的一致性哈希分区等。</p></li></ul><p>衡量数据分区方法好坏的标准有很多，其中比较重要的两个因素是(1)数据分布是否均匀(2)增加或删减节点对数据分布的影响。由于哈希的随机性，哈希分区基本可以保证数据分布均匀；因此在比较哈希分区方案时，重点要看增减节点对数据分布的影响。</p><p>（1）哈希取余分区</p><p>哈希取余分区思路非常简单：计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。</p><p>（2）一致性哈希分区</p><p>一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，如下图所示，范围为0-2^32-1；对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。</p><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/1174710-20181025213424713-1246878063.png" class="" title="img"><p>与哈希取余分区相比，一致性哈希分区将增减节点的影响限制在相邻节点。以上图为例，如果在node1和node2之间增加node5，则只有node2中的一部分数据会迁移到node5；如果去掉node2，则原node2中的数据只会迁移到node4中，只有node4会受影响。</p><p>一致性哈希分区的主要问题在于，当节点数量较少时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。还是以上图为例，如果去掉node2，node4中的数据由总数据的1/4左右变为1/2左右，与其他节点相比负载过高。</p><p>（3）带虚拟节点的一致性哈希分区</p><p>该方案在一致性哈希分区的基础上，引入了虚拟节点的概念。**Redis<strong><strong>集群使用的便是该方案，其中的虚拟节点称为槽（slot</strong></strong>）。**槽是介于数据和实际节点之间的虚拟概念；每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。引入槽以后，数据的映射关系由数据hash-&gt;实际节点，变成了数据hash-&gt;槽-&gt;实际节点。</p><p>**在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小。**仍以上图为例，系统中有4个实际节点，假设为其分配16个槽(0-15)； 槽0-3位于node1，4-7位于node2，以此类推。如果此时删除node2，只需要将槽4-7重新分配即可，例如槽4-5分配给node1，槽6分配给node3，槽7分配给node4；可以看出删除node2后，数据在其他节点的分布仍然较为均衡。</p><p>槽的数量一般远小于2^32，远大于实际节点的数量；在Redis集群中，槽的数量为16384。</p><p>下面这张图很好的总结了Redis集群将数据映射到实际节点的过程：</p><img src="/dajiangdahe/2021/10/22/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/1174710-20190802191100758-1110624103.png" class="" title="img"><p>（1）Redis对数据的特征值（一般是key）计算哈希值，使用的算法是CRC16。</p><p>（2）根据哈希值，计算数据属于哪个槽。</p><p>（3）根据槽与节点的映射关系，计算数据属于哪个节点。</p><h3 id="3-节点通信机制">3.节点通信机制</h3><h4 id="两个端口">两个端口</h4><p>在哨兵系统中，节点分为数据节点和哨兵节点：前者存储数据，后者实现额外的控制功能。在集群中，没有数据节点与非数据节点之分：所有的节点都存储数据，也都参与集群状态的维护。为此，集群中的每个节点，都提供了两个TCP端口：</p><ul><li>普通端口：即我们在前面指定的端口(7000等)。普通端口主要用于为客户端提供服务（与单机节点类似）；但在节点间数据迁移时也会使用。</li><li>集群端口：端口号是普通端口+10000（10000是固定值，无法改变），如7000节点的集群端口为17000。集群端口只用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</li></ul><h4 id="Gossip协议">Gossip协议</h4><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip协议等。重点是广播和Gossip的对比。</p><p>广播是指向集群内所有节点发送消息；优点是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，缺点是每条消息都要发送给所有节点，CPU、带宽等消耗较大。</p><p>Gossip协议的特点是：在节点数量有限的网络中，每个节点都“随机”的与部分节点通信（并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip协议的优点有负载(比广播)低、去中心化、容错性高(因为通信有冗余)等；缺点主要是集群的收敛速度慢。</p><h4 id="消息类型">消息类型</h4><p>集群中的节点采用固定频率（每秒10次）的定时任务进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p><p>节点间发送的消息主要分为5种：meet消息、ping消息、pong消息、fail消息、publish消息。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的。</p><ul><li>MEET消息：在节点握手阶段，当节点收到客户端的CLUSTER MEET命令时，会向新加入的节点发送MEET消息，请求新节点加入到当前集群；新节点收到MEET消息后会回复一个PONG消息。</li><li>PING消息：集群里每个节点每秒钟会选择部分节点发送PING消息，接收者收到消息后会回复一个PONG消息。PING消息的内容是自身节点和部分其他节点的状态信息；作用是彼此交换信息，以及检测节点是否在线。PING消息使用Gossip协议发送，接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：(1)随机找5个节点，在其中选择最久没有通信的1个节点(2)扫描节点列表，选择最近一次收到PONG消息时间大于cluster_node_timeout/2的所有节点，防止这些节点长时间未更新。</li><li>PONG消息：PONG消息封装了自身状态数据。可以分为两种：第一种是在接到MEET/PING消息后回复的PONG消息；第二种是指节点向集群广播PONG消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播PONG消息。</li><li>FAIL消息：当一个主节点判断另一个主节点进入FAIL状态时，会向集群广播这一FAIL消息；接收节点会将这一FAIL消息保存起来，便于后续的判断。</li><li>PUBLISH消息：节点收到PUBLISH命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该PUBLISH命令。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化</title>
    <link href="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1>1.Redis高可用概述</h1><p>在介绍Redis高可用之前，先说明一下在Redis的语境中高可用的含义。</p><p>我们知道，在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务（99.9%、99.99%、99.999% 等等）。但是在Redis语境中，高可用的含义似乎要宽泛一些，除了保证提供正常服务(如主从分离、快速容灾技术)，还需要考虑数据容量的扩展、数据安全不会丢失等。</p><p>在Redis中，实现高可用的技术主要包括持久化、复制、哨兵和集群，下面分别说明它们的作用，以及解决了什么样的问题。</p><ol><li><strong>持久化</strong>：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。</li><li><strong>复制</strong>：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</li><li><strong>哨兵</strong>：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。</li><li><strong>集群</strong>：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。</li></ol><h1>2.Redis持久化概述</h1><p>持久化的功能：Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。</p><p>Redis持久化分为RDB持久化和AOF持久化**：前者将当前数据保存到硬盘，后者则是将每次执行的==写命令==保存到硬盘（类似于MySQL的binlog）；**由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。</p><h2 id="RDB持久化">RDB持久化</h2><p>RDB持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当Redis重新启动时，可以读取快照文件恢复数据。</p><h3 id="1-触发条件">1.触发条件</h3><p>RDB持久化的触发分为手动触发和自动触发两种。</p><p><strong>save</strong>和<strong>bgsave</strong>的区别</p><img src="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg" class="" title="img"><h4 id="1-手动触发">(1)手动触发</h4><p><strong>save</strong>命令和<strong>bgsave</strong>命令都可以生成RDB文件。</p><p><strong>save</strong>命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。</p><img src="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/1174710-20180605085242889-137050862.png" class="" title="img"><p>而<strong>bgsave</strong>命令会创建一个子进程，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求。</p><img src="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/1174710-20180605085309364-1576452765.png" class="" title="img"><p>此时服务器执行日志如下：</p><img src="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/1174710-20180605085325656-76060516.png" class="" title="img"><p>bgsave命令执行过程中，只有fork子进程时会阻塞服务器，而对于save命令，整个过程都会阻塞服务器，因此save已基本被废弃，线上环境要杜绝save的使用；后文中也将只介绍bgsave命令。此外，在自动触发RDB持久化时，Redis也会选择bgsave而不是save来进行持久化；下面介绍自动触发RDB持久化的条件。</p><h4 id="2-自动触发">(2).自动触发</h4><p><strong>save m n</strong>:自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。</p><img src="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/1174710-20180605085420533-1928501600.png" class="" title="img"><p>除了<strong>save m n</strong> 以外，还有一些其他情况会触发bgsave：</p><ul><li>在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点</li><li>执行shutdown命令时，自动执行rdb持久化，如下图所示：</li></ul><img src="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/1174710-20180605085620830-1223048825.png" class="" title="img"><h3 id="2-执行流程">2.执行流程</h3><img src="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/1174710-20180605085813461-389677620.png" class="" title="img"><p>图片中的5个步骤所进行的操作如下：</p><ol><li><p>Redis父进程首先判断：当前是否在执行save，或bgsave/bgrewriteaof（后面会详细介绍该命令）的子进程，如果在执行则bgsave命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。</p></li><li><p>父进程执行fork操作创建子进程，这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令</p></li><li><p>父进程fork后，bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响应其他命令</p></li><li><p>子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换</p></li><li><p>子进程发送信号给父进程表示完成，父进程更新统计信息</p></li></ol><h3 id="3-RDB优势与劣势">3.RDB优势与劣势</h3><p>①、优势</p><p>（1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</p><p>（2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p><p>（3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p><p>②、劣势</p><p>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p><h2 id="AOF机制">AOF机制</h2><p>全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。</p><h3 id="1-持久化原理">1.持久化原理</h3><img src="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/32fa828ba61ea8d3c2502e396b1b3848251f58b0.jpeg" class="" title="img"><p>每当有一个<strong>写命令</strong>过来时，就直接保存到我们的AOF中</p><h3 id="2-文件重写原理">2.文件重写原理</h3><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。</p><img src="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg" class="" title="img"><p>重写AOF文件的操作，并没有读取旧的AOF文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的AOF文件，这点和快照有点类似。</p><h3 id="3-触发机制">3.触发机制</h3><p>（1）每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p><p>（2）每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</p><p>（3）不同no：从不同步</p><img src="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/b17eca8065380cd7df69859ba056a5325982816c.jpeg" class="" title="img"><h3 id="4-AOF优缺点">4.AOF优缺点</h3><p>①、优势</p><p>（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</p><p>（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</p><p>（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p><p>（4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p><p>②、劣势</p><p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p><p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p><p>（3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</p><h2 id="RDB和AOF到底该如何选择">RDB和AOF到底该如何选择</h2><img src="/dajiangdahe/2021/10/22/Redis%E6%8C%81%E4%B9%85%E5%8C%96/8326cffc1e178a82c532308ef2117b8ba977e8ae.jpeg" class="" title="img">]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis内存策略</title>
    <link href="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <url>/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1>Redis内存淘汰策略</h1><p>当 redis 的内存空间（maxmemory 参数配置）已经用满时，redis 将根据配置的驱逐策略（maxmemory-policy 参数配置），进行相应的动作。在redis4.0之后，增加了两种基于LFU算法实现的内存淘汰策略</p><ul><li><strong>noeviction</strong>：默认策略，不淘汰任何 key，直接返回错误</li><li><strong>allkeys</strong>-<strong>lru</strong>：在所有的 key 中，使用 LRU 算法淘汰部分 key</li><li><strong>allkeys</strong>-<strong>lfu</strong>：在所有的 key 中，使用 LFU 算法淘汰部分 key，该算法于 Redis 4.0 新增</li><li><strong>allkeys</strong>-<strong>random</strong>：在所有的 key 中，随机淘汰部分 key</li><li><strong>volatile</strong>-<strong>lru</strong>：在设置了过期时间的 key 中，使用 LRU 算法淘汰部分 key</li><li><strong>volatile</strong>-<strong>lfu</strong>：在设置了过期时间的 key 中，使用 LFU 算法淘汰部分 key，该算法于 Redis 4.0 新增</li><li><strong>volatile</strong>-<strong>random</strong>：在设置了过期时间的 key 中，随机淘汰部分 key</li><li><strong>volatile</strong>-<strong>ttl</strong>：在设置了过期时间的 key 中，挑选 TTL（time to live，剩余时间）短的 key 淘汰</li></ul><h3 id="LRU算法">LRU算法</h3><p>在操作系统中<strong>LRU</strong>算法淘汰的<strong>不是内存中的对象</strong>，而是页,当内存中数据不足时，通过LRU算法，选择<strong>一页</strong>(一般是4KB)将其交换到虚拟内存区(<strong>Swap</strong>区)。</p><p>默认情况下，Redis随机挑选5个键，并且从中选取一个最近最久未使用的key进行淘汰，在配置文件中可以通过maxmemory-samples的值来设置redis需要检查key的个数,但是栓查的越多，耗费的时间也就越久,但是结构越精确</p><p>详解：<a href="https://blog.csdn.net/kuizhu7142/article/details/81115750">https://blog.csdn.net/kuizhu7142/article/details/81115750</a></p><p>【<strong>命中率</strong>】</p><p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p><p>【<strong>复杂度</strong>】</p><p>实现简单。</p><p>【<strong>代价</strong>】</p><p>命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/aHR0cDovL2ltYWdlcy5jbml0YmxvZy5jb20vYmxvZzIwMTUvNDcxNTMyLzIwMTUwMy8yNTE5NTQzNDk3NDIyMjAucG5n" class="" title="在这里插入图片描述"><ul><li>最开始时，内存空间是空的，因此依次进入A、B、C是没有问题的。</li><li>当加入D时，就出现了问题，内存空间不够了，因此根据LRU算法，内存空间中A待的时间最为久远，选择A,将其淘汰。</li><li>当再次引用B时，内存空间中的B又处于活跃状态，而C则变成了内存空间中，近段时间最久未使用的。</li><li>当再次向内存空间加入E时，这时内存空间又不足了，选择在内存空间中待的最久的C将其淘汰出内存，这时的内存空间存放的对象就是E-&gt;B-&gt;D。</li></ul><h4 id="实现原理">实现原理</h4><p>传统意义的LRU算法是为每一个Cache对象设置一个计数器，每次Cache命中则给计数器+1，而Cache用完，需要淘汰旧内容，放置新内容时，就查看所有的计数器，并将最少使用的内容替换掉。</p><p>它的弊端很明显，如果Cache的数量少，问题不会很大， 但是如果Cache的空间过大，达到10W或者100W以上，一旦需要淘汰，则需要遍历所有计算器，其性能与资源消耗是巨大的，效率也就非常的慢了。</p><p>它的原理： 将Cache的所有位置都用双连表连接起来，当一个位置被命中之后，就将通过调整链表的指向，将该位置调整到链表头的位置，新加入的Cache直接加到链表头中。</p><p>这样，在多次进行Cache操作后，最近被命中的，就会被向链表头方向移动，而没有命中的，而想链表后面移动，链表尾则表示最近最少使用的Cache。</p><p>当需要替换内容时候，链表的最后位置就是最少被命中的位置，我们只需要淘汰链表最后的部分即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Integer</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(capacity, <span class="hljs-number">0.75F</span>, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getOrDefault(key, -<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.put(key, value);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size() &gt; capacity; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLinkedNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">int</span> value;<br>        DLinkedNode prev;<br>        DLinkedNode next;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DLinkedNode</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DLinkedNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _value)</span> </span>&#123;key = _key; value = _value;&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;Integer, DLinkedNode&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">private</span> DLinkedNode head, tail;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>        <span class="hljs-comment">// 使用伪头部和伪尾部节点</span><br>        head = <span class="hljs-keyword">new</span> DLinkedNode();<br>        tail = <span class="hljs-keyword">new</span> DLinkedNode();<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        DLinkedNode node = cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span><br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        DLinkedNode node = cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 如果 key 不存在，创建一个新的节点</span><br>            DLinkedNode newNode = <span class="hljs-keyword">new</span> DLinkedNode(key, value);<br>            <span class="hljs-comment">// 添加进哈希表</span><br>            cache.put(key, newNode);<br>            <span class="hljs-comment">// 添加至双向链表的头部</span><br>            addToHead(newNode);<br>            ++size;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-comment">// 如果超出容量，删除双向链表的尾部节点</span><br>                DLinkedNode tail = removeTail();<br>                <span class="hljs-comment">// 删除哈希表中对应的项</span><br>                cache.remove(tail.key);<br>                --size;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br>            node.value = value;<br>            moveToHead(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;<br>        removeNode(node);<br>        addToHead(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> DLinkedNode <span class="hljs-title">removeTail</span><span class="hljs-params">()</span> </span>&#123;<br>        DLinkedNode res = tail.prev;<br>        removeNode(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LFU算法">LFU算法</h2><p>LFU（Least Frequently Used）算法，即最少访问算法，根据访问缓存的历史频率来淘汰数据，核心思想是“如果数据在过去一段时间被访问的次数很少，那么将来被访问的概率也会很低”。如果两个元素的访问频率相同，则淘汰最久没被访问的元素。也就是说LFU淘汰的时候会选择两个维度，先比较频率，选择访问频率最小的元素；如果频率相同，则按时间维度淘汰掉最久远的那个元素。</p><p>一般会维护两个数据结构：</p><ul><li><p>哈希：用来提供对外部的访问，查询效率更高；</p></li><li><p>双向链表或队列：维护了对元素访问次数的排序</p><p>缓存操作导致的链表变化：</p></li><li><p>添加新元素：新元素访问次数为1，放到队尾；</p></li><li><p>缓存淘汰：从队尾开始淘汰，因为队尾元素的访问次数最少；</p></li><li><p>访问缓存：访问缓存会增加元素的访问次数，所以元素在队列或双向链表中的位置会重新排序</p></li></ul><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/93e8e91e143ea01757667be4b54e4a10.png" class="" title="img"><p>这里的key就是输入的key，没什么特别的。<strong>关键是value</strong>，它的value不是一个简单的value，而是一个节点对象。节点对象<strong>Node</strong>包含了<strong>key，value，以及频率</strong>，这个Node又会出现在第二个哈希表的value中(等会我们再说)。至于为什么Node中又重复包含了key，因为某些情况下我们不是通过k-v哈希表拿到Node的，而是通过其他方式获得了Node，之后需要用Node中的key反向去k-v哈希表中做一些操作，所以Node中包含了一些冗余信息。</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/23d1c0e3501b4b82b5eca0b9a631dc18.png" class="" title="img"><p>这张<strong>哈希表中的key是频率</strong>，也就是元素被访问的频率(被访问了1次，被访问了两次等等)，<strong>它的value是一个双向链表刚才说的Node对象，现在又出现了，这里的Node其实是双向链表中的一个节点</strong>。第一张图中我们说了Node中包含了一个冗余的key，其实它还包含了一个冗余的频率值，因为某些情况下，我们需要通过Node中的频率值，反向去频率哈希表中做查找，所以也需要一个冗余的频率值。</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/c5bf76ee14075961a202f8dbf6dcb6b2.png" class="" title="img"><ul><li>优点 ：一般情况下，LFU效率要优于LRU，能够避免周期性或者偶发性的操作导致缓存命中率下降的问题。</li><li>缺点：<strong>复杂度较高</strong>：需要额外维护一个队列或双向链表，复杂度较高。<ul><li><strong>对新缓存不友好</strong>：新加入的缓存容易被清理掉，即使可能会被经常访问</li><li><strong>缓存污染</strong>：一旦缓存的访问模式发生变化，访问记录的历史存量，会导致缓存污染；</li><li><strong>内存开销</strong>：需要对每一项缓存数据维护一个访问次数，内存成本较大；</li><li><strong>处理器开销</strong>：需要对访问次数排序，会增加一定的处理器开销</li></ul></li></ul><h3 id="算法实现">算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LFUCache</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minfreq, capacity;<br>    Map&lt;Integer, Node&gt; key_table;<br>    Map&lt;Integer, LinkedList&lt;Node&gt;&gt; freq_table;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LFUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.minfreq = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>        key_table = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Node&gt;();;<br>        freq_table = <span class="hljs-keyword">new</span> HashMap&lt;Integer, LinkedList&lt;Node&gt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!key_table.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        Node node = key_table.get(key);<br>        <span class="hljs-keyword">int</span> val = node.val, freq = node.freq;<br>        freq_table.get(freq).remove(node);<br>        <span class="hljs-comment">// 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq</span><br>        <span class="hljs-keyword">if</span> (freq_table.get(freq).size() == <span class="hljs-number">0</span>) &#123;<br>            freq_table.remove(freq);<br>            <span class="hljs-keyword">if</span> (minfreq == freq) &#123;<br>                minfreq += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 插入到 freq + 1 中</span><br>        LinkedList&lt;Node&gt; list = freq_table.getOrDefault(freq + <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;());<br>        list.offerFirst(<span class="hljs-keyword">new</span> Node(key, val, freq + <span class="hljs-number">1</span>));<br>        freq_table.put(freq + <span class="hljs-number">1</span>, list);<br>        key_table.put(key, freq_table.get(freq + <span class="hljs-number">1</span>).peekFirst());<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!key_table.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 缓存已满，需要进行删除操作</span><br>            <span class="hljs-keyword">if</span> (key_table.size() == capacity) &#123;<br>                <span class="hljs-comment">// 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点</span><br>                Node node = freq_table.get(minfreq).peekLast();<br>                key_table.remove(node.key);<br>                freq_table.get(minfreq).pollLast();<br>                <span class="hljs-keyword">if</span> (freq_table.get(minfreq).size() == <span class="hljs-number">0</span>) &#123;<br>                    freq_table.remove(minfreq);<br>                &#125;<br>            &#125;<br>            LinkedList&lt;Node&gt; list = freq_table.getOrDefault(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;());<br>            list.offerFirst(<span class="hljs-keyword">new</span> Node(key, value, <span class="hljs-number">1</span>));<br>            freq_table.put(<span class="hljs-number">1</span>, list);<br>            key_table.put(key, freq_table.get(<span class="hljs-number">1</span>).peekFirst());<br>            minfreq = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 与 get 操作基本一致，除了需要更新缓存的值</span><br>            Node node = key_table.get(key);<br>            <span class="hljs-keyword">int</span> freq = node.freq;<br>            freq_table.get(freq).remove(node);<br>            <span class="hljs-keyword">if</span> (freq_table.get(freq).size() == <span class="hljs-number">0</span>) &#123;<br>                freq_table.remove(freq);<br>                <span class="hljs-keyword">if</span> (minfreq == freq) &#123;<br>                    minfreq += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            LinkedList&lt;Node&gt; list = freq_table.getOrDefault(freq + <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;());<br>            list.offerFirst(<span class="hljs-keyword">new</span> Node(key, value, freq + <span class="hljs-number">1</span>));<br>            freq_table.put(freq + <span class="hljs-number">1</span>, list);<br>            key_table.put(key, freq_table.get(freq + <span class="hljs-number">1</span>).peekFirst());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> key, val, freq;<br><br>    Node(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> freq) &#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.val = val;<br>        <span class="hljs-keyword">this</span>.freq = freq;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>Redis过期键删除策略</h1><p><strong>Redis中带有过期时间的key是保存在一个字典中（这个字典叫做==过期字典==），以后会定时遍历这个字典，删除过期的key。</strong></p><p><strong>检查过期时间：ttl key</strong></p><ol><li><p>查看过期时间 ttl key( 返回值   -1:当前key没有过期时间   &gt;0:当前key的剩余存活时间  -2:当前key不存在)</p></li><li><p>删除过期时间 persist key   把带有过期时间的key变为永久不过期（返回值   1代表删除过期时间成功     0代表当前key没过期时间 or key不存在）</p></li></ol><h2 id="1-定时删除">1.定时删除</h2><p>在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</p><ul><li><strong>优点</strong>：对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽 可能快地被删除，并释放过期键所占用的内存</li><li><strong>缺点</strong>：它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O(N)——并不能高效地处理大量时间 事件</li></ul><h2 id="2-惰性删除">2.惰性删除</h2><p><strong>每次从键空间获取键时，都检查是否过期，过期则删除，未过期，则返回该键</strong></p><p>只有取出键时才对其进行过期检查，不会删除其他键，不会花费CPU太多时间。若一个键早已过期，但一直未被取到，它便会一直占用内存。若有大量的未被访问的键，而服务器又不会主动释放，就会造成大量的内存浪费。</p><ul><li><strong>优点</strong>：对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，<br>这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间</li><li><strong>缺点</strong>：它对内存是最不友好的：如果一个键已经过期，而这个键又仍 然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。<br>例如：在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不 会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息</li></ul><h3 id="实现原理（expireIfNeeded函数）">实现原理（expireIfNeeded函数）</h3><p><strong>expireIfNeeded</strong>函数就像一个<strong>过滤器</strong>，它可以==在命令真正执行之前，过滤掉过期的输入键，从而避免命令接触到过期键== 。惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用<strong>expireIfNeeded</strong>函数对输入键进行检查：</p><ul><li><p>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/20201204131000785.png" class="" title="在这里插入图片描述"></li><li><p>如果输入键未过期，那么expireIfNeeded函数不做动作。因为每个被访问的键都可能因为过期而被expireIfNeeded函数删除，所以每个命令的实现函数<strong>都必须能同时处理键存在以及键不存在这两种情况</strong>：</p></li><li><p>当键存在时，命令按照键存在的情况执行</p></li><li><p>当键不存在或者键因为过期而被expireIfNeeded函数删除时，命令按照键不存在的情况执行</p></li></ul><p><strong>举个例子，下图展示了GET命令的执行过程，在这个执行过程中，命令需要判断键是否存在以及键是否过期，然后根据判断来执行合适的动作</strong></p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/20201204131056907.png" class="" title="在这里插入图片描述"><h2 id="3-定期删除">3.定期删除</h2><p><strong>每隔一段时间删除里面的过期键</strong></p><p>Redis默认会1秒进行10次过期扫描，过期扫描不会遍历字典中所有的key，而是采用一种贪心的策略。</p><ol><li>从字典中随机选出20个key。</li><li>删除这20个key中过期的key。</li><li>如果过期的key比例超过1/4，那就在进行步骤1.</li><li>同时，为了保证扫描不会出现循环过度，导致线程卡死的现象，算法会设置扫描时间的上限，默认为25ms。</li></ol><ul><li><p><strong>优点</strong>：定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长 和频率来减少删除操作对CPU时间的影响。通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</p></li><li><p><strong>缺点</strong>：如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一 样，出现浪费内存的情况。</p></li></ul><h3 id="实现原理（activeExpireCycle函数）">实现原理（activeExpireCycle函数）</h3><p>过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#默认每次检查的数据库数量</span><br>DEFAULT_DB_NUMBERS = <span class="hljs-number">16</span><br> <br><span class="hljs-comment">#默认每个数据库检查的键数量</span><br>DEFAULT_KEY_NUMBERS = <span class="hljs-number">20</span><br> <br><span class="hljs-comment">#全局变量，记录检查进度</span><br>current_db = <span class="hljs-number">0</span><br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">activeExpireCycle</span>():</span><br>    <span class="hljs-comment"># 初始化要检查的数据库数量</span><br>    <span class="hljs-comment"># 如果服务器的数据库数量比 DEFAULT_DB_NUMBERS 要小</span><br>    <span class="hljs-comment"># 那么以服务器的数据库数量为准</span><br>    <span class="hljs-keyword">if</span> server.dbnum &lt; DEFAULT_DB_NUMBERS:<br>        db_numbers = server.dbnum<br>    <span class="hljs-keyword">else</span>:<br>        db_numbers = DEFAULT_DB_NUMBERS<br> <br>    <span class="hljs-comment"># 遍历各个数据库</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(db_numbers):<br>        <span class="hljs-comment"># 如果current_db 的值等于服务器的数据库数量</span><br>        <span class="hljs-comment"># 这表示检查程序已经遍历了服务器的所有数据库一次</span><br>        <span class="hljs-comment"># 将current_db 重置为0 ，开始新的一轮遍历</span><br>        <span class="hljs-keyword">if</span> current_db == server.dbnum:<br>            current_db = <span class="hljs-number">0</span><br>       <br>        <span class="hljs-comment"># 获取当前要处理的数据库</span><br>        redisDb = server.db[current_db]<br> <br>        <span class="hljs-comment"># 将数据库索引增1 ，指向下一个要处理的数据库</span><br>        current_db += <span class="hljs-number">1</span><br> <br>        <span class="hljs-comment"># 检查数据库键</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(DEFAULT_KEY_NUMBERS):<br>            <span class="hljs-comment"># 如果数据库中没有一个键带有过期时间，那么跳过这个数据库</span><br>            <span class="hljs-keyword">if</span> redisDb.expires.size() == <span class="hljs-number">0</span>: <span class="hljs-keyword">break</span><br>                <span class="hljs-comment">#随机获取一个带有过期时间的键</span><br>                key_with_ttl = redisDb.expires.get_random_key()<br>    <br>                <span class="hljs-comment"># 检查键是否过期，如果过期就删除它</span><br>                <span class="hljs-keyword">if</span> is_expired(key_with_ttl):<br>                    delete_key(key_with_ttl)<br>                <span class="hljs-comment"># 已达到时间上限，停止处理</span><br>                <span class="hljs-keyword">if</span> reach_time_limit(): <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">DB_NUMBER = <span class="hljs-number">16</span> <span class="hljs-comment"># 数据库数量，默认16（0-15），可以通过配置无限增加</span><br>KEY_NUMBERS = <span class="hljs-number">20</span> <span class="hljs-comment"># 每次检查key的数量</span><br><br>current_db = <span class="hljs-number">0</span> <span class="hljs-comment"># 记录当前检查到哪个库</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">activeExpireCycle</span>():</span><br>  <br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(DB_NUMBERS):<br>  <br>    <span class="hljs-keyword">if</span> current_db == DB_BUMBERS:<br>      current_db = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 获取当前数据库</span><br>    redisDB = server.db[current_db]<br>    first_start = <span class="hljs-literal">True</span><br>    del_key_num = <span class="hljs-number">0</span><br>    current_db += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">while</span>(first_start <span class="hljs-keyword">or</span> del_key_num &gt; KEY_NUMBERS/<span class="hljs-number">4</span>):<br>      first_start = <span class="hljs-literal">False</span><br>      <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(KEY_NUMBERS):<br>        <br>        _key = redisDB.randomExpireKey()<br>        <span class="hljs-keyword">if</span> is_expire(_key):<br>          <span class="hljs-comment"># 过期 则直接删除</span><br>          delete_key(_key)<br>          del_key_num += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">if</span> time_is_limit():<br>          <span class="hljs-comment"># 若执行时间太长，则停止，默认25毫秒</span><br>          <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis内存模型</title>
    <link href="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1>1.Redis内存划分</h1><p>Redis作为内存数据库，在内存中存储的内容主要是数据（键值对key-value）其他部分也会站一定的内存。</p><h2 id="数据">数据</h2><p>Redis数据类型：</p><ul><li>string：字符串，可以用作分布式锁</li><li>hash：哈希，可以用作早期的购物车</li><li>list：列表，可以用作微信文章列表</li><li>set：集合，可以用在做交集，差集</li><li>zset：有序集合，可以用做排行榜。</li><li>HyperLogLog：Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</li><li>Geo：Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。</li><li>Stream：Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。</li></ul><p>作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等</p><h2 id="进程本身运行需要的内存">进程本身运行需要的内存</h2><p>Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。</p><p>补充说明：除了主进程外，Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。</p><h2 id="缓冲内存">缓冲内存</h2><p>缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。</p><h2 id="内存碎片">内存碎片</h2><p>内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。</p><p>如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片：因为重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内存单元，减小内存碎片。</p><h1>2.Redis数据存储的细节</h1><h2 id="Redis存储细节">Redis存储细节</h2><p><a href="https://www.cnblogs.com/kismetv/p/8654978.html">https://www.cnblogs.com/kismetv/p/8654978.html</a></p><p>关于Redis数据存储的细节，涉及到内存分配器（如jemalloc）、简单动态字符串（SDS）、5种对象类型及内部编码、redisObject。在讲述具体内容之前，先说明一下这几个概念之间的关系。</p><p>下图是执行set hello world时，所涉及到的数据模型。</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1174710-20180327001055927-1896197804.png" class="" title="img"><p>（1）dictEntry：Redis是Key-Value数据库，因此对每个键值对都会有一个dictEntry，里面存储了指向Key和Value的指针；next指向下一个dictEntry，与本Key-Value无关。</p><p>（2）Key：图中右上角可见，Key（”hello”）并不是直接以字符串存储，而是存储在SDS结构中。</p><p>（3）redisObject：Value(“world”)既不是直接以字符串存储，也不是像Key一样直接存储在SDS中，而是存储在redisObject中。实际上，不论Value是5种类型的哪一种，都是通过redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储。</p><p>实际上，redisObject除了type和ptr字段以外，还有其他字段图中没有给出，如用于指定对象内部编码的字段；后面会详细介绍。</p><p>（4）jemalloc：无论是DictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。以DictEntry对象为例，有3个指针组成，在64位机器下占24个字节，jemalloc会为它分配32字节大小的内存单元。</p><h2 id="SDS与C字符串的比较">SDS与C字符串的比较</h2><p>SDS在C字符串的基础上加入了free和len字段，带来了很多好处：</p><ul><li>获取字符串长度：SDS是O(1)，C字符串是O(n)</li><li>缓冲区溢出：使用C字符串的API时，如果字符串长度增加（如strcat操作）而忘记重新分配内存，很容易造成缓冲区的溢出；而SDS由于记录了长度，相应的API在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出。</li><li>修改字符串时内存的重分配：对于C字符串，如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。而对于SDS，由于可以记录len和free，因此解除了字符串长度和空间数组长度之间的关联，可以在此基础上进行优化：空间预分配策略（即分配内存时比实际需要的多）使得字符串长度增大时重新分配内存的概率大大减小；惰性空间释放策略使得字符串长度减小时重新分配内存的概率大大减小。</li><li>存取二进制数据：SDS可以，C字符串不可以。因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而SDS以字符串长度len来作为字符串结束标识，因此没有这个问题。</li></ul><p>此外，由于SDS中的buf仍然使用了C字符串（即以’\0’结尾），因此SDS可以使用C字符串库中的部分函数；但是需要注意的是，只有当SDS用来存储文本数据时才可以这样使用，在存储二进制数据时则不行（’\0’不一定是结尾）。</p><p>Redis在存储对象时，一律使用SDS代替C字符串。例如set hello world命令，hello和world都是以SDS的形式存储的。而sadd myset member1 member2 member3命令，不论是键（”myset”），还是集合中的元素（”member1”、 ”member2”和”member3”），都是以SDS的形式存储。除了存储对象，SDS还用于存储各种缓冲区。</p><p>只有在字符串不会改变的情况下，如打印日志时，才会使用C字符串。</p><h1>3.Redis的对象类型与内部编码</h1><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1174710-20180327001358239-1304238510.png" class="" title="img"><h2 id="字符串">字符串</h2><h3 id="（1）概况">（1）概况</h3><p>字符串是最基础的类型，因为所有的键都是字符串类型，且字符串之外的其他几种复杂类型的元素也是字符串。</p><p>字符串长度不能超过512MB。</p><h3 id="（2）内部编码">（2）内部编码</h3><p>字符串类型的内部编码有3种，它们的应用场景如下：</p><ul><li><p>int：8个字节的长整型。字符串值是整型时，这个值使用long整型表示。</p></li><li><p>embstr：&lt;=39字节的字符串。embstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。</p></li><li><p>raw：大于39个字节的字符串</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1174710-20180327001417703-15851809.png" class="" title="img"></li></ul><p>embstr和raw进行区分的长度，是39；是因为redisObject的长度是16字节，sds的长度是9+字符串长度；因此当字符串长度是39时，embstr的长度正好是16+9+39=64，jemalloc正好可以分配64字节的内存单元。</p><h3 id="（3）编码转换">（3）编码转换</h3><p>当int数据不再是整数，或大小超过了long的范围时，自动转化为raw。</p><p>而对于embstr，由于其实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了39个字节。示例如下图所示：</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1174710-20180327001426651-1225081171.png" class="" title="img"><h2 id="列表">列表</h2><h3 id="（1）概况-2">（1）概况</h3><p>列表（list）用来存储多个有序的字符串，每个字符串称为元素；一个列表可以存储2^32-1个元素。Redis中的列表支持两端插入和弹出，并可以获得指定位置（或范围）的元素，可以充当数组、队列、栈等。</p><h3 id="（2）内部编码-2">（2）内部编码</h3><p>列表的内部编码可以是压缩列表（ziplist）或双端链表（linkedlist）。</p><p>双端链表：由一个list结构和多个listNode结构组成；典型结构如下图所示：</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1174710-20180327001435577-242733744.png" class="" title="img"><p>通过图中可以看出，双端链表同时保存了表头指针和表尾指针，并且每个节点都有指向前和指向后的指针；链表中保存了列表的长度；dup、free和match为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。而链表中每个节点指向的是type为字符串的redisObject。</p><p>压缩列表：压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的<strong>连续内存块</strong>(而不是像双端链表一样每个节点是指针)组成的顺序型数据结构；具体结构相对比较复杂，略。与双端链表相比，压缩列表可以节省内存空间，但是进行修改或增删操作时，复杂度较高；因此当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算。</p><p>压缩列表不仅用于实现列表，也用于实现哈希、有序列表；使用非常广泛。</p><h3 id="（3）编码转换-2">（3）编码转换</h3><p>只有同时满足下面两个条件时，才会使用压缩列表：列表中元素数量小于512个；列表中所有字符串对象都不足64字节。如果有一个条件不满足，则使用双端列表；且编码只可能由压缩列表转化为双端链表，反方向则不可能。</p><p>下图展示了列表编码转换的特点：</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1174710-20180327001457636-673470263.png" class="" title="img"><p>其中，单个字符串不能超过64字节，是为了便于统一分配每个节点的长度；这里的64字节是指字符串的长度，不包括SDS结构，因为<strong>压缩列表使用连续、定长内存块存储字符串</strong>，不需要SDS结构指明长度。后面提到压缩列表，也会强调长度不超过64字节，原理与这里类似。</p><h2 id="哈希">哈希</h2><h3 id="（1）概况-3">（1）概况</h3><p>哈希（作为一种数据结构），不仅是redis对外提供的5种对象类型的一种（与字符串、列表、集合、有序结合并列），也是Redis作为Key-Value数据库所使用的数据结构。为了说明的方便，在本文后面当使用“内层的哈希”时，代表的是redis对外提供的5种对象类型的一种；使用“外层的哈希”代指Redis作为Key-Value数据库所使用的数据结构。</p><h3 id="（2）内部编码-3">（2）内部编码</h3><p>内层的哈希使用的内部编码可以是压缩列表（ziplist）和哈希表（hashtable）两种；Redis的外层的哈希则只使用了hashtable。</p><p>压缩列表前面已介绍。与哈希表相比，压缩列表用于元素个数少、元素长度小的场景；其优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(1)变为了O(n)，但由于哈希中元素数量较少，因此操作的时间并没有明显劣势。</p><p>正常情况下（即hashtable没有进行rehash时）各部分关系如下图所示：</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1174710-20180327001627028-325473621.png" class="" title="img"><p><strong>dictEntry</strong></p><p>dictEntry结构用于保存键值对，结构定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct dictEntry&#123;<br>    <span class="hljs-keyword">void</span> *key;<br>    union&#123;<br>        <span class="hljs-keyword">void</span> *val;<br>        uint64_tu64;<br>        int64_ts64;<br>    &#125;v;<br>    struct dictEntry *next;<br>&#125;dictEntry;<br></code></pre></td></tr></table></figure><p>其中，各个属性的功能如下：</p><ul><li>key：键值对中的键；</li><li>val：键值对中的值，使用union(即共用体)实现，存储的内容既可能是一个指向值的指针，也可能是64位整型，或无符号64位整型；</li><li>next：指向下一个dictEntry，用于解决哈希冲突问题</li></ul><p>在64位系统中，一个dictEntry对象占24字节（key/val/next各占8字节）。</p><p><strong>bucket</strong></p><p>bucket是一个数组，数组的每个元素都是指向dictEntry结构的指针。redis中bucket数组的大小计算规则如下：大于dictEntry的、最小的2^n；例如，如果有1000个dictEntry，那么bucket大小为1024；如果有1500个dictEntry，则bucket大小为2048。</p><p><strong>dictht</strong></p><p>dictht结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct dictht&#123;<br>    dictEntry **table;<br>    unsigned <span class="hljs-keyword">long</span> size;<br>    unsigned <span class="hljs-keyword">long</span> sizemask;<br>    unsigned <span class="hljs-keyword">long</span> used;<br>&#125;dictht;<br></code></pre></td></tr></table></figure><p>其中，各个属性的功能说明如下：</p><ul><li>table属性是一个指针，指向bucket；</li><li>size属性记录了哈希表的大小，即bucket的大小；</li><li>used记录了已使用的dictEntry的数量；</li><li>sizemask属性的值总是为size-1，这个属性和哈希值一起决定一个键在table中存储的位置。</li></ul><p><strong>dict</strong></p><p>一般来说，通过使用dictht和dictEntry结构，便可以实现普通哈希表的功能；但是Redis的实现中，在dictht结构的上层，还有一个dict结构。下面说明dict结构的定义及作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct dict&#123;<br>    dictType *type;<br>    <span class="hljs-keyword">void</span> *privdata;<br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">int</span> trehashidx;<br>&#125; dict;<br></code></pre></td></tr></table></figure><p>其中，type属性和privdata属性是为了适应不同类型的键值对，用于创建多态字典。</p><p>ht属性和trehashidx属性则用于rehash，即当哈希表需要扩展或收缩时使用。ht是一个包含两个项的数组，每项都指向一个dictht结构，这也是Redis的哈希会有1个dict、2个dictht结构的原因。通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用。dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]，并清空ht[1]。</p><p>因此，Redis中的哈希之所以在dictht和dictEntry结构之外还有一个dict结构，一方面是为了适应不同类型的键值对，另一方面是为了rehash。</p><h3 id="（3）编码转换-3">（3）编码转换</h3><p>如前所述，Redis中内层的哈希既可能使用哈希表，也可能使用压缩列表。</p><p>只有同时满足下面两个条件时，才会使用压缩列表：哈希中元素数量小于512个；哈希中所有键值对的键和值字符串长度都小于64字节。如果有一个条件不满足，则使用哈希表；且编码只可能由压缩列表转化为哈希表，反方向则不可能。</p><p>下图展示了Redis内层的哈希编码转换的特点：</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1174710-20180327001855681-1566128865.png" class="" title="img"><h2 id="集合">集合</h2><h3 id="（1）概况-4">（1）概况</h3><p>集合（set）与列表类似，都是用来保存多个字符串，但集合与列表有两点不同：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。</p><p>一个集合中最多可以存储2^32-1个元素；除了支持常规的增删改查，Redis还支持多个集合取交集、并集、差集。</p><h3 id="（2）内部编码-4">（2）内部编码</h3><p>集合的内部编码可以是整数集合（intset）或哈希表（hashtable）。</p><p>哈希表前面已经讲过，这里略过不提；需要注意的是，集合在使用哈希表时，值全部被置为null。</p><p>整数集合的结构定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct intset&#123;<br>    uint32_t encoding;<br>    uint32_t length;<br>    int8_t contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure><h3 id="（3）编码转换-4">（3）编码转换</h3><p>只有同时满足下面两个条件时，集合才会使用整数集合：集合中元素数量小于512个；集合中所有元素都是整数值。如果有一个条件不满足，则使用哈希表；且编码只可能由整数集合转化为哈希表，反方向则不可能。</p><p>下图展示了集合编码转换的特点：</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1174710-20180327001926146-2105183556.png" class="" title="img"><h2 id="有序集合">有序集合</h2><h3 id="（1）概况-5">（1）概况</h3><p>有序集合与集合一样，元素都不能重复；但与集合不同的是，有序集合中的元素是有顺序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。</p><h3 id="（2）内部编码-5">（2）内部编码</h3><p>有序集合的内部编码可以是压缩列表（ziplist）或跳跃表（skiplist）。ziplist在列表和哈希中都有使用，前面已经讲过，这里略过不提。</p><p>跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。除了跳跃表，实现有序数据结构的另一种典型实现是平衡树；大多数情况下，跳跃表的效率可以和平衡树媲美，且跳跃表实现比平衡树简单很多，因此redis中选用跳跃表代替平衡树。跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成：前者用于保存跳跃表信息（如头结点、尾节点、长度等），后者用于表示跳跃表节点。具体结构相对比较复杂，略。</p><h3 id="（3）编码转换-5">（3）编码转换</h3><p>只有同时满足下面两个条件时，才会使用压缩列表：有序集合中元素数量小于128个；有序集合中所有成员长度都不足64字节。如果有一个条件不满足，则使用跳跃表；且编码只可能由压缩列表转化为跳跃表，反方向则不可能。</p><p>下图展示了有序集合编码转换的特点：</p><img src="/dajiangdahe/2021/10/22/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1174710-20180327001936290-955216194.png" class="" title="img">]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql索引</title>
    <link href="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/"/>
    <url>/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1>Mysql索引</h1><h2 id="【概念】">【概念】</h2><p>MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。简单的理解，索引类似于字典里面的目录。</p><h2 id="【索引类型】">【索引类型】</h2><p>==从数据结构角度划分：==</p><ul><li><p><strong>hash索引</strong>：底层就是 hash 表。进行查找时，根据 key 调用 hash 函数获得对应的 hashcode，根据 hashcode 找到对应的数<strong>据行地址</strong>，根据地址拿到对应的数据。</p></li><li><p>B 树索引：B树是一种多路搜索树，n 路搜索树代表每个节点最多有 n 个子节点。每个节点<strong>存储 key</strong> + <strong>指向下一层节点的指针</strong>+ <strong>指向 key 数据记录的地址</strong>。查找时，从根结点向下进行查找，直到找到对应的key。</p></li><li><p><strong>B+树索引</strong>：B+树是b树的变种，主要区别在于：B+树的==非叶子节点==只<strong>存储 key + 指向下一层节点的指针</strong>。另外，<strong>B+树的叶子节点之间通过指针来连接</strong>，构成一个有序链表，因此对整棵树的遍历只需要一次线性遍历叶子结点即可（o（n）时间复杂度遍历全部节点）。</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkhHY0JXdFdpYmxRb1RFWWdZcUlGQVJ3R0UydDhDdTZKeHZibTFNcDMxMGlhWlU1ekhYazZTNzhpYldUcDlodzQ4RE4wQ3U0ZUlIaWFjRVVnLw" class="" title="img"></li></ul><p>==从逻辑结构角度划分：==</p><ul><li><p><strong>聚簇索引</strong>：聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。聚簇索引将索引和数据行放到了一块，找到索引也就找到了数据。因为无需进行回表操作，所以效率很高。<strong>InnoDB 中必然会有，且只会有一个聚簇索引</strong>。通常是主键，如果没有主键，则优先选择非空的唯一索引，如果唯一索引也没有，则会创建一个隐藏的row_id 作为聚簇索引。至于为啥会只有一个聚簇索引，其实很简单，因为我们的数据只会存储一份。</p><ul><li>优点：<ul><li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul></li><li>缺点：<ul><li>插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong></li><li><strong>更新主键的代价很高</strong>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li></ul></li></ul></li><li><p><strong>非聚簇索引</strong>：在<strong>聚簇索引之上创建的索引称之为辅助索引</strong>，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。</p><p>​1、为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</p><p>2、用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p></li><li><p><strong>联合索引</strong>：联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持<strong>a</strong> | <strong>a,b</strong>| <strong>a,b,c</strong> 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p></li><li><p><strong>唯一索引</strong></p></li><li><p><strong>普通索引</strong></p></li><li><p><strong>覆盖索引</strong>：覆盖索引（covering index）指一个<strong>查询语句的执行只用从索引中就能够取得</strong>，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkhHY0JXdFdpYmxRb1RFWWdZcUlGQVJ3eDB5c3FQZ3JlemJteVFCdFRqMmJYWGZpYjR5aWJTZmxBNWhjT0JXZ0NpYXNjVUNvaWJDUDV1WmZuQS8" class="" title="img"></li><li><p>**自适应哈希索引(adaptive hash index）：**InnoDB 会监控对表上索引的查找，如果观察到某些索引被频繁访问，索引成为热数据，建立哈希索引可以带来速度的提升，则建立哈希索引，所以称之为自适应（adaptive）的。自适应哈希索引通过缓冲池的 B+ 树构造而来，因此建立的速度很快。而且不需要将整个表都建哈希索引，InnoDB 会自动根据访问的频率和模式来为某些页建立哈希索引。</p></li></ul><h2 id="【InnoDB引擎实现方式】">【InnoDB引擎实现方式】</h2><p>InnoDB<strong>也使用B+Tree作为索引结构</strong>，但具体实现方式却与MyISAM截然不同.</p><p>1）主键索引：</p><p><strong>MyISAM索引文件和数据文件是分离的</strong>，<strong>索引文件仅保存数据记录的地址</strong>。而在<strong>InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构</strong>，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1464190-20191106145200302-932404581.png" class="" title="img"><p>(图inndb主键索引）是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚簇索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则*<em>MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段（row_id）<em>长度为6个字节，类型为长整形</em></em>。</p><p>2）InnoDB的辅助索引</p><p>InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1464190-20191106145241480-1330791289.png" class="" title="img"><p>InnoDB 表是基于聚簇索引建立的。因此InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列，所以，<strong>如果主键定义的比较大，其他索引也将很大</strong>。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些。InnoDB 不会压缩索引。</p><p>文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白：</p><p>1、为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，<strong>过长的主索引会令辅助索引变得过大。</strong></p><p>2、用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，<strong>非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整</strong>，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><p>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用&quot;where id = 14&quot;这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p><h2 id="【MyISAM索引实现】">【MyISAM索引实现】</h2><p>MyISAM<strong>索引文件和数据文件是分离的</strong>，索引文件仅保存数据记录的地址</p><p>1）主键索引：</p><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的<strong>data域存放的是数据记录的地址</strong>。下图是MyISAM主键索引的原理图：</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1464190-20191106151308457-531875534.png" class="" title="img"><p>这里设表一共有三列，假设我们以Col1为主键，图myisam1是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。</p><p>2）辅助索引（Secondary key）</p><p>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，<strong>只是主索引要求key是唯一的，而辅助索引的key可以重复</strong>。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1464190-20191106151427711-625351515.png" class="" title="img"><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1464190-20191106151527647-152458631.png" class="" title="img"><h2 id="【最左前缀匹配原则】">【最左前缀匹配原则】</h2><p>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子。</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521182659976-48843100.png" class="" title="img"><p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为<strong>MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序</strong>。所以b=2这种查询条件没有办法利用索引。</p><p>由于整个过程是基于explain结果分析的，那接下来在了解下explain中的type字段和key_lef字段。</p><p><strong>1.type</strong>：<strong>联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:（重点看ref,rang,index）</strong></p><p>system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计<br>　　　　const：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const<br>　　　　eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。<br>　　　　注意：ALL全表扫描的表记录最少的表如t1表<br>　　　　<strong>ref</strong>：非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。<br>　　　　<strong>range</strong>：只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、&lt;、&gt;、in等的查询。这种索引列上的范围扫描比全索引扫描要好。<strong>只需要开始于某个点，结束于另一个点</strong>，<strong>不用扫描全部索引。</strong><br>　　　　<strong>index</strong>：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常为ALL块，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取）<br>　　　　ALL：Full Table Scan，遍历全表以找到匹配的行</p><p><strong>2.key_len</strong>：<strong>显示MySQL实际决定使用的索引的长度。如果索引是NULL，则长度为NULL。如果不是NULL，则为使用的索引的长度。所以通过此字段就可推断出使用了那个索引。</strong></p><p>计算规则：</p><p>1.定长字段，int占用4个字节，date占用3个字节，char(n)占用n个字符。</p><p>2.变长字段varchar(n)，则占用n个字符+两个字节。</p><p>3.不同的字符集，一个字符占用的字节数是不同的。Latin1编码的，一个字符占用一个字节，gdk编码的，一个字符占用两个字节，utf-8编码的，一个字符占用三个字节。</p><p>（由于我数据库使用的是Latin1编码的格式，所以在后面的计算中，一个字符按一个字节算）</p><p>4.对于所有的索引字段，如果设置为NULL，则还需要1个字节。</p><h3 id="1-全值匹配查询时"><strong>1.全值匹配查询时</strong></h3><p>​<img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521202947593-2126832810.png" class="" title="img"></p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521203003652-366842075.png" class="" title="img"><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521203020127-1655735915.png" class="" title="img"><p>通过观察上面的结果图可知，where后面的查询条件，不论是使用（id，age，name）（name，id，age）还是（age，name，id）顺序，在查询时都使用到了联合索引，可能有同学会疑惑，为什么底下两个的搜索条件明明没有按照联合索引从左到右进行匹配，却也使用到了联合索引？ 这是因为<strong>MySQL中有查询优化器explain，所以sql语句中字段的顺序不需要和联合索引定义的字段顺序相同，查询优化器会判断纠正这条SQL语句以什么样的顺序执行效率高</strong>，最后才能生成真正的执行计划，所以不论以何种顺序都可使用到联合索引。另外通过观察上<strong>面三个图中的key_len字段，也可说明在搜索时使用的联合索引中的（id_name_age）索引</strong>，因为id为int型，允许null，所以占5个字节，name为char(10)，允许null，又使用的是latin1编码，所以占11个字节，age为int型允许null，所以也占用5个字节，所以该索引长度为21（5+11+5），而上面key_len的值也正好为21，<strong>可证明使用的（id_name_age）索引</strong>。</p><h3 id="2-匹配最左边的列时"><strong>2.匹配最左边的列时</strong></h3><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521202447168-1029938685.png" class="" title="img"><p>该搜索是遵循最左匹配原则的，通过key字段也可知，在搜索过程中使用到了联合索引，且使用的是联合索引中的（id）索引，因为<strong>key_len字段值为5，而id索引的长度正好为5</strong>（因为id为int型，允许null，所以占5个字节）。</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521202737461-1486677111.png" class="" title="img"><p><strong>由于id到name是从左边依次往右边匹配，这两个字段中的值都是有序的，所以也遵循最左匹配原则</strong>，通过key字段可知，在搜索过程中也使用到了联合索引，但使用的是联合索引中的（id_name）索引，因为key_len字段值为16，而(id_name)索引的长度正好为16（因为id为int型，允许null，所以占5个字节，name为char(10)，允许null，又使用的是latin1编码，所以占11个字节）。</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521202810363-1061003410.png" class="" title="img"><p>由于上面三个搜索都是从最左边id依次向右开始匹配的，所以都用到了id_name_age_index联合索引。</p><p><strong>==那如果不是依次匹配呢？==</strong></p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521204203700-302471529.png" class="" title="img"><p>通过key字段可知，在搜索过程中也使用到了联合索引，但使用的是联合索引中的（id）索引，从key_len字段也可知。因为联合索引树是按照id字段创建的，<strong>但age相对于id来说是无序的，只有id只有序的，所以他只能使用联合索引中的id索引。</strong></p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521203757147-65081383.png" class="" title="img"><p>通过观察发现上面key字段发现在搜索中也使用了id_name_age_index索引，可能许多同学就会疑惑它并没有遵守最左匹配原则，按道理会索引失效，为什么也使用到了联合索引？<strong>因为没有从id开始匹配，且name单独来说是无序的，所以它确实不遵循最左匹配原则，然而从type字段可知，它虽然使用了联合索引，但是它是对整个索引树进行了扫描，正好匹配到该索引，与最左匹配原则无关</strong>，一般只要是某联合索引的一部分，但又不遵循最左匹配原则时，都可能会采用index类型的方式扫描，但它的效率远不如最做匹配原则的查询效率高，index类型类型的扫描方式是从索引第一个字段一个一个的查找，直到找到符合的某个索引，<strong>与all不同的是，index是对所有索引树进行扫描，而all是对整个磁盘的数据进行全表扫描。</strong></p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521203731486-172947522.png" class="" title="img"><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521203818877-809915868.png" class="" title="img"><p>这两个结果跟上面的是同样的道理，由于它们都没有从最左边开始匹配，所以没有用到联合索引，使用的<strong>都是index全索引扫描。</strong></p><h3 id="3-匹配列前缀"><strong>3.匹配列前缀</strong></h3><p>如果id是字符型，那么前缀匹配用的是索引，中坠和后缀用的是全表扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> staffs <span class="hljs-keyword">where</span> id <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;A%&#x27;</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>前缀都是排好序的，使用的都是联合索引<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> staffs <span class="hljs-keyword">where</span> id <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%A%&#x27;</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>全表查询<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> staffs <span class="hljs-keyword">where</span> id <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%A&#x27;</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>全表查询<br></code></pre></td></tr></table></figure><h3 id="4-匹配范围值"><strong>4.匹配范围值</strong></h3><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521210125009-1177423028.png" class="" title="img"><p>在匹配的过程中<strong>遇到&lt;&gt;=号，就会停止匹配</strong>，但id本身就是有序的，所以通过possible_keys字段和key_len 字段可知，在该搜索过程中<strong>使用了联合索引的id索引</strong>（因为id为int型，允许null，所以占5个字节），且进行的是rang范围查询。</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200522115901524-226070462.png" class="" title="img"><p>由于不遵循最左匹配原则，且在<strong>id&lt;4的范围中，age是无序的，所以使用的是index全索引扫描</strong>。</p><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521210146172-1428008775.png" class="" title="img"><p>不遵循最左匹配原则，但在数据库中id&lt;2的只有一条（id），所以在<strong>id&lt;2的范围中，age是有序的，所以使用的是rang范围查询。</strong><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521210203002-1943736888.png" class="" title="img"></p><p>不遵循最左匹配原则，而age又是无序的，所以进行的<strong>全索引扫描</strong>。</p><h3 id="5-准确匹配第一列并范围匹配其他某一列"><strong>5.准确匹配第一列并范围匹配其他某一列</strong></h3><img src="/dajiangdahe/2021/10/22/Mysql%E7%B4%A2%E5%BC%95/1804577-20200521210726024-2037980339.png" class="" title="img"><p>由于搜索中有id=1，所以在id范围内age是无序的，所以只<strong>使用了联合索引中的id索引。</strong></p><h2 id="【索引优化问题】">【索引优化问题】</h2><p><strong>1.创建索引</strong></p><p>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加</p><p>索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，<strong>比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</strong></p><p><strong>2.复合索引</strong></p><p>比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;</p><p>如果我们是在area和age上<strong>分别创建</strong>单个索引的话，由于mysql查询每次只能使用<strong>一个索引</strong>，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。<strong>因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</strong></p><p><strong>3.索引不会包含有NULL值的列</strong></p><p>只要列中包含有NULL值都将不会被包含在索引中，<strong>复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的</strong>。所以我们在数据库设计时不要让字段的默认值为NULL。</p><p><strong>4.使用短索引</strong></p><p><strong>对串列进行索引，如果可能应该指定一个前缀长度</strong>。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。<strong>短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</strong></p><p><strong>5.排序的索引问题</strong></p><p>mysql查询只使用一个索引，<strong>因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的</strong>。因此数据库默认排序可以<strong>符合要求的情况下不要使用排序操作</strong>；尽量不要包含<strong>多个列的排序</strong>，如果需要最好给这些列创建<strong>复合索引</strong>。</p><p><strong>6.like语句操作</strong></p><p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。l<strong>ike “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</strong></p><p><strong>7.不要在列上进行运算</strong></p><p>select * from users where YEAR(adddate)</p><p><strong>8.不使用NOT IN</strong></p><p>NOT IN都不会使用索引将进行全表扫描。NOT IN可以<strong>NOT EXISTS代替</strong></p><h3 id="【慢SQL优化】">【慢SQL优化】</h3><h4 id="【如何分析慢SQL语句】">【如何分析慢SQL语句】</h4><ul><li>通过慢日志检查</li><li>通过explain</li></ul><p>首先要搞明白慢的原因是什么：是查询条件没有命中索引？还是 load 了不需要的数据列？还是数据量太大？所以优化也是针对这三个方向来的。</p><h4 id="【SQL语句优化】">【SQL语句优化】</h4><ul><li><p>首先用 explain 分析语句的执行计划，查看使用索引的情况，是不是查询没走索引，如果可以加索引解决，优先采用加索引解决。</p></li><li><p>分析语句，看看是否存在一些导致索引失效的用法，是否 load 了额外的数据，是否加载了许多结果中并不需要的列，对语句进行分析以及重写。慎用部分关键字，如distinct、union关键字等。</p></li><li><p>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行垂直拆分或者水平拆分。</p></li><li><p>范围查询，比如在查询某条语句时，加入limit 1,等限制。</p></li><li><p><strong>保证不查询多余的列与行。</strong></p></li><li><p>如果你同时修改或删除过多数据，会造成cpu利用率过高从而影响别人对数据库的访问。如果你删除或修改过多数据，采用单一循环操作，那么会是效率很低，也就是操作时间过程会很漫长。</p><p>这样你该怎么做呢？</p><p>折中的办法就是，分批操作数据。</p></li><li><p>连接查询的优化</p><ul><li><p>首先你要弄明白你想要的数据是什么样子的，然后再做出决定使用哪一种连接，这很重要。</p><p>各种连接的取值大小为：</p><ul><li>内连接结果集大小取决于左右表满足条件的数量</li><li>左连接取决与左表大小，右相反。</li><li>完全连接和交叉连接取决与左右两个表的数据总数量</li></ul></li></ul></li></ul><h2 id="【hash】vs【红黑树】vs【B树】vs【B-树】">【hash】vs【红黑树】vs【B树】vs【B+树】</h2><p><strong>红黑树</strong>：如果在内存中，红黑树的查找效率比B树更高，但是涉及到磁盘操作，B树就更优了。因为红黑树是二叉树，数据量大时树的层数很高，从树的根结点向下寻找的过程，每读1个节点，都相当于一次IO操作，因此红黑树的I/O操作会比B树多的多。</p><p><strong>hash 索引</strong>：如果只查询单个值的话，hash 索引的效率非常高。但是 hash 索引有几个问题：1）不支持范围查询；2）不支持索引值的排序操作；3）不支持联合索引的最左匹配规则。</p><p><strong>B树索引</strong>：B树索相比于B+树，在进行范围查询时，需要做局部的中序遍历，可能要跨层访问，跨层访问代表着要进行额外的磁盘I/O操作；另外，B树的非叶子节点存放了数据记录的地址，会导致存放的节点更少，树的层数变高。</p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql主从复制</title>
    <link href="/dajiangdahe/2021/10/22/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/dajiangdahe/2021/10/22/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1>1.什么是主从复制</h1><p>将主数据库中的DDL和DML操作通过二进制日志传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p><h1>2.基本原理</h1><p>MySQL支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p><p>MySQL复制是基于主服务器在二进制日志中跟踪所有对数据库的更改。因此，要进行复制，必须在主服务器上启用二进制日志（binlog日志）。每个从服务器从主服务器接收主服务器已经记录到日志的数据。</p><p>当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，并在本机上执行相同的更新。然后封锁并等待主服务器通知新的更新。从服务器执行备份不会干扰主服务器，在备份过程中主服务器可以继续处理更新。</p><h1>3.主从复制的作用</h1><p>1、主数据库出现问题，可以切换到从数据库。</p><p>2、可以进行数据库层面的读写分离。</p><p>3、可以在从数据库上进行日常备份。</p><h1>4.复制过程</h1><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1606768-20190408141304873-785770801.png" class="" title="img"><p><em>Binary log：主数据库的二进制日志。</em></p><p><em>Relay log：从服务器的中继日志。</em></p><p>**第一步：**master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p><p>**第二步：**salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p><p>**第三步：**SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql中的锁</title>
    <link href="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <url>/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1>Mysql中的锁</h1><p><strong>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。</strong></p><h2 id="1-全局锁">1.全局锁</h2><p>全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure><p>当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><p>**全局锁的典型使用场景是，做全库逻辑备份。**也就是把整库每个表都select出来存成文本</p><p>但是让整个库都只读，可能出现以下问题：</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆</li><li>果在从库上备份，那么在备份期间从库不能执行主库同步过来的binlog，会导致主从延迟<br>在可重复读隔离级别下开启一个事务能够拿到一致性视图</li></ul><p>官方自带的逻辑备份工具是<strong>mysqldump</strong>。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。single-transaction只适用于所有的表使用事务引擎的库。</p><p><strong>1.既然要全库只读，为什么不使用set global readonly=true的方式？</strong></p><ul><li>在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此修改global变量的方式影响面更大</li><li>在异常处理机制上有差异。如果执行Flush tables with read lock命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高</li></ul><h2 id="2-表级锁">2.表级锁</h2><p><strong>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL）</strong></p><p>表锁的语法是lock tables … read/write。可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象</p><p>如果在某个线程A中执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">lock tables t1 read,t2 wirte;<br></code></pre></td></tr></table></figure><p>这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许</p><p>另一类表级的锁是MDL。MDL不需要显式使用，在访问一个表的时候会被自动加上。**MDL的作用是，保证读写的正确性。**如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做了变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定不行</p><p>在MySQL5.5版本引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p><ul><li><strong>读锁之间不互斥，因此可以有多个线程同时对一张表增删改查</strong></li><li><strong>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行</strong></li></ul><p>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，需要特别小心，以免对线上服务造成影响。</p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/201906051620443.png" class="" title="在这里插入图片描述"><p>session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。之后sesession C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。</p><p><strong>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放</strong></p><p><strong>1.如果安全地给小表加字段？</strong></p><p>首先要解决长事务，事务不提交，就会一直占着DML锁。在MySQL的information_schema库的innodb_trx表中，可以查到当前执行的事务。如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务</p><p><strong>2.如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而又不得不加个字段，该怎么做？</strong></p><p>在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后再通过重试命令重复这个过程。</p><h2 id="3-行级锁">3.行级锁</h2><p>MySQL的行锁是在引擎层由各个引擎自己实现的。但不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁</p><p>行锁就是针对数据表中行记录的锁。比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。</p><h3 id="1、两阶段锁协议">1、两阶段锁协议</h3><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162055774.png" class="" title="在这里插入图片描述"><p>事务A持有的两个记录的行锁都是在commit的时候才释放的，事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。</p><p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议</strong></p><p><strong>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</strong></p><p>【<strong>示例</strong>】</p><p>假设要实现一个电影票在线交易业务，顾客A要在影院B购买电影票。业务需要涉及到以下操作：</p><p>1.从顾客A账户余额中扣除电影票价</p><p>2.给影院B的账户余额增加这张电影票价</p><p>3.记录一条交易日志</p><p>为了保证交易的原子性，要把这三个操作放在一个事务中。如何安排这三个语句在事务中的顺序呢？</p><p>如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。根据两阶段锁协议，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p><h3 id="2、死锁和死锁检测">2、死锁和死锁检测</h3><p><strong>在并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁</strong>。</p><p><strong>【死锁的条件】：</strong></p><ul><li><p>互斥条件：简单的说就是进程抢夺的资源必须是临界资源，一段时间内，该资源只能同时被一个进程所占有。</p></li><li><p>请求和保持条件：当一个进程持有了一个（或者更多）资源，申请另外的资源的时候发现申请的资源被其他进程所持有，当前进程阻塞，但不会是放自己所持有的资源。</p></li><li><p>不可抢占条件：进程已经获得的资源在未使用完毕的情况下不可被其他进程所抢占。</p></li><li><p>循环等待条件：存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源。</p></li></ul><p><strong>【预防死锁】：</strong></p><ol><li><p>破坏请求和保持条件：</p><p>1.所有进程在开始运行之前，必须一次性获得所有资源，如果无法获得完全，释放已经获得的资源，等待；</p><p>2.所有进程在开始运行之前，只获得初始运行所需要的资源，然后在运行过程中不断请求新的资源，同时释放自己已经用完的资源。</p></li></ol><p>2.破坏不可抢占条件：</p><p>​1.只要当一个进程申请一个资源，然而却申请不到的时候，必须释放已经申请到的所有资源。</p><p>3.破坏循环等待条件：</p><p>​1.设立一个规则，让进程获取资源的时候按照一定的顺序依次申请，不能违背这个顺序的规则。必须按照顺序申请和释放，想要申请后面的资源必须先把该资源之前的资源全部申请，想要申请前面的资源必须先把该资源之后的资源。</p><p>4.破坏互斥条件：</p><p>​没法破坏，是资源本身的性质所引起的。</p><p><strong>【死锁避免】：</strong></p><p>1.有序资源分配法：</p><p>​这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1,、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。</p><p>​采用有序资源分配法：R1的编号为1，R2的编号为2,；PA：申请次序应是：R1，R2；PB：申请次序应是：R1，R2；这样就破坏了环路条件，避免了死锁的发生。</p><p>2.银行家算法：</p><p>​该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可以很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。</p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162105380.png" class="" title="在这里插入图片描述"><p>事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><p>一种策略是，<strong>直接进入等待，直到超时</strong>。这个超时时间可以通过参数innodb_lock_wait_timeout来设置<br>另一种策略是，<strong>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务</strong>，让其他事务得以继续执行。将参数<strong>innodb_deadlock_detect设置为on</strong>，表示开启这个逻辑。</p><p>在InnoDB中，<strong>innodb_lock_wait_timeout的默认值是50s</strong>，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的</p><p>正常情况下还是要采用主动死锁检查策略，而且innodb_deadlock_detect的默认值本身就是on。主动死锁监测在发生死锁的时候，是能够快速发现并进行处理的，但是它有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁</p><p>如果所有事务都要更新同一行的场景，每个新来的被堵住的线程都要判断会不会由于自己的加入导致死锁，这是一个时间复杂度是O(n)的操作。</p><p>【<strong>示例</strong>】</p><p><strong>怎么解决由这种热点行更新导致的性能问题？</strong></p><p>1.如果确保这个业务一定不会出现死锁，可以临时把死锁检测关掉</p><p>2.控制并发度</p><p>3.将一行改成逻辑上的多行来减少锁冲突。以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成员原来的1/10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p><h1>Mysql中的锁</h1><p>根据锁的设计思想，MySQL里面的锁大致分为乐观锁和悲观锁。</p><h2 id="1、乐观锁和悲观锁的澄清">1、乐观锁和悲观锁的澄清</h2><ul><li>无论是悲观锁还是乐观锁，他们本质上不是数据库中具体的锁概念，而是我们定义出来，用来描述两种类别的锁的思想。所以有了设计的分类，我们就可以通过这个分类去对数据库中具体的锁进行分门别类；</li><li>不过数据库中的乐观锁更倾向叫乐观并发控制（OCC），悲观锁叫悲观并发控制（PCC），还有区别于乐观悲观锁的一种控制叫MVCC，多版本并发控制</li><li>也不要把乐观锁和悲观锁与数据库中的行锁，表锁，排他锁，共享锁混为一谈，他们并不是一个维度的东西；前者是一个锁思想，可以将后者根据是否进行趋近于乐观或悲观锁的思想进行分类</li><li>乐观锁和悲观锁的概念不仅仅存在于数据库领域，可以说存在线程安全，存在并发的场景几乎都有乐观锁和悲观锁的适用场景，比如Java中也有乐观锁和悲观锁思想的具体实现；但不同领域的乐观和悲观锁的具体实现都不尽相同，要解决的问题也可能有所不一样</li></ul><h2 id="1、悲观锁">1、悲观锁</h2><h3 id="【概念】">【概念】</h3><p>在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法; <strong>悲观锁指的是采用一种持悲观消极的态度，默认数据被外界访问时，必然会产生冲突，所以在数据处理的整个过程中都采用加锁的状态，保证同一时间，只有一个线程可以访问到数据，实现数据的排他性</strong>；通常，数据库的悲观锁是利用数据库本身提供的锁机制去实现的.</p><p>数据库的悲观并发控制可以解决<strong>读-写冲突和写-写冲突</strong>,指在用<strong>加锁的方式</strong>去解决</p><hr><h3 id="【实现】">【实现】</h3><p><strong>通常情况下，数据库的悲观锁就是利用数据库本身提供的锁去实现的</strong></p><ul><li>外界要访问某条数据，那它就要首先向数据库申请该数据的锁(某种锁)</li><li>如果获得成功，那它就可以操作该数据，在它操作期间，其他客户端就无法再操作该数据了</li><li>如果获得失败，则代表同一时间已有其他客户端获得了该锁，那就必须等待其他客户端释放锁</li></ul><p>当然数据库提供了非常多的锁，每种数据库提供的锁也不尽然相同，所以具体情况就要看是什么锁了,比如行锁，表锁等。</p><h3 id="【优缺点】">【优缺点】</h3><p>**优点：**适合在写多读少的并发环境中使用，虽然无法维持非常高的性能，但是在乐观锁无法提更好的性能前提下，可以做到数据的安全性<br>**缺点：**加锁会增加系统开销，虽然能保证数据的安全，但数据处理吞吐量低，不适合在读书写少的场合下使用。</p><h2 id="2、乐观锁">2、乐观锁</h2><h3 id="【概念】-2">【概念】</h3><p>在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法；乐观锁（ Optimistic Locking ） 是相对悲观锁而言，<strong>乐观锁是假设认为即使在并发环境中，外界对数据的操作一般是不会造成冲突，所以并不会去加锁(所以乐观锁不是一把锁)，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测</strong>，如果发现冲突了，则让返回冲突信息，让用户决定如何去做下一步，比如说重试，直至成功为止；数据库的乐观锁，并不是利用数据库本身的锁去实现的，可能是利用某种实现逻辑去实现做到乐观锁的思想</p><p>数据库的乐观并发控制要解决的是数据库并发场景下的<strong>写-写冲突</strong>，指在用<strong>无锁的方式</strong>去解决</p><hr><h3 id="【CAS思想】">【CAS思想】</h3><p>其实数据库乐观锁的具体实现几乎就跟Java中乐观锁采用的CAS算法思想是一致，所以我们可以从CAS算法中学习到数据库乐观锁的设计：</p><p>CAS指令全称为Compare and Swap，它是系统的指令集，<strong>整个CAS操作是一个原子操作，是不可分割的</strong>。从具体的描述上，我们可以这么看CAS操作：</p><hr><p><strong>CAS指令需要3个操作数，分别是内存位置V，旧的预期值A,和新值B。CAS指令执行时，当我们读取的内置位置V的现值等于旧预期值A时，处理器才会将新值B去更新内置位置V的值。否则它就不执行更新，但无论是否更新V的值，都会返回V的旧值。</strong></p><p>我们通俗的放到代码层次上去理解i = 2; i++，就是说：</p><ul><li>首先线程1从内存位置V中读取到了值，保存并作为旧预期值A. (v = 2 ,a = 2)</li><li>然后在因为i要进行++操作，系统会比较内存位置V的现值跟旧预期值A进行比较，既V =? A。</li><li>如果相等，B = i++ = 3 ，新值B就会对内存位置V进行更新，所以内存位置V的值就变成了B的值，3</li><li>如果不相等，则说明有其他的线程修改过了内存位置V的值，比如线程2在线程1修改i的值前就更新了i的值。，所以线程1会更新变量i失败。但线程不会挂起，而是返回失败状态，等待调用线程决定是否重试或其他操作。(通常会重试直到成功)</li></ul><h3 id="【实现】-2">【实现】</h3><p><strong>通常乐观锁的实现有两种，但它们的内在都是CAS思想的设计：</strong></p><ul><li><strong>方式一：</strong> 使用数据版本（<code>version</code>）实现</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">这是乐观锁最常用的一种实现方式。什么是数据版本呢？就是在表中增添一个字段作为该记录的版本标识，比如叫version，每次对该记录的写操作都会让 version<span class="hljs-operator">+</span> <span class="hljs-number">1</span>。<br><br>所以当我们读取了数据(包括version)，做出更新，要提交的时候，就会拿取得的version去跟数据库中的version比较是否一致，如果一致则代表这个时间段，并没有其他的线程的也修改过这个数据，给予更新，同时version <span class="hljs-operator">+</span> <span class="hljs-number">1</span>；如果不一致，则代表在这个时间段，该记录以及被其他线程修改过了， 认为是过期数据，返回冲突信息，让用户决定下一步动作，比如重试（重新读取最新数据，再过更新）<br>update <span class="hljs-keyword">table</span> <span class="hljs-keyword">set</span> num <span class="hljs-operator">=</span> num <span class="hljs-operator">+</span> <span class="hljs-number">1</span> , version <span class="hljs-operator">=</span> version <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> version <span class="hljs-operator">=</span> #&#123;version&#125; <span class="hljs-keyword">and</span> id <span class="hljs-operator">=</span> #&#123;id&#125;<br><br></code></pre></td></tr></table></figure><ul><li><strong>方式二：</strong> 使用时间戳(<code>timestamp</code>)实现</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">表中增加一个字段，名称无所谓，比如叫update_time, 字段类型使用时间戳（<span class="hljs-type">timestamp</span>）<br><br>原理和方式一一致，也是在更新提交的时检查当前数据库中数据的时间戳和自己更新前取到的时间戳是否一致，如果一致则代表此刻没有冲突，可以提交更新，同时时间戳更新为当前时间，否则就是该时间段有其他线程也更新提交过，返回冲突信息，等待用户下一步动作。<br>update <span class="hljs-keyword">table</span> <span class="hljs-keyword">set</span> num <span class="hljs-operator">=</span> num <span class="hljs-operator">+</span> <span class="hljs-number">1</span> ,update_time <span class="hljs-operator">=</span> unix_timestamp(now()) <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> #&#123;id&#125; <span class="hljs-keyword">and</span> update_time <span class="hljs-operator">=</span> #&#123;updateTime&#125;<br><br></code></pre></td></tr></table></figure><p>但是我们要注意的是，要实现乐观锁的思想的同时，我们必须要要保证CAS多个操作的原子性，即<strong>获取数据库数据的版本</strong>，<strong>拿数据库的数据版本与之前拿到的版本的比较</strong>，以及<strong>更新数据</strong>等这几个操作的执行必须是连贯执行，具有复合操作的原子性；所以如果是数据库的SQL,那么我们就要保证<strong>多个SQL操作处于同一个事务中</strong>。</p><h3 id="【优缺点】-2">【优缺点】</h3><p>**优点：**在读多写少的并发场景下，可以避免数据库加锁的开销，提高Dao层的响应性能。其实很多情况下，我们orm工具都有带有乐观锁的实现，所以这些方法不一定需要我们人为的去实现</p><p>**缺点：**在写多读少的并发场景下，即在写操作竞争激烈的情况下，会导致CAS多次重试，冲突频率过高，导致开销比悲观锁更高。</p><h1>Mysql锁的底层算法</h1><h2 id="1、记录锁">1、记录锁</h2><p>​记录锁是锁住记录，锁住索引记录，而不是真正的数据记录</p><ul><li>锁是非主键索引，会在索引记录上加锁后，在去主键索引上加锁</li><li>表上没有索引，会在隐藏的主键索引上加锁</li><li>如果要锁的列没有索引，进行全表记录加锁</li></ul><h2 id="2、间隙锁">2、间隙锁</h2><p>当我们用<strong>范围条件</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB（可重复读、串行化级别下才有效）会给符合条件的已有数据的索引项加锁；对于<strong>键值在条件范围内但并不存在的记录</strong>，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162243301.png" class="" title="在这里插入图片描述"><p>当执行<code>select * from t where d=5 for update</code>的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p><p><strong>跟间隙锁存在冲突关系的是往这个间隙中插入一个记录这个操作。间隙锁之间不存在冲突关系</strong></p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162258745.png" class="" title="在这里插入图片描述"><p>这里sessionB并不会被堵住。因为表t里面并没有c=7会这个记录，因此sessionA加的是间隙锁(5,10)。而sessionB也是在这个间隙加的间隙锁。它们用共同的目标，保护这个间隙，不允许插入值。但它们之间是不冲突的。</p><p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是(-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。因为+∞是开区间，在实现上，InnoDB给每个索引加了一个不存在的最大值supremum，这样才符合都是前开后闭区间。</p><p>间隙锁和next-key lock的引入，解决了幻读的问题，但同时也带来了一些困扰。</p><p><strong>间隙锁导致的死锁：</strong></p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162307738.png" class="" title="在这里插入图片描述"><p>1.sessionA执行select … for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10)</p><p>2.sessionB执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突</p><p>3.sessionB试图插入一行(9,9,9)，被sessionA的间隙锁挡住了，只好进入等待</p><p>4.sessionA试图插入一行(9,9,9)，被sessionB的间隙锁挡住了</p><p>两个session进入互相等待状态，形成了死锁，间隙锁的引入可能会导致同样的语句锁住更大的范围，这其实是影响并发度的。在读提交隔离级别下，不存在间隙锁。</p><h2 id="3、the-next-key-lock">3、the next-key lock</h2><p>该锁是记录锁加gap锁，在RR隔离级别下，对行的扫描、锁定都是使用这种锁。如果查询中包含唯一索引，就会只适用记录锁。因为唯一索引能确定记录行数，其他索引不能确定行数，有可能在其他事务中添加这个索引的数据导致幻读。</p><h3 id="1、next-key-lock加锁规则">1、next-key lock加锁规则</h3><ul><li>原则1：加锁的基本单位是next-key lock，next-key lock是<strong>前开后闭区间</strong></li><li>原则2：查找过程中<strong>访问到的对象</strong>才会加锁</li><li>优化1：索引上的<strong>等值查询，给唯一索引加锁的时候，next-key lock退化为行锁</strong></li><li>优化2：索引上的<strong>等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁</strong></li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止</li></ul><hr><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">这个规则只限于<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MySQL5</span>.</span></span>x系列&lt;=<span class="hljs-number">5.7</span>.<span class="hljs-number">24</span>，<span class="hljs-number">8.0</span>系列&lt;=<span class="hljs-number">8.0</span>.<span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `c` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `d` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<br>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>),(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>),(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">25</span>,<span class="hljs-number">25</span>,<span class="hljs-number">25</span>);<br><br></code></pre></td></tr></table></figure><h3 id="2、案例一：等值查询间隙锁">2、案例一：等值查询间隙锁</h3><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162316586.png" class="" title="在这里插入图片描述"><p>1.由于表t中没有id=7的记录，根据原则1，加锁单位是next-key lock，sessionA加锁范围就是(5,10]</p><p>2.根据优化2，这是一个等值查询(id=7)，而id=10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)</p><p>所以，sessionB要往这个间隙里面插入id=8的记录会被锁住，但是sessionC修改id=10这行是可以的</p><hr><h3 id="3、案例二：非唯一索引等值锁">3、案例二：非唯一索引等值锁</h3><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162326725.png" class="" title="在这里插入图片描述"><p>1.根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock</p><p>2.c是普通索引，因此访问c=5这一条记录是不能马上停下来的，需要向右遍历，查到c=10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock</p><p>3.根据优化2，等值判断，向右遍历，最后一个值不满足c=5这个等值条件，因此退化成间隙锁(5,10)</p><p>4.根据原则2，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有任何锁，这就是为什么sessionB的update语句可以执行完成</p><p>锁是加在索引上的，在这个例子中，lock in share mode只锁覆盖索引，但是如果是for update，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁，这样的话sessionB的update语句会被阻塞住。如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段</p><h3 id="4、案例三：主键索引范围锁">4、案例三：主键索引范围锁</h3><p>1.开始执行的时候，要找到第一个id=10的行，因此本该是next-key lock(5,10]。根据优化1，主键id上的等值条件，退化成行锁，只加了id=10这一行的行锁</p><p>2.范围查询就往后继续找，找到id=15这一行停下来，因此需要加next-key lock(10,15]</p><p>所以，sessionA这时候锁的范围就是主键索引上，行锁id=10和next-key lock(10,15]</p><h3 id="5、案例四：非唯一索引范围锁">5、案例四：非唯一索引范围锁</h3><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162335984.png" class="" title="在这里插入图片描述"><p>这次sessionA用字段c来判断，加锁规则跟案例三唯一的不同是：在第一次用c=10定位记录的时候，索引c上加上(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，因此最终sessionA加的锁是索引c上的(5,10]和(10,15]这两个next-key lock</p><h3 id="6、案例五：唯一索引范围锁bug">6、案例五：唯一索引范围锁bug</h3><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162344192.png" class="" title="在这里插入图片描述"><p>sessionA是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id=15这一行就应该停止了</p><p>但是实现上，InnoDB会扫描到第一个不满足条件的行为止，也就是id=20。而且由于这是个范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上</p><p>所以，sessionB要更新id=20这一行是会被锁住的。同样地，sessionC要插入id=16的一行，也会被锁住</p><h3 id="7、案例六：非唯一索引上存在等值的例子">7、案例六：非唯一索引上存在等值的例子</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">30</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>​新插入的这一行c=10，现在表里有两个c=10的行。虽然有两个c=10，但是它们的主键值id是不同的，因此这两个c=10的记录之间也是有间隙的.</p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162401642.png" class="" title="在这里插入图片描述"><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162410516.png" class="" title="在这里插入图片描述"><p>sessionA在遍历的时候，先访问第一个c=10的记录。根据原则1，这里加的是(c=5,id=5)到(c=10,id=10)这个next-key lock。然后sessionA向右查找，直到碰到(c=15,id=15)这一行，循环才结束。根据优化2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成(c=10,id=10)到(c=15,id=15)的间隙锁</p><p>也就是说，这个delete语句在索引c上的加锁范围，就是下图中蓝色区域覆盖的部分，这个蓝色区域左右两边都是虚线，表示开区间.</p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162418283.png" class="" title="在这里插入图片描述"><h3 id="8、案例七：limit语句加锁">8、案例七：limit语句加锁</h3><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/2019060516242975.png" class="" title="在这里插入图片描述"><p>加了limit 2的限制，因此在遍历到(c=10,id=30)这一行之后，满足条件的语句已经有两条，循环就结束了。因此，索引c上的加锁范围就变成了从(c=5,id=5)到(c=10,id=30)这个前开后闭区间，如下图所示：</p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162438271.png" class="" title="在这里插入图片描述"><p>再删除数据的时候尽量加limit，这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围</p><h3 id="9、案例八：一个死锁的例子">9、案例八：一个死锁的例子</h3><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162446585.png" class="" title="在这里插入图片描述"><p>1.sessionA启动事务后执行查询语句加lock in share mode，在索引c上加了next-key lock(5,10]和间隙锁(10,15)</p><p>2.sessionB的update语句也要在索引c上加next-key lock(5,10]，进入锁等待</p><p>3.然后sessionA要再插入(8,8,8)这一行，被sessionB的间隙锁锁住。由于出现了死锁，InnoDB让sessionB回滚</p><p>sessionB的加next-key lock(5,10]操作，实际上分成了两步，先是加(5,10)间隙锁，加锁成功；然后加c=10的行锁，这时候才被锁住的.</p><h3 id="10、不等号条件里的等值查询">10、不等号条件里的等值查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> id<span class="hljs-operator">&gt;</span><span class="hljs-number">9</span> <span class="hljs-keyword">and</span> id<span class="hljs-operator">&lt;</span><span class="hljs-number">12</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span> <span class="hljs-keyword">for</span> update;<br><br></code></pre></td></tr></table></figure><p>利用上面的加锁规则，这个语句的加锁范围是主键索引上的(0,5]、(5,10]和(10,15)。加锁单位是next-key lock，这里用到了优化2，即索引上的等值查询，向右遍历的时候id=15不满足条件，所以next-key lock退化为了间隙锁(10,15)</p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162454802.png" class="" title="在这里插入图片描述"><p>1.首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到第一个id&lt;12的值</p><p>2.这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id=12的这个值，只是最终没找到，但找到了(10,15)这个间隙</p><p>3.然后根据order by id desc，再向左遍历，在遍历过程中，就不是等值查询了，会扫描到id=5这一行，所以会加一个next-key lock (0,5]</p><p>在执行过程中，通过树搜索的方式定位记录的时候，用的是等值查询的方法</p><h3 id="11、等值查询的过程">11、等值查询的过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> c <span class="hljs-keyword">in</span>(<span class="hljs-number">5</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>) lock <span class="hljs-keyword">in</span> share mode;<br><br></code></pre></td></tr></table></figure><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/2019060516250347.png" class="" title="在这里插入图片描述"><p>这条in语句使用了索引c并且rows=3，说明这三个值都是通过B+树搜索定位的</p><p><strong>在查找c=5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c=5，就要向右遍历，找到c=10确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。执行c=10会这个逻辑的时候，加锁的范围是(5,10]和(10,15)，执行c=20这个逻辑的时候，加锁的范围是(15,20]和(20,25)</strong></p><p>这条语句在索引c上加的三个记录锁的顺序是：先加c=5的记录锁，再加c=10的记录锁，最后加c=20的记录锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> c <span class="hljs-keyword">in</span>(<span class="hljs-number">5</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c <span class="hljs-keyword">desc</span> <span class="hljs-keyword">for</span> update;<br><br></code></pre></td></tr></table></figure><p>由于语句里面是order by c desc，这三个记录锁的加锁顺序是先锁c=20，然后c=10，最后是c=5。这两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，就可能出现死锁。</p><h3 id="12、insert语句的锁为什么这么多？">12、insert语句的锁为什么这么多？</h3><h4 id="1、insert-…-select语句">1、insert … select语句</h4><p>表t和t2的表结构、初始化数据语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `c` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `d` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `c` (`c`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-number">4</span>,<span class="hljs-number">4</span>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t2 <span class="hljs-keyword">like</span> t;<br><br></code></pre></td></tr></table></figure><p><strong>在可重复读隔离级别下，binlog_format=statement时执行下面这个语句时，需要对表t的所有行和间隙加锁</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t2(c,d) <span class="hljs-keyword">select</span> c,d <span class="hljs-keyword">from</span> t;<br><br></code></pre></td></tr></table></figure><h4 id="2、insert循环写入">2、insert循环写入</h4><p>要往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t2(c,d)  (<span class="hljs-keyword">select</span> c<span class="hljs-operator">+</span><span class="hljs-number">1</span>, d <span class="hljs-keyword">from</span> t force index(c) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1</span>);<br><br></code></pre></td></tr></table></figure><p>这个语句的加锁范围，就是表t索引c上的(3,4]和(4,supermum]这两个next-key lock，以及主键索引上id=4这一行</p><p>执行流程是从表t中按照索引c倒序吗，扫描第一行，拿到结果写入到表t2中，因此整条语句的扫描行数是1</p><p>但如果要把这一行的数据插入到表t中的话:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t(c,d)  (<span class="hljs-keyword">select</span> c<span class="hljs-operator">+</span><span class="hljs-number">1</span>, d <span class="hljs-keyword">from</span> t force index(c) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1</span>);<br><br></code></pre></td></tr></table></figure><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162511513.png" class="" title="在这里插入图片描述"><p>explain结果中的Extra字段中Using temporary字段，表示这个语句用到了临时表</p><p>执行流程如下：</p><p>1.创建临时表，表里有两个字段c和d</p><p>2.按照索引c扫描表t，依次取c=4、3、2、1，然后回表，读到c和d的值写入临时表</p><p>3.由于语义里面有limit 1，所以只取了临时表的第一行，再插入到表t中</p><p>这个语句会导致在表t上做全表扫描，并且会给索引c上的所有间隙都加上共享的next-key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据</p><p>需要临时表是因为这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符.</p><h4 id="3、insert唯一键冲突">3、insert唯一键冲突</h4><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162520967.png" class="" title="在这里插入图片描述"><p>sessionA执行的insert语句，发生唯一键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁，sessionA持有索引c上的(5,10]共享next-key lock（读锁）</p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162531598.png" class="" title="在这里插入图片描述"><p>在sessionA执行rollback语句回滚的时候，sessionC几乎同时发现死锁并返回</p><p>1.在T1时刻，启动sessionA，并执行insert语句，此时在索引c的c=5上加了记录锁。这个索引是唯一索引，因此退化为记录锁</p><p>2.在T2时刻，sessionA回滚。这时候，sessionB和sessionC都试图继续执行插入操作，都要加上写锁。两个session都要等待对方的行锁，所以就出现了死锁</p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/20190605162540324.png" class="" title="在这里插入图片描述"><h4 id="4、insert-into-…-on-duplicate-key-update">4、insert into … on duplicate key update</h4><p>上面这个例子是主键冲突后直接报错，如果改写成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>) <span class="hljs-keyword">on</span> duplicate key update d<span class="hljs-operator">=</span><span class="hljs-number">100</span>; <br><br></code></pre></td></tr></table></figure><p>就会给索引c上(5,10]加一个排他的next-key lock（写锁）</p><p>insert into … on duplicate key update的语义逻辑是，插入一行数据，如果碰到唯一键约束，就继续执行后面的更新语句。如果有多个列违反了唯一性索引，就会按照索引的顺序，修改跟第一个索引冲突的行</p><p>表t里面已经有了(1,1,1)和(2,2,2)这两行，执行这个语句效果如下：</p><img src="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/2019060516255097.png" class="" title="在这里插入图片描述"><p>主键id是先判断的，MySQL认为这个语句跟id=2这一行冲突，所以修改的是id=2的行</p><p><strong>思考题：</strong><br>1、如果要删除一个表里面的前10000行数据，有以下三种方法可以做到：</p><ul><li>第一种，直接执行delete from T limit 10000;</li><li>第二种，在一个连接中循环执行20次delete from T limit 500；</li><li>第三种，在20个连接中同时执行delete from T limit 500；<br>选择哪一种方式比较好？</li></ul><p><strong>参考答案：</strong></p><ul><li><p>第一种方式，单个语句占用时间长，锁的时间也比较长，而且大事务还会导致主从延迟</p></li><li><p>第三种方式，会人为造成锁冲突</p></li><li><p>第二种方式相对较好</p></li></ul><hr><h1>MyISAM和MySQL的锁的对比总结</h1><p><strong>对于ＭyISAM的表锁，主要有以下几点</strong></p><p>（１）共享读锁（S）之间是兼容的，但共享读锁（S）和排他写锁（X）之间，以及排他写锁之间（X）是互斥的，也就是说读和写是串行的。</p><p>（２）在一定条件下，ＭyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表和插入的锁争用问题。</p><p>（３）ＭyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIPORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。</p><p>（４）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，ＭyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</p><p><strong>对于InnoDB表，主要有以下几点</strong></p><p>（１）InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。</p><p>（２）InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。</p><p>（３）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。</p><p>（４）ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。</p><p>（５）锁冲突甚至死锁很难完全避免。</p><p><strong>在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</strong></p><ul><li>尽量使用较低的隔离级别</li><li>精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li><li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li><li>不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql中的日志</title>
    <link href="/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97/"/>
    <url>/dajiangdahe/2021/10/22/Mysql%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1>Mysql中的日志</h1><ul><li>错误日志</li><li>查询日志</li><li>redo log（重做日志）</li><li>undo log（回滚日志）</li><li>bin log（二进制日志）</li></ul><h2 id="1-错误日志">1.错误日志</h2><p>用来记录 MySQL 服务器运行过程中的错误信息,默认开启无法关闭.<br>复制环境下，从服务器进程的信息也会被记录进错误日志</p><p>默认情况下，错误日志是存储在数据库的数据文件目录中，名称为 hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7 之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7 之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mv hostname.err hostname.err.old mysqladmin flush<span class="hljs-operator">-</span>logs<br></code></pre></td></tr></table></figure><h2 id="2-查询日志">2.查询日志</h2><p><strong>查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录</strong>，具体原因如下:</p><ul><li>insert 查询为了避免数据冲突，如果此前插入过数据，当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；</li><li>update 时也会查询因为更新的时候很可能会更新某一块数据；</li><li>delete 查询，只删除符合条件的数据；</li></ul><p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能，因此如果不是在调试环境下，是不建议开启查询日志功能的。</p><p>查询日志模式是关闭的，可以通过以下命令开启查询日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> generallog<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> logoutput<span class="hljs-operator">=</span>‘<span class="hljs-keyword">table</span>’;<br></code></pre></td></tr></table></figure><h2 id="3-redo-log-重做日志-一种缓存机制">3.redo log(重做日志) 一种缓存机制</h2><p><strong>是什么</strong>:为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题</p><p>怎么办:<strong>先将数据</strong>写入内存中，再<strong>批量把内存中的数据</strong>统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 redo log 来解决此问题。</p><h2 id="4-undo-log（回滚日志）">4.undo log（回滚日志）</h2><p><strong>是什么</strong>：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。</p><p><strong>怎么做</strong>:<strong>undo log</strong> 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。<strong>undo log 默认存放在共享表空间中</strong>，在 ySQL 5.6 中，undo log 的存放位置还可以通过变量 innodbundodirectory 来自定义存放目录，默认值为“.”表示 datadir 目录。</p><h2 id="5-bin-log-二进制日志">5.bin log(二进制日志)</h2><p>是一个二进制文件，主要记录所有数据库表结构变更bin log 中记录了对 MySQL 数据库<strong>执行更改的所有操作</strong>，并且记录了语句发生时间、执行时长、操作数据等其它额外信息，但是<strong>它不记录 SELECT、SHOW 等那些不修改数据的 SQL 语句</strong>。</p><p>【<strong>binlog 的作用如下</strong>】：</p><ul><li><strong>恢复（recovery）</strong>：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；</li><li><strong>复制（replication）</strong>：其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；</li><li><strong>审计（audit）</strong>：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</li><li>binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用</li></ul><p>开启方法:</p><p>binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin = [base-name] 开启记录 binlog 日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。</p><p>通过以下命令来查询 binlog 是否开启：</p><blockquote><p>show variables like ‘log_%’;</p></blockquote><p><strong>binlog 格式分为: STATEMENT、ROW 和 MIXED 三种：</strong></p><p><strong>STATEMENT格式</strong>：的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，所以相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间。</p><p><strong>ROW 格式</strong>：是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直</p><p><strong>MIXED 格式</strong>：也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENTUSER()、ROWCOUNT() 等无法确定的函数。</p><h1>MySQL日志问题扩充</h1><h2 id="1-redo-log-和-binlog-有什么区别？">1.redo log 和 binlog 有什么区别？</h2><p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p><ul><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。</li><li>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li><li>redo log 是 InnoDB 引擎特有的；</li><li>binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是循环写的，空间固定会用完；</li><li>binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。（两段式提交，分成<strong>prepare + commit</strong> 来保证crash-safe）</li></ul><h2 id="2-什么是-crash-safe？">2.什么是 crash-safe？</h2><p>crash-safe 是指发生宕机等意外情况下，服务器重启后数据依然不会丢失的情况。</p><h2 id="3-什么是脏页和干净页？">3.什么是脏页和干净页？</h2><p>MySQL 为了操作的性能优化，会把数据更新先放入内存中，之后再统一更新到磁盘。当内存数据和磁盘数据内容不一致的时候，我们称这个内存页为脏页；内存数据写到磁盘后，内存的数据和磁盘上的内容就一致了，我们称为“干净页”。</p><h2 id="4-MySQL一页的大小是多少？">4.MySQL一页的大小是多少？</h2><p>16KB</p><h2 id="5-什么情况下会引发-MySQL-刷脏页（flush）的操作？">5.什么情况下会引发 MySQL 刷脏页（flush）的操作？</h2><ul><li>内存写满了，这个时候就会引发 flush 操作，对应到 InnoDB 就是 redo log 写满了；</li><li>系统的内存不足了，当需要新的内存页的时候，就会淘汰一些内存页，如果淘汰的是脏页这个时候就会触发 flush 操作；</li><li>系统空闲的时候，MySQL 会同步内存中的数据到磁盘也会触发 flush 操作；</li><li>MySQL 服务关闭的时候也会刷脏页，触发 flush 操作。</li></ul><h2 id="6-MySQL-刷脏页的速度很慢可能是什么原因？">6.MySQL 刷脏页的速度很慢可能是什么原因？</h2><p>在 MySQL 中单独刷一个脏页的速度是很快的，如果发现刷脏页的速度很慢，说明触发了 MySQL 刷脏页的“连坐”机制，MySQL 的“连坐”机制是指当 MySQL 刷脏页的时候如果发现相邻的数据页也是脏页也会一起刷掉，而这个动作可以一直蔓延下去，这就是导致 MySQL 刷脏页慢的原因了。</p><h2 id="7-如何控制-MySQL-只刷新当前脏页？">7.如何控制 MySQL 只刷新当前脏页？</h2><p>在 InnoDB 中设置 innodbflushneighbors 这个参数的值为 0，来规定 MySQL 只刷当前脏页，MySQL 8 这个值默认是 0。</p><h2 id="8-MySQL-的-WAL-技术是解决什么问题的？">8.MySQL 的 WAL 技术是解决什么问题的？</h2><p>WAL 技术的全称是 Write Ahead Logging（中文：预写式日志），是先写日志，再写磁盘的方式，因为每次更新都写磁盘的话 IO 成本很高，所以才有了 WAL 技术。</p><h2 id="9-为什么有时候会感觉-MySQL-偶尔卡一下？">9.为什么有时候会感觉 MySQL 偶尔卡一下？</h2><p>如果偶尔感觉 MySQL 卡一下，可能是 MySQL 正在刷脏页，正在把内存中的更新操作刷到磁盘中。</p><h2 id="10-redo-log-和-binlog-是怎么关联的">10.redo log 和 binlog 是怎么关联的?</h2><p>它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p><ul><li>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</li><li>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</li></ul><h2 id="11-MySQL-怎么知道-binlog-是完整的">11.MySQL 怎么知道 binlog 是完整的?</h2><ul><li>statement 格式的 binlog，完整的标识是最后有 COMMIT 关键字。</li><li>row 格式的 binlog，完整的标识是最后会有一个 XID event 关键字。</li></ul><h2 id="12-MySQL-中可不可以只要-binlog，不要-redo-log？">12.MySQL 中可不可以只要 binlog，不要 redo log？</h2><p>不可以，binlog 没有崩溃恢复的能力。</p><h2 id="13-MySQL-中可不可以只要-redo-log，不要-binlog？">13.MySQL 中可不可以只要 redo log，不要 binlog？</h2><p>不可以，原因有以下两个：</p><ul><li>redo log 是循环写不能保证所有的历史数据，这些历史数据只能在 binlog 中找到；</li><li>binlog 是高可用的基础，高可用的实现原理就是 binlog 复制。</li></ul><h2 id="14-为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的？">14.为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</h2><p>因为 binlog 是不能“被打断的”，一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中，redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p><h2 id="15-事务执行期间，还未提交，如果发生-crash，redo-log-丢失，会导致主备不一致呢？">15.事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？</h2><p>不会，因为这时候 binlog 也还在 binlog cache 里，没发给备库，crash 以后 redo log 和 binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。</p><h2 id="16-在-MySQL-中用什么机制来优化随机读-写磁盘对-IO-的消耗？">16.在 MySQL 中用什么机制来优化随机读/写磁盘对 IO 的消耗？</h2><p>redo log 是<strong>用来节省随机写磁盘的 IO 消耗</strong>，而 <strong>change buffer 主要是节省随机读磁盘的 IO</strong> 消耗。redo log 会把 MySQL 的更新操作先记录到内存中，之后再统一更新到磁盘，而 change buffer 也是把关键查询数据先加载到内存中，以便优化 MySQL 的查询。</p><p>A.redo log 是 InnoDB 引擎特有的，它的固定大小的</p><p>B.redo log 日志是不全的，只有最新的一些日志，这和它的内存大小有关</p><p>C.redo log 可以保证数据库异常重启之后，数据不丢失</p><p>D binlog 是 MySQL 自带的日志，但它并不能保证数据库异常重启之后数据不丢失。</p><p>E.binlog 日志是追加写的，后面的日志并不会覆盖前面的日志，redo log 日志是固定大小的，后面的日志会覆盖前面的日志。</p><h2 id="17-有没有办法把-MySQL-的数据恢复到过去某个指定的时间节点？怎么恢复？">17.有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？</h2><p>可以恢复，只要你<strong>备份了这段时间的所有 binlog</strong>，同时做了<strong>全量数据库的定期备份</strong>，比如，一天一备，或者三天一备，这取决于你们的备份策略，这个时候你就可以把之前备份的数据库先还原到测试库，从备份的时间点开始，将备份的 binlog 依次取出来，重放到你要恢复数据的那个时刻，这个时候就完成了数据到指定节点的恢复。比如，今天早上 9 点的时候，你想把数据恢复成今天早上 6:00:00 的状态，这个时候你可以先取出今天凌晨（00:01:59）备份的数据库文件，还原到测试库，再从 binlog 文件中依次取出 00:01:59 之后的操作信息，重放到 6:00:00 这个时刻，这就完成了数据库的还原。</p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql MVCC</title>
    <link href="/dajiangdahe/2021/10/22/MysqlMVCC/"/>
    <url>/dajiangdahe/2021/10/22/MysqlMVCC/</url>
    
    <content type="html"><![CDATA[<h1>Mysql MVCC</h1><h2 id="【数据库事务】">【数据库事务】</h2><h3 id="【概念】">【概念】</h3><p>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。</p><h3 id="【特性】">【特性】</h3><ul><li><strong>原子性（Atomicity）</strong></li></ul><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><ul><li><strong>一致性（Consistency）</strong></li></ul><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><ul><li><strong>隔离性（Isolation）</strong></li></ul><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><p>关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p><ul><li><strong>持久性（Durability）</strong></li></ul><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><p>​例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p><h3 id="【并发产生的问题】">【并发产生的问题】</h3><ul><li><strong>丢失修改</strong></li></ul><p>当两个或多个事务选择同行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题一一最后的更新覆盖了由其他事务所做的更新。  例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。</p><ul><li><strong>脏读</strong></li></ul><p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</p><img src="/dajiangdahe/2021/10/22/MysqlMVCC/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkZxZzc4MjI5eWppYlBuOE9iczN2U040Vlo3TEtYanpsM3E1WE9wSWtxUUFLcGFwUDhoY0pLVlhHM21LbWtsMEk0WG9pYVM3eVRrdndWdy82NDA" class="" title="img"><ul><li><strong>不可重复读</strong></li></ul><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p><img src="/dajiangdahe/2021/10/22/MysqlMVCC/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkZxZzc4MjI5eWppYlBuOE9iczN2U040cWdRWWFrM043c29CRFZ3eVdKRHJpYU1ycVB2bE9zSXdURlpnVldxM1lNcUlTbUYxTkREWDVqZy82NDA" class="" title="img"><ul><li><strong>虚读(幻读)</strong></li></ul><p>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</p><img src="/dajiangdahe/2021/10/22/MysqlMVCC/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkZxZzc4MjI5eWppYlBuOE9iczN2U040WG1BSWpwRTRIVlpZaE5hTHZLNUNIeGNLWW4yaWJwZW9oVUxFbnE5ZThFSkNpYlZ0aWJZaGFzcW9nLzY0MA" class="" title="img"><h3 id="【隔离级别】">【隔离级别】</h3><p>① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</p><p>② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</p><p>③ Read committed (读已提交)：可避免脏读的发生。</p><p>④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>读数据一致性</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>最低级别，只能保证不读取物理上损坏的数据</td><td>有</td><td>有</td><td>有</td></tr><tr><td>读已提交（read-committed）</td><td>语句级</td><td>否</td><td>有</td><td>有</td></tr><tr><td>可重复读（repeatable-read）</td><td>事务级</td><td>否</td><td>否</td><td>有</td></tr><tr><td>串行化（serializable）</td><td>最高级别，事务级</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>在<strong>MySQL</strong>数据库中，支持上面四种隔离级别，默认的为<strong>Repeatable read (可重复读)</strong>；而在<strong>Oracle</strong>数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为<strong>Read committed</strong>级别。</p><h2 id="【MVCC】">【MVCC】</h2><h3 id="【概念】-2">【概念】</h3><p>多版本控制: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，<strong>只有写写之间相互阻塞，其他三种操作都可以并行</strong>，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，<strong>InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本</strong>。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。**在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。**MVCC是一种多版本并发控制机制。</p><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p><h3 id="【当前读和快照读】">【当前读和快照读】</h3><ul><li>当前读<br>像select lock in share mode(<code>共享锁</code>), select for update ; update, insert ,delete(<code>排他锁</code>)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</li><li>快照读<br>像<code>不加锁</code>的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</li></ul><p>MVCC就是为了实现读-写冲突不加锁，而这个<strong>读指的就是<code>快照读</code>, 而非当前读</strong>，当前读实际上是一种加锁的操作，是悲观锁的实现</p><h3 id="【当前读和快照读的关系】">【当前读和快照读的关系】</h3><ul><li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念</li><li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现</li><li>要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 <code>3个隐式字段</code>，<code>undo日志</code> ，<code>Read View</code> 等去完成的，具体可以看下面的MVCC实现原理</li></ul><h3 id="【并发场景】">【并发场景】</h3><ul><li><code>读-读</code>：不存在任何问题，也不需要并发控制</li><li><code>读-写</code>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li><li><code>写-写</code>：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li></ul><p>备注：第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了；第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失</p><p>【<strong>优点</strong>】</p><p>多版本并发控制（MVCC）是一种用来解决<code>读-写冲突</code>的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p><ul><li><p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</p></li><li><p>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p></li></ul><p>【<strong>方案</strong>】</p><ul><li><code>MVCC + 悲观锁</code><br>MVCC解决读写冲突，悲观锁解决写写冲突</li><li><code>MVCC + 乐观锁</code><br>MVCC解决读写冲突，乐观锁解决写写冲突</li></ul><p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p><h3 id="【实现原理】">【实现原理】</h3><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖记录中的 <code>3个隐式字段</code>，<code>undo日志</code> ，<code>Read View</code> 来实现的。所以我们先来看看这个三个point的概念</p><h3 id="【隐式字段】">【<strong>隐式字段</strong>】</h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的<code>DB_TRX_ID</code>,<code>DB_ROLL_PTR</code>,<code>DB_ROW_ID</code>等字段</p><ul><li><code>DB_TRX_ID</code><br>6byte，最近修改(<code>修改/插入</code>)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li><li><code>DB_ROLL_PTR</code><br>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li><li><code>DB_ROW_ID</code><br>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以<code>DB_ROW_ID</code>产生一个聚簇索引</li><li>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li></ul><img src="/dajiangdahe/2021/10/22/MysqlMVCC/20190313213705258.png" class="" title="在这里插入图片描述"><p>如上图，<code>DB_ROW_ID</code>是数据库默认为该行记录生成的唯一隐式主键，<strong><code>DB_TRX_ID</code>是当前操作该记录的事务ID,而<code>DB_ROLL_PTR</code>是一个回滚指针，用于配合undo日志，指向上一个旧版本</strong></p><h3 id="【undo日志】">【<strong>undo日志</strong>】</h3><p>undo log主要分为两种：</p><ul><li>insert undo log<br>代表事务在<code>insert</code>新记录时产生的<code>undo log</code>, <strong>只在事务回滚时需要，并且在事务提交后可以被立即丢弃</strong></li><li>update undo log<br>事务在进行<code>update</code>或<code>delete</code>时产生的<code>undo log</code>; <strong>不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被<code>purge</code>线程统一清除</strong></li></ul><p>【<strong>purge</strong>】</p><ul><li>从前面的分析可以看出，为了实现InnoDB的MVCC机制，<strong>更新或者删除操作都只是设置一下老记录的deleted_bit</strong>，并不真正将过时的记录删除。</li><li>为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li></ul><h3 id="【示例】">【<strong>示例</strong>】</h3><p>对MVCC有帮助的实质是<code>update undo log</code> ，<code>undo log</code>实际上就是存在<code>rollback segment</code>中旧记录链，它的执行流程如下：</p><p><strong>一、 比如一个有个事务插入persion表插入了一条新记录，记录如下，<code>name</code>为Jerry, <code>age</code>为24岁，<code>隐式主键</code>是1，<code>事务ID</code>和<code>回滚指针</code>，我们假设为NULL。</strong></p><img src="/dajiangdahe/2021/10/22/MysqlMVCC/20190313213836406.png" class="" title="img"><p><strong>二、 现在来了一个<code>事务1</code>对该记录的<code>name</code>做出了修改，改为Tom</strong></p><ul><li>在<code>事务1</code>修改该行(记录)数据时，数据库会先对该行加<code>排他锁</code></li><li>然后把该行数据拷贝到<code>undo log</code>中，作为旧记录，<strong>既在<code>undo log</code>中有当前行的拷贝副本</strong></li><li>拷贝完毕后，修改该行<code>name</code>为Tom，并且<strong>修改隐藏字段的事务ID为当前<code>事务1</code>的ID</strong>, 我们默认从<code>1</code>开始，之后递增，回滚指针指向拷贝到<code>undo log</code>的副本记录，既表示我的上一个版本就是它</li><li>事务提交后，释放锁。</li></ul><img src="/dajiangdahe/2021/10/22/MysqlMVCC/20190313220441831.png" class="" title="img"><p><strong>三、 又来了个<code>事务2</code>修改<code>person表</code>的同一个记录，将<code>age</code>修改为30岁</strong></p><ul><li>在<code>事务2</code>修改该行数据时，数据库也先为该行加锁</li><li>然后把该行数据拷贝到<code>undo log</code>中，作为旧记录，发现该行记录已经有<code>undo log</code>了，那么最新的旧数据作为链表的表头，插在该行记录的<code>undo log</code>最前面</li><li>修改该行<code>age</code>为30岁，并且修改隐藏字段的事务ID为当前<code>事务2</code>的ID, 那就是<code>2</code>，回滚指针指向刚刚拷贝到<code>undo log</code>的副本记录</li><li>事务提交，释放锁</li></ul><img src="/dajiangdahe/2021/10/22/MysqlMVCC/20190313220528630.png" class="" title="img"><p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的<code>undo log</code>成为一条记录版本线性表，既链表，<code>undo log</code>的链首就是最新的旧记录，<strong>链尾就是最早的旧记录</strong>（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p><h3 id="Read-View-读视图">Read View(读视图)</h3><p>什么是Read View?</p><p>什么是Read View，说白了Read View就是事务进行<code>快照读</code>操作的时候生产的<code>读视图</code>(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p><p>所以我们知道 <code>Read View</code>主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个<code>Read View</code>读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的<code>undo log</code>里面的某个版本的数据。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">Read View`遵循一个可见性算法，主要是将`要被修改的数据`的最新记录中的`DB_TRX_ID`（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果`DB_TRX_ID`跟Read View的属性做了某些比较，不符合可见性，那就通过`DB_ROLL_PTR`回滚指针去取出`Undo Log`中的`DB_TRX_ID`再比较，即遍历链表的`DB_TRX_ID`（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的`DB_TRX_ID`, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新`老版本<br></code></pre></td></tr></table></figure><p>那么这个判断条件是什么呢？</p><img src="/dajiangdahe/2021/10/22/MysqlMVCC/20190314144440494.png" class="" title="在这里插入图片描述"><ul><li><p><code>trx_list</code>（名字我随便取的）<br>一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID</p></li><li><p><code>up_limit_id</code><br>记录trx_list列表中事务ID最小的ID</p></li><li><p><code>low_limit_id</code><br>ReadView生成时刻系统尚未分配的下一个事务ID，也就是<code>目前已出现过的事务ID的最大值+1</code></p></li><li><p>首先比较<code>DB_TRX_ID &lt; up_limit_id</code>, 如果小于，则当前事务能看到<code>DB_TRX_ID</code> 所在的记录，如果大于等于进入下一个判断</p></li><li><p>接下来判断 <code>DB_TRX_ID 大于等于 low_limit_id</code> , 如果大于等于则代表<code>DB_TRX_ID</code> 所在的记录在<code>Read View</code>生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</p></li><li><p>判断<code>DB_TRX_ID</code> 是否在活跃事务之中，<code>trx_list.contains(DB_TRX_ID)</code>，如果在，则代表我<code>Read View</code>生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在<code>Read View</code>生成之前就已经Commit了，你修改的结果，我当前事务是能看见的</p></li></ul><h4 id="整体流程">整体流程</h4><p>我们在了解了<code>隐式字段</code>，<code>undo log</code>， 以及<code>Read View</code>的概念之后，就可以来看看MVCC实现的整体流程是怎么样了</p><p>整体的流程是怎么样的呢？我们可以模拟一下</p><ul><li>当<code>事务2</code>对某行数据执行了<code>快照读</code>，数据库为该行数据生成一个<code>Read View</code>读视图，假设当前事务ID为<code>2</code>，此时还有<code>事务1</code>和<code>事务3</code>在活跃中，<code>事务4</code>在<code>事务2</code>快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为<code>trx_list</code></li></ul><table><thead><tr><th>事务1</th><th>事务2</th><th>事务3</th><th>事务4</th></tr></thead><tbody><tr><td>事务开始</td><td>事务开始</td><td>事务开始</td><td>事务开始</td></tr><tr><td>…</td><td>…</td><td>…</td><td>修改且已提交</td></tr><tr><td>进行中</td><td>快照读</td><td>进行中</td><td></td></tr><tr><td>…</td><td>…</td><td>…</td><td></td></tr></tbody></table><ul><li>Read View不仅仅会通过一个列表<code>trx_list</code>来维护<code>事务2</code>执行<code>快照读</code>那刻系统正活跃的事务ID，还会有两个属性<code>up_limit_id</code>（记录trx_list列表中事务ID最小的ID），<code>low_limit_id</code>(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是<code>目前已出现过的事务ID的最大值+1</code>，我更倾向于后者。所以在这里例子中<code>up_limit_id</code>就是1，<code>low_limit_id</code>就是4 + 1 = 5，trx_list集合的值是1,3，<code>Read View</code>如下图</li></ul><img src="/dajiangdahe/2021/10/22/MysqlMVCC/20190313224045780.png" class="" title="img"><ul><li>我们的例子中，只有<code>事务4</code>修改过该行记录，并在<code>事务2</code>执行<code>快照读</code>前，就提交了事务，所以当前该行当前数据的<code>undo log</code>如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的<code>DB_TRX_ID</code>去跟<code>up_limit_id</code>,<code>low_limit_id</code>和<code>活跃事务ID列表(trx_list)</code>进行比较，判断当前<code>事务2</code>能看到该记录的版本是哪个。</li></ul><img src="/dajiangdahe/2021/10/22/MysqlMVCC/2019031322511052.png" class="" title="img"><ul><li>所以先拿该记录<code>DB_TRX_ID</code>字段记录的事务ID <code>4</code>去跟<code>Read View</code>的的<code>up_limit_id</code>比较，看<code>4</code>是否小于<code>up_limit_id</code>(1)，所以不符合条件，继续判断 <code>4</code> 是否大于等于 <code>low_limit_id</code>(5)，也不符合条件，最后判断<code>4</code>是否处于<code>trx_list</code>中的活跃事务, 最后发现事务ID为<code>4</code>的事务不在当前活跃事务列表中, 符合可见性条件，所以<code>事务4</code>修改后提交的最新结果对<code>事务2</code>快照读时是可见的，所以<code>事务2</code>能读到的最新数据记录是<code>事务4</code>所提交的版本，而事务4提交的版本也是全局角度上最新的版本</li></ul><img src="/dajiangdahe/2021/10/22/MysqlMVCC/20190314141320189.jpg" class="" title="在这里插入图片描述"><ul><li>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</li></ul><h3 id="【相关问题】">【相关问题】</h3><h5 id="当前读和快照读在RR级别下的区别：">当前读和快照读在RR级别下的区别：</h5><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>开启事务</td><td>开启事务</td></tr><tr><td>快照读(无影响)查询金额为500</td><td>快照读查询金额为500</td></tr><tr><td>更新金额为400</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>select <code>快照读</code>金额为500</td></tr><tr><td></td><td>select lock in share mode<code>当前读</code>金额为400</td></tr></tbody></table><p>在上表的顺序下，事务B的在事务A提交修改后的快照读是旧版本数据，而当前读是实时新数据400</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>开启事务</td><td>开启事务</td></tr><tr><td>快照读（无影响）查询金额为500</td><td></td></tr><tr><td>更新金额为400</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>select <code>快照读</code>金额为400</td></tr><tr><td></td><td>select lock in share mode<code>当前读</code>金额为400</td></tr></tbody></table><p>而在<code>表2</code>这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p><ul><li>这里与上表的唯一区别仅仅是<code>表1</code>的事务B在事务A修改金额前<code>快照读</code>过一次金额数据，而<code>表2</code>的事务B在事务A修改金额前没有进行过快照读。</li></ul><p>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</p><p>我们这里测试的是<code>更新</code>，同时<code>删除</code>和<code>更新</code>也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</p><h4 id="RC-RR级别下的InnoDB快照读有什么不同？">RC,RR级别下的InnoDB快照读有什么不同？</h4><p>正是<code>Read View</code>生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p><ul><li><strong>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View</strong>, 将当前系统活跃的其他事务记录起来，此后在<strong>调用快照读的时候，还是使用的是同一个Read</strong> <strong>View</strong>，所以只要当前事务在其他事务提交更新之前使用过快照读，那么<strong>之后的快照读使用的都是同一个Read View</strong>，所以对之后的修改不可见；即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</li><li>而在<strong>RC级别下的，事务中，每次快照读都会新生成一个快照和Read View</strong>, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</li></ul><p><strong>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaInterview-04</title>
    <link href="/dajiangdahe/2021/10/22/JavaInterview-04/"/>
    <url>/dajiangdahe/2021/10/22/JavaInterview-04/</url>
    
    <content type="html"><![CDATA[<h3 id="十五、Kafka">十五、Kafka</h3><h4 id="152-kafka-可以脱离-zookeeper-单独使用吗？为什么？">152.kafka 可以脱离 zookeeper 单独使用吗？为什么？</h4><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p><h4 id="153-kafka-有几种数据保留的策略？">153.kafka 有几种数据保留的策略？</h4><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p><h4 id="154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？">154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</h4><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p><h4 id="155-什么情况会导致-kafka-运行变慢？">155.什么情况会导致 kafka 运行变慢？</h4><ul><li>cpu 性能瓶颈</li><li>磁盘读写瓶颈</li><li>网络瓶颈</li></ul><h4 id="156-使用-kafka-集群需要注意什么？">156.使用 kafka 集群需要注意什么？</h4><ul><li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</li><li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</li></ul><h3 id="十六、Zookeeper">十六、Zookeeper</h3><h4 id="157-zookeeper-是什么？">157.zookeeper 是什么？</h4><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><h4 id="158-zookeeper-都有哪些功能？">158.zookeeper 都有哪些功能？</h4><ul><li>集群管理：监控节点存活状态、运行请求等。</li><li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</li><li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</li><li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li></ul><h4 id="159-zookeeper-有几种部署模式？">159.zookeeper 有几种部署模式？</h4><p>zookeeper 有三种部署模式：</p><ul><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群运行；</li><li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li></ul><h4 id="160-zookeeper-怎么保证主从节点的状态同步？">160.zookeeper 怎么保证主从节点的状态同步？</h4><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><h4 id="161-集群中为什么要有主节点？">161.集群中为什么要有主节点？</h4><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h4 id="162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？">162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h4><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p><h4 id="163-说一下-zookeeper-的通知机制？">163.说一下 zookeeper 的通知机制？</h4><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p><h3 id="十七、MySql">十七、MySql</h3><h4 id="164-数据库的三范式是什么？">164.数据库的三范式是什么？</h4><ul><li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li><li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li><li>第三范式：任何非主属性不依赖于其它非主属性。</li></ul><h4 id="165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了一条数据，此时-id-是几？">165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</h4><ul><li>表类型如果是 MyISAM ，那 id 就是 8。</li><li>表类型如果是 InnoDB，那 id 就是 6。</li></ul><p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p><h4 id="166-如何获取当前数据库版本？">166.如何获取当前数据库版本？</h4><p>使用 select version() 获取当前 mysql 数据库版本。</p><h4 id="167-说一下-ACID-是什么？">167.说一下 ACID 是什么？</h4><ul><li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h4 id="168-char-和-varchar-的区别是什么？">168.char 和 varchar 的区别是什么？</h4><ul><li><strong>char(n)</strong> ：固定长度类型，比如订阅 char(10)，当你输入&quot;abc&quot;三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</li></ul><p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p><ul><li><strong>varchar(n)</strong> ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</li></ul><p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p><h4 id="169-float-和-double-的区别是什么？">169.float 和 double 的区别是什么？</h4><ul><li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</li><li>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</li></ul><h4 id="170-mysql-的内连接、左连接、右连接有什么区别？">170.mysql 的内连接、左连接、右连接有什么区别？</h4><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p><p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h4 id="171-mysql-索引是怎么实现的？">171.mysql 索引是怎么实现的？</h4><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p><p>具体来说 mysql 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h4 id="172-怎么验证-mysql-的索引是否满足需求？">172.怎么验证 mysql 的索引是否满足需求？</h4><p>使用 explain 查看 sql 是如何执行查询语句的，从而分析你的索引是否满足需求。</p><p>explain 语法：explain select * from table where type=1。</p><h4 id="173-说一下数据库的事务隔离？">173.说一下数据库的事务隔离？</h4><p>mysql 的事务隔离是在 mysql.ini 配置文件里添加的，在文件的最后添加：</p><blockquote><p>transaction-isolation = REPEATABLE-READ</p></blockquote><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><ul><li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li><li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li><li>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li><li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p><p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h4 id="174-说一下-mysql-常用的引擎？">174.说一下 mysql 常用的引擎？</h4><ul><li>InnoDB 引擎：mysql 5.1 之后默认引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。mysql 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</li><li>MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</li></ul><h4 id="175-说一下-mysql-的行锁和表锁？">175.说一下 mysql 的行锁和表锁？</h4><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><ul><li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li><li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li></ul><h4 id="176-说一下乐观锁和悲观锁？">176.说一下乐观锁和悲观锁？</h4><ul><li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li><li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li></ul><p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><h4 id="177-mysql-问题排查都有哪些手段？">177.mysql 问题排查都有哪些手段？</h4><ul><li>使用 show processlist 命令查看当前所有连接信息。</li><li>使用 explain 命令查询 sql 语句执行计划。</li><li>开启慢查询日志，查看慢查询的 sql。</li></ul><h4 id="178-如何做-mysql-的性能优化？">178.如何做 mysql 的性能优化？</h4><ul><li>为搜索字段创建索引。</li><li>避免使用 select *，列出需要查询的字段。</li><li>垂直分割分表。</li><li>选择正确的存储引擎。</li></ul><h3 id="十八、Redis">十八、Redis</h3><h4 id="179-redis-是什么？都有哪些使用场景？">179.redis 是什么？都有哪些使用场景？</h4><p>redis 是一个使用 C 语言开发的高速缓存数据库。</p><p>redis 使用场景：</p><ul><li>记录帖子点赞数、点击数、评论数；</li><li>缓存近期热帖；</li><li>缓存文章详情信息；</li><li>记录用户会话信息。</li></ul><h4 id="180-redis-有哪些功能？">180.redis 有哪些功能？</h4><ul><li>数据缓存功能</li><li>分布式锁的功能</li><li>支持数据持久化</li><li>支持事务</li><li>支持消息队列</li></ul><h4 id="181-redis-和-memcache-有什么区别？">181.redis 和 memcache 有什么区别？</h4><ul><li>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；redis 有部份存在硬盘上，这样能保证数据的持久性。</li><li>数据支持类型：memcache 对数据类型支持相对简单；redis 有复杂的数据类型。</li><li>使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>value 值大小不同：redis 最大可以达到 512mb；memcache 只有 1mb。</li></ul><h4 id="182-redis-为什么是单线程的？">182.redis 为什么是单线程的？</h4><p>因为 cpu 不是 redis 的瓶颈，redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu  又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><p>关于 redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p><h4 id="183-什么是缓存穿透？怎么解决？">183.什么是缓存穿透？怎么解决？</h4><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p><p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h4 id="184-redis-支持的数据类型有哪些？">184.redis 支持的数据类型有哪些？</h4><p>redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p><h4 id="185-redis-支持的-java-客户端都有哪些？">185.redis 支持的 java 客户端都有哪些？</h4><p>支持的 java 客户端有 redisson、jedis、lettuce 等。</p><h4 id="186-jedis-和-redisson-有哪些区别？">186.jedis 和 redisson 有哪些区别？</h4><ul><li>jedis：提供了比较全面的 redis 命令的支持。</li><li>redisson：实现了分布式和可扩展的 java 数据结构，与 jedis 相比 redisson 的功能相对简单，不支持排序、事务、管道、分区等 redis 特性。</li></ul><h4 id="187-怎么保证缓存和数据库数据的一致性？">187.怎么保证缓存和数据库数据的一致性？</h4><ul><li>合理设置缓存的过期时间。</li><li>新增、更改、删除数据库操作时同步更新 redis，可以使用事物机制来保证数据的一致性。</li></ul><h4 id="188-redis-持久化有几种方式？">188.redis 持久化有几种方式？</h4><p>redis 的持久化有两种方式，或者说有两种策略：</p><ul><li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</li><li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</li></ul><h4 id="189-redis-怎么实现分布式锁？">189.redis 怎么实现分布式锁？</h4><p>redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p><p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p><h4 id="190-redis-分布式锁有什么缺陷？">190.redis 分布式锁有什么缺陷？</h4><p>redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p><h4 id="191-redis-如何做内存优化？">191.redis 如何做内存优化？</h4><p>尽量使用 redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 web 系统的用户对象，应该放到散列表里面再整体存储到 redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p><h4 id="192-redis-淘汰策略有哪些？">192.redis 淘汰策略有哪些？</h4><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰。</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。</li><li>no-enviction（驱逐）：禁止驱逐数据。</li></ul><h4 id="193-redis-常见的性能问题有哪些？该如何解决？">193.redis 常见的性能问题有哪些？该如何解决？</h4><ul><li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li><li>redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li></ul><h3 id="十九、JVM">十九、JVM</h3><h4 id="194-说一下-jvm-的主要组成部分？及其作用？">194.说一下 jvm 的主要组成部分？及其作用？</h4><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><p><strong>组件的作用：</strong> 首先通过类加载器（ClassLoader）会把 java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 jvm 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><h4 id="195-说一下-jvm-运行时数据区？">195.说一下 jvm 运行时数据区？</h4><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 java 虚拟机规范， java 虚拟机规范规定的区域分为以下 5 个部分：</p><ul><li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li><li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li><li>Java 堆（Java Heap）：java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li><li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li></ul><h4 id="196-说一下堆栈的区别？">196.说一下堆栈的区别？</h4><ul><li>功能方面：堆是用来存放对象的，栈是用来执行程序的。</li><li>共享性：堆是线程共享的，栈是线程私有的。</li><li>空间大小：堆大小远远大于栈。</li></ul><h4 id="197-队列和栈是什么？有什么区别？">197.队列和栈是什么？有什么区别？</h4><p>队列和栈都是被用来预存储数据的。</p><p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</p><p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p><h4 id="198-什么是双亲委派模型？">198.什么是双亲委派模型？</h4><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 jvm 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 jvm 内存，然后再转化为 class 对象。</p><p>类加载器分类：</p><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载JAVA_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li><li>其他类加载器：<ul><li>扩展类加载器（Extension ClassLoader）：负责加载&lt;JAVA_HOME&gt;\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul></li></ul><p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><h4 id="199-说一下类装载的执行过程？">199.说一下类装载的执行过程？</h4><p>类装载分为以下 5 个步骤：</p><ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>检查：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul><h4 id="200-怎么判断对象是否可以被回收？">200.怎么判断对象是否可以被回收？</h4><p>一般有两种方法来判断：</p><ul><li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><h4 id="201-java-中都有哪些引用类型？">201.java 中都有哪些引用类型？</h4><ul><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li></ul><h4 id="202-说一下-jvm-有哪些垃圾回收算法？">202.说一下 jvm 有哪些垃圾回收算法？</h4><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul><h4 id="203-说一下-jvm-有哪些垃圾回收器？">203.说一下 jvm 有哪些垃圾回收器？</h4><ul><li>Serial：最早的单线程串行垃圾回收器。</li><li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li><li>ParNew：是 Serial 的多线程版本。</li><li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li><li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li><li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li><li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li></ul><h4 id="204-详细介绍一下-CMS-垃圾回收器？">204.详细介绍一下 CMS 垃圾回收器？</h4><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 jvm 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h4 id="205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？">205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h4><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><h4 id="206-简述分代垃圾回收器是怎么工作的？">206.简述分代垃圾回收器是怎么工作的？</h4><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><ul><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li></ul><p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h4 id="207-说一下-jvm-调优的工具？">207.说一下 jvm 调优的工具？</h4><p>jdk 自带了很多监控工具，都位于 jdk 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><ul><li>jconsole：用于对 jvm 中的内存、线程和类等进行监控；</li><li>jvisualvm：jdk 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ul><h4 id="208-常用的-jvm-调优的参数都有哪些？">208.常用的 jvm 调优的参数都有哪些？</h4><ul><li>-Xms2g：初始化推大小为 2g；</li><li>-Xmx2g：堆最大内存为 2g；</li><li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li><li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li><li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li><li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li><li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li><li>-XX:+PrintGC：开启打印 gc 信息；</li><li>-XX:+PrintGCDetails：打印 gc 详细信息。</li></ul><h2 id="结尾">结尾</h2><p>这不止是一份面试清单，更是一种“被期望的责任”，因为有无数个待面试着，希望从这篇文章中，找出通往期望公司的“钥匙”，所以上面的每道选题都是结合我自身的经验，于千万个面试题中经过艰辛的两周，一个题一个题筛选出来再校对好答案和格式做出来的，面试的答案也是再三斟酌，生怕误人子弟是小，影响他人的“仕途”才是大过，所以如有纰漏，还请读者朋友们在评论区不吝指出。</p><p>也希望您能把这篇文章分享给更多的朋友，让它帮助更多的人。</p>]]></content>
    
    
    <categories>
      
      <category>JavaInterview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaInterview-03</title>
    <link href="/dajiangdahe/2021/10/22/JavaInterview-03/"/>
    <url>/dajiangdahe/2021/10/22/JavaInterview-03/</url>
    
    <content type="html"><![CDATA[<h3 id="九、设计模式">九、设计模式</h3><h4 id="88-说一下你熟悉的设计模式？">88.说一下你熟悉的设计模式？</h4><ul><li>单例模式：保证被创建一次，节省系统开销。</li><li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li><li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li><li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li><li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li><li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li></ul><h4 id="89-简单工厂和抽象工厂有什么区别？">89.简单工厂和抽象工厂有什么区别？</h4><ul><li>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</li><li>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</li><li>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</li></ul><h3 id="十、Spring-Spring-MVC">十、Spring/Spring MVC</h3><h4 id="90-为什么要使用-spring？">90.为什么要使用 spring？</h4><ul><li>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</li><li>spring 提供了事务支持，使得事务操作变的更加方便。</li><li>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</li><li>更方便的框架集成，spring 可以很方便的集成其他框架，比如 mybatis、hibernate 等。</li><li>方便程序的测试，提供了对Junit4的支持。</li></ul><h4 id="91-解释一下什么是-aop？">91.解释一下什么是 aop？</h4><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p><p>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p><h4 id="92-解释一下什么是-ioc？">92.解释一下什么是 ioc？</h4><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</p><p>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p><h4 id="93-spring-有哪些主要模块？">93.spring 有哪些主要模块？</h4><ul><li>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</li><li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li><li>spring dao：Data Access Object 提供了JDBC的抽象层。</li><li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li><li>spring web：提供了针对 web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 web 的 ApplicationContext。</li><li>spring web mvc：spring 中的 mvc 封装包提供了 web 应用的 Model-View-Controller（MVC）的实现。</li></ul><h4 id="94-spring-常用的注入方式有哪些？">94.spring 常用的注入方式有哪些？</h4><ul><li>setter 属性注入</li><li>构造方法注入</li><li>注解方式注入</li></ul><h4 id="95-spring-中的-bean-是线程安全的吗？">95.spring 中的 bean 是线程安全的吗？</h4><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p><p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p><ul><li>有状态就是有数据存储功能。</li><li>无状态就是不会保存数据。</li></ul><h4 id="96-spring-支持几种-bean-的作用域？">96.spring 支持几种 bean 的作用域？</h4><p>spring 支持 5 种作用域，如下：</p><ul><li>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</li><li>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</li><li>Web 环境下的作用域：<ul><li>request：每次 http 请求都会创建一个 bean；</li><li>session：同一个 http session 共享一个 bean 实例；</li><li>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</li></ul></li></ul><p><strong>注意：</strong> 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h4 id="97-spring-自动装配-bean-有哪些方式？">97.spring 自动装配 bean 有哪些方式？</h4><ul><li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li><li>byName：它根据 bean 的名称注入对象依赖项。</li><li>byType：它根据类型注入对象依赖项。</li><li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</li><li>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</li></ul><h4 id="98-spring-事务实现方式有哪些？">98.spring 事务实现方式有哪些？</h4><ul><li>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</li><li>编码方式：提供编码的形式管理和维护事务。</li></ul><h4 id="99-说一下-spring-的事务隔离？">99.说一下 spring 的事务隔离？</h4><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p><p>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p><p>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），sql server 的默认级别；</p><p>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），mysql 的默认级别；</p><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p><p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p><p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h4 id="100-说一下-spring-mvc-运行流程？">100.说一下 spring mvc 运行流程？</h4><ul><li>spring mvc 先将请求发送给 DispatcherServlet。</li><li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li><li>DispatcherServlet 再把请求提交到对应的 Controller。</li><li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li><li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li><li>视图对象负责渲染返回给客户端。</li></ul><h4 id="101-spring-mvc-有哪些组件？">101.spring mvc 有哪些组件？</h4><ul><li>前置控制器 DispatcherServlet。</li><li>映射控制器 HandlerMapping。</li><li>处理器 Controller。</li><li>模型和视图 ModelAndView。</li><li>视图解析器 ViewResolver。</li></ul><h4 id="102-RequestMapping-的作用是什么？">102.@RequestMapping 的作用是什么？</h4><p>将 http 请求映射到相应的类/方法上。</p><h4 id="103-Autowired-的作用是什么？">103.@Autowired 的作用是什么？</h4><p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p><h3 id="十一、Spring-Boot-Spring-Cloud">十一、Spring Boot/Spring Cloud</h3><h4 id="104-什么是-spring-boot？">104.什么是 spring boot？</h4><p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p><h4 id="105-为什么要用-spring-boot？">105.为什么要用 spring boot？</h4><ul><li>配置简单</li><li>独立运行</li><li>自动装配</li><li>无代码生成和 xml 配置</li><li>提供应用监控</li><li>易上手</li><li>提升开发效率</li></ul><h4 id="106-spring-boot-核心配置文件是什么？">106.spring boot 核心配置文件是什么？</h4><p>spring boot 核心的两个配置文件：</p><ul><li>bootstrap (.yml 或者 .properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</li><li>application (.yml 或者 .properties)：用于 spring boot 项目的自动化配置。</li></ul><h4 id="107-spring-boot-配置文件有哪几种类型？它们有什么区别？">107.spring boot 配置文件有哪几种类型？它们有什么区别？</h4><p>配置文件有 .properties 格式和 .yml 格式，它们主要的区别是书法风格不同。</p><p>.properties 配置如下：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">spring</span>.rabbitmq.<span class="hljs-keyword">port</span>=5672<br><br></code></pre></td></tr></table></figure><p>.yml 配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">rabbitmq:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br><br></code></pre></td></tr></table></figure><p>.yml 格式不支持 @PropertySource 注解导入。</p><h4 id="108-spring-boot-有哪些方式可以实现热部署？">108.spring boot 有哪些方式可以实现热部署？</h4><ul><li>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring.devtools.restart.enabled 设置为 true；</li><li>使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</li></ul><h4 id="109-jpa-和-hibernate-有什么区别？">109.jpa 和 hibernate 有什么区别？</h4><p>jpa 全称 Java Persistence API，是 java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p><h4 id="110-什么是-spring-cloud？">110.什么是 spring cloud？</h4><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p><h4 id="111-spring-cloud-断路器的作用是什么？">111.spring cloud 断路器的作用是什么？</h4><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p><h4 id="112-spring-cloud-的核心组件有哪些？">112.spring cloud 的核心组件有哪些？</h4><ul><li>Eureka：服务注册于发现。</li><li>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</li><li>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</li><li>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li><li>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</li></ul><h3 id="十二、Hibernate">十二、Hibernate</h3><h4 id="113-为什么要使用-hibernate？">113.为什么要使用 hibernate？</h4><ul><li>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。</li><li>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。</li><li>可以很方便的进行数据库的移植工作。</li><li>提供了缓存机制，是程序执行更改的高效。</li></ul><h4 id="114-什么是-ORM-框架？">114.什么是 ORM 框架？</h4><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</p><p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p><h4 id="115-hibernate-中如何在控制台查看打印的-sql-语句？">115.hibernate 中如何在控制台查看打印的 sql 语句？</h4><p>在 Config 里面把 hibernate.show_sql 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p><h4 id="116-hibernate-有几种查询方式？">116.hibernate 有几种查询方式？</h4><p>三种：hql、原生 sql、条件查询 Criteria。</p><h4 id="117-hibernate-实体类可以被定义为-final-吗？">117.hibernate 实体类可以被定义为 final 吗？</h4><p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p><h4 id="118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？">118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h4><p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p><h4 id="119-hibernate-是如何工作的？">119.hibernate 是如何工作的？</h4><ul><li>读取并解析配置文件。</li><li>读取并解析映射文件，创建 SessionFactory。</li><li>打开 Session。</li><li>创建事务。</li><li>进行持久化操作。</li><li>提交事务。</li><li>关闭 Session。</li><li>关闭 SessionFactory。</li></ul><h4 id="120-get-和-load-的区别？">120.get()和 load()的区别？</h4><ul><li>数据查询时，没有 OID 指定的对象，get()返回 null；load()返回一个代理对象。</li><li>load()支持延迟加载；get()不支持延迟加载。</li></ul><h4 id="121-说一下-hibernate-的缓存机制？">121.说一下 hibernate 的缓存机制？</h4><p>hibernate 常用的缓存有一级缓存和二级缓存：</p><p>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</p><p>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p><h4 id="122-hibernate-对象有哪些状态？">122.hibernate 对象有哪些状态？</h4><ul><li>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</li><li>持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。</li><li>游离状态：Session 关闭之后对象就是游离状态。</li></ul><h4 id="123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？">123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h4><ul><li>getCurrentSession 会绑定当前线程，而 openSession 则不会。</li><li>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</li></ul><h4 id="124-hibernate-实体类必须要有无参构造函数吗？为什么？">124.hibernate 实体类必须要有无参构造函数吗？为什么？</h4><p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p><h3 id="十三、Mybatis">十三、Mybatis</h3><h4 id="125-mybatis-中-和-的区别是什么？">125.mybatis 中 #{}和 ${}的区别是什么？</h4><p>#{}是预编译处理，${}是字符替换。<br>在使用 #{}时，mybatis 会将 sql 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 sql 注入，保证程序的运行安全。</p><h4 id="126-mybatis-有几种分页方式？">126.mybatis 有几种分页方式？</h4><p>分页方式：逻辑分页和物理分页。</p><p><strong>1).逻辑分页：</strong> 使用 mybatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p><p><strong>2).物理分页：</strong> 自己手写 sql 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p><h4 id="127-RowBounds-是一次性查询全部结果吗？为什么？">127.RowBounds 是一次性查询全部结果吗？为什么？</h4><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 mybatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p><p>Fetch Size 官方相关文档：<a href="http://t.cn/EfSE2g3">http://t.cn/EfSE2g3</a></p><h4 id="128-mybatis-逻辑分页和物理分页的区别是什么？">128.mybatis 逻辑分页和物理分页的区别是什么？</h4><ul><li>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</li><li>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</li></ul><h4 id="129-mybatis-是否支持延迟加载？延迟加载的原理是什么？">129.mybatis 是否支持延迟加载？延迟加载的原理是什么？</h4><p>mybatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</p><p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a.getB().getName()，这个时候发现 a.getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 sql，先查询出来 B，然后再调用 a.setB(b)，而这时候再调用 a.getB().getName() 就有值了，这就是延迟加载的基本原理。</p><h4 id="130-说一下-mybatis-的一级缓存和二级缓存？">130.说一下 mybatis 的一级缓存和二级缓存？</h4><ul><li>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 sqlSession  一致的，有多个 sqlSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</li><li>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个sqlSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。</li></ul><p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><p>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h4 id="131-mybatis-和-hibernate-的区别有哪些？">131.mybatis 和 hibernate 的区别有哪些？</h4><ul><li>灵活性：mybatis 更加灵活，自己可以写 sql 语句，使用起来比较方便。</li><li>可移植性：mybatis 有很多自己写的 sql，因为每个数据库的 sql 可以不相同，所以可移植性比较差。</li><li>学习和使用门槛：mybatis 入门比较简单，使用门槛也更低。</li><li>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</li></ul><h4 id="132-mybatis-有哪些执行器（Executor）？">132.mybatis 有哪些执行器（Executor）？</h4><p>mybatis 有三种基本的Executor执行器：</p><ul><li>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</li><li>ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</li><li>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</li></ul><h4 id="133-mybatis-分页插件的实现原理是什么？">133.mybatis 分页插件的实现原理是什么？</h4><p>分页插件的基本原理是使用 mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><h4 id="134-mybatis-如何编写一个自定义插件？">134.mybatis 如何编写一个自定义插件？</h4><p><strong>1).自定义插件实现原理</strong></p><p>mybatis 自定义插件针对 mybatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p><ul><li>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</li><li>StatementHandler：拦截 sql 语法构建的处理，它是 mybatis 直接和数据库执行 sql 脚本的对象，另外它也实现了 mybatis 的一级缓存；</li><li>ParameterHandler：拦截参数的处理；</li><li>ResultSetHandler：拦截结果集的处理。</li></ul><p><strong>2).自定义插件实现关键</strong></p><p>mybatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interceptor</span> </span>&#123;   <br>   <span class="hljs-function">Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable</span>;       <br>   <span class="hljs-function">Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span></span>;    <br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>setProperties 方法是在 mybatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</li><li>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin.wrap(target, this)；</li><li>intercept 方法就是要进行拦截的时候要执行的方法。</li></ul><p><strong>3).自定义插件实现示例</strong></p><p>官方插件实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(type = Executor.class, method = &quot;query&quot;,</span><br><span class="hljs-meta">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>     Object target = invocation.getTarget(); <span class="hljs-comment">//被代理对象</span><br>     Method method = invocation.getMethod(); <span class="hljs-comment">//代理方法</span><br>     Object[] args = invocation.getArgs(); <span class="hljs-comment">//方法参数</span><br>     <span class="hljs-comment">// do something ...... 方法拦截前执行代码块</span><br>     Object result = invocation.proceed();<br>     <span class="hljs-comment">// do something .......方法拦截后执行代码块</span><br>     <span class="hljs-keyword">return</span> result;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="十四、RabbitMQ">十四、RabbitMQ</h3><h4 id="135-rabbitmq-的使用场景有哪些？">135.rabbitmq 的使用场景有哪些？</h4><ul><li>抢购活动，削峰填谷，防止系统崩塌。</li><li>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。</li><li>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</li></ul><h4 id="136-rabbitmq-有哪些重要的角色？">136.rabbitmq 有哪些重要的角色？</h4><p>rabbitmq 中重要的角色有：生产者、消费者和代理：</p><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li><li>消费者：消息的接收方，用于处理数据和确认消息；</li><li>代理：就是 rabbitmq 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h4 id="137-rabbitmq-有哪些重要的组件？">137.rabbitmq 有哪些重要的组件？</h4><ul><li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li><li>Channel（信道）：消息推送使用的通道。</li><li>Exchange（交换器）：用于接受、分配消息。</li><li>Queue（队列）：用于存储生产者的消息。</li><li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li><li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li></ul><h4 id="138-rabbitmq-中-vhost-的作用是什么？">138.rabbitmq 中 vhost 的作用是什么？</h4><p>vhost：每个 rabbitmq 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的rabbitmq，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><h4 id="139-rabbitmq-的消息是怎么发送的？">139.rabbitmq 的消息是怎么发送的？</h4><p>首先客户端必须连接到 rabbitmq 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 rabbitmq 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><h4 id="140-rabbitmq-怎么保证消息的稳定性？">140.rabbitmq 怎么保证消息的稳定性？</h4><ul><li>提供了事务的功能。</li><li>通过将 channel 设置为 confirm（确认）模式。</li></ul><h4 id="141-rabbitmq-怎么避免消息丢失？">141.rabbitmq 怎么避免消息丢失？</h4><ul><li>把消息持久化磁盘，保证服务器重启消息不丢失。</li><li>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</li></ul><h4 id="142-要保证消息持久化成功的条件有哪些？">142.要保证消息持久化成功的条件有哪些？</h4><ul><li>声明队列必须设置持久化 durable 设置为 true.</li><li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li><li>消息已经到达持久化交换器。</li><li>消息已经到达持久化队列。</li></ul><p>以上四个条件都满足才能保证消息持久化成功。</p><h4 id="143-rabbitmq-持久化有什么缺点？">143.rabbitmq 持久化有什么缺点？</h4><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p><h4 id="144-rabbitmq-有几种广播类型？">144.rabbitmq 有几种广播类型？</h4><ul><li>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</li><li>headers：与 direct 类似，只是性能很差，此类型几乎用不到。</li><li>fanout：分发模式，把消费分发给所有订阅者。</li><li>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</li></ul><h4 id="145-rabbitmq-怎么实现延迟消息队列？">145.rabbitmq 怎么实现延迟消息队列？</h4><p>延迟队列的实现有两种方式：</p><ul><li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li><li>使用 rabbitmq-delayed-message-exchange 插件实现延迟功能。</li></ul><h4 id="146-rabbitmq-集群有什么用？">146.rabbitmq 集群有什么用？</h4><p>集群主要有以下两个用途：</p><ul><li>高可用：某个服务器出现问题，整个 rabbitmq 还可以继续使用；</li><li>高容量：集群可以承载更多的消息量。</li></ul><h4 id="147-rabbitmq-节点的类型有哪些？">147.rabbitmq 节点的类型有哪些？</h4><ul><li>磁盘节点：消息会存储到磁盘。</li><li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li></ul><h4 id="148-rabbitmq-集群搭建需要注意哪些问题？">148.rabbitmq 集群搭建需要注意哪些问题？</h4><ul><li>各节点之间使用“–link”连接，此属性不能忽略。</li><li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li><li>整个集群中必须包含一个磁盘节点。</li></ul><h4 id="149-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？">149.rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</h4><p>不是，原因有以下两个：</p><ul><li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li><li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li></ul><h4 id="150-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？">150.rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h4><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p><h4 id="151-rabbitmq-对集群节点停止顺序有要求吗？">151.rabbitmq 对集群节点停止顺序有要求吗？</h4><p>rabbitmq 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p>]]></content>
    
    
    <categories>
      
      <category>JavaInterview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaInterview-02</title>
    <link href="/dajiangdahe/2021/10/22/JavaInterview-02/"/>
    <url>/dajiangdahe/2021/10/22/JavaInterview-02/</url>
    
    <content type="html"><![CDATA[<h3 id="四、反射">四、反射</h3><h4 id="57-什么是反射？">57.什么是反射？</h4><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><h4 id="58-什么是-java-序列化？什么情况下需要序列化？">58.什么是 java 序列化？什么情况下需要序列化？</h4><p>java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</p><p>以下情况需要使用 java 序列化：</p><ul><li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>想用套接字在网络上传送对象的时候；</li><li>想通过RMI（远程方法调用）传输对象的时候。</li></ul><h4 id="59-动态代理是什么？有哪些应用？">59.动态代理是什么？有哪些应用？</h4><p>在运行时提供了一系列的API来访问系统里面的对象和类的信息。</p><p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，java注解对象获取等。</p><p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合，入口是Proxy。</p><h4 id="60-怎么实现动态代理？">60.怎么实现动态代理？</h4><p>jdk 原生动态代理和 cglib 动态代理。jdk 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代理类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span></span>&#123;<br>    <span class="hljs-comment">//解决问题1：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxyInstance</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>        <span class="hljs-comment">//obj:被代理类</span><br>        <span class="hljs-comment">//解决问题2：当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法</span><br>        MyInvocationHandler handler = <span class="hljs-keyword">new</span> MyInvocationHandler();<br>        handler.bind(obj);<br><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),handler);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Object object;<span class="hljs-comment">//需要使用被代理类的对象进行赋值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(Object object)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.object = object;<br>    &#125;<br>    <span class="hljs-comment">//当我们通过代理类的对象时，调用方法a，就会跑到下面来调用invoke()。</span><br>    <span class="hljs-comment">//将被代理类要执行的方法a声明带invoke中</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">//代理类对象调用的方法，也是被代理类即将调用的方法。</span><br>        <span class="hljs-comment">//object:被代理类对象</span><br>        Object returnValue = method.invoke(object, args);<br>        <span class="hljs-comment">//上述方法的返回值就是作为当前类中的invoke（）值</span><br>        <span class="hljs-keyword">return</span> returnValue;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="五、对象拷贝">五、对象拷贝</h3><h4 id="61-为什么要使用克隆？">61.为什么要使用克隆？</h4><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p><h4 id="62-如何实现对象克隆？">62.如何实现对象克隆？</h4><ul><li>实现 Cloneable 接口并重写 Object 类中的 clone()方法。</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li></ul><h4 id="63-深拷贝和浅拷贝区别是什么？">63.深拷贝和浅拷贝区别是什么？</h4><ul><li>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</li><li>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</li></ul><h3 id="六、Java-Web">六、Java Web</h3><h4 id="64-jsp-和-servlet-有什么区别？">64.jsp 和 servlet 有什么区别？</h4><ol><li>Servlet是一种服务器端的Java程序，担当客户端请求与服务器端响应的中间层。Servlet由web服务器端进行加载。</li><li>JSP是一种动态页面设计，主要目的是将表示逻辑从Servlet中分离出来。</li></ol><p>jsp 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 jsp 最主要的不同点在于，servlet 的应用逻辑是在 java 文件中，并且完全从表示层中的 html 里分离开来，而 jsp 的情况是 java 和 html 可以组合成一个扩展名为 jsp 的文件。jsp代码经过web容器的编译就能变成JVM识别的java类。</p><ol><li>jsp 侧重于视图，servlet 主要用于控制逻辑</li><li>JSP中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</li></ol><h4 id="65-jsp-有哪些内置对象？作用分别是什么？">65.jsp 有哪些内置对象？作用分别是什么？</h4><p>jsp 有 9 大内置对象：</p><ul><li>HttpServletRequet类的Request对象：代表请求对象，主要用于接受客户端通过HTTP协议连接传输服务器端的数据；</li><li>HttpSevletResponse类的Response对象：代表响应对象，主要用于向客户端发送数据；</li><li>PageContext类的PageContext对象：管理网页属性，为jsp页面包装页面的上下文，管理对属于jsp的特殊可见部分中已经命名对象的访问，它的创建和初始化都是由容器来完成的；</li><li>HttpSession类的session对象：主要用来分别保存每个月的信息与请求关联的会话；会话状态的维持是web应用开发者必须面对的问题；</li><li>ServletContext类的application对象：主要用于保存用户信息，代码片段的运行环境；它是一个共享的内置对象，即一个容器中的多个用户共享一个application；</li><li>JspWriter类的out对象：主要用于向客户端输出数据，out的基类是jspWriter；</li><li>ServletConfig类的Config对象：代码片段配置对象，标识Servlet的配置；</li><li>Object类的Page对象：处理jsp页面，是object类的一个实例，指的是jsp实现类的实例；</li><li>Exception：处理jsp文件执行时发生的错误和异常，只有在错误页面里才使用，前提是在页面指令里要有isErrorPage=true。。</li></ul><h4 id="66-说一下-jsp-的-4-种作用域？">66.说一下 jsp 的 4 种作用域？</h4><ul><li>page：代表与一个页面相关的对象和属性。</li><li>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 web 组件；需要在页面显示的临时数据可以置于此作用域。</li><li>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</li><li>application：代表与整个 web 应用程序相关的对象和属性，它实质上是跨越整个 web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul><h4 id="67-session-和-cookie-有什么区别？">67.session 和 cookie 有什么区别？</h4><ul><li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</li><li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li><li>容量和个数限制：cookie 有容量限制&lt;=4KB，一个站点下的 cookie 最多存20个cookie。</li><li>存储的多样性：session 可以存储在 redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</li><li>有效期不同：开发可以通过设置cookie的属性，达到使cookie长期有效的效果。session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</li><li>跨域支持上不同：cookie支持跨域访问，session不支持跨域访问。</li></ul><h4 id="68-说一下-session-的工作原理？">68.说一下 session 的工作原理？</h4><p><img src="https://img-blog.csdnimg.cn/20200422094415521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2MTg0MDc1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>执行流程：</p><ol><li>第一次请求，请求头中没有jsessionid的cookie，当访问到对应的servlet资源时，执行到getSession()会创建HttpSession对象；进而响应时就将session的id作为cookie的value，响应到浏览器 Set-cookie:jsessionid=xxxx;</li><li>再一次请求时，http请求中就有一个cookie:jsessionid=xxxx信息，那么该servlet就可以通过getSession()获取到jsessionid在服务器内查找对应的session对象，有就使用，无就创建。</li></ol><p>生命周期：</p><p>​一般都是默认30min，取决于tomcat中的web.xml文件里的设置</p><p>​结束时机：</p><ul><li>浏览器关闭：销毁cookie中的jsessionid=xxx</li><li>session销毁：主动调用session.invalidate()方法后，立即将session对象销毁。</li></ul><h4 id="69-如果客户端禁止-cookie-能实现-session-还能用吗？">69.如果客户端禁止 cookie 能实现 session 还能用吗？</h4><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p><h4 id="70-spring-mvc-和-struts-的区别是什么？">70.spring mvc 和 struts 的区别是什么？</h4><ul><li>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。</li><li>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</li><li>拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。</li><li>对 ajax 的支持：spring mvc 集成了ajax，所以 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</li></ul><h4 id="71-如何避免-sql-注入？">71.如何避免 sql 注入？</h4><ul><li>使用预处理 PreparedStatement。</li><li>使用正则表达式过滤掉字符中的特殊字符。</li></ul><h4 id="72-什么是-XSS-攻击，如何避免？">72.什么是 XSS 攻击，如何避免？</h4><p>XSS 攻击：即跨站脚本攻击，它是 web 程序中常见的漏洞。原理是攻击者往 web 页面里插入恶意的脚本代码（css 代码、javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p><p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p><h4 id="73-什么是-CSRF-攻击，如何避免？">73.什么是 CSRF 攻击，如何避免？</h4><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p><p>防御手段：</p><ul><li>验证请求来源地址；</li><li>关键操作添加验证码；</li><li>在请求地址添加 token 并验证。</li></ul><h3 id="七、异常">七、异常</h3><h4 id="74-throw-和-throws-的区别？">74.throw 和 throws 的区别？</h4><ul><li>throw：是真实抛出一个异常。</li><li>throws：是声明可能会抛出一个异常。</li></ul><h4 id="75-final、finally、finalize-有什么区别？">75.final、finally、finalize 有什么区别？</h4><ul><li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li><li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li><li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li></ul><h4 id="76-try-catch-finally-中哪个部分可以省略？">76.try-catch-finally 中哪个部分可以省略？</h4><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p><h4 id="77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？">77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h4><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p><h4 id="78-常见的异常类有哪些？">78.常见的异常类有哪些？</h4><ul><li>NullPointerException 空指针异常</li><li>ClassNotFoundException 指定类不存在</li><li>NumberFormatException 字符串转换为数字异常</li><li>IndexOutOfBoundsException 数组下标越界异常</li><li>ClassCastException 数据类型转换异常</li><li>FileNotFoundException 文件未找到异常</li><li>NoSuchMethodException 方法不存在异常</li><li>IOException IO 异常</li><li>SocketException Socket 异常</li></ul><h3 id="八、网络">八、网络</h3><h4 id="79-http-响应码-301-和-302-代表的是什么？有什么区别？">79.http 响应码 301 和 302 代表的是什么？有什么区别？</h4><p>301：永久重定向。</p><p>302：暂时重定向。</p><p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p><h4 id="80-forward-和-redirect-的区别？">80.forward 和 redirect 的区别？</h4><p>forward 是转发 和 redirect 是重定向：</p><ul><li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li><li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li><li>效率：forward 比 redirect 效率高。</li></ul><h4 id="81-简述-tcp-和-udp的区别？">81.简述 tcp 和 udp的区别？</h4><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p><p>两者的区别大致如下：</p><ul><li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li><li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li><li>tcp 面向字节流，udp 面向报文；</li><li>tcp 数据传输慢，udp 数据传输快；</li></ul><ol><li><p><strong>TCP详解</strong></p><p><a href="https://blog.csdn.net/sinat_36629696/article/details/80740678">https://blog.csdn.net/sinat_36629696/article/details/80740678</a></p><p><img src="https://img-blog.csdn.net/20180620002403691?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Alt text"></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">URG:</span> 标识紧急指针是否有效<br><span class="hljs-symbol">ACK:</span> 标识确认序号是否有效<br><span class="hljs-symbol">PSH:</span> 用来提示接收端应用程序立刻将数据从tcp缓冲区读走<br><span class="hljs-symbol">RST:</span> 要求重新建立连接. 我们把含有RST标识的报文称为复位报文段<br><span class="hljs-symbol">SYN:</span> 请求建立连接. 我们把含有SYN标识的报文称为同步报文段<br><span class="hljs-symbol">FIN:</span> 通知对端, 本端即将关闭. 我们把含有FIN标识的报文称为结束报文段<br></code></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C13126%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210517141753451.png" alt="image-20210517141753451"><strong>三次握手过程原理</strong>：</p><ul><li>TCP服务器进程先创建传输控制块TCB, 时刻准备接受客户端进程的连接请求, 此时服务器就进入了 LISTEN（监听）状态</li><li>TCP客户端进程也是先创建传输控制块TCB, 然后向服务器发出连接请求报文，此时报文首部中的同步标志位SYN=1, 同时选择一个初始序列号 seq = x, 此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定, SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li><li>TCP服务器收到请求报文后, 如果同意连接, 则发出确认报文。确认报文中的 ACK=1, SYN=1, 确认序号是 x+1, 同时也要为自己初始化一个序列号 seq = y, 此时, TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据, 但是同样要消耗一个序号。</li><li>TCP客户端进程收到确认后还, 要向服务器给出确认。确认报文的ACK=1，确认序号是 y+1，自己的序列号是 x+1</li><li>此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li></ul><p><img src="C:%5CUsers%5C13126%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210517143200048.png" alt="image-20210517143200048"></p><p><strong>四次挥手过程原理</strong>：</p><p>数据传输完毕后，双方都可以释放连接.<br>此时客户端和服务器都是处于ESTABLISHED状态，然后客户端主动断开连接，服务器被动断开连接.</p><ul><li>客户端进程发出连接释放报文，并且停止发送数据。<br>释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK=1，确认序号为 u+1，并且带上自己的序列号seq=v，此时服务端就进入了CLOSE-WAIT（关闭等待）状态。<br>TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最终数据）</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，确认序号为v+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，确认序号为w+1，而自己的序列号是u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ul></li><li><p><strong>tcp在四次挥手时，为什么还要等待2*MSL秒呢？</strong></p><ol><li>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</li><li>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li><li>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li></ol></li><li><p><strong>tcp关闭连接为什么会比建立连接多一次呢？</strong></p><ol><li>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</li></ol></li><li><p><strong>如果已经建立了连接，但是客户端又发生了故障怎么办？</strong></p><ol><li>TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</li></ol></li><li><p><strong>拥塞控制</strong></p><ol><li>TCP引入慢启动机制，先发少量的数据探探路，摸清当前的网络拥堵情况以后，在按照多大的速度传输数据。</li><li>拥塞窗口：每接收到一次ACK应答，拥塞窗口大小+1</li><li>慢启动阈值：当拥塞窗口达到阈值的时候，改为线性增加的方式。当TCP启动的时候，慢启动阈值等于窗口最大值。在每次超时重发的时候，慢启动阈值会变为原来的一半，同时拥塞窗口置为1</li></ol></li></ol><h4 id="82-tcp-为什么要三次握手，两次不行吗？为什么？">82.tcp 为什么要三次握手，两次不行吗？为什么？</h4><p>​      主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的费。<br>​     如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h4 id="83-tcp粘包产生的原因？">83.tcp粘包产生的原因？</h4><p>粘包：指的是应用层的数据包，指的是站在应用层的角度，看到了发来的一连串的字节数据，就不知道从哪个部分开始，到哪个部分结束是一个完整的应用数据包。此时数据没有了边界，就产生了粘包问题。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">对于定长的包<br><span class="hljs-bullet">- </span>保证每次都按固定大小读取即可<br>例如上面的Request结构, 是固定大小的, 那么就从缓冲区从头开始按sizeof(Request)依次读取即可<br><br>对于变长的包<br><span class="hljs-bullet">- </span>可以在数据包的头部, 约定一个数据包总长度的字段, 从而就知道了包的结束位置<br>还可以在包和包之间使用明确的分隔符来作为边界(应用层协议, 是程序员自己来定的, 只要保证分隔符不和正文冲突即可)<br></code></pre></td></tr></table></figure><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p><ul><li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li><li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li></ul><h4 id="84-OSI-的七层模型都有哪些？">84.OSI 的七层模型都有哪些？</h4><ul><li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li><li>数据链路层：负责建立和管理节点间的链路。</li><li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li><li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li><li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li><li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li><li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li></ul><h4 id="85-get-和-post-请求有哪些区别？">85.get 和 post 请求有哪些区别？</h4><ul><li>在浏览器进行回退操作时,get请求是无害的,而post请求则会重新请求一次</li><li>get请求参数是连接在url后面的,而post请求参数是存放在requestbody内的</li><li>get请求因为浏览器对url长度有限制(不同浏览器长度限制不一样)对传参数量有限制,而post请求因为参数存放在requestbody内所以参数数量没有限制(事实上get请求也能在requestbody内携带参数,只不过不符合规定,有的浏览器能够获取到数据,而有的不能)</li><li>因为get请求参数暴露在url上,所以安全方面post比get更加安全</li><li>get请求浏览器会主动cache,post并不会,除非主动设置</li><li>get请求参数会保存在浏览器历史记录内,post请求并不会</li><li>get请求只能进行url编码,而post请求可以支持多种编码方式</li><li>get请求产生1个tcp数据包,post请求产生2个tcp数据包</li><li>==浏览器在发送get请求时会将header和data一起发送给服务器,服务器返回200状态码,而在发送post请求时,会先将header发送给服务器,服务器返回100,之后再将data发送给服务器,服务器返回200 OK==</li></ul><h4 id="86-如何实现跨域？">86.如何实现跨域？</h4><p>跨域：当浏览器执行脚本时会检查是否同源，只有同源的脚本才会执行，如果不同源即为跨域。</p><ul><li><p>这里的同源指访问的协议、域名、端口都相同。</p></li><li><p>同源策略是由 Netscape 提出的著名安全策略，是浏览器最核心、基本的安全功能，它限制了一个源中加载脚本与来自其他源中资源的交互方式。</p></li><li><p>Ajax 发起的跨域 HTTP 请求，结果被浏览器拦截，同时 Ajax 请求不能携带与本网站不同源的 Cookie。</p></li><li><script> <img> <iframe> <link> <video> <audio> 等带有 src 属性的标签可以从不同的域加载和执行资源<script> <img> <iframe> <link> <video> <audio> 等带有 src 属性的标签可以从不同的域加载和执行资</li></ul><p>实现跨域有以下几种方案：</p><ul><li>服务器端运行跨域 设置 CORS（Cross-Origin Resource Sharing）跨域资源共享 等于 *；<ul><li>当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头 origin；</li><li>后端在接受到请求后确定响应后会在后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin；</li><li>浏览器判断响应中的 Access-Control-Allow-Origin 值是否和当前的地址相同，匹配成功后才继续响应处理，否则报错</li></ul></li><li>在单个接口使用注解 @CrossOrigin 运行跨域；</li><li>使用 jsonp 跨域；利用了scripts不受同源策略的限制</li></ul><h4 id="87-说一下-JSONP-实现原理？">87.说一下 JSONP 实现原理？</h4><p>jsonp：JSON with Padding，它是利用<script>标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p><h4 id="88-HTTP响应类型有哪几种？">88.HTTP响应类型有哪几种？</h4><ol><li>消息响应：100（继续）、101（切换协议）</li><li>成功响应：200（成功）</li><li>重定向：301（永久移动）表示所请求的URI资源路径已经改变,新的URL会在响应的<code>Location</code>:头字段里找到.）、302（临时移动）==http0.9==、307（临时重定向）、308（永久重定向） ==http1.1==，区别 307、308必须是两次相同请求访问。</li><li>客户端错误：400（错误请求）、401（未授权）、403（禁止访问）、404（请求资源找不到）、405（不允许使用此方法）、408（请求超时）</li><li>服务器端错误：500（内部服务器错误）、501（服务器不支持使用的方法，如put、delete）、502（网关错误）、503（服务不可用）</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaInterview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaInterview-01</title>
    <link href="/dajiangdahe/2021/10/22/JavaInterview-01/"/>
    <url>/dajiangdahe/2021/10/22/JavaInterview-01/</url>
    
    <content type="html"><![CDATA[<h2 id="初心">初心</h2><p>在本篇文章开始之前，我想先来回答一个问题：我为什么要写这样一篇关于面试的文章？原因有三个：第一，我想为每一个为梦想时刻准备着的“有心人”，尽一份自己的力量，提供一份高度精华的 java 面试清单；第二，目前市面上的面试题不是答案不准确就是内容覆盖面太窄，所以提供一份经典而又准确的面试题是非常有必要的；第三，本文会对部分面试题提供详细解读和代码案例，让读者知其然并知其所以然，从而学到更多的知识。</p><p>或许这份面试题还不足以囊括所有 java 问题，但有了它，我相信你一定不会“败”的很惨，因为有了它，足以应对目前市面上绝大部分的 java 面试了，因为这篇文章不论是从深度还是广度上来讲，都已经囊括了非常多的知识点了。</p><p>凡事预则立，不预则废。能读到这里的人，我相信都是这个世界上的“有心人”，还是那句老话：上天不负有心人！我相信你的每一步努力，都会收获意想不到的回报。</p><h2 id="适宜阅读人群">适宜阅读人群</h2><ul><li>准备跳槽的初/中/高级 Java 程序员</li><li>想要查漏补缺的人</li><li>想要不断完善和扩充自己 Java 技术栈的人</li><li>Java 面试官</li></ul><h2 id="阅读建议">阅读建议</h2><p>本文会按技能模块划分文章段落，每个模块里的内容，从易到难依次进行排序，各模块之间不存在互相关联的关系，读者可选择文章顺序阅读或者跳跃式阅读。</p><h2 id="正文">正文</h2><p>本文分为十九个模块，分别是： <strong>Java 基础、容器、多线程、反射、对象拷贝、Java Web 模块、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、Mybatis、RabbitMQ、Kafka、Zookeeper、MySql、Redis、JVM</strong> ，如下图所示：</p><p><img src="http://icdn.apigo.cn/gitchat/java-intervier-gitchat-path.png" alt=""></p><p>共包含 208 道面试题，本文的宗旨是为读者朋友们整理一份详实而又权威的面试清单，下面一起进入主题吧。</p><h3 id="一、Java-基础">一、Java 基础</h3><h4 id="1-JDK-和-JRE-有什么区别？">1.JDK 和 JRE 有什么区别？</h4><ul><li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li><li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li></ul><p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p><h4 id="2-和-equals-的区别是什么？">2.== 和 equals 的区别是什么？</h4><p><strong>== 解读</strong></p><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p><ul><li>基本类型：比较的是值是否相同；</li><li>引用类型：比较的是引用是否相同；</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String x = <span class="hljs-string">&quot;string&quot;</span>;<br>String y = <span class="hljs-string">&quot;string&quot;</span>;<br>String z = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;string&quot;</span>);<br>System.out.println(x==y); <span class="hljs-comment">// true</span><br>System.out.println(x==z); <span class="hljs-comment">// false</span><br>System.out.println(x.equals(y)); <span class="hljs-comment">// true</span><br>System.out.println(x.equals(z)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p><strong>equals 解读</strong></p><p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p><p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br>Cat c1 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;王磊&quot;</span>);<br>Cat c2 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;王磊&quot;</span>);<br>System.out.println(c1.equals(c2)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>原来 equals 本质上就是 ==。</p><p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;老王&quot;</span>);<br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;老王&quot;</span>);<br>System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>        String anotherString = (String)anObject;<br>        <span class="hljs-keyword">int</span> n = value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>            <span class="hljs-keyword">char</span> v1[] = value;<br>            <span class="hljs-keyword">char</span> v2[] = anotherString.value;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p><p><strong>总结</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h4 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？">3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h4><p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String str1 = <span class="hljs-string">&quot;通话&quot;</span>;<br>String str2 = <span class="hljs-string">&quot;重地&quot;</span>;<br>System.out.println(String.format(<span class="hljs-string">&quot;str1：%d | str2：%d&quot;</span>,  str1.hashCode(),str2.hashCode()));<br>System.out.println(str1.equals(str2));<br></code></pre></td></tr></table></figure><p>执行的结果：</p><p>str1：1179395 | str2：1179395</p><p>false</p><p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><h4 id="4-final-在-java-中有什么作用？">4.final 在 java 中有什么作用？</h4><ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><h4 id="5-java-中的-Math-round-1-5-等于多少？">5.java 中的 Math.round(-1.5) 等于多少？</h4><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p><h4 id="6-String-属于基础的数据类型吗？">6.String 属于基础的数据类型吗？</h4><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p><h4 id="7-java-中操作字符串都有哪些类？它们之间有什么区别？">7.java 中操作字符串都有哪些类？它们之间有什么区别？</h4><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p><p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p><p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p><h4 id="8-String-str-i-与-String-str-new-String-“i”-一样吗？">8.String str=&quot;i&quot;与 String str=new String(“i”)一样吗？</h4><p>不一样，因为内存的分配方式不一样。String str=&quot;i&quot;的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p><h4 id="9-如何将字符串反转？">9.如何将字符串反转？</h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringBuffer reverse</span><br>StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();<br>stringBuffer.append(<span class="hljs-string">&quot;abcdefg&quot;</span>);<br>System.out.println(stringBuffer.reverse()); <span class="hljs-comment">// gfedcba</span><br><span class="hljs-comment">// StringBuilder reverse</span><br>StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>stringBuilder.append(<span class="hljs-string">&quot;abcdefg&quot;</span>);<br>System.out.println(stringBuilder.reverse()); <span class="hljs-comment">// gfedcba</span><br></code></pre></td></tr></table></figure><h4 id="10-String-类的常用方法都有那些？">10.String 类的常用方法都有那些？</h4><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><h4 id="11-抽象类必须要有抽象方法吗？">11.抽象类必须要有抽象方法吗？</h4><p>不需要，抽象类不一定非要有抽象方法。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHi</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hi~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p><h4 id="12-普通类和抽象类有哪些区别？">12.普通类和抽象类有哪些区别？</h4><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h4 id="13-抽象类能使用-final-修饰吗？">13.抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p><p><img src="http://icdn.apigo.cn/gitchat/java-intervier002.png" alt="final定义抽象类"></p><h4 id="14-接口和抽象类有什么区别？">14.接口和抽象类有什么区别？</h4><ul><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul><h4 id="15-java-中-IO-流分为几种？">15.java 中 IO 流分为几种？</h4><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流和字符流。</p><p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><h4 id="16-BIO、NIO、AIO-有什么区别？">16.BIO、NIO、AIO 有什么区别？</h4><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO（或 Non Blocking IO）同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><h4 id="17-Files的常用方法都有哪些？">17.Files的常用方法都有哪些？</h4><ul><li>Files.exists()：检测文件路径是否存在。</li><li>Files.createFile()：创建文件。</li><li>Files.createDirectory()：创建文件夹。</li><li>Files.delete()：删除一个文件或目录。</li><li>Files.copy()：复制文件。</li><li>Files.move()：移动文件。</li><li>Files.size()：查看文件个数。</li><li>Files.read()：读取文件。</li><li>Files.write()：写入文件。</li></ul><h3 id="二、容器">二、容器</h3><h4 id="18-java-容器都有哪些？">18.java 容器都有哪些？</h4><p>java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p><ul><li>Collection<ul><li>List<ul><li>ArrayList</li><li>LinkedList</li><li>Vector<ul><li>Stack</li></ul></li></ul></li><li>Set<ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>TreeSet</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>TreeMap</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul><h4 id="19-Collection-和-Collections-有什么区别？">19.Collection 和 Collections 有什么区别？</h4><ul><li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li><li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections.sort(list)。</li></ul><h4 id="20-List、Set、Map-之间的区别是什么？">20.List、Set、Map 之间的区别是什么？</h4><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p><p>三者之间的区别，如下表：</p><p><img src="http://icdn.apigo.cn/gitchat/listmapset.png" alt="list/set/map区别图"></p><h4 id="21-HashMap-和-Hashtable-有什么区别？">21.HashMap 和 Hashtable 有什么区别？</h4><ul><li>存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。</li><li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li><li>HashMap 的默认初始容量为 16，Hashtable 为 11。</li><li>HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。</li><li>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</li><li>HashMap 去掉了 Hashtable 中的 contains 方法。</li><li>HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。</li></ul><h4 id="22-如何决定使用-HashMap-还是-TreeMap？">22.如何决定使用 HashMap 还是 TreeMap？</h4><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p><h4 id="23-说一下-HashMap-的实现原理？">23.说一下 HashMap 的实现原理？</h4><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key.hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p><p>==HashMap的链表上数据节点超过8时，就会转换为红黑树。==</p><ol><li><p>补充：</p><ol><li>头结点是HashMap&lt;K,V&gt; table表上索引位置的节点</li><li>红黑树的根节点不一定是索引位置的头结点，HashMap通过moveRootToFont来维护头结点的位置。</li><li>转换为红黑树之后，链表的结构还存在，通过next属性来维持，红黑树上的任何操作都会顺带维护链表结构。</li><li>在红黑树上，叶子结点也可能是next节点，两种结构互不影响。</li><li>源码中，在进行红黑树的查找时，会利用以下两种规则：<ol><li>如果目标节点的 hash 值小于 p 节点的 hash 值，则向 p 节点的左边遍历；否则向 p 节点的右边遍历。</li><li>如果目标节点的 key 值小于 p 节点的 key 值，则向 p 节点的左边遍历；否则向 p 节点的右边遍历。（左节点 &lt; 根节点 &lt; 右节点）</li></ol></li></ol></li><li><p>默认容量：16</p></li><li><p>默认负载因子：0.75</p></li><li><p>链表节点转换的红黑树的阈值：8</p></li><li><p>红黑树转链表的阈值：6</p></li><li><p>转红黑树的时候，table的长度阈值：64</p></li><li><p><strong>get方法</strong></p><ol><li>对table进行校验：table不为空&amp;&amp;table长度大于0&amp;&amp;索引位置的节点不为空</li><li>然后检查first节点是目标入参，是返回，不是执行3。</li><li>通过next遍历first下的链表<ol><li>如果是红黑树，则调用红黑树的查找目标节点的方法getTreeNode()</li><li>不是则遍历链表，找到节点key和入参key相等的值，返回value</li></ol></li></ol></li><li><p><strong>put方法</strong></p><ol><li>校验table是否为空&amp;&amp;长度==0，如果是调用resize()进行初始化。<ol><li>通过Hash值计算索引位置，将该索引位置的头结点赋值给P，如果为空，则在此新增节点。</li></ol></li><li>若table不为空，判断p的key的hash值是否一样，如果相等，则将p赋值给e节点</li><li>判断p节点是不是TreeNode，如果是调用红黑树的putTreeVal方法查找目标节点</li><li>否则，是普通链表节点（使用bincount计数）<ol><li>如果p的next为空，则新增一个节点插入尾部。<ol><li>如果bincount的值超过8个，则调用treeifyBin将链表节点转换为红黑树节点</li></ol></li><li>如果e节点存在hash值和key值都与传入的相同，则e节点即为目标节点。p指向e。</li></ol></li><li>如果e的节点不为空，则代表目标节点存在，使用value覆盖该节点的value，并返回oldValue。</li><li>如果插入节点后节点数超过阈值，则调用resize方法进行扩容</li></ol></li><li><p><strong>扩容</strong>resize方法</p><ol><li><p>如果old表的容量不为0</p><ol><li>判断old表的容量是否超过最大容量，如果超过最大阈值设置为Interger.MAX_VALUE，并直接返回old表。此时oldCap*2比Integer.MAX_VALUE大，因此无法进行重新分布，只是单纯的将阈值扩容到最大。</li><li>==将newCap赋值为oldCap的2倍，如果newCap&lt;最大容量并且oldCap&gt;=16，则将新阈值设置为原来的两倍==</li></ol></li><li><p>如果old表的容量为0，阈值&gt;0，是因为初始容量被放入阈值，则将新表的容量设置为old表的阈值</p></li><li><p>如果old表的容量为0，阈值&gt;=0，这种情况是没有穿初始容量的new方法创建的空表，将阈值和容量设置为默认值。</p></li><li><p>如果新表的阈值为空，则通过新的容量*负载因子获得阈值。</p></li><li><p>将当前阈值设置成新计算出来的新的阈值，定义新表，容量为刚计算出来的新容量，将table设置为新定义的表。</p></li><li><p>扩容后，节点重 hash 为什么只可能分布在 “原索引位置” 与 “原索引 + oldCap 位置“。（针对于普通的链表节点）</p></li></ol></li></ol><h4 id="24-说一下-HashSet-的实现原理？">24.说一下 HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h4 id="25-ArrayList-和-LinkedList-的区别是什么？">25.ArrayList 和 LinkedList 的区别是什么？</h4><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><h4 id="26-如何实现数组和-List-之间的转换？">26.如何实现数组和 List 之间的转换？</h4><ul><li>数组转 List：使用 Arrays.asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// list to array</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;王磊&quot;</span>);<br>list.add(<span class="hljs-string">&quot;的博客&quot;</span>);<br>list.toArray();<br><span class="hljs-comment">// array to list</span><br>String[] array = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;王磊&quot;</span>,<span class="hljs-string">&quot;的博客&quot;</span>&#125;;<br>Arrays.asList(array);<br></code></pre></td></tr></table></figure><h4 id="27-ArrayList-和-Vector-的区别是什么？">27.ArrayList 和 Vector 的区别是什么？</h4><ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul><h4 id="28-Array-和-ArrayList-有何区别？">28.Array 和 ArrayList 有何区别？</h4><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><h4 id="29-在-Queue-中-poll-和-remove-有什么区别？">29.在 Queue 中 poll()和 remove()有什么区别？</h4><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>queue.offer(<span class="hljs-string">&quot;string&quot;</span>); <span class="hljs-comment">// add</span><br>System.out.println(queue.poll());<br>System.out.println(queue.remove());<br>System.out.println(queue.size());<br></code></pre></td></tr></table></figure><h4 id="30-哪些集合类是线程安全的？">30.哪些集合类是线程安全的？</h4><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 jdk 1.5 之后随着 java.util.concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h4 id="31-迭代器-Iterator-是什么？">31.迭代器 Iterator 是什么？</h4><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h4 id="32-Iterator-怎么使用？有什么特点？">32.Iterator 怎么使用？有什么特点？</h4><p>Iterator 使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Iterator&lt;String&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>  String obj = it.next();<br>  System.out.println(obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h4 id="33-Iterator-和-ListIterator-有什么区别？">33.Iterator 和 ListIterator 有什么区别？</h4><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h4 id="34-怎么确保一个集合不能被修改？">34.怎么确保一个集合不能被修改？</h4><p>可以使用 Collections.unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 java.lang.UnsupportedOperationException 异常。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;x&quot;</span>);<br>Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);<br>clist.add(<span class="hljs-string">&quot;y&quot;</span>); <span class="hljs-comment">// 运行时此行报错</span><br>System.out.println(list.size());<br></code></pre></td></tr></table></figure><h3 id="三、多线程">三、多线程</h3><h4 id="35-并行和并发有什么区别？">35.并行和并发有什么区别？</h4><ul><li>并行：多个处理器或多核处理器同时处理多个任务。</li><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li></ul><p>如下图：</p><p><img src="http://icdn.apigo.cn/gitchat/gitchat208-010.png" alt=""></p><p>并发 = 两个队列和一台咖啡机。</p><p>并行 = 两个队列和两台咖啡机。</p><h4 id="36-线程和进程的区别？">36.线程和进程的区别？</h4><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><h4 id="37-守护线程是什么？">37.守护线程是什么？</h4><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 java 中垃圾回收线程就是特殊的守护线程。</p><h4 id="38-创建线程有哪几种方式？">38.创建线程有哪几种方式？</h4><p>创建线程有四种方式：</p><ul><li>继承 Thread 重写 run 方法；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口。</li><li>使用线程池ThreadPoolExecutor。</li></ul><h4 id="39-说一下-runnable-和-callable-有什么区别？">39.说一下 runnable 和 callable 有什么区别？</h4><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p><p>FutureTask类：</p><ol><li><p>​一个可取消的异步计算。FutureTask提供了对Future的基本实现。可以调用一个方法去开始或者取消一个计算，并可以查询和返回一个计算结果。</p></li><li><p>FutureTask还实现了Runnable接口，所以FutureTash的实例对象可以交给Thread或者Excutor执行。也可以自己调用futureTash.run()：分为三个状态：</p><ol><li><p>未启动</p></li><li><p>已启动</p></li><li><p>已完成</p><p><img src="https://img-blog.csdnimg.cn/20190530214704456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0ODQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li></li></ol></li></ol><h4 id="40-线程有哪些状态？">40.线程有哪些状态？</h4><p>线程的状态：new Runnable Running  Blocked Dead</p><ul><li><p>NEW 尚未启动</p></li><li><p>RUNNABLE 可运行/就绪状态，等待分配CPU时间片</p></li><li><p>Running  获取CPU时间片，正在运行</p></li><li><p>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</p><ul><li>线程通过调用sleep方法进入睡眠状态；</li><li>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；、</li><li>线程试图得到一个锁，而该锁正被其他线程持有；</li><li>线程在等待某个触发条件；</li></ul></li><li><p>Dead ：线程结束（判断线程是否活着用 isAlive（）方法）</p><ul><li>run方法正常退出而自然死亡；</li><li>一个未捕获的异常终止了run方法而使线程猝死；</li></ul><p><img src="https://img-blog.csdnimg.cn/20201228162648820.png" alt="在这里插入图片描述"></p></li></ul><h4 id="41-sleep-和-wait-有什么区别？">41.sleep() 和 wait() 有什么区别？</h4><ul><li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li><li>释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。而且使用wait的线程会进入Wait Set集中。</li></ul><h4 id="42-notify-和-notifyAll-有什么区别？">42.notify()和 notifyAll()有什么区别？</h4><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。其中等待池就是 JVM 维护的 Wait Set集合</p><h4 id="43-线程的-run-和-start-有什么区别？">43.线程的 run()和 start()有什么区别？</h4><p>start()方法用于启动线程，run()方法用于执行线程的运行时代码。run() 可以重复调用，而 start()只能调用一次。</p><h4 id="44-创建线程池有哪几种方式？">44.创建线程池有哪几种方式？</h4><p>线程池创建有七种方式，最核心的是最后一种：</p><ul><li>new SingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li><li>new CachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li><li>new FixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li><li>new SingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li><li>new ScheduledThreadPool(int corePoolSize)：和new SingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li><li>new WorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li><li>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</li></ul><h4 id="45-线程池都有哪些状态？">45.线程池都有哪些状态？</h4><ul><li><p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</p></li><li><p>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</p></li><li><p>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</p></li><li><p>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</p></li><li><p>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p><p><img src="https://img-blog.csdnimg.cn/20201228162704883.png" alt="在这里插入图片描述"></p></li></ul><h4 id="46-线程池中-submit-和-execute-方法有什么区别？">46.线程池中 submit()和 execute()方法有什么区别？</h4><ul><li><p>execute()：只能执行 Runnable 类型的任务。</p></li><li><p>submit()：可以执行 Runnable 和 Callable 类型的任务。</p></li><li><p>方法所在的类不同：<br><code>execute</code> 方法：<code>java.util.concurrent.Executor</code>;<br><code>submit</code>方法：<code>java.util.concurrent.ExecutorService</code></p></li><li><p>所需要的参数不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">execute : java.util.concurrent.Executor#execute(java.lang.Runnable)<br>submit: java.util.concurrent.ExecutorService#submit(java.lang.Runnable, T),<br>               java.util.concurrent.ExecutorService#submit(java.lang.Runnable)<br>               java.util.concurrent.ExecutorService#submit(java.util.concurrent.Callable&lt;T&gt;)<br><br></code></pre></td></tr></table></figure></li></ul><p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><h4 id="47-在-java-程序中怎么保证多线程的运行安全？">47.在 java 程序中怎么保证多线程的运行安全？</h4><ul><li>方法一：使用安全类，比如 java.util.concurrent 下的类。</li><li>方法二：使用自动锁 synchronized。</li><li>方法三：使用手动锁 Lock。</li></ul><p>手动锁 java 示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;获得锁&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>    lock.unlock();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="48-多线程中-synchronized-锁升级的原理是什么？">48.多线程中 synchronized 锁升级的原理是什么？</h4><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h4 id="49-什么是死锁？">49.什么是死锁？</h4><p>当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><ol><li><strong>死锁产生的原因</strong>：<ol><li>系统资源的竞争：多个进程使用一个资源造成的僵局，例如打印机。</li><li>进程推进顺序的非法：请求和释放资源的顺序问题</li><li>死锁产生的必要条件：只要一个条件不满足，就不会产生死锁。<ol><li>互斥条件：同一时间内只允许一个线程使用。</li><li>不剥夺条件：线程在获取资源还没使用完毕，不能被其他线程占有，必须由此线程自己释放</li><li>请求和保持条件：线程已经保持了至少一个资源，但是又请求了新的资源请求，此时请求资源进程等待，保持的资源不释放</li><li>循环等待条件：请求资源的线程构成一个请求资源链{p1,p2…pn}，后一个线程必须依赖于前一个线程。</li></ol></li></ol></li><li><strong>JVM对锁的维护</strong>：<ol><li>JVM在底层维护了两个“队列”，一个是Entry Set（入口集），一个Wait Set（等待集）</li><li>首先每一个对象都有唯一一个内部的monitor（内部锁），Entry Set存储所有的等待获取资源的资源，Wait Set存储执行了objectX.wait（）的线程。</li><li>假设ABC三个线程，B线程获取了资源，线程AC进入Entry Set，等待请求资源（此时处于BLOCKED状态），当B释放资源，Entry Set队列里随机一个线程出列与其他获取的线程来争夺线程（处于RUNNABLE），抢占成功就真正离开Entry Set，否则，再回到Entry Set。</li><li>如果有个线程执行了objectX.wait（）方法，则进入Wait Set队列，当其他线程执行了objectX.notify()/notifyAll()方法，Wait Set中的线程才会离开队列，共同去抢占资源，如果被唤醒的线程抢夺了资源，则会离开队列，否则，再次回到Wait Set中</li></ol></li></ol><h4 id="50-怎么防止死锁？">50.怎么防止死锁？</h4><ul><li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。 （设置加锁时长）</li><li>尽量使用 java.util.concurrent 并发类代替自己手写锁。</li><li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li><li>加锁顺序。</li><li>死锁检测。并且给线程设置优先级。</li></ul><h4 id="51-ThreadLocal-是什么？有哪些使用场景？">51.ThreadLocal 是什么？有哪些使用场景？</h4><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><h4 id="52-说一下-synchronized-底层实现原理？">52.说一下 synchronized 底层实现原理？</h4><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 java 6 的时候，java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能</p><p>==补充1：i++等操作不具备原子性，它分为读取，计算，赋值三个步骤，可能在步骤还没完成就被赋值了。==</p><p>==synchronized 过程：当线程获取锁的时候，monitor+1，如果重复进入，则继续+1，如果失去锁，则monitor=0。通过指令monittorenter和monitorexit来操作。==</p><p>==synchronized 锁膨胀：无锁状态、偏向锁、轻量级锁、重量级锁，此过程不可逆。==</p><p>==偏向锁：减少同一线程获取锁的代价，大多数情况下，锁不存在多线程竞争，总是由统一线程多次获得。==</p><p>==轻量级锁：当存在第二个线程申请同一个锁时，偏向锁就会立即升级为轻量级锁，这里是申请锁，而不是竞争锁，可以一前一后的交替执行代码块。==</p><p>==重量级锁：当多个线程同时竞争一个锁时，就会升级成重量级锁，一般追求吞吐量、同步块、或者同步方法较长的场景下。==</p><p>==锁消除：jvm扫描上下文，去除不存在竞争的锁==</p><p>==锁粗化：jvm扫描上下文，通过扩大枷锁的范围，避免反复加锁和释放锁==</p><p>==自旋锁：在共享数据的状态持续过短的情况下，切换线程不值得，就通过让线程执行循环等待锁的释放的方式来进行优化，得到锁就进入临界区，否则就挂起。缺点：如果一直得不到锁，就会带来大量性能开销==</p><p>==自适应自旋锁：它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。==</p><h4 id="53-synchronized-和-volatile-的区别是什么？">53.synchronized 和 volatile 的区别是什么？</h4><ul><li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li></ul><p>==volatile 定义：volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略（可见性、有序性、原子性）==</p><p>==作用：保证了不同线程对这个变量进行修改时，新值对其他线程来说是立马可见的。 只能保证对变量的单次读/写操作的原子性。能够禁止进行指令重排序==</p><h4 id="54-synchronized-和-Lock-有什么区别？">54.synchronized 和 Lock 有什么区别？</h4><ul><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><h4 id="55-synchronized-和-ReentrantLock-区别是什么？">55.synchronized 和 ReentrantLock 区别是什么？</h4><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 java 6 中对 synchronized 进行了非常多的改进。</p><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li></ul><p>==AbstractQueuedSynchronizer(AQS)：是一个构建锁和相关同步器的框架，它依赖于FIFO的等待队列实现。ReentrantLock就是基于AQS构建的。AQS维护了一个FIFO的队列，记录等待的线程，上锁和释放锁就是线程进队or出队的过程；获取不到锁，就进入队列进行等待，被唤醒就出队列。==</p><h4 id="56-说一下-atomic-的原理？">56.说一下 atomic 的原理？</h4><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>==Atomic的作用：方面程序员在多线程的环境下，进行无锁编程==</p><p>==CAS：比较和替换技术，将预期值与当前变量的值进行比较，如果相等就用新值替换，否则就不操作。注意：CAS的操作中的再面对ABA问题时，不能保证这个值是否被修改过，可以给自己增加一个版本号，每次修改变量时，版本自增，比较的时候比较值与版本号==</p>]]></content>
    
    
    <categories>
      
      <category>JavaInterview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HR面试</title>
    <link href="/dajiangdahe/2021/10/22/HR%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94%E7%AD%96%E7%95%A5/"/>
    <url>/dajiangdahe/2021/10/22/HR%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1>1、你怎么看待本公司在行业内的地位。</h1><p>​对公司的认知以及的行业认知。哪里的优势，哪里的缺点。</p><h1>2、你现在收到了几个offer了，来本公司的意愿有多大。</h1><p>求职意愿，基于个人未来规划。 根据规划面试了那些公司，拿到了哪些offer，但是我最最终目标的是xxx。 1.与求职意愿符合       2.在我的offer中，也是我的最优解。3、城市的选择，</p><h1>3、为什么选择杭州/北京，（有考虑定居的打算吗）</h1><p>1.有定居的打算。这是我第一份的工作，我可能要进行学校-社会的转换，这一转换和任我认知的发展是需要长时期的。因为先加强自己的技术栈，需要在这个岗位长期学习，我也愿意为了定居去努力，尽自己最大的可能去留下来。       2.让自己留下来的方法：           1.让自己值钱 — 技术           2.工资 — 生存。</p><h1>4、个人学习上有什么规划</h1><p>表达出成就感的事情，长期坚持的事情，抗压性。解决压力的办法。</p><h1>5、对实习有什么看法。</h1><h1>6、反问</h1><p>1.在面试结束时，赶紧补充这一句：我很看重我这次的交流，希望有更多的交流机会，我可以留您一个联系方式吗？</p><h1>7、期望薪资多少。</h1><p>​1.行业平均之上/不能低于去年校招相同岗位工资</p><h1>8、你对什么行业/公司最感兴趣？</h1><p>智慧企业/城市、 金融科技、车联网</p><h1>9、你如果拿到我们的offer，但是最终没有来，你觉得什么原因导致的呢。</h1><p>首先，我能拿到offer，我肯定非常开心，我肯定也会去。如果我最终没有来，可能公司觉得我太菜了，收回offer了。</p><h1>10、你选择一个公司的标准是什么。</h1><p>1.企业文化</p><p>2.团队精神</p><p>3.是否是进步的积极的</p><p>4.付出和回报是否成正比</p><h1>11、你对加班怎么看</h1><ol><li>如果项目出现bug和紧急情况的话，我也会加班去完成这个事情。当然公司要求的每天任务还是要积极完成的，如果没完成，会要求主动加班去完成。       2. 减少无意义的加班，然后让自己有一定的时间去提升自己，形成一种工作-提升的良性循环。       3. 对每天工作进行一种复盘。</li></ol><h1>12、项目合作中如果你们产生了意见分歧怎么解决？</h1><p>1.过往真实故事。虚假的情节会容易被找到漏洞。</p><h1>13、你的领导和身边的同事和你相处不来怎么办。</h1><p>如果只对我不和的话，可能就是我问题，我回反思一下自己，会很坦陈的与大家进行一种沟通，改掉自己的毛病。     如果是领导问题的话，那是部门人心不齐吗，应该不会，毕竟一个部门有一个统一的目标。那可能也是管理方式不同，可以大家一起探讨一下。毕竟每个人都有优点和缺点，我们不能只看到别人的缺点，也需要看到别人的优点。</p><h1>14、自我介绍</h1><p>个人 相关信息，应聘什么岗位，面试xx的原因。</p>]]></content>
    
    
    <categories>
      
      <category>JavaInterview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>校招</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Hexo自动推送问题</title>
    <link href="/dajiangdahe/2021/10/22/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/dajiangdahe/2021/10/22/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1>1.解决每次git时，都需要输入账号密码问题</h1><p>只需要在git bash 里执行此git命令，以后N次操作就不需要输入账号密码了。（第一次push的时候需要账号和密码）</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git config --<span class="hljs-keyword">global</span> credential.helper <span class="hljs-keyword">store</span><br></code></pre></td></tr></table></figure><h1>2.解决hexo自动推送博客到码云问题（方案一）</h1><p>1.在/{your blog}目录下新建一个文件，<a href="http://xn--ss0ao17a.sh">部署.sh</a></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>2.文件内容如上图所示</p><p>​hexo clean 是清除文件</p><p>​    hexo g 是生成静态文件</p><p>​hexo d 是部署到gitee</p><p>3.在码云 gitee pages 页面点击更新即可。（付费版可以自动更新）</p><h1>3.解决图片不显示问题</h1><p>1.需要安装推送图片插件</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">npm install hexo-asset-<span class="hljs-built_in">image</span> --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure><p>2.设置博客目录下_config.yml文件中的 post_asset_folder：选项是否为 true</p><p>3.设置Typora</p><img src="/dajiangdahe/2021/10/22/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20210913131129705.png" class="" title="image-20210913131129705"><p>4.将下面的index.js中的代码替换node_modules\hexo-asset-image中的index.js。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> log = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;hexo-log&#x27;</span>)(&#123; <span class="hljs-string">&#x27;debug&#x27;</span>: <span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;slient&#x27;</span>: <span class="hljs-literal">false</span> &#125;);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * md文件返回 true</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>data </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ignore</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 好奇怪，试了一下, md返回true, 但却需要忽略 取反!</span><br>    <span class="hljs-keyword">var</span> source = data.source;<br>    <span class="hljs-keyword">var</span> ext = source.substring(source.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>)).toLowerCase();<br>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;md&#x27;</span>,].indexOf(ext) &gt; -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> reverseSource = data.source.split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">var</span> fileName = reverseSource.substring(<span class="hljs-number">3</span>, reverseSource.indexOf(<span class="hljs-string">&quot;/&quot;</span>)).split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">// ![example](postname/example.jpg)  --&gt;  &#123;% asset_img example.jpg example %&#125;</span><br>    <span class="hljs-keyword">var</span> regExp = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;!\\[(.*?)\\]\\(&quot;</span> + fileName + <span class="hljs-string">&#x27;/(.+?)\\)&#x27;</span>, <span class="hljs-string">&quot;g&quot;</span>);<br>    <span class="hljs-comment">// hexo g</span><br>    data.content = data.content.replace(regExp, <span class="hljs-string">&quot;&#123;% asset_img $2 $1 %&#125;&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>);<br><br>    <span class="hljs-comment">// log.info(`hexo-asset-img: filename: $&#123;fileName&#125;, title: $&#123;data.title.trim()&#125;`);</span><br>    <br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br>hexo.extend.filter.register(<span class="hljs-string">&#x27;before_post_render&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(!ignore(data))&#123;<br>        action(data)<br>    &#125;<br>&#125;, <span class="hljs-number">0</span>);<br><br></code></pre></td></tr></table></figure><p>5.测试</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap为什么默认扩容因子是0.75？</title>
    <link href="/dajiangdahe/2021/10/22/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF0.75%EF%BC%9F/"/>
    <url>/dajiangdahe/2021/10/22/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF0.75%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1>从泊松分布谈起HashMap</h1><p><strong>【二项分布】</strong></p><p>二项分布就是重复n次独立的伯努利试验。在每次试验中只有两种可能的结果，而且两种结果发生与否互相对立，并且相互独立，与其它各次试验结果无关，事件发生与否的概率p在每一次独立试验中都保持不变，则这一系列试验总称为n重伯努利实验，当试验次数为1时，二项分布服从0-1分布。</p><p>两个重点：</p><ul><li>每次试验独立：第n次试验不受n-1次试验的影响，也不影响n+1次试验；</li><li>结果有且只有两个，并且互相对立：要么成功，要么失败，成功的概率+失败的概率=1；</li></ul><p>至于二项分布图的绘制，也就是做n次试验，期望成功k次的概率分布。根据二项分布函数，你只需要知道试验总次数n、期望成功的次数k，以及每次试验成功的概率p，即可很快的求出成功k次的概率。</p><p>【<strong>泊松分布</strong>】</p><p>泊松分布： 是离散随机分布的一种，通常被使用在估算在 一段特定时间/空间内发生成功事件的数量的概率。</p><img src="/dajiangdahe/2021/10/22/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF0.75%EF%BC%9F/v2-7adb1965b4f92d6121d77687907583e1_720w.jpg" class="" title="img"><p>【<strong>HashMap与泊松分布的关系</strong>】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs text">* Ideally, under random hashCodes, the frequency of<br>     * nodes in bins follows a Poisson distribution<br>     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a<br>     * parameter of about 0.5 on average for the default resizing<br>     * threshold of 0.75, although with a large variance because of<br>     * resizing granularity.<br>     *<br>     * 翻译：<br>     *     尽管因为调整粒度而产生较大的方差，但是理想的情况，在随机hashCodes下，桶中节点的频率遵循泊松分布。<br>     *     默认调整阈值为0.75的条件下，泊松分布中的概率参数λ=0.5。<br>     * 解释：<br>     *     k表示数量，这里指桶中节点的个数。<br>     *     λ表示事件的频率。这里λ=0.5，代表理想情况下，平均100个桶，50个数据，则1个桶有数据的概率是0.5。<br>     *     忽略方差，把λ代入。则求一个桶中出现k个节点的概率，公式为：<br>     <br>     <br>    private static String poisson(int k) &#123;<br>        //泊松分布 Java<br>        double value = Math.exp(-0.5) * Math.pow(0.5, k) / IntMath.factorial(k);<br>        //格式化参数，保留10位小数。<br>        return new BigDecimal(value+&quot;&quot;).setScale(10, ROUND_HALF_UP).toPlainString();<br>    &#125;<br></code></pre></td></tr></table></figure><p>【<strong>每个桶中出现1个节点的概率</strong>】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs text">public static void main(String[] args) &#123;<br>        System.out.println(&quot;1个桶中出现1个节点的概率:&quot; + poisson(1));<br>        System.out.println(&quot;1个桶中出现2个节点的概率:&quot; +poisson(2));<br>        System.out.println(&quot;1个桶中出现3个节点的概率:&quot; +poisson(3));<br>        System.out.println(&quot;1个桶中出现4个节点的概率:&quot; +poisson(4));<br>        System.out.println(&quot;1个桶中出现5个节点的概率:&quot; +poisson(5));<br>        System.out.println(&quot;1个桶中出现6个节点的概率:&quot; +poisson(6));<br>        System.out.println(&quot;1个桶中出现7个节点的概率:&quot; +poisson(7));<br>        System.out.println(&quot;1个桶中出现8个节点的概率:&quot; +poisson(8));//亿分之六<br>        System.out.println(&quot;1个桶中出现9个节点的概率:&quot; +poisson(9));<br>    &#125;<br><br>Console:<br>    1个桶中出现1个节点的概率:0.3032653299<br>    1个桶中出现2个节点的概率:0.0758163325<br>    1个桶中出现3个节点的概率:0.0126360554<br>    1个桶中出现4个节点的概率:0.0015795069<br>    1个桶中出现5个节点的概率:0.0001579507<br>    1个桶中出现6个节点的概率:0.0000131626<br>    1个桶中出现7个节点的概率:0.0000009402<br>    1个桶中出现8个节点的概率:0.0000000588//亿分之六<br>    1个桶中出现9个节点的概率:0.0000000033<br></code></pre></td></tr></table></figure><p>这一段乃至HashMap开头的一大段注释都没有解释load factory默认值是0.75的原因，而是说load factor的值会影响泊松分布PMF函数公式中的参数λ的值，例如load factor=0.75f时λ=0.5。按照泊松分布公式来看，期望放入bin中数据的数量k=8，e是一个无理常数，λ的值受load factor的值的影响（泊松分布是用来估算在 一段特定时间或空间内发生成功事件的数量的概率，即在长度为length的数组中hash地放入0.75*length数量的数据，数组中某一个下标放入k个数据的概率）。</p><img src="/dajiangdahe/2021/10/22/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF0.75%EF%BC%9F/20181013121844583" class="" title="img"><p>java8及以上版本的HashMap中这段注释的解释：</p><ul><li>这一段注释的内容和目的都是为了解释在java8 HashMap中引入Tree Bin（也就是放入数据的每个数组bin从链表node转换为red-black tree node）的原因</li><li>原注释如上图划线部分：Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD).</li><li><strong>TreeNode</strong>虽然改善了链表增删改查的性能，<strong>但是其节点大小是链表节点的两倍</strong></li><li>虽然引入TreeNode但是不会轻易转变为TreeNode（如果存在大量转换那么资源代价比较大），<strong>根据泊松分布来看转变是小概率事件，性价比是值得的</strong></li><li>泊松分布是二项分布的极限形式，两个重点：<strong>事件独立</strong>、<strong>有且只有两个相互对立的结果</strong></li><li>泊松分布是指一段时间或空间中发生成功事件的数量的概率</li><li>对HashMap table[]中任意一个bin来说，存入一个数据，要么放入要么不放入，这个动作满足二项分布的两个重点概念</li><li>对于HashMap.table[].length的空间来说，放入0.75<em>length个数据，某一个bin中放入节点数量的概率情况如上图注释中给出的数据（表示数组某一个下标存放数据数量为0~8时的概率情况）</em><ul><li><strong>举个例子说明</strong>，HashMap默认的table[].length=16，在长度为16的HashMap中放入12（0.75*length）个数据，某一个bin中存放了8个节点的概率是0.00000006</li><li><strong>扩容一次</strong>，16*2=32，在长度为32的HashMap中放入24个数据，某一个bin中存放了8个节点的概率是0.00000006</li><li><strong>再扩容一次</strong>，32*2=64，在长度为64的HashMap中放入48个数据，某一个bin中存放了8个节点的概率是0.00000006</li><li><strong>所以，当某一个bin的节点大于等于8个的时候，就可以从链表node转换为treenode，其性价比是值得的。</strong></li></ul></li></ul><p><strong>【load factor=0.75f的真正原因】</strong></p><p>load factory=0.75的真正原因，在java7、8等中均有注释（这段注释在public class HashMap类定义之前，附注的注释即本文所讨论的注释是在HashMap类定义之后），如下图所示，负载因子太小了浪费空间并且会发生更多次数的resize，太大了哈希冲突增加会导致性能不好，所以0.75只是一个折中的选择，和泊松分布没有什么关系。</p><img src="/dajiangdahe/2021/10/22/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF0.75%EF%BC%9F/20181013121921758" class="" title="img">]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EasyExcel插件在web下的使用</title>
    <link href="/dajiangdahe/2021/10/22/EasyExcel%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/dajiangdahe/2021/10/22/EasyExcel%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1>1.EasyExcel插件</h1><p>EasyExcel是一个基于Java的简单、省内存的读写Excel的开源项目。在尽可能节约内存的情况下支持读写百M的Excel。</p><h1>2.EasyExcel web读</h1><h2 id="1-依赖">1.依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>           &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;<br>           &lt;version&gt;<span class="hljs-number">2.1</span><span class="hljs-number">.6</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="2-对应的execl表格">2.对应的execl表格</h2><img src="/dajiangdahe/2021/10/22/EasyExcel%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/image-20211007105045718.png" class="" title="image-20211007105045718">Ian<h2 id="3-在bean层建立对应的vo类">3.在bean层建立对应的vo类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraindataVo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer userId;<br><br>    <span class="hljs-keyword">private</span> String type;<br><br>    <span class="hljs-keyword">private</span> Date timeStamp;<br><br>    <span class="hljs-keyword">private</span> Double firstSub;<br><br>    <span class="hljs-keyword">private</span> Double secondSub;<br><br>    <span class="hljs-keyword">private</span> Double thirdSub;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对应的vo类来匹配对应的excel进行excel的读取.</p><h2 id="4-controller层">4.controller层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/importExcel&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;文件上传&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">importExcel</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> MultipartFile file)</span> </span>&#123;<br>       traindataService.importExcel(file);<br>       <span class="hljs-keyword">return</span> Result.ok();<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="5-service层">5.service层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导入文件</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">importExcel</span><span class="hljs-params">(MultipartFile file)</span></span>; <br><br><span class="hljs-comment">//插入数据到数据库</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Traindata results)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="6-serviceImpl层">6.serviceImpl层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 导入excel</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> file 文件</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">importExcel</span><span class="hljs-params">(MultipartFile file)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span>==file)&#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       InputStream in = <span class="hljs-keyword">null</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           in = <span class="hljs-keyword">new</span> BufferedInputStream(file.getInputStream());<br>           <span class="hljs-comment">//实例化实现了AnalysisEventListener接口的类</span><br>           <span class="hljs-comment">//打印信息</span><br>           LOGGER.info(in.toString());<br>           EasyExcel.read(in, TraindataVo.class, <span class="hljs-keyword">new</span> ExcelListener(traindataService)).sheet().doRead();<br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> traindata traindata</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Traindata traindata)</span> </span>&#123;<br>        baseMapper.insert(traindata);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="7-ExcelListener工具类">7.ExcelListener工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> edu.bjut.visualization.utils.listeners;<br><br><span class="hljs-keyword">import</span> com.alibaba.excel.context.AnalysisContext;<br><span class="hljs-keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> edu.bjut.visualization.bean.Traindata;<br><span class="hljs-keyword">import</span> edu.bjut.visualization.bean.vo.TraindataVo;<br><span class="hljs-keyword">import</span> edu.bjut.visualization.service.ITraindataService;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">// 有个很重要的点 ExcelListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnalysisEventListener</span>&lt;<span class="hljs-title">TraindataVo</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//日志使用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ExcelListener.class);<br>    <span class="hljs-comment">//缓存的数据列表</span><br>    <span class="hljs-keyword">private</span> List&lt;TraindataVo&gt; datas = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">//每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BATCH_COUNT = <span class="hljs-number">3000</span>;<br>    <span class="hljs-keyword">private</span> ITraindataService traindataService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExcelListener</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">//如果使用了spring,则需要使用此构造器,每次创建Listener的时候需要把spring管理的类传进来</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExcelListener</span><span class="hljs-params">(ITraindataService traindataService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.traindataService = traindataService;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data    数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 上下文</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(TraindataVo data, AnalysisContext context)</span> </span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));<br>        <span class="hljs-comment">//数据存储到datas，供批量处理，或后续自己业务逻辑处理。</span><br>        datas.add(data);<br>        <span class="hljs-comment">//达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span><br>        <span class="hljs-keyword">if</span>(datas.size() &gt;= BATCH_COUNT)&#123;<br>            saveData();<br>            <span class="hljs-comment">// 存储完成清理datas</span><br>            datas.clear();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveData</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">//如果是大批量的数据,尽量别多次调用insert一次次插入,可以在mapper层写一个批量插入</span><br>        <span class="hljs-keyword">for</span>(TraindataVo results : datas)&#123;<br>            Traindata traindata = <span class="hljs-keyword">new</span> Traindata();<br>            traindata.setUserId(results.getUserId());<br>            traindata.setTimeStamp(<span class="hljs-keyword">new</span> java.sql.Timestamp(results.getTimeStamp().getTime()));<br>            traindata.setFirstSub(results.getFirstSub());<br>            traindata.setSecondSub(results.getSecondSub());<br>            traindata.setType(results.getType());<br>            traindata.setThirdSub(results.getThirdSub());<br>            LOGGER.info(<span class="hljs-string">&quot;traindata数据，开始存储数据库！&quot;</span>,  JSON.toJSONString(traindata));<br>            <span class="hljs-keyword">this</span>.traindataService.insert(traindata);<br>        &#125;<br>        LOGGER.info(<span class="hljs-string">&quot;存储数据库成功！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//所有数据解析完成了 都会来调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfterAllAnalysed</span><span class="hljs-params">(AnalysisContext context)</span> </span>&#123;<br>        <span class="hljs-comment">//这里也要保存数据,确保最后遗留的数据也存储到数据库</span><br>        saveData();<br>        LOGGER.info(<span class="hljs-string">&quot;所有数据解析完成！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>3.总结</h1><p>easyexcel是一个比较简单方便使用的插件,对于web读和web写基本上都只需要在监听类做一些配置即可.</p><p>官方文档地址https://www.yuque.com/easyexcel/doc/read</p>]]></content>
    
    
    <categories>
      
      <category>插件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EasyExcel</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
