

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/dajiangdahe/img/favicon.png">
  <link rel="icon" href="/dajiangdahe/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Hello,here is kengkeng&#39;s blog.">
  <meta name="author" content="kengkeng">
  <meta name="keywords" content="">
  
  <title>Apache Thrift Rpc框架 - kengkeng&#39;s life</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/dajiangdahe/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/dajiangdahe/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"kengkengya.github.io","root":"/dajiangdahe/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/dajiangdahe/js/utils.js" ></script>
  <script  src="/dajiangdahe/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/dajiangdahe/">&nbsp;<strong>kengkeng's life</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dajiangdahe/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/dajiangdahe/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Apache Thrift Rpc框架">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      kengkeng
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-20 19:53" pubdate>
        2022年4月20日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      176
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Apache Thrift Rpc框架</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2 个月前
                
              </p>
            
            <div class="markdown-body">
              <h1>Apache Thrift</h1>
<h1>前言</h1>
<p><code>Thrift</code>是一个<strong>轻量级</strong>、<strong>跨语言</strong>的<strong>远程服务调用</strong>框架，最初由<code>Facebook</code>开发，后面进入<code>Apache</code>开源项目。它通过自身的<code>IDL</code><strong>中间语言</strong>, 并借助<strong>代码生成引擎</strong>生成各种主流语言的<code>RPC</code><strong>服务端</strong>/<strong>客户端</strong>模板代码。</p>
<p><code>Thrift</code>支持多种不同的<strong>编程语言</strong>，包括<code>C++</code>、<code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>等，本系列主要讲述基于<code>Java</code>语言的<code>Thrift</code>的配置方式和具体使用。</p>
<h1>概述与入门</h1>
<h2 id="Thrift的技术栈">Thrift的技术栈</h2>
<p><code>Thrift</code>对<strong>软件栈</strong>的定义非常的清晰, 使得各个组件能够<strong>松散的耦合</strong>, 针对不同的应用场景, 选择不同是方式去搭建服务。</p>
<img src="Thrift%E5%8D%8F%E8%AE%AE/image-20220420113451662.png" alt="image-20220420113451662" style="zoom:50%;" />
<p><code>Thrift</code><strong>软件栈</strong>分层<strong>从下向上</strong>分别为：<strong>传输层</strong>(<code>Transport Layer</code>)、<strong>协议层</strong>(<code>Protocol Layer</code>)、<strong>处理层</strong>(<code>Processor Layer</code>)和<strong>服务层</strong>(<code>Server Layer</code>)。</p>
<ul>
<li><strong>传输层</strong>(<code>Transport Layer</code>)：传输层负责直接从网络中<strong>读取</strong>和<strong>写入</strong>数据，它定义了具体的<strong>网络传输协议</strong>；比如说<code>TCP/IP</code>传输等。</li>
<li><strong>协议层</strong>(<code>Protocol Layer</code>)：协议层定义了<strong>数据传输格式</strong>，负责网络传输数据的<strong>序列化</strong>和<strong>反序列化</strong>；比如说<code>JSON</code>、<code>XML</code>、<strong>二进制数据</strong>等。</li>
<li><strong>处理层</strong>(<code>Processor Layer</code>)：处理层是由具体的<code>IDL</code>（<strong>接口描述语言</strong>）生成的，封装了具体的<strong>底层网络传输</strong>和<strong>序列化方式</strong>，并委托给用户实现的<code>Handler</code>进行处理。</li>
<li><strong>服务层</strong>(<code>Server Layer</code>)：整合上述组件，提供具体的<strong>网络线程/IO服务模型</strong>，形成最终的服务。</li>
</ul>
<h2 id="Thrift的特性">Thrift的特性</h2>
<h3 id="一-开发速度快">(一) 开发速度快</h3>
<p>通过编写<code>RPC</code>接口<code>Thrift IDL</code>文件，利用<strong>编译生成器</strong>自动生成<strong>服务端骨架</strong>(<code>Skeletons</code>)和<strong>客户端桩</strong>(<code>Stubs</code>)。从而省去开发者<strong>自定义</strong>和<strong>维护接口编解码</strong>、<strong>消息传输</strong>、<strong>服务器多线程模型</strong>等基础工作。</p>
<ul>
<li>服务端：只需要按照<strong>服务骨架</strong>即<strong>接口</strong>，编写好具体的<strong>业务处理程序</strong>(<code>Handler</code>)即<strong>实现类</strong>即可。</li>
<li>客户端：只需要拷贝<code>IDL</code>定义好的<strong>客户端桩</strong>和<strong>服务对象</strong>，然后就像调用本地对象的方法一样调用远端服务。</li>
</ul>
<h3 id="二-接口维护简单">(二) 接口维护简单</h3>
<p>通过维护<code>Thrift</code>格式的IDL（<strong>接口描述语言</strong>）文件（注意写好注释），即可作为给<code>Client</code>使用的接口文档使用，也<strong>自动生成</strong>接口代码，始终保持代码和文档的一致性。且<code>Thrift</code>协议可灵活支持<strong>接口</strong>的<strong>可扩展性</strong>。</p>
<h3 id="三-学习成本低">(三) 学习成本低</h3>
<p>因为其来自<code>Google Protobuf</code>开发团队，所以其<code>IDL</code>文件风格类似<code>Google Protobuf</code>，且更加<strong>易读易懂</strong>；特别是<code>RPC</code><strong>服务接口</strong>的风格就像写一个<strong>面向对象</strong>的<code>Class</code>一样简单。</p>
<h3 id="四-多语言-跨语言支持">(四) 多语言/跨语言支持</h3>
<p><code>Thrift</code>支持<code>C++</code>、 <code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>、<code>Erlang</code>、<code>Perl</code>、<code>Haskell</code>、<code>C#</code>、<code>Cocoa</code>、<code>JavaScript</code>、<code>Node.js</code>、<code>Smalltalk</code>等多种语言，即可生成上述语言的<strong>服务器端</strong>和<strong>客户端程序</strong>。</p>
<p>对于我们经常使用的<code>Java</code>、<code>PHP</code>、<code>Python</code>、<code>C++</code>支持良好，虽然对<code>iOS</code>环境的<code>Objective-C</code>(<code>Cocoa</code>)支持稍逊，但也完全满足我们的使用要求。</p>
<h3 id="五-稳定-广泛使用">(五) 稳定/广泛使用</h3>
<p><code>Thrift</code>在很多开源项目中已经被验证是<strong>稳定</strong>和<strong>高效</strong>的，例如<code>Cassandra</code>、<code>Hadoop</code>、<code>HBase</code>等；国外在<code>Facebook</code>中有广泛使用，国内包括百度、美团小米、和饿了么等公司。</p>
<h2 id="Thrift的数据类型">Thrift的数据类型</h2>
<p>Thrift 脚本可定义的数据类型包括以下几种类型：</p>
<ol>
<li>基本类型：
<ul>
<li><strong>bool</strong>: 布尔值</li>
<li><strong>byte</strong>: 8位有符号整数</li>
<li><strong>i16</strong>: 16位有符号整数</li>
<li><strong>i32</strong>: 32位有符号整数</li>
<li><strong>i64</strong>: 64位有符号整数</li>
<li><strong>double</strong>: 64位浮点数</li>
<li><strong>string</strong>: UTF-8编码的字符串</li>
<li><strong>binary</strong>: 二进制串</li>
</ul>
</li>
<li>结构体类型：
<ul>
<li><strong>struct</strong>: 定义的结构体对象</li>
</ul>
</li>
<li>容器类型：
<ul>
<li><strong>list</strong>: 有序元素列表</li>
<li><strong>set</strong>: 无序无重复元素集合</li>
<li><strong>map</strong>: 有序的key/value集合</li>
</ul>
</li>
<li>异常类型：
<ul>
<li><strong>exception</strong>: 异常类型</li>
</ul>
</li>
<li>服务类型：
<ul>
<li><strong>service</strong>: 具体对应服务的类</li>
</ul>
</li>
</ol>
<h2 id="Thrift的协议">Thrift的协议</h2>
<p><code>Thrift</code>可以让用户选择<strong>客户端</strong>与<strong>服务端</strong>之间<strong>传输通信协议</strong>的类别，在<strong>传输协议</strong>上总体划分为<strong>文本</strong>(<code>text</code>)和<strong>二进制</strong>(<code>binary</code>)传输协议。为<strong>节约带宽</strong>，<strong>提高传输效率</strong>，一般情况下使用<strong>二进制</strong>类型的传输协议为多数，有时还会使用基于<strong>文本类型</strong>的协议，这需要根据项目/产品中的实际需求。常用协议有以下几种：</p>
<ul>
<li>TBinaryProtocol：<strong>二进制</strong>编码格式进行数据传输</li>
<li>TCompactProtocol：<strong>高效率</strong>的、<strong>密集</strong>的<strong>二进制</strong>编码格式进行数据传输</li>
<li>TJSONProtocol： 使用<code>JSON</code><strong>文本</strong>的数据编码协议进行数据传输</li>
<li>TSimpleJSONProtocol：只提供<code>JSON</code><strong>只写</strong>的协议，适用于通过<strong>脚本语言解析</strong></li>
</ul>
<h2 id="Thrift的传输层">Thrift的传输层</h2>
<p>常用的传输层有以下几种：</p>
<ul>
<li>TSocket：使用<strong>阻塞式</strong><code>I/O</code>进行传输，是最常见的模式</li>
<li>TNonblockingTransport：使用<strong>非阻塞方式</strong>，用于构建<strong>异步客户端</strong></li>
<li>TFramedTransport：使用<strong>非阻塞方式</strong>，按<strong>块的大小</strong>进行传输，类似于<code>Java</code>中的<code>NIO</code></li>
</ul>
<h2 id="Thrift的服务端类型">Thrift的服务端类型</h2>
<ul>
<li>TSimpleServer：<strong>单线程</strong>服务器端，使用标准的<strong>阻塞式</strong><code>I/O</code></li>
<li>TThreadPoolServer：<strong>多线程</strong>服务器端，使用标准的<strong>阻塞式</strong><code>I/O</code></li>
<li>TNonblockingServer：<strong>单线程</strong>服务器端，使用<strong>非阻塞式</strong><code>I/O</code></li>
<li>THsHaServer：<strong>半同步半异步</strong>服务器端，基于<strong>非阻塞式</strong><code>IO</code>读写和<strong>多线程</strong>工作任务处理</li>
<li>TThreadedSelectorServer：<strong>多线程选择器</strong>服务器端，对<code>THsHaServer</code>在<strong>异步</strong><code>IO</code>模型上进行增强</li>
</ul>
<h2 id="Thrift入门示例">Thrift入门示例</h2>
<h3 id="一-编写Thrift-IDL文件">(一) 编写Thrift IDL文件</h3>
<p>a). 下载<code>0.10.0</code>的<code>Thrift IDL</code>编译器，下载地址：<a target="_blank" rel="noopener" href="http://thrift.apache.org/docs/install%E3%80%82">http://thrift.apache.org/docs/install。</a> 通过<strong>编译生成器</strong>生成<code>.java</code>接口的类文件。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/569a6d60686d">https://www.jianshu.com/p/569a6d60686d</a></p>
<p>b). 下载<code>Windows</code>安装环境的<code>.exe</code>文件，将<code>thrift.exe</code>的路径加入环境变量中。在<code>Idea</code>上安装<code>Thrift</code>编辑插件。(Mac 忽略，只要在idea添加插件即可)</p>
<img src="Thrift%E5%8D%8F%E8%AE%AE/image-20220420143539459.png" alt="image-20220420143539459" style="zoom:50%;" />
<p>c). 编写<code>hello.thrift</code>的<code>IDL</code>文件：</p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">HelloWorldService</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> say(<span class="hljs-number">1</span>: <span class="hljs-built_in">string</span> username)<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>d). 使用代码生成工具生成代码，执行以下命令：</p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs thrift">thrift -gen java hello.thrift<br><br></code></pre></td></tr></table></figure>
<p>e). 由于未指定代码生成的目标目录，生成的类文件默认存放在<code>gen-java</code>目录下。这里生成一个<code>HelloWorldService.java</code>类文件，文件大小超过数千行，下面截取一部分<strong>核心代码</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldService</span> </span>&#123;<br>		<br>		<span class="hljs-comment">//服务端通过实现HelloWorldService.Iface接口，向客户端的提供具体的同步业务逻辑。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iface</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> org.apache.thrift.TException</span>;<br>    &#125;<br>		<br>  <span class="hljs-comment">//服务端通过实现HelloWorldService.Iface接口，向客户端的提供具体的异步业务逻辑。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AsyncIface</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(String username, org.apache.thrift.async.AsyncMethodCallback&lt;String&gt; resultHandler)</span> <span class="hljs-keyword">throws</span> org.apache.thrift.TException</span>;<br>    &#125;<br>		<span class="hljs-comment">//客户端通过HelloWorldService.Client的实例对象，以同步的方式访问服务端提供的服务方法。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">thrift</span>.<span class="hljs-title">TServiceClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iface</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">thrift</span>.<span class="hljs-title">TServiceClientFactory</span>&lt;<span class="hljs-title">Client</span>&gt; </span>&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Factory</span><span class="hljs-params">()</span> </span>&#123;<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Client <span class="hljs-title">getClient</span><span class="hljs-params">(org.apache.thrift.protocol.TProtocol prot)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Client(prot);<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Client <span class="hljs-title">getClient</span><span class="hljs-params">(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Client(iprot, oprot);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Client</span><span class="hljs-params">(org.apache.thrift.protocol.TProtocol prot)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(prot, prot);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Client</span><span class="hljs-params">(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(iprot, oprot);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> org.apache.thrift.TException </span>&#123;<br>            send_say(username);<br>            <span class="hljs-keyword">return</span> recv_say();<br>        &#125;<br>        <span class="hljs-comment">// 省略.....</span><br>    &#125;<br>		<span class="hljs-comment">//客户端通过HelloWorldService.AsyncClient的实例对象，以异步的方式访问服务端提供的服务方法。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">thrift</span>.<span class="hljs-title">async</span>.<span class="hljs-title">TAsyncClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AsyncIface</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">thrift</span>.<span class="hljs-title">async</span>.<span class="hljs-title">TAsyncClientFactory</span>&lt;<span class="hljs-title">AsyncClient</span>&gt; </span>&#123;<br>            <span class="hljs-keyword">private</span> org.apache.thrift.async.TAsyncClientManager clientManager;<br>            <span class="hljs-keyword">private</span> org.apache.thrift.protocol.TProtocolFactory protocolFactory;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Factory</span><span class="hljs-params">(org.apache.thrift.async.TAsyncClientManager clientManager, org.apache.thrift.protocol.TProtocolFactory protocolFactory)</span> </span>&#123;<br>                <span class="hljs-keyword">this</span>.clientManager = clientManager;<br>                <span class="hljs-keyword">this</span>.protocolFactory = protocolFactory;<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> AsyncClient <span class="hljs-title">getAsyncClient</span><span class="hljs-params">(org.apache.thrift.transport.TNonblockingTransport transport)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AsyncClient(protocolFactory, clientManager, transport);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncClient</span><span class="hljs-params">(org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.async.TAsyncClientManager clientManager, org.apache.thrift.transport.TNonblockingTransport transport)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(protocolFactory, clientManager, transport);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(String username, org.apache.thrift.async.AsyncMethodCallback&lt;String&gt; resultHandler)</span> <span class="hljs-keyword">throws</span> org.apache.thrift.TException </span>&#123;<br>            checkReady();<br>            say_call method_call = <span class="hljs-keyword">new</span> say_call(username, resultHandler, <span class="hljs-keyword">this</span>, ___protocolFactory, ___transport);<br>            <span class="hljs-keyword">this</span>.___currentMethod = method_call;<br>            ___manager.call(method_call);<br>        &#125;<br>        <span class="hljs-comment">// 省略.....</span><br>    &#125;<br>    <span class="hljs-comment">// 省略.....</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>对于开发人员而言，使用原生的<code>Thrift</code>框架，仅需要关注以下四个核心<strong>内部接口/类</strong>：<code>Iface</code>, <code>AsyncIface</code>, <code>Client</code>和<code>AsyncClient</code>。</p>
<ul>
<li><strong>Iface</strong>：<strong>服务端</strong>通过实现<code>HelloWorldService.Iface</code>接口，向<strong>客户端</strong>的提供具体的<strong>同步</strong>业务逻辑。</li>
<li><strong>AsyncIface</strong>：<strong>服务端</strong>通过实现<code>HelloWorldService.Iface</code>接口，向<strong>客户端</strong>的提供具体的<strong>异步</strong>业务逻辑。</li>
<li><strong>Client</strong>：<strong>客户端</strong>通过<code>HelloWorldService.Client</code>的实例对象，以<strong>同步</strong>的方式<strong>访问服务端</strong>提供的服务方法。</li>
<li><strong>AsyncClient</strong>：<strong>客户端</strong>通过<code>HelloWorldService.AsyncClient</code>的实例对象，以<strong>异步</strong>的方式<strong>访问服务端</strong>提供的服务方法。</li>
</ul>
<h3 id="二-新建Maven工程">(二) 新建Maven工程</h3>
<p>a). 新建<code>maven</code>工程，引入<code>thrift</code>的依赖，这里使用的是版本<code>0.10.0</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;<br>    &lt;artifactId&gt;libthrift&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">0.10</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br></code></pre></td></tr></table></figure>
<p>b). 将生成类的<code>HelloWorldService.java</code>源文件拷贝进项目源文件目录中，并实现<code>HelloWorldService.Iface</code>的定义的<code>say()</code>方法。</p>
<p>HelloWorldServiceImpl.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> com.example.catserver.thrift;<br><br><span class="hljs-keyword">import</span> com.example.catserver.iface.HelloWorldService;<br><span class="hljs-keyword">import</span> org.apache.thrift.TException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guolonghang</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloWorldService</span>.<span class="hljs-title">Iface</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span> + username;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>c). 服务器端程序编写：</p>
<p>SimpleServer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.catserver.thrift;<br><br><span class="hljs-keyword">import</span> com.example.catserver.iface.HelloWorldService;<br><span class="hljs-keyword">import</span> org.apache.thrift.protocol.TBinaryProtocol;<br><span class="hljs-keyword">import</span> org.apache.thrift.server.TServer;<br><span class="hljs-keyword">import</span> org.apache.thrift.server.TSimpleServer;<br><span class="hljs-keyword">import</span> org.apache.thrift.transport.TServerSocket;<br><span class="hljs-keyword">import</span> org.apache.thrift.transport.TTransportException;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guolonghang</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleServer</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(SimpleServer.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer port = <span class="hljs-number">8080</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TTransportException </span>&#123;<br>        <span class="hljs-comment">//服务端地址</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(port);<br>        TServerSocket serverTransport = <span class="hljs-keyword">new</span> TServerSocket(serverSocket);<br>        <span class="hljs-comment">//通信处理</span><br>        HelloWorldService.Processor&lt;HelloWorldService.Iface&gt; processor =<br>                <span class="hljs-keyword">new</span> HelloWorldService.Processor&lt;&gt;(<span class="hljs-keyword">new</span> HelloWorldServiceImpl());<br>        <span class="hljs-comment">//二进制传输协议</span><br>        TBinaryProtocol.Factory protocolFactory = <span class="hljs-keyword">new</span> TBinaryProtocol.Factory();<br>        <span class="hljs-comment">//单线程服务器端，使用标准的阻塞式I/O</span><br>        TSimpleServer.Args tArgs = <span class="hljs-keyword">new</span> TSimpleServer.Args(serverTransport);<br>        tArgs.processor(processor);<br>        tArgs.protocolFactory(protocolFactory);<br><br>        <span class="hljs-comment">// 简单的单线程服务模型 一般用于测试</span><br>        TServer tServer = <span class="hljs-keyword">new</span> TSimpleServer(tArgs);<br>        logger.info(<span class="hljs-string">&quot;server run&quot;</span>);<br>        tServer.serve();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>d). 客户端程序编写：</p>
<p>SimpleClient.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.catclient.thrift;<br><br><br><span class="hljs-keyword">import</span> com.example.catclient.iface.HelloWorldService;<br><span class="hljs-keyword">import</span> org.apache.thrift.TException;<br><span class="hljs-keyword">import</span> org.apache.thrift.protocol.TBinaryProtocol;<br><span class="hljs-keyword">import</span> org.apache.thrift.protocol.TProtocol;<br><span class="hljs-keyword">import</span> org.apache.thrift.transport.TSocket;<br><span class="hljs-keyword">import</span> org.apache.thrift.transport.TTransport;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guolonghang</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(SimpleClient.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String ip = <span class="hljs-string">&quot;localhost&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer port=<span class="hljs-number">8080</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer timeout=<span class="hljs-number">100</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (TTransport transport = <span class="hljs-keyword">new</span> TSocket(ip, port, timeout)) &#123;<br>            <span class="hljs-comment">//配置传输方式</span><br>            <span class="hljs-comment">//配置传输协议</span><br>            TProtocol protocol = <span class="hljs-keyword">new</span> TBinaryProtocol(transport);<br>            <span class="hljs-comment">//以同步的方式访问服务端</span><br>            HelloWorldService.Client client = <span class="hljs-keyword">new</span> HelloWorldService.Client(protocol);<br>            <span class="hljs-comment">//通信</span><br>            transport.open();<br>            String result = client.say(<span class="hljs-string">&quot;Keng&quot;</span>);<br>            logger.info(<span class="hljs-string">&quot;Result := &#123;&#125;&quot;</span>, result);<br>        &#125; <span class="hljs-keyword">catch</span> (TException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>e). 运行服务端程序，<strong>服务端</strong>在<strong>指定端口</strong>监听<strong>客户端</strong>的<strong>连接请求</strong>，控制台输出启动日志：</p>
<img src="Thrift%E5%8D%8F%E8%AE%AE/image-20220420161911532.png" alt="image-20220420161911532" style="zoom:50%;" />
<p>f). 运行客户端程序，<strong>客户端</strong>通过网络请求<code>HelloWorldService</code>的<code>say()</code>方法的<strong>具体实现</strong>，控制台输出返回结果：</p>
<img src="Thrift%E5%8D%8F%E8%AE%AE/image-20220420161841316.png" alt="image-20220420161841316" style="zoom:50%;" />
<p>一个简单的<strong>单线程同步</strong>的<strong>简单服务模型</strong>完成测试。</p>
<h1>网络服务模型</h1>
<p><code>Thrift</code>提供的<strong>网络服务模型</strong>：<strong>单线程</strong>、<strong>多线程</strong>、<strong>事件驱动</strong>，从另一个角度划分为：<strong>阻塞服务模型</strong>、<strong>非阻塞服务模型</strong>。</p>
<ul>
<li>阻塞服务模型：<code>TSimpleServer</code>、<code>TThreadPoolServer</code>。</li>
<li>非阻塞服务模型：<code>TNonblockingServer</code>、<code>THsHaServer</code>和<code>TThreadedSelectorServer</code>。</li>
</ul>
<p><code>TServer</code>类的层次关系：</p>
<img src="Thrift%E5%8D%8F%E8%AE%AE/image-20220420162929849.png" alt="image-20220420162929849" style="zoom:50%;" />
<h2 id="TServer">TServer</h2>
<p><code>TServer</code>定义了静态内部类<code>Args</code>，<code>Args</code>继承自抽象类<code>AbstractServerArgs</code>。<code>AbstractServerArgs</code>采用了建造者模式，向<code>TServer</code>提供各种工厂：</p>
<table>
<thead>
<tr>
<th>工厂属性</th>
<th>工厂类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ProcessorFactory</td>
<td>TProcessorFactory</td>
<td>处理层工厂类，用于具体的TProcessor对象的创建</td>
</tr>
<tr>
<td>InputTransportFactory</td>
<td>TTransportFactory</td>
<td>传输层输入工厂类，用于具体的TTransport对象的创建</td>
</tr>
<tr>
<td>OutputTransportFactory</td>
<td>TTransportFactory</td>
<td>传输层输出工厂类，用于具体的TTransport对象的创建</td>
</tr>
<tr>
<td>InputProtocolFactory</td>
<td>TProtocolFactory</td>
<td>协议层输入工厂类，用于具体的TProtocol对象的创建</td>
</tr>
<tr>
<td>OutputProtocolFactory</td>
<td>TProtocolFactory</td>
<td>协议层输出工厂类，用于具体的TProtocol对象的创建</td>
</tr>
</tbody>
</table>
<p>下面是<code>TServer</code>的部分核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TServer</span> </span>&#123;<br>  <br>  	<span class="hljs-comment">//设置服务端传输类型，如单线程、多线程等。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Args</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">thrift</span>.<span class="hljs-title">server</span>.<span class="hljs-title">TServer</span>.<span class="hljs-title">AbstractServerArgs</span>&lt;<span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">thrift</span>.<span class="hljs-title">server</span>.<span class="hljs-title">TServer</span>.<span class="hljs-title">Args</span>&gt; </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Args</span><span class="hljs-params">(TServerTransport transport)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(transport);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractServerArgs</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">thrift</span>.<span class="hljs-title">server</span>.<span class="hljs-title">TServer</span>.<span class="hljs-title">AbstractServerArgs</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        <span class="hljs-keyword">final</span> TServerTransport serverTransport;<br>        TProcessorFactory processorFactory;<br>        TTransportFactory inputTransportFactory = <span class="hljs-keyword">new</span> TTransportFactory();<br>        TTransportFactory outputTransportFactory = <span class="hljs-keyword">new</span> TTransportFactory();<br>        TProtocolFactory inputProtocolFactory = <span class="hljs-keyword">new</span> TBinaryProtocol.Factory();<br>        TProtocolFactory outputProtocolFactory = <span class="hljs-keyword">new</span> TBinaryProtocol.Factory();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractServerArgs</span><span class="hljs-params">(TServerTransport transport)</span> </span>&#123;<br>            serverTransport = transport;<br>        &#125;<br>    &#125;<br>		<br>  	<span class="hljs-comment">//五大工厂</span><br>    <span class="hljs-keyword">protected</span> TProcessorFactory processorFactory_;<br>    <span class="hljs-keyword">protected</span> TServerTransport serverTransport_;<br>    <span class="hljs-keyword">protected</span> TTransportFactory inputTransportFactory_;<br>    <span class="hljs-keyword">protected</span> TTransportFactory outputTransportFactory_;<br>    <span class="hljs-keyword">protected</span> TProtocolFactory inputProtocolFactory_;<br>    <span class="hljs-keyword">protected</span> TProtocolFactory outputProtocolFactory_;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isServing;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">TServer</span><span class="hljs-params">(org.apache.thrift.server.TServer.AbstractServerArgs args)</span> </span>&#123;<br>        processorFactory_ = args.processorFactory;<br>        serverTransport_ = args.serverTransport;<br>        inputTransportFactory_ = args.inputTransportFactory;<br>        outputTransportFactory_ = args.outputTransportFactory;<br>        inputProtocolFactory_ = args.inputProtocolFactory;<br>        outputProtocolFactory_ = args.outputProtocolFactory;<br>    &#125;<br>		<br>    <span class="hljs-comment">//启动服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">()</span></span>;<br>  	<span class="hljs-comment">//关闭服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>		<span class="hljs-comment">//检测服务状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isServing</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isServing;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setServing</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> serving)</span> </span>&#123;<br>        isServing = serving;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>TServer</code>的三个方法：<code>serve()</code>、<code>stop()</code>和<code>isServing()</code>。<code>serve()</code>用于启动服务，<code>stop()</code>用于关闭服务，<code>isServing()</code>用于检测服务的起停状态。</p>
<p><code>TServer</code>的<strong>不同实现类</strong>的启动方式不一样，因此<code>serve()</code>定义为抽象方法。不是所有的服务都需要优雅的退出, 因此<code>stop()</code>方法没有被定义为抽象。</p>
<h2 id="TSimpleServer：单线程阻塞式IO服务端类型">TSimpleServer：单线程阻塞式IO服务端类型</h2>
<h3 id="一-工作流程">(一) 工作流程</h3>
<p><code>TSimpleServer</code>的<strong>工作模式</strong>采用最简单的<strong>阻塞</strong>IO，实现方法简洁明了，便于理解，但是一次只能接收和处理一个<code>socket</code>连接，效率比较低。它主要用于演示<code>Thrift</code>的工作过程，在实际开发过程中很少用到它。</p>
<img src="Thrift%E5%8D%8F%E8%AE%AE/image-20220420164410791.png" alt="image-20220420164410791" style="zoom:50%;" />
<h3 id="二-使用入门">(二) 使用入门</h3>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(ServerConfig.SERVER_PORT);<br>TServerSocket serverTransport = <span class="hljs-keyword">new</span> TServerSocket(serverSocket);<br>HelloWorldService.Processor processor =<br>        <span class="hljs-keyword">new</span> HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(<span class="hljs-keyword">new</span> HelloWorldServiceImpl());<br>TBinaryProtocol.Factory protocolFactory = <span class="hljs-keyword">new</span> TBinaryProtocol.Factory();<br><br>TSimpleServer.Args tArgs = <span class="hljs-keyword">new</span> TSimpleServer.Args(serverTransport);<br>tArgs.processor(processor);<br>tArgs.protocolFactory(protocolFactory);<br><span class="hljs-comment">// 简单的单线程服务模型 一般用于测试</span><br>TServer tServer = <span class="hljs-keyword">new</span> TSimpleServer(tArgs);<br>System.out.println(<span class="hljs-string">&quot;Running Simple Server&quot;</span>);<br>tServer.serve();<br><br></code></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">    TTransport transport = <span class="hljs-keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT);<br>    TProtocol protocol = <span class="hljs-keyword">new</span> TBinaryProtocol(transport);<br>    HelloWorldService.Client client = <span class="hljs-keyword">new</span> HelloWorldService.Client(protocol);<br>    transport.open();<br><br>    String result = client.say(<span class="hljs-string">&quot;Leo&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;Result =: &quot;</span> + result);<br>    transport.close();<br>复制代码<br></code></pre></td></tr></table></figure>
<h3 id="三-源码分析">(三) 源码分析</h3>
<p>查看上述流程的源代码，即<code>TSimpleServer.java</code>中的<code>serve()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="hljs-comment">// (powered by FernFlower decompiler)</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">package</span> org.apache.thrift.server;<br><br><span class="hljs-keyword">import</span> org.apache.thrift.TException;<br><span class="hljs-keyword">import</span> org.apache.thrift.TProcessor;<br><span class="hljs-keyword">import</span> org.apache.thrift.protocol.TProtocol;<br><span class="hljs-keyword">import</span> org.apache.thrift.server.TServer.AbstractServerArgs;<br><span class="hljs-keyword">import</span> org.apache.thrift.transport.TTransport;<br><span class="hljs-keyword">import</span> org.apache.thrift.transport.TTransportException;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TSimpleServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TServer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TSimpleServer.class.getName());<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TSimpleServer</span><span class="hljs-params">(AbstractServerArgs args)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(args);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">this</span>.serverTransport_.listen();<br>        &#125; <span class="hljs-keyword">catch</span> (TTransportException var9) &#123;<br>            LOGGER.error(<span class="hljs-string">&quot;Error occurred during listening.&quot;</span>, var9);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventHandler_ != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.eventHandler_.preServe();<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.setServing(<span class="hljs-keyword">true</span>);<br><br>        <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.stopped_) &#123;<br>            TTransport client = <span class="hljs-keyword">null</span>;<br>            TProcessor processor = <span class="hljs-keyword">null</span>;<br>            TTransport inputTransport = <span class="hljs-keyword">null</span>;<br>            TTransport outputTransport = <span class="hljs-keyword">null</span>;<br>            TProtocol inputProtocol = <span class="hljs-keyword">null</span>;<br>            TProtocol outputProtocol = <span class="hljs-keyword">null</span>;<br>            ServerContext connectionContext = <span class="hljs-keyword">null</span>;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                client = <span class="hljs-keyword">this</span>.serverTransport_.accept();<br>                <span class="hljs-keyword">if</span> (client != <span class="hljs-keyword">null</span>) &#123;<br>                    processor = <span class="hljs-keyword">this</span>.processorFactory_.getProcessor(client);<br>                    inputTransport = <span class="hljs-keyword">this</span>.inputTransportFactory_.getTransport(client);<br>                    outputTransport = <span class="hljs-keyword">this</span>.outputTransportFactory_.getTransport(client);<br>                    inputProtocol = <span class="hljs-keyword">this</span>.inputProtocolFactory_.getProtocol(inputTransport);<br>                    outputProtocol = <span class="hljs-keyword">this</span>.outputProtocolFactory_.getProtocol(outputTransport);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventHandler_ != <span class="hljs-keyword">null</span>) &#123;<br>                        connectionContext = <span class="hljs-keyword">this</span>.eventHandler_.createContext(inputProtocol, outputProtocol);<br>                    &#125;<br><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventHandler_ != <span class="hljs-keyword">null</span>) &#123;<br>                            <span class="hljs-keyword">this</span>.eventHandler_.processContext(connectionContext, inputTransport, outputTransport);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span>(processor.process(inputProtocol, outputProtocol));<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (TTransportException var10) &#123;<br>            &#125; <span class="hljs-keyword">catch</span> (TException var11) &#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stopped_) &#123;<br>                    LOGGER.error(<span class="hljs-string">&quot;Thrift error occurred during processing of message.&quot;</span>, var11);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception var12) &#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stopped_) &#123;<br>                    LOGGER.error(<span class="hljs-string">&quot;Error occurred during processing of message.&quot;</span>, var12);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventHandler_ != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">this</span>.eventHandler_.deleteContext(connectionContext, inputProtocol, outputProtocol);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (inputTransport != <span class="hljs-keyword">null</span>) &#123;<br>                inputTransport.close();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (outputTransport != <span class="hljs-keyword">null</span>) &#123;<br>                outputTransport.close();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.setServing(<span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.stopped_ = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">this</span>.serverTransport_.interrupt();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><code>serve()</code>方法的操作：</p>
<ol>
<li>设置<code>TServerSocket</code>的<code>listen()</code>方法启动连接<strong>监听</strong>。</li>
<li>以<strong>阻塞</strong>的方式接受客户端地连接请求，每进入一个<strong>连接</strong>即为其创建一个通道<code>TTransport</code>对象。</li>
<li>为客户端创建<strong>处理器对象</strong>、<strong>输入传输通道对象</strong>、<strong>输出传输通道对象</strong>、<strong>输入协议对象</strong>和<strong>输出协议对象</strong>。</li>
<li>通过<code>TServerEventHandler</code>对象处理具体的业务请求。</li>
<li>处理完成后，将<code>Serving</code>置为<code>false</code>完成一次请求。</li>
</ol>
<h2 id="ThreadPoolServer">ThreadPoolServer</h2>
<p><code>TThreadPoolServer</code>模式采用<strong>阻塞</strong><code>socket</code>方式工作，主线程负责<strong>阻塞式</strong>监听是否有新<code>socket</code>到来，具体的业务处理交由一个<strong>线程池</strong>来处理。</p>
<h3 id="一-工作流程-2">(一) 工作流程</h3>
<img src="Thrift%E5%8D%8F%E8%AE%AE/image-20220420170214778.png" alt="image-20220420170214778" style="zoom:50%;" />
<h3 id="二-使用入门-2">(二) 使用入门</h3>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(ServerConfig.SERVER_PORT);<br>TServerSocket serverTransport = <span class="hljs-keyword">new</span> TServerSocket(serverSocket);<br>HelloWorldService.Processor&lt;HelloWorldService.Iface&gt; processor =<br>        <span class="hljs-keyword">new</span> HelloWorldService.Processor&lt;&gt;(<span class="hljs-keyword">new</span> HelloWorldServiceImpl());<br><br>TBinaryProtocol.Factory protocolFactory = <span class="hljs-keyword">new</span> TBinaryProtocol.Factory();<br>TThreadPoolServer.Args ttpsArgs = <span class="hljs-keyword">new</span> TThreadPoolServer.Args(serverTransport);<br>ttpsArgs.processor(processor);<br>ttpsArgs.protocolFactory(protocolFactory);<br><br><span class="hljs-comment">// 线程池服务模型 使用标准的阻塞式IO 预先创建一组线程处理请求</span><br>TServer ttpsServer = <span class="hljs-keyword">new</span> TThreadPoolServer(ttpsArgs);<br>System.out.println(<span class="hljs-string">&quot;Running ThreadPool Server&quot;</span>);<br>ttpsServer.serve();<br><br></code></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">TTransport transport = <span class="hljs-keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT);<br>TProtocol protocol = <span class="hljs-keyword">new</span> TBinaryProtocol(transport);<br>HelloWorldService.Client client = <span class="hljs-keyword">new</span> HelloWorldService.Client(protocol);<br><br>transport.open();<br>String result = client.say(<span class="hljs-string">&quot;ThreadPoolClient&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Result =: &quot;</span> + result);<br>transport.close();<br><br></code></pre></td></tr></table></figure>
<h3 id="三-源码分析-2">(三) 源码分析</h3>
<p><code>ThreadPoolServer</code>解决了<code>TSimpleServer</code>不支持<strong>并发</strong>和<strong>多连接</strong>的问题，引入了<strong>线程池</strong>。实现的模型是<code>One Thread Per Connection</code>。查看上述流程的源代码，先查看<strong>线程池</strong>的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">createDefaultExecutorService</span><span class="hljs-params">(TThreadPoolServer.Args args)</span> </span>&#123;<br>       SynchronousQueue&lt;Runnable&gt; executorQueue = <span class="hljs-keyword">new</span> SynchronousQueue();<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(args.minWorkerThreads, args.maxWorkerThreads, (<span class="hljs-keyword">long</span>)args.stopTimeoutVal, TimeUnit.SECONDS, executorQueue);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>SynchronousQueue</code>队列比较特殊：SynchronousQueue 也是一个队列来的，但它的特别之处在于它内部没有容器，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先take后put,原理是一样的)。<br>
<code>TThreadPoolServer.java</code>中的<code>serve()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">this</span>.serverTransport_.listen();<br>       &#125; <span class="hljs-keyword">catch</span> (TTransportException var10) &#123;<br>           LOGGER.error(<span class="hljs-string">&quot;Error occurred during listening.&quot;</span>, var10);<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventHandler_ != <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">this</span>.eventHandler_.preServe();<br>       &#125;<br><br>       <span class="hljs-keyword">this</span>.stopped_ = <span class="hljs-keyword">false</span>;<br>       <span class="hljs-keyword">this</span>.setServing(<span class="hljs-keyword">true</span>);<br>       <span class="hljs-keyword">int</span> var1 = <span class="hljs-number">0</span>;<br><br>       <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.stopped_) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               TTransport client = <span class="hljs-keyword">this</span>.serverTransport_.accept();<br>               TThreadPoolServer.WorkerProcess wp = <span class="hljs-keyword">new</span> TThreadPoolServer.WorkerProcess(client);<br>               <span class="hljs-keyword">int</span> retryCount = <span class="hljs-number">0</span>;<br>               <span class="hljs-keyword">long</span> remainTimeInMillis = <span class="hljs-keyword">this</span>.requestTimeoutUnit.toMillis(<span class="hljs-keyword">this</span>.requestTimeout);<br><br>               <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       <span class="hljs-keyword">this</span>.executorService_.execute(wp);<br>                       <span class="hljs-keyword">break</span>;<br>                   &#125; <span class="hljs-keyword">catch</span> (Throwable var13) &#123;<br>                       Throwable t = var13;<br>                       <span class="hljs-keyword">if</span> (!(var13 <span class="hljs-keyword">instanceof</span> RejectedExecutionException)) &#123;<br>                           <span class="hljs-keyword">if</span> (var13 <span class="hljs-keyword">instanceof</span> Error) &#123;<br>                               LOGGER.error(<span class="hljs-string">&quot;ExecutorService threw error: &quot;</span> + var13, var13);<br>                               <span class="hljs-keyword">throw</span> (Error)var13;<br>                           &#125;<br><br>                           LOGGER.warn(<span class="hljs-string">&quot;ExecutorService threw error: &quot;</span> + var13, var13);<br>                           <span class="hljs-keyword">break</span>;<br>                       &#125;<br><br>                       ++retryCount;<br><br>                       <span class="hljs-keyword">try</span> &#123;<br>                           <span class="hljs-keyword">if</span> (remainTimeInMillis &lt;= <span class="hljs-number">0L</span>) &#123;<br>                               client.close();<br>                               wp = <span class="hljs-keyword">null</span>;<br>                               LOGGER.warn(<span class="hljs-string">&quot;Task has been rejected by ExecutorService &quot;</span> + retryCount + <span class="hljs-string">&quot; times till timedout, reason: &quot;</span> + t);<br>                               <span class="hljs-keyword">break</span>;<br>                           &#125;<br><br>                           <span class="hljs-keyword">long</span> sleepTimeInMillis = (<span class="hljs-keyword">long</span>)(<span class="hljs-keyword">this</span>.random.nextDouble() * (<span class="hljs-keyword">double</span>)(<span class="hljs-number">1L</span> &lt;&lt; Math.min(retryCount, <span class="hljs-number">20</span>))) * <span class="hljs-keyword">this</span>.beBackoffSlotInMillis;<br>                           sleepTimeInMillis = Math.min(sleepTimeInMillis, remainTimeInMillis);<br>                           TimeUnit.MILLISECONDS.sleep(sleepTimeInMillis);<br>                           remainTimeInMillis -= sleepTimeInMillis;<br>                       &#125; <span class="hljs-keyword">catch</span> (InterruptedException var12) &#123;<br>                           LOGGER.warn(<span class="hljs-string">&quot;Interrupted while waiting to place client on executor queue.&quot;</span>);<br>                           Thread.currentThread().interrupt();<br>                           <span class="hljs-keyword">break</span>;<br>                       &#125;<br>                   &#125;<br>               &#125;<br>           &#125; <span class="hljs-keyword">catch</span> (TTransportException var14) &#123;<br>               <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stopped_) &#123;<br>                   ++var1;<br>                   LOGGER.warn(<span class="hljs-string">&quot;Transport error occurred during acceptance of message.&quot;</span>, var14);<br>               &#125;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">this</span>.executorService_.shutdown();<br>       <span class="hljs-keyword">long</span> timeoutMS = <span class="hljs-keyword">this</span>.stopTimeoutUnit.toMillis(<span class="hljs-keyword">this</span>.stopTimeoutVal);<br>       <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<br><br>       <span class="hljs-keyword">while</span>(timeoutMS &gt;= <span class="hljs-number">0L</span>) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-keyword">this</span>.executorService_.awaitTermination(timeoutMS, TimeUnit.MILLISECONDS);<br>               <span class="hljs-keyword">break</span>;<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException var11) &#123;<br>               <span class="hljs-keyword">long</span> newnow = System.currentTimeMillis();<br>               timeoutMS -= newnow - now;<br>               now = newnow;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">this</span>.setServing(<span class="hljs-keyword">false</span>);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p><code>serve()</code>方法的操作：</p>
<ol>
<li>设置<code>TServerSocket</code>的<code>listen()</code>方法启动连接<strong>监听</strong>。</li>
<li>以<strong>阻塞</strong>的方式接受<strong>客户端</strong>的<strong>连接请求</strong>，每进入一个<strong>连接</strong>，将<strong>通道对象</strong>封装成一个<code>WorkerProcess</code>对象(<code>WorkerProcess</code>实现了<code>Runnabel</code>接口)，并提交到<strong>线程池</strong>。</li>
<li><code>WorkerProcess</code>的<code>run()</code>方法负责<strong>业务处理</strong>，为客户端创建了<strong>处理器对象</strong>、<strong>输入传输通道对象</strong>、<strong>输出传输通道对象</strong>、<strong>输入协议对象</strong>和<strong>输出协议对象</strong>。</li>
<li>通过<code>TServerEventHandler</code>对象处理具体的业务请求。</li>
</ol>
<p><code>WorkerProcess</code>的<code>run()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            TProcessor processor = <span class="hljs-keyword">null</span>;<br>            TTransport inputTransport = <span class="hljs-keyword">null</span>;<br>            TTransport outputTransport = <span class="hljs-keyword">null</span>;<br>            TProtocol inputProtocol = <span class="hljs-keyword">null</span>;<br>            TProtocol outputProtocol = <span class="hljs-keyword">null</span>;<br>            TServerEventHandler eventHandler = <span class="hljs-keyword">null</span>;<br>            ServerContext connectionContext = <span class="hljs-keyword">null</span>;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                processor = TThreadPoolServer.<span class="hljs-keyword">this</span>.processorFactory_.getProcessor(<span class="hljs-keyword">this</span>.client_);<br>                inputTransport = TThreadPoolServer.<span class="hljs-keyword">this</span>.inputTransportFactory_.getTransport(<span class="hljs-keyword">this</span>.client_);<br>                outputTransport = TThreadPoolServer.<span class="hljs-keyword">this</span>.outputTransportFactory_.getTransport(<span class="hljs-keyword">this</span>.client_);<br>                inputProtocol = TThreadPoolServer.<span class="hljs-keyword">this</span>.inputProtocolFactory_.getProtocol(inputTransport);<br>                outputProtocol = TThreadPoolServer.<span class="hljs-keyword">this</span>.outputProtocolFactory_.getProtocol(outputTransport);<br>                eventHandler = TThreadPoolServer.<span class="hljs-keyword">this</span>.getEventHandler();<br>                <span class="hljs-keyword">if</span> (eventHandler != <span class="hljs-keyword">null</span>) &#123;<br>                    connectionContext = eventHandler.createContext(inputProtocol, outputProtocol);<br>                &#125;<br><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (eventHandler != <span class="hljs-keyword">null</span>) &#123;<br>                        eventHandler.processContext(connectionContext, inputTransport, outputTransport);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">while</span>(!TThreadPoolServer.<span class="hljs-keyword">this</span>.stopped_ &amp;&amp; processor.process(inputProtocol, outputProtocol));<br>            &#125; <span class="hljs-keyword">catch</span> (TSaslTransportException var15) &#123;<br>            &#125; <span class="hljs-keyword">catch</span> (TTransportException var16) &#123;<br>            &#125; <span class="hljs-keyword">catch</span> (TException var17) &#123;<br>                TThreadPoolServer.LOGGER.error(<span class="hljs-string">&quot;Thrift error occurred during processing of message.&quot;</span>, var17);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception var18) &#123;<br>                TThreadPoolServer.LOGGER.error(<span class="hljs-string">&quot;Error occurred during processing of message.&quot;</span>, var18);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (eventHandler != <span class="hljs-keyword">null</span>) &#123;<br>                    eventHandler.deleteContext(connectionContext, inputProtocol, outputProtocol);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (inputTransport != <span class="hljs-keyword">null</span>) &#123;<br>                    inputTransport.close();<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (outputTransport != <span class="hljs-keyword">null</span>) &#123;<br>                    outputTransport.close();<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.client_.isOpen()) &#123;<br>                    <span class="hljs-keyword">this</span>.client_.close();<br>                &#125;<br><br>            &#125;<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="四-优缺点">(四) 优缺点</h3>
<h4 id="TThreadPoolServer模式的优点">TThreadPoolServer模式的优点</h4>
<p>拆分了<strong>监听线程</strong>(<code>Accept Thread</code>)和处理<strong>客户端连接</strong>的<strong>工作线程</strong>(<code>Worker Thread</code>)，<strong>数据读取</strong>和<strong>业务处理</strong>都交给<strong>线程池</strong>处理。因此在<strong>并发量较大</strong>时新连接也能够被及时接受。</p>
<p><strong>线程池模式</strong>比较适合<strong>服务器端</strong>能预知最多有多少个<strong>客户端并发</strong>的情况，这时每个请求都能被业务线程池及时处理，性能也非常高。</p>
<h4 id="TThreadPoolServer模式的缺点">TThreadPoolServer模式的缺点</h4>
<p>线程池模式的处理能力受限于<strong>线程池</strong>的工作能力，当<strong>并发请求数</strong>大于线程池中的<strong>线程数</strong>时，新请求也只能<strong>排队等待</strong>。</p>
<h2 id="TNonblockingServer">TNonblockingServer</h2>
<p><code>TNonblockingServer</code>模式也是<strong>单线程工作</strong>，但是采用<code>NIO</code>的模式，借助<code>Channel/Selector</code>机制, 采用<code>IO</code><strong>事件模型</strong>来处理。</p>
<p>所有的<code>socket</code>都被注册到<code>selector</code>中，在一个<strong>线程</strong>中通过<code>seletor</code><strong>循环监控</strong>所有的<code>socket</code>。</p>
<p>每次<code>selector</code>循环结束时，处理所有的处于<strong>就绪状态</strong>的<code>socket</code>，对于有数据到来的<code>socket</code>进行<strong>数据读取</strong>操作，对于有数据发送的socket则进行<strong>数据发送</strong>操作，对于监听<code>socket</code>则产生一个新业务<code>socket</code>并将其<strong>注册</strong>到<code>selector</code>上。</p>
<blockquote>
<p>注意：TNonblockingServer要求底层的传输通道必须使用TFramedTransport。</p>
</blockquote>
<h3 id="一-工作流程-3">(一) 工作流程</h3>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/19/164185ecb6daaa5f~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:50%;" />
<h3 id="二-使用入门-3">(二) 使用入门</h3>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">TProcessor tprocessor = <span class="hljs-keyword">new</span> HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(<span class="hljs-keyword">new</span> HelloWorldServiceImpl());<br>TNonblockingServerSocket tnbSocketTransport = <span class="hljs-keyword">new</span> TNonblockingServerSocket(ServerConfig.SERVER_PORT);<br><br>TNonblockingServer.Args tnbArgs = <span class="hljs-keyword">new</span> TNonblockingServer.Args(tnbSocketTransport);<br>tnbArgs.processor(tprocessor);<br>tnbArgs.transportFactory(<span class="hljs-keyword">new</span> TFramedTransport.Factory());<br>tnbArgs.protocolFactory(<span class="hljs-keyword">new</span> TCompactProtocol.Factory());<br><br><span class="hljs-comment">// 使用非阻塞式IO服务端和客户端需要指定TFramedTransport数据传输的方式</span><br>TServer server = <span class="hljs-keyword">new</span> TNonblockingServer(tnbArgs);<br>System.out.println(<span class="hljs-string">&quot;Running Non-blocking Server&quot;</span>);<br>server.serve();<br><br></code></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">TTransport transport = <span class="hljs-keyword">new</span> TFramedTransport(<span class="hljs-keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT));<br><span class="hljs-comment">// 协议要和服务端一致</span><br>TProtocol protocol = <span class="hljs-keyword">new</span> TCompactProtocol(transport);<br>HelloWorldService.Client client = <span class="hljs-keyword">new</span> HelloWorldService.Client(protocol);<br>transport.open();<br><br>String result = client.say(<span class="hljs-string">&quot;NonBlockingClient&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Result =: &quot;</span> + result);<br>transport.close();<br></code></pre></td></tr></table></figure>
<h3 id="三-源码分析-3">(三) 源码分析</h3>
<p><code>TNonblockingServer</code>继承于<code>AbstractNonblockingServer</code>，这里我们更关心基于<code>NIO</code>的<code>selector</code>部分的关键代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">()</span> </span>&#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">this</span>.selector.select();<br>              Iterator selectedKeys = <span class="hljs-keyword">this</span>.selector.selectedKeys().iterator();<br><br>              <span class="hljs-keyword">while</span>(!TNonblockingServer.<span class="hljs-keyword">this</span>.stopped_ &amp;&amp; selectedKeys.hasNext()) &#123;<br>                  SelectionKey key = (SelectionKey)selectedKeys.next();<br>                  selectedKeys.remove();<br>                  <span class="hljs-keyword">if</span> (!key.isValid()) &#123;<br>                      <span class="hljs-keyword">this</span>.cleanupSelectionKey(key);<br>                  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                      <span class="hljs-keyword">this</span>.handleAccept();<br>                  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                      <span class="hljs-keyword">this</span>.handleRead(key);<br>                  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>                      <span class="hljs-keyword">this</span>.handleWrite(key);<br>                  &#125; <span class="hljs-keyword">else</span> &#123;<br>                      TNonblockingServer.<span class="hljs-keyword">this</span>.LOGGER.warn(<span class="hljs-string">&quot;Unexpected state in select! &quot;</span> + key.interestOps());<br>                  &#125;<br>              &#125;<br>          &#125; <span class="hljs-keyword">catch</span> (IOException var3) &#123;<br>              TNonblockingServer.<span class="hljs-keyword">this</span>.LOGGER.warn(<span class="hljs-string">&quot;Got an IOException while selecting!&quot;</span>, var3);<br>          &#125;<br><br>      &#125;<br></code></pre></td></tr></table></figure>
<p><code>run()</code>:业务具体处理逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (TNonblockingServer.<span class="hljs-keyword">this</span>.eventHandler_ != <span class="hljs-keyword">null</span>) &#123;<br>                    TNonblockingServer.<span class="hljs-keyword">this</span>.eventHandler_.preServe();<br>                &#125;<br><br>                <span class="hljs-keyword">while</span>(!TNonblockingServer.<span class="hljs-keyword">this</span>.stopped_) &#123;<br>                    <span class="hljs-keyword">this</span>.select();<br>                    <span class="hljs-keyword">this</span>.processInterestChanges();<br>                &#125;<br><br>                Iterator i$ = <span class="hljs-keyword">this</span>.selector.keys().iterator();<br><br>                <span class="hljs-keyword">while</span>(i$.hasNext()) &#123;<br>                    SelectionKey selectionKey = (SelectionKey)i$.next();<br>                    <span class="hljs-keyword">this</span>.cleanupSelectionKey(selectionKey);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var11) &#123;<br>                TNonblockingServer.<span class="hljs-keyword">this</span>.LOGGER.error(<span class="hljs-string">&quot;run() exiting due to uncaught error&quot;</span>, var11);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">this</span>.selector.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;<br>                    TNonblockingServer.<span class="hljs-keyword">this</span>.LOGGER.error(<span class="hljs-string">&quot;Got an IOException while closing selector!&quot;</span>, var10);<br>                &#125;<br><br>                TNonblockingServer.<span class="hljs-keyword">this</span>.stopped_ = <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>        &#125;<br><br></code></pre></td></tr></table></figure>
<p><code>server()</code>:启动服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.startThreads()) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.startListening()) &#123;<br>                <span class="hljs-keyword">this</span>.setServing(<span class="hljs-keyword">true</span>);<br>                <span class="hljs-keyword">this</span>.waitForShutdown();<br>                <span class="hljs-keyword">this</span>.setServing(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-keyword">this</span>.stopListening();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>startThreads()</code>:启动select线程进行多路IO</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startThreads</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">this</span>.selectAcceptThread_ = <span class="hljs-keyword">new</span> TNonblockingServer.SelectAcceptThread((TNonblockingServerTransport)<span class="hljs-keyword">this</span>.serverTransport_);<br>           <span class="hljs-keyword">this</span>.selectAcceptThread_.start();<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>       &#125; <span class="hljs-keyword">catch</span> (IOException var2) &#123;<br>           <span class="hljs-keyword">this</span>.LOGGER.error(<span class="hljs-string">&quot;Failed to start selector thread!&quot;</span>, var2);<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p><code>waitForShutdown()</code>:：等待关闭服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitForShutdown</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.joinSelector();<br>   &#125;<br></code></pre></td></tr></table></figure>
<h3 id="四-优缺点-2">(四) 优缺点</h3>
<h4 id="TNonblockingServer模式优点">TNonblockingServer模式优点</h4>
<p>相比于<code>TSimpleServer</code>效率提升主要体现在<code>IO</code><strong>多路复用上</strong>，<code>TNonblockingServer</code>采用<strong>非阻塞</strong><code>IO</code>，对<code>accept/read/write</code>等<code>IO</code>事件进行<strong>监控</strong>和<strong>处理</strong>，同时监控多个<code>socket</code>的状态变化。</p>
<h4 id="TNonblockingServer模式缺点">TNonblockingServer模式缺点</h4>
<p><code>TNonblockingServer</code>模式在<strong>业务处理</strong>上还是采用<strong>单线程顺序</strong>来完成。在业务处理比较<strong>复杂</strong>、<strong>耗时</strong>的时候，例如某些接口函数需要读取数据库执行时间较长，会导致<strong>整个服务</strong>被<strong>阻塞</strong>住，此时该模式<strong>效率也不高</strong>，因为<strong>多个调用请求任务</strong>依然是<strong>顺序</strong>一个接一个执行。</p>
<h2 id="THsHaServer">THsHaServer</h2>
<p>鉴于<code>TNonblockingServer</code>的缺点，<code>THsHaServer</code>继承于<code>TNonblockingServer</code>，引入了<strong>线程池</strong>提高了任务处理的<strong>并发能力</strong>。<code>THsHaServer</code>是<strong>半同步半异步</strong>(<code>Half-Sync/Half-Async</code>)的处理模式，<code>Half-Aysnc</code>用于<code>IO</code><strong>事件处理</strong>(<code>Accept/Read/Write</code>)，<code>Half-Sync</code>用于业务<code>handler</code>对<code>rpc</code>的<strong>同步处理</strong>上。</p>
<blockquote>
<p>注意：THsHaServer和TNonblockingServer一样，要求底层的传输通道必须使用TFramedTransport。</p>
</blockquote>
<h3 id="一-工作流程-4">(一) 工作流程</h3>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/19/164185ecc4675e69~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:50%;" />
<h3 id="二-使用入门-4">(二) 使用入门</h3>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">TNonblockingServerSocket tnbSocketTransport = <span class="hljs-keyword">new</span> TNonblockingServerSocket(ServerConfig.SERVER_PORT);<br>TProcessor tprocessor = <span class="hljs-keyword">new</span> HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(<span class="hljs-keyword">new</span> HelloWorldServiceImpl());<br><span class="hljs-comment">// 半同步半异步</span><br>THsHaServer.Args thhsArgs = <span class="hljs-keyword">new</span> THsHaServer.Args(tnbSocketTransport);<br>thhsArgs.processor(tprocessor);<br>thhsArgs.transportFactory(<span class="hljs-keyword">new</span> TFramedTransport.Factory());<br>thhsArgs.protocolFactory(<span class="hljs-keyword">new</span> TBinaryProtocol.Factory());<br><br>TServer server = <span class="hljs-keyword">new</span> THsHaServer(thhsArgs);<br>System.out.println(<span class="hljs-string">&quot;Running HsHa Server&quot;</span>);<br>server.serve();<br><br></code></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">TTransport transport = <span class="hljs-keyword">new</span> TFramedTransport(<span class="hljs-keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT));<br><span class="hljs-comment">// 协议要和服务端一致</span><br>TProtocol protocol = <span class="hljs-keyword">new</span> TBinaryProtocol(transport);<br>HelloWorldService.Client client = <span class="hljs-keyword">new</span> HelloWorldService.Client(protocol);<br>transport.open();<br><br>String result = client.say(<span class="hljs-string">&quot;HsHaClient&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Result =: &quot;</span> + result);<br>transport.close();<br><br></code></pre></td></tr></table></figure>
<h3 id="三-源码分析-4">(三) 源码分析</h3>
<p><code>THsHaServer</code>继承于<code>TNonblockingServer</code>，新增了<strong>线程池</strong>并发处理工作任务的功能，查看线程池的相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">THsHaServer</span><span class="hljs-params">(THsHaServer.Args args)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(args);<br>        <span class="hljs-keyword">this</span>.invoker = args.executorService == <span class="hljs-keyword">null</span> ? createInvokerPool(args) : args.executorService;<br>        <span class="hljs-keyword">this</span>.args = args;<br>    &#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">createInvokerPool</span><span class="hljs-params">(THsHaServer.Args options)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> minWorkerThreads = options.minWorkerThreads;<br>        <span class="hljs-keyword">int</span> maxWorkerThreads = options.maxWorkerThreads;<br>        <span class="hljs-keyword">int</span> stopTimeoutVal = options.stopTimeoutVal;<br>        TimeUnit stopTimeoutUnit = options.stopTimeoutUnit;<br>        LinkedBlockingQueue&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> LinkedBlockingQueue();<br>        ExecutorService invoker = <span class="hljs-keyword">new</span> ThreadPoolExecutor(minWorkerThreads, maxWorkerThreads, (<span class="hljs-keyword">long</span>)stopTimeoutVal, stopTimeoutUnit, queue);<br>        <span class="hljs-keyword">return</span> invoker;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>下文的TThreadedSelectorServer囊括了THsHaServer的大部分特性，源码分析可参考TThreadedSelectorServer。</p>
</blockquote>
<h3 id="四-优缺点-3">(四) 优缺点</h3>
<h4 id="THsHaServer的优点">THsHaServer的优点</h4>
<p><code>THsHaServer</code>与<code>TNonblockingServer</code>模式相比，<code>THsHaServer</code>在完成<strong>数据读取</strong>之后，将<strong>业务处理</strong>过程交由一个<strong>线程池</strong>来完成，<strong>主线程</strong>直接返回进行<strong>下一次循环</strong>操作，效率大大提升。</p>
<h4 id="THsHaServer的缺点">THsHaServer的缺点</h4>
<p><strong>主线程</strong>仍然需要完成所有<code>socket</code>的<strong>监听接收</strong>、<strong>数据读取</strong>和<strong>数据写入</strong>操作。当<strong>并发请求数</strong>较大时，且发送<strong>数据量</strong>较多时，监听<code>socket</code>上<strong>新连接请求</strong>不能被及时接受。</p>
<h2 id="TThreadedSelectorServer">TThreadedSelectorServer</h2>
<p><code>TThreadedSelectorServer</code>是对<code>THsHaServer</code>的一种扩充，它将<code>selector</code>中的<strong>读写</strong><code>IO</code><strong>事件</strong>(<code>read/write</code>)从<strong>主线程</strong>中分离出来。同时引入<code>worker</code><strong>工作线程池</strong>，它也是种<code>Half-Sync/Half-Async</code>的服务模型。</p>
<p><code>TThreadedSelectorServer</code>模式是目前<code>Thrift</code>提供的最高级的<strong>线程服务模型</strong>，它内部有如果几个部分构成：</p>
<ol>
<li><strong>一个</strong><code>AcceptThread</code>线程对象，专门用于处理监听<code>socket</code>上的新连接。</li>
<li><strong>若干个</strong><code>SelectorThread</code>对象专门用于处理业务<code>socket</code>的<strong>网络</strong><code>I/O</code><strong>读写</strong>操作，所有网络数据的<strong>读写</strong>均是有这些线程来完成。</li>
<li>一个<strong>负载均衡器</strong><code>SelectorThreadLoadBalancer</code>对象，主要用于<code>AcceptThread</code><strong>线程</strong>接收到一个新<code>socket</code>连接请求时，决定将这个<strong>新连接</strong>请求分配给哪个<code>SelectorThread</code><strong>线程</strong>。</li>
<li>一个<code>ExecutorService</code>类型的<strong>工作线程池</strong>，在<code>SelectorThread</code>线程中，监听到有业务<code>socket</code>中有调用请求过来，则将<strong>请求数据读取</strong>之后，交给<code>ExecutorService</code><strong>线程池</strong>中的线程完成此次调用的具体执行。主要用于处理每个<code>rpc</code>请求的<code>handler</code><strong>回调处理</strong>(这部分是<strong>同步的</strong>)。</li>
</ol>
<h3 id="一-工作流程-5">(一) 工作流程</h3>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/19/164185f134387cf5~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:50%;" />
<h3 id="二-使用入门-5">(二) 使用入门</h3>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">TNonblockingServerSocket serverSocket = <span class="hljs-keyword">new</span> TNonblockingServerSocket(ServerConfig.SERVER_PORT);<br>TProcessor processor = <span class="hljs-keyword">new</span> HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(<span class="hljs-keyword">new</span> HelloWorldServiceImpl());<br><span class="hljs-comment">// 多线程半同步半异步</span><br>TThreadedSelectorServer.Args ttssArgs = <span class="hljs-keyword">new</span> TThreadedSelectorServer.Args(serverSocket);<br>ttssArgs.processor(processor);<br>ttssArgs.protocolFactory(<span class="hljs-keyword">new</span> TBinaryProtocol.Factory());<br><span class="hljs-comment">// 使用非阻塞式IO时 服务端和客户端都需要指定数据传输方式为TFramedTransport</span><br>ttssArgs.transportFactory(<span class="hljs-keyword">new</span> TFramedTransport.Factory());<br><br><span class="hljs-comment">// 多线程半同步半异步的服务模型</span><br>TThreadedSelectorServer server = <span class="hljs-keyword">new</span> TThreadedSelectorServer(ttssArgs);<br>System.out.println(<span class="hljs-string">&quot;Running ThreadedSelector Server&quot;</span>);<br>server.serve();<br><br></code></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;Thread &quot;</span> + i) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 设置传输通道 对于非阻塞服务 需要使用TFramedTransport(用于将数据分块发送)</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                TTransport transport = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    transport = <span class="hljs-keyword">new</span> TFramedTransport(<span class="hljs-keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT));<br>                    TProtocol protocol = <span class="hljs-keyword">new</span> TBinaryProtocol(transport);<br>                    HelloWorldService.Client client = <span class="hljs-keyword">new</span> HelloWorldService.Client(protocol);<br>                    transport.open();<br>                    String result = client.say(<span class="hljs-string">&quot;ThreadedSelector Client&quot;</span>);<br>                    System.out.println(<span class="hljs-string">&quot;Result =: &quot;</span> + result);<br>                    transport.close();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 关闭传输通道</span><br>                    transport.close();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;.start();<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>
<h3 id="三-核心代码">(三) 核心代码</h3>
<p>以上工作流程的三个组件<code>AcceptThread</code>、<code>SelectorThread</code>和<code>ExecutorService</code>在源码中的定义如下：</p>
<p><code>TThreadedSelectorServer</code>模式中有一个专门的线程<code>AcceptThread</code>用于处理<strong>新连接请求</strong>，因此能够及时响应<strong>大量并发连接请求</strong>；另外它将<strong>网络I/O操作</strong>分散到多个<code>SelectorThread</code><strong>线程</strong>中来完成，因此能够快速对<strong>网络</strong><code>I/O</code>进行<strong>读写操作</strong>，能够很好地应对<strong>网络</strong><code>I/O</code>较多的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">private</span> TThreadedSelectorServer.AcceptThread acceptThread;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;TThreadedSelectorServer.SelectorThread&gt; selectorThreads = <span class="hljs-keyword">new</span> HashSet();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService invoker;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Args</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractNonblockingServerArgs</span>&lt;<span class="hljs-title">TThreadedSelectorServer</span>.<span class="hljs-title">Args</span>&gt; </span>&#123;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> selectorThreads = <span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> workerThreads = <span class="hljs-number">5</span>;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> stopTimeoutVal = <span class="hljs-number">60</span>;<br>       <span class="hljs-keyword">private</span> TimeUnit stopTimeoutUnit;<br>       <span class="hljs-keyword">private</span> ExecutorService executorService;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> acceptQueueSizePerThread;<br>       <span class="hljs-keyword">private</span> TThreadedSelectorServer.Args.AcceptPolicy acceptPolicy;<br><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Args</span><span class="hljs-params">(TNonblockingServerTransport transport)</span> </span>&#123;<br>           <span class="hljs-keyword">super</span>(transport);<br>           <span class="hljs-keyword">this</span>.stopTimeoutUnit = TimeUnit.SECONDS;<br>           <span class="hljs-keyword">this</span>.executorService = <span class="hljs-keyword">null</span>;<br>           <span class="hljs-keyword">this</span>.acceptQueueSizePerThread = <span class="hljs-number">4</span>;<br>           <span class="hljs-keyword">this</span>.acceptPolicy = TThreadedSelectorServer.Args.AcceptPolicy.FAST_ACCEPT;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>负责网络IO读写的selector默认线程数(selectorThreads)：2</li>
<li>负责业务处理的默认工作线程数(workerThreads)：5</li>
<li>工作线程池单个线程的任务队列大小(acceptQueueSizePerThread)：4</li>
</ul>
<p>创建、初始化并启动<code>AcceptThread</code>和<code>SelectorThreads</code>，同时启动<code>selector</code>线程的<strong>负载均衡器</strong>(<code>selectorThreads</code>)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startThreads</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.args.selectorThreads; ++i) &#123;<br>            <span class="hljs-keyword">this</span>.selectorThreads.add(<span class="hljs-keyword">new</span> TThreadedSelectorServer.SelectorThread(<span class="hljs-keyword">this</span>.args.acceptQueueSizePerThread));<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.acceptThread = <span class="hljs-keyword">new</span> TThreadedSelectorServer.AcceptThread((TNonblockingServerTransport)<span class="hljs-keyword">this</span>.serverTransport_, <span class="hljs-keyword">this</span>.createSelectorThreadLoadBalancer(<span class="hljs-keyword">this</span>.selectorThreads));<br>        Iterator i$ = <span class="hljs-keyword">this</span>.selectorThreads.iterator();<br><br>        <span class="hljs-keyword">while</span>(i$.hasNext()) &#123;<br>            TThreadedSelectorServer.SelectorThread thread = (TThreadedSelectorServer.SelectorThread)i$.next();<br>            thread.start();<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.acceptThread.start();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException var3) &#123;<br>        LOGGER.error(<span class="hljs-string">&quot;Failed to start threads!&quot;</span>, var3);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="AcceptThread源码">AcceptThread源码</h4>
<p><code>AcceptThread</code>继承于<code>Thread</code>，可以看出包含三个重要的属性：<strong>非阻塞式传输通道</strong>(<code>TNonblockingServerTransport</code>)、<code>NIO</code><strong>选择器</strong>(<code>acceptSelector</code>)和<strong>选择器线程负载均衡器</strong>(<code>threadChooser</code>)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AcceptThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TNonblockingServerTransport serverTransport;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector acceptSelector;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TThreadedSelectorServer.SelectorThreadLoadBalancer threadChooser;<br><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AcceptThread</span><span class="hljs-params">(TNonblockingServerTransport serverTransport, TThreadedSelectorServer.SelectorThreadLoadBalancer threadChooser)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>           <span class="hljs-keyword">this</span>.serverTransport = serverTransport;<br>           <span class="hljs-keyword">this</span>.threadChooser = threadChooser;<br>           <span class="hljs-keyword">this</span>.acceptSelector = SelectorProvider.provider().openSelector();<br>           <span class="hljs-keyword">this</span>.serverTransport.registerSelector(<span class="hljs-keyword">this</span>.acceptSelector);<br>       &#125;<br></code></pre></td></tr></table></figure>
<p>查看<code>AcceptThread</code>的<code>run()</code>方法，可以看出<code>accept</code>线程一旦启动，就会不停地调用<code>select()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-keyword">if</span> (TThreadedSelectorServer.<span class="hljs-keyword">this</span>.eventHandler_ != <span class="hljs-keyword">null</span>) &#123;<br>                   TThreadedSelectorServer.<span class="hljs-keyword">this</span>.eventHandler_.preServe();<br>               &#125;<br><br>               <span class="hljs-keyword">while</span>(!TThreadedSelectorServer.<span class="hljs-keyword">this</span>.stopped_) &#123;<br>                   <span class="hljs-keyword">this</span>.select();<br>               &#125;<br>           &#125; <span class="hljs-keyword">catch</span> (Throwable var10) &#123;<br>               TThreadedSelectorServer.LOGGER.error(<span class="hljs-string">&quot;run() on AcceptThread exiting due to uncaught error&quot;</span>, var10);<br>           &#125; <span class="hljs-keyword">finally</span> &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-keyword">this</span>.acceptSelector.close();<br>               &#125; <span class="hljs-keyword">catch</span> (IOException var9) &#123;<br>                   TThreadedSelectorServer.LOGGER.error(<span class="hljs-string">&quot;Got an IOException while closing accept selector!&quot;</span>, var9);<br>               &#125;<br><br>               TThreadedSelectorServer.<span class="hljs-keyword">this</span>.stop();<br>           &#125;<br><br>       &#125;<br></code></pre></td></tr></table></figure>
<p>查看<code>select()</code>方法，<code>acceptSelector</code><strong>选择器</strong>等待<code>IO</code>事件的到来，拿到<code>SelectionKey</code>即检查是不是<code>accept</code>事件。如果是，通过<code>handleAccept()</code>方法接收一个<strong>新来的连接</strong>；否则，如果是<code>IO</code><strong>读写事件</strong>，<code>AcceptThread</code>不作任何处理，交由<code>SelectorThread</code>完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.acceptSelector.select();<br>                Iterator selectedKeys = <span class="hljs-keyword">this</span>.acceptSelector.selectedKeys().iterator();<br><br>                <span class="hljs-keyword">while</span>(!TThreadedSelectorServer.<span class="hljs-keyword">this</span>.stopped_ &amp;&amp; selectedKeys.hasNext()) &#123;<br>                    SelectionKey key = (SelectionKey)selectedKeys.next();<br>                    selectedKeys.remove();<br>                    <span class="hljs-keyword">if</span> (key.isValid()) &#123;<br>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                            <span class="hljs-keyword">this</span>.handleAccept();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            TThreadedSelectorServer.LOGGER.warn(<span class="hljs-string">&quot;Unexpected state in select! &quot;</span> + key.interestOps());<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException var3) &#123;<br>                TThreadedSelectorServer.LOGGER.warn(<span class="hljs-string">&quot;Got an IOException while selecting!&quot;</span>, var3);<br>            &#125;<br><br>        &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>handleAccept()</code>方法中，先通过<code>doAccept()</code>去拿<strong>连接通道</strong>，然后<code>Selector</code><strong>线程负载均衡器</strong>选择一个<code>Selector</code>线程，完成接下来的<code>IO</code><strong>读写事件</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleAccept</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">final</span> TNonblockingTransport client = <span class="hljs-keyword">this</span>.doAccept();<br>            <span class="hljs-keyword">if</span> (client != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">final</span> TThreadedSelectorServer.SelectorThread targetThread = <span class="hljs-keyword">this</span>.threadChooser.nextThread();<br>                <span class="hljs-keyword">if</span> (TThreadedSelectorServer.<span class="hljs-keyword">this</span>.args.acceptPolicy != TThreadedSelectorServer.Args.AcceptPolicy.FAST_ACCEPT &amp;&amp; TThreadedSelectorServer.<span class="hljs-keyword">this</span>.invoker != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        TThreadedSelectorServer.<span class="hljs-keyword">this</span>.invoker.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                                AcceptThread.<span class="hljs-keyword">this</span>.doAddAccept(targetThread, client);<br>                            &#125;<br>                        &#125;);<br>                    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException var4) &#123;<br>                        TThreadedSelectorServer.LOGGER.warn(<span class="hljs-string">&quot;ExecutorService rejected accept registration!&quot;</span>, var4);<br>                        client.close();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">this</span>.doAddAccept(targetThread, client);<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br></code></pre></td></tr></table></figure>
<p>接下来继续查看<code>doAddAccept()</code>方法的实现，毫无悬念，它进一步调用了<code>SelectorThread</code>的<code>addAcceptedConnection()</code>方法，把<strong>非阻塞传输通道对象</strong>传递给<strong>选择器线程</strong>做进一步的<code>IO</code><strong>读写操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAddAccept</span><span class="hljs-params">(TThreadedSelectorServer.SelectorThread thread, TNonblockingTransport client)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (!thread.addAcceptedConnection(client)) &#123;<br>                client.close();<br>            &#125;<br><br>        &#125;<br></code></pre></td></tr></table></figure>
<h4 id="SelectorThreadLoadBalancer源码">SelectorThreadLoadBalancer源码</h4>
<p><code>SelectorThreadLoadBalancer</code>如何创建？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> TThreadedSelectorServer.<span class="hljs-function">SelectorThreadLoadBalancer <span class="hljs-title">createSelectorThreadLoadBalancer</span><span class="hljs-params">(Collection&lt;? extends TThreadedSelectorServer.SelectorThread&gt; threads)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TThreadedSelectorServer.SelectorThreadLoadBalancer(threads);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p><code>SelectorThreadLoadBalancer</code>是一个基于<strong>轮询算法</strong>的<code>Selector</code><strong>线程选择器</strong>，通过<strong>线程迭代器</strong>为新进来的<strong>连接</strong>顺序分配<code>SelectorThread</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectorThreadLoadBalancer</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Collection&lt;? extends TThreadedSelectorServer.SelectorThread&gt; threads;<br>        <span class="hljs-keyword">private</span> Iterator&lt;? extends TThreadedSelectorServer.SelectorThread&gt; nextThreadIterator;<br><br>        <span class="hljs-keyword">public</span> &lt;T extends TThreadedSelectorServer.SelectorThread&gt; SelectorThreadLoadBalancer(Collection&lt;T&gt; threads) &#123;<br>            <span class="hljs-keyword">if</span> (threads.isEmpty()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;At least one selector thread is required&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">this</span>.threads = Collections.unmodifiableList(<span class="hljs-keyword">new</span> ArrayList(threads));<br>                <span class="hljs-keyword">this</span>.nextThreadIterator = <span class="hljs-keyword">this</span>.threads.iterator();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> TThreadedSelectorServer.<span class="hljs-function">SelectorThread <span class="hljs-title">nextThread</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.nextThreadIterator.hasNext()) &#123;<br>                <span class="hljs-keyword">this</span>.nextThreadIterator = <span class="hljs-keyword">this</span>.threads.iterator();<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> (TThreadedSelectorServer.SelectorThread)<span class="hljs-keyword">this</span>.nextThreadIterator.next();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="SelectorThread源码">SelectorThread源码</h4>
<p><code>SelectorThread</code>和<code>AcceptThread</code>一样，是<code>TThreadedSelectorServer</code>的一个<strong>成员内部类</strong>，每个<code>SelectorThread</code><strong>线程对象</strong>内部都有一个<strong>阻塞式的队列</strong>，用于存放该线程<strong>被接收</strong>的<strong>连接通道</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectorThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSelectThread</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;TNonblockingTransport&gt; acceptedQueue;<br></code></pre></td></tr></table></figure>
<p><strong>阻塞队列</strong>的大小可由构造函数指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SelectorThread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxPendingAccepts)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>           <span class="hljs-keyword">this</span>(TThreadedSelectorServer.createDefaultAcceptQueue(maxPendingAccepts));<br>       &#125;<br></code></pre></td></tr></table></figure>
<p>上面看到，在<code>AcceptThread</code>的<code>doAddAccept()</code>方法中调用了<code>SelectorThread</code>的<code>addAcceptedConnection()</code>方法。</p>
<p>这个方法做了两件事：</p>
<ol>
<li>将被此<code>SelectorThread</code>线程接收的<strong>连接通道</strong>放入<strong>阻塞队列</strong>中。</li>
<li>通过<code>wakeup()</code>方法唤醒<code>SelectorThread</code>中的<code>NIO</code><strong>选择器</strong><code>selector</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAcceptedConnection</span><span class="hljs-params">(TNonblockingTransport accepted)</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.acceptedQueue.put(accepted);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException var3) &#123;<br>                TThreadedSelectorServer.LOGGER.warn(<span class="hljs-string">&quot;Interrupted while adding accepted connection!&quot;</span>, var3);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">this</span>.selector.wakeup();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>既然<code>SelectorThread</code>也是继承于<code>Thread</code>，查看其<code>run()</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span>(!TThreadedSelectorServer.<span class="hljs-keyword">this</span>.stopped_) &#123;<br>                    <span class="hljs-keyword">this</span>.select();<br>                    <span class="hljs-keyword">this</span>.processAcceptedConnections();<br>                    <span class="hljs-keyword">this</span>.processInterestChanges();<br>                &#125;<br><br>                Iterator i$ = <span class="hljs-keyword">this</span>.selector.keys().iterator();<br><br>                <span class="hljs-keyword">while</span>(i$.hasNext()) &#123;<br>                    SelectionKey selectionKey = (SelectionKey)i$.next();<br>                    <span class="hljs-keyword">this</span>.cleanupSelectionKey(selectionKey);<br>                &#125;<br><br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var11) &#123;<br>                TThreadedSelectorServer.LOGGER.error(<span class="hljs-string">&quot;run() on SelectorThread exiting due to uncaught error&quot;</span>, var11);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">this</span>.selector.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;<br>                    TThreadedSelectorServer.LOGGER.error(<span class="hljs-string">&quot;Got an IOException while closing selector!&quot;</span>, var10);<br>                &#125;<br><br>                TThreadedSelectorServer.<span class="hljs-keyword">this</span>.stop();<br>            &#125;<br><br>        &#125;<br></code></pre></td></tr></table></figure>
<p><code>SelectorThread</code>方法的<code>select()</code>监听<code>IO</code>事件，仅仅用于处理<strong>数据读取</strong>和<strong>数据写入</strong>。如果连接有<strong>数据可读</strong>，读取并以<code>frame</code>的方式缓存；如果需要向连接中<strong>写入数据</strong>，缓存并发送客户端的数据。且在<strong>数据读写</strong>处理完成后，需要向<code>NIO</code>的<code>selector</code><strong>清空</strong>和<strong>注销</strong>自身的<code>SelectionKey</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.selector.select();<br>                Iterator selectedKeys = <span class="hljs-keyword">this</span>.selector.selectedKeys().iterator();<br><br>                <span class="hljs-keyword">while</span>(!TThreadedSelectorServer.<span class="hljs-keyword">this</span>.stopped_ &amp;&amp; selectedKeys.hasNext()) &#123;<br>                    SelectionKey key = (SelectionKey)selectedKeys.next();<br>                    selectedKeys.remove();<br>                    <span class="hljs-keyword">if</span> (!key.isValid()) &#123;<br>                        <span class="hljs-keyword">this</span>.cleanupSelectionKey(key);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                        <span class="hljs-keyword">this</span>.handleRead(key);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>                        <span class="hljs-keyword">this</span>.handleWrite(key);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        TThreadedSelectorServer.LOGGER.warn(<span class="hljs-string">&quot;Unexpected state in select! &quot;</span> + key.interestOps());<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException var3) &#123;<br>                TThreadedSelectorServer.LOGGER.warn(<span class="hljs-string">&quot;Got an IOException while selecting!&quot;</span>, var3);<br>            &#125;<br><br>        &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>数据写操作</strong>完成以后，整个<code>rpc</code>调用过程也就结束了，<code>handleWrite()</code>方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleWrite</span><span class="hljs-params">(SelectionKey key)</span> </span>&#123;<br>            AbstractNonblockingServer.FrameBuffer buffer = (AbstractNonblockingServer.FrameBuffer)key.attachment();<br>            <span class="hljs-keyword">if</span> (!buffer.write()) &#123;<br>                <span class="hljs-keyword">this</span>.cleanupSelectionKey(key);<br>            &#125;<br><br>        &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>数据读操作</strong>完成以后，<code>Thrift</code>会利用<strong>已读数据</strong>执行<strong>目标方法</strong>，<code>handleRead()</code>方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">(SelectionKey key)</span> </span>&#123;<br>            AbstractNonblockingServer.FrameBuffer buffer = (AbstractNonblockingServer.FrameBuffer)key.attachment();<br>            <span class="hljs-keyword">if</span> (!buffer.read()) &#123;<br>                <span class="hljs-keyword">this</span>.cleanupSelectionKey(key);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (buffer.isFrameFullyRead() &amp;&amp; !AbstractNonblockingServer.<span class="hljs-keyword">this</span>.requestInvoke(buffer)) &#123;<br>                    <span class="hljs-keyword">this</span>.cleanupSelectionKey(key);<br>                &#125;<br><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p><code>handleRead</code>方法在执行<code>read()</code>方法，将<strong>数据读取</strong>完成后，会调用<code>requestInvoke()</code>方法调用<strong>目标方法</strong>完成具体业务处理。<code>requestInvoke()</code>方法将<strong>请求数据</strong>封装为一个<code>Runnable</code>对象，提交到<strong>工作任务线程池</strong>(<code>ExecutorService</code>)进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">requestInvoke</span><span class="hljs-params">(FrameBuffer frameBuffer)</span> </span>&#123;<br>        Runnable invocation = <span class="hljs-keyword">this</span>.getRunnable(frameBuffer);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.invoker != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.invoker.execute(invocation);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException var4) &#123;<br>                LOGGER.warn(<span class="hljs-string">&quot;ExecutorService rejected execution!&quot;</span>, var4);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            invocation.run();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>select()</code>方法完成后，线程继续运行<code>processAcceptedConnections()</code>方法处理<strong>下一个连接</strong>的<code>IO</code>事件。</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/19/164185f210098119~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:100%;" />
<p>这里比较核心的几个操作：</p>
<ol>
<li>尝试从<code>SelectorThread</code>的<strong>阻塞队列</strong><code>acceptedQueue</code>中获取一个<strong>连接的传输通道</strong>。如果获取成功，调用<code>registerAccepted()</code>方法；否则，进入下一次循环。</li>
<li><code>registerAccepted()</code>方法将<strong>传输通道</strong>底层的<strong>连接</strong>注册到<code>NIO</code>的<strong>选择器</strong><code>selector</code>上面，获取到一个<code>SelectionKey</code>。</li>
<li>创建一个<code>FrameBuffer</code>对象，并绑定到获取的<code>SelectionKey</code>上面，用于数据传输时的中间<strong>读写缓存</strong>。</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文对<code>Thrift</code>的各种<strong>线程服务模型</strong>进行了介绍，包括2种<strong>阻塞式服务模型</strong>：<code>TSimpleServer</code>、<code>TThreadPoolServer</code>，3种<strong>非阻塞式服务模型</strong>：<code>TNonblockingServer</code>、<code>THsHaServer</code>和<code>TThreadedSelectorServer</code>。对各种服务模型的<strong>具体用法</strong>、<strong>工作流程</strong>、<strong>原理和源码实现</strong>进行了一定程度的分析。</p>
<h1>序列化机制</h1>
<p><code>Thrift</code>支持<strong>二进制</strong>，<strong>压缩格式</strong>，以及<code>json</code>格式数据的<strong>序列化</strong>和<strong>反序列化</strong>。开发人员可以更加灵活的选择协议的具体形式。协议是可<strong>自由扩展</strong>的，新版本的协议，完全<strong>兼容</strong>老的版本！</p>
<h1>正文</h1>
<h2 id="数据交换格式简介">数据交换格式简介</h2>
<p>当前流行的<strong>数据交换格式</strong>可以分为如下几类：</p>
<h3 id="一-自解析型">(一) 自解析型</h3>
<p>序列化的数据包含<strong>完整</strong>的结构， 包含了<code>field</code><strong>名称</strong>和<code>value</code><strong>值</strong>。比如<code>xml/json/java serizable</code>，大百度的<code>mcpack/compack</code>，都属于此类。即调整不同属性的<strong>顺序</strong>对<strong>序列化/反序列化</strong>不造成影响。</p>
<h3 id="二-半解析型">(二) 半解析型</h3>
<p>序列化的数据，丢弃了部分信息， 比如<code>field</code>名称， 但引入了<code>index</code>(常常是<code>id</code>+<code>type</code>的方式)来对应具体<strong>属性</strong>和<strong>值</strong>。这方面的代表有<code>google protobuf/thrift</code>也属于此类。</p>
<h3 id="三-无解析型">(三) 无解析型</h3>
<p>传说中大百度的<code>infpack</code>实现，就是借助该种方式来实现，丢弃了很多<strong>有效信息</strong>，<strong>性能/压缩</strong>比最好，不过向后兼容需要开发做一定的工作， 详情不知。</p>
<table>
<thead>
<tr>
<th>交换格式</th>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Xml</td>
<td>文本</td>
<td>易读</td>
<td>臃肿，不支持二进制数据类型</td>
</tr>
<tr>
<td>JSON</td>
<td>文本</td>
<td>易读</td>
<td>丢弃了类型信息，比如&quot;score&quot;:100，对score类型是int/double解析有二义性， 不支持二进制数据类型</td>
</tr>
<tr>
<td>Java serizable</td>
<td>二进制</td>
<td>使用简单</td>
<td>臃肿，只限制在JAVA领域</td>
</tr>
<tr>
<td>Thrift</td>
<td>二进制</td>
<td>高效</td>
<td>不易读，向后兼容有一定的约定限制</td>
</tr>
<tr>
<td>Google Protobuf</td>
<td>二进制</td>
<td>高效</td>
<td>不易读，向后兼容有一定的约定限制</td>
</tr>
</tbody>
</table>
<h2 id="Thrift的数据类型-2">Thrift的数据类型</h2>
<ol>
<li><strong>基本类型：</strong>  <strong>bool</strong>: 布尔值  <strong>byte</strong>: 8位有符号整数  <strong>i16</strong>: 16位有符号整数  <strong>i32</strong>: 32位有符号整数  <strong>i64</strong>: 64位有符号整数  <strong>double</strong>: 64位浮点数  <strong>string</strong>: UTF-8编码的字符串  <strong>binary</strong>: 二进制串</li>
<li><strong>结构体类型：</strong>  <strong>struct</strong>: 定义的结构体对象</li>
<li><strong>容器类型：</strong>  <strong>list</strong>: 有序元素列表  <strong>set</strong>: 无序无重复元素集合  <strong>map</strong>: 有序的key/value集合</li>
<li><strong>异常类型：</strong>  <strong>exception</strong>: 异常类型</li>
<li><strong>服务类型：</strong>  <strong>service</strong>: 具体对应服务的类</li>
</ol>
<h2 id="Thrift的序列化协议">Thrift的序列化协议</h2>
<p><code>Thrift</code>可以让用户选择<strong>客户端</strong>与<strong>服务端</strong>之间<strong>传输通信协议</strong>的类别，在<strong>传输协议</strong>上总体划分为<strong>文本</strong>(<code>text</code>)和<strong>二进制</strong>(<code>binary</code>)传输协议。为<strong>节约带宽</strong>，<strong>提高传输效率</strong>，一般情况下使用<strong>二进制</strong>类型的传输协议为多数，有时还会使用基于<strong>文本类型</strong>的协议，这需要根据项目/产品中的实际需求。常用协议有以下几种：</p>
<ul>
<li>TBinaryProtocol：<strong>二进制</strong>编码格式进行数据传输</li>
<li>TCompactProtocol：<strong>高效率</strong>的、<strong>密集</strong>的<strong>二进制</strong>编码格式进行数据传输</li>
<li>TJSONProtocol： 使用<code>JSON</code><strong>文本</strong>的数据编码协议进行数据传输</li>
<li>TSimpleJSONProtocol：只提供<code>JSON</code><strong>只写</strong>的协议，适用于通过<strong>脚本语言解析</strong></li>
</ul>
<h2 id="Thrift的序列化测试">Thrift的序列化测试</h2>
<p>(a). 首先编写一个简单的<code>thrift</code>文件<code>pair.thrift</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">struct Pair &#123;<br>    <span class="hljs-number">1</span>: required string key<br>    <span class="hljs-number">2</span>: required string value<br>&#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>这里标识了<code>required</code>的字段，要求在使用时必须正确赋值，否则运行时会抛出<code>TProtocolException</code>异常。缺省和指定为<code>optional</code>时，则运行时不做字段非空校验。</p>
</blockquote>
<p>(b). 编译并生成<code>java</code>源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">thrift -gen java pair.thrift<br><br></code></pre></td></tr></table></figure>
<p>©. 编写序列化和反序列化的测试代码：</p>
<ul>
<li>序列化测试，将<code>Pair</code>对象写入文件中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException， TException </span>&#123;<br>    Pair pair = <span class="hljs-keyword">new</span> Pair();<br>    pair.setKey(<span class="hljs-string">&quot;key1&quot;</span>).setValue(<span class="hljs-string">&quot;value1&quot;</span>);<br>    FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;pair.txt&quot;</span>));<br>    pair.write(<span class="hljs-keyword">new</span> TBinaryProtocol(<span class="hljs-keyword">new</span> TIOStreamTransport(fos)));<br>    fos.close();<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>反序列化测试，从文件中解析生成<code>Pair</code>对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TException， IOException </span>&#123;<br>    Pair pair = <span class="hljs-keyword">new</span> Pair();<br>    FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;pair.txt&quot;</span>));<br>    pair.read(<span class="hljs-keyword">new</span> TBinaryProtocol(<span class="hljs-keyword">new</span> TIOStreamTransport(fis)));<br>    System.out.println(<span class="hljs-string">&quot;key =&gt; &quot;</span> + pair.getKey());<br>    System.out.println(<span class="hljs-string">&quot;value =&gt; &quot;</span> + pair.getValue());<br>    fis.close();<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>(d) 观察运行结果，正常输出表明<strong>序列化</strong>和<strong>反序列化</strong>过程正常完成。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/19/164185feecd44c1c~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<h2 id="Thrift协议源码">Thrift协议源码</h2>
<h3 id="一-writeData-分析">(一) writeData()分析</h3>
<p>首先查看<code>thrift</code>的<strong>序列化机制</strong>，即数据写入实现，这里采用<strong>二进制协议</strong><code>TBinaryProtocol</code>，切入点为<code>pair.write(TProtocol)</code>：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/19/164185feedbc8084~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>查看<code>scheme()</code>方法，决定采用<strong>元组计划</strong>(<code>TupleScheme</code>)还是<strong>标准计划</strong>(<code>StandardScheme</code>)来实现序列化，默认采用的是<strong>标准计划</strong><code>StandardScheme</code>。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/19/164185feee277b86~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p><strong>标准计划</strong>(<code>StandardScheme</code>)下的<code>write()</code>方法：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/19/164185ff1a8f1fdf~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>这里完成了几步操作：</p>
<p>(a). 根据<code>Thrift IDL</code>文件中定义了<code>required</code>的字段验证字段是否正确赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> org.apache.thrift.TException </span>&#123;<br>  <span class="hljs-comment">// check for required fields</span><br>  <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="hljs-string">&quot;Required field &#x27;key&#x27; was not present! Struct: &quot;</span> + toString());<br>  &#125;<br>  <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="hljs-string">&quot;Required field &#x27;value&#x27; was not present! Struct: &quot;</span> + toString());<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>(b). 通过<code>writeStructBegin()</code>记录<strong>写入结构</strong>的<strong>开始标记</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeStructBegin</span><span class="hljs-params">(TStruct struct)</span> </span>&#123;&#125;<br><br></code></pre></td></tr></table></figure>
<p>©. 逐一写入<code>Pair</code>对象的各个字段，包括字段<strong>字段开始标记</strong>、<strong>字段的值</strong>和<strong>字段结束标记</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (struct.key != <span class="hljs-keyword">null</span>) &#123;<br>  oprot.writeFieldBegin(KEY_FIELD_DESC);<br>  oprot.writeString(struct.key);<br>  oprot.writeFieldEnd();<br>&#125;<br><span class="hljs-comment">// 省略...</span><br><br></code></pre></td></tr></table></figure>
<p>(1). 首先是<strong>字段开始标记</strong>，包括<code>type</code>和<code>field-id</code>。<code>type</code>是字段的<strong>数据类型的标识号</strong>，<code>field-id</code>是<code>Thrift IDL</code>定义的<strong>字段次序</strong>，比如说<code>key</code>为1，<code>value</code>为2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeFieldBegin</span><span class="hljs-params">(TField field)</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  writeByte(field.type);<br>  writeI16(field.id);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><code>Thrift</code>提供了<code>TType</code>，对不同的<strong>数据类型</strong>(<code>type</code>)提供了唯一标识的<code>typeID</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TType</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> STOP   = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 数据读写完成</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> VOID   = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 空值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> BOOL   = <span class="hljs-number">2</span>;   <span class="hljs-comment">// 布尔值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> BYTE   = <span class="hljs-number">3</span>;   <span class="hljs-comment">// 字节</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> DOUBLE = <span class="hljs-number">4</span>;   <span class="hljs-comment">// 双精度浮点型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> I16    = <span class="hljs-number">6</span>;   <span class="hljs-comment">// 短整型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> I32    = <span class="hljs-number">8</span>;   <span class="hljs-comment">// 整型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> I64    = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 长整型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> STRING = <span class="hljs-number">11</span>;  <span class="hljs-comment">// 字符串类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> STRUCT = <span class="hljs-number">12</span>;  <span class="hljs-comment">// 引用类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> MAP    = <span class="hljs-number">13</span>;  <span class="hljs-comment">// Map</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> SET    = <span class="hljs-number">14</span>;  <span class="hljs-comment">// 集合</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> LIST   = <span class="hljs-number">15</span>;  <span class="hljs-comment">// 列表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> ENUM   = <span class="hljs-number">16</span>;  <span class="hljs-comment">// 枚举</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>(2). 然后是写入<strong>字段的值</strong>，根据字段的数据类型又归纳为以下实现：<code>writeByte()</code>、<code>writeBool()</code>、<code>writeI32()</code>、<code>writeI64()</code>、<code>writeDouble()</code>、<code>writeString()</code>和<code>writeBinary()</code>方法。</p>
<p><code>TBinaryProtocol</code>通过一个长度为<code>8</code>的<code>byte</code>字节数组缓存<strong>写入</strong>或<strong>读取</strong>的临时字节数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] inoutTemp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8</span>];<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>**常识1：**16进制的介绍。以0x开始的数据表示16进制，0xff换成十进制为255。在16进制中，A、B、C、D、E、F这五个字母来分别表示10、11、12、13、14、15。</p>
</blockquote>
<p><code>16</code><strong>进制</strong>变<strong>十进制</strong>：f表示15。第n位的权值为16的n次方，由右到左从0位起：0xff = 15<em>16^1 + 15</em>16^0 = 255 <code>16</code><strong>进制</strong>变<strong>二进制</strong>再变<strong>十进制</strong>：0xff = 1111 1111 = 2^8 - 1 = 255</p>
<blockquote>
<p>**常识2：**位运算符的使用。&gt;&gt;表示代表右移符号，如：int i=15; i&gt;&gt;2的结果是3，移出的部分将被抛弃。而&lt;&lt;表示左移符号，与&gt;&gt;刚好相反。</p>
</blockquote>
<p>转为<strong>二进制</strong>的形式可能更好理解，0000 1111(15)右移2位的结果是0000 0011(3)，0001 1010(18)右移3位的结果是0000 0011(3)。</p>
<ul>
<li><strong>writeByte()</strong>：写入<strong>单个字节</strong>数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeByte</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b)</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  inoutTemp[<span class="hljs-number">0</span>] = b;<br>  trans_.write(inoutTemp， <span class="hljs-number">0</span>， <span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>writeBool()</strong>：写入<strong>布尔值</strong>数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBool</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  writeByte(b ? (<span class="hljs-keyword">byte</span>)<span class="hljs-number">1</span> : (<span class="hljs-keyword">byte</span>)<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>writeI16()</strong>：写入<strong>短整型</strong><code>short</code>类型数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeI16</span><span class="hljs-params">(<span class="hljs-keyword">short</span> i16)</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  inoutTemp[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i16 &gt;&gt; <span class="hljs-number">8</span>));<br>  inoutTemp[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i16));<br>  trans_.write(inoutTemp， <span class="hljs-number">0</span>， <span class="hljs-number">2</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>writeI32()</strong>：写入<strong>整型</strong><code>int</code>类型数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeI32</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i32)</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  inoutTemp[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i32 &gt;&gt; <span class="hljs-number">24</span>));<br>  inoutTemp[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i32 &gt;&gt; <span class="hljs-number">16</span>));<br>  inoutTemp[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i32 &gt;&gt; <span class="hljs-number">8</span>));<br>  inoutTemp[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i32));<br>  trans_.write(inoutTemp， <span class="hljs-number">0</span>， <span class="hljs-number">4</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>writeI64()</strong>：写入<strong>长整型</strong><code>long</code>类型数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeI64</span><span class="hljs-params">(<span class="hljs-keyword">long</span> i64)</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  inoutTemp[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i64 &gt;&gt; <span class="hljs-number">56</span>));<br>  inoutTemp[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i64 &gt;&gt; <span class="hljs-number">48</span>));<br>  inoutTemp[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i64 &gt;&gt; <span class="hljs-number">40</span>));<br>  inoutTemp[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i64 &gt;&gt; <span class="hljs-number">32</span>));<br>  inoutTemp[<span class="hljs-number">4</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i64 &gt;&gt; <span class="hljs-number">24</span>));<br>  inoutTemp[<span class="hljs-number">5</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i64 &gt;&gt; <span class="hljs-number">16</span>));<br>  inoutTemp[<span class="hljs-number">6</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i64 &gt;&gt; <span class="hljs-number">8</span>));<br>  inoutTemp[<span class="hljs-number">7</span>] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0xff</span> &amp; (i64));<br>  trans_.write(inoutTemp， <span class="hljs-number">0</span>， <span class="hljs-number">8</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>writeDouble()</strong>：写入<strong>双浮点型</strong><code>double</code>类型数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeDouble</span><span class="hljs-params">(<span class="hljs-keyword">double</span> dub)</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  writeI64(Double.doubleToLongBits(dub));<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>writeString()</strong>：写入<strong>字符串类型</strong>，这里先写入<strong>字符串长度</strong>，再写入<strong>字符串内容</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeString</span><span class="hljs-params">(String str)</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">byte</span>[] dat = str.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    writeI32(dat.length);<br>    trans_.write(dat， <span class="hljs-number">0</span>， dat.length);<br>  &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException uex) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TException(<span class="hljs-string">&quot;JVM DOES NOT SUPPORT UTF-8&quot;</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>writeBinary</strong>：写入<strong>二进制数组</strong>类型数据，这里数据输入是<code>NIO</code>中的<code>ByteBuffer</code>类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBinary</span><span class="hljs-params">(ByteBuffer bin)</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  <span class="hljs-keyword">int</span> length = bin.limit() - bin.position();<br>  writeI32(length);<br>  trans_.write(bin.array()， bin.position() + bin.arrayOffset()， length);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>(3). 每个字段写入完成后，都需要记录<strong>字段结束标记</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeFieldEnd</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br></code></pre></td></tr></table></figure>
<p>(d). 当所有的字段都写入以后，需要记录<strong>字段停止标记</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeFieldStop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  writeByte(TType.STOP);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>(e). 当所有数据写入完成后，通过<code>writeStructEnd()</code>记录<strong>写入结构</strong>的<strong>完成标记</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeStructEnd</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="二-readData-分析">(二) readData()分析</h3>
<p>查看<code>thrift</code>的<strong>反序列化机制</strong>，即<strong>数据读取</strong>实现，同样采用<strong>二进制协议</strong><code>TBinaryProtocol</code>，切入点为<code>pair.read(TProtocol)</code>：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/19/164185ff1a945020~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p><strong>数据读取</strong>和<strong>数据写入</strong>一样，也是采用的<strong>标准计划</strong><code>StandardScheme</code>。<strong>标准计划</strong>(<code>StandardScheme</code>)下的<code>read()</code>方法：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/19/164185ff165f31e8~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>这里完成的几步操作：</p>
<p>(a). 通过<code>readStructBegin</code>读取<strong>结构</strong>的<strong>开始标记</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">iprot.readStructBegin();<br><br></code></pre></td></tr></table></figure>
<p>(b). 循环读取<strong>结构</strong>中的<strong>所有字段数据</strong>到<code>Pair</code>对象中，直到读取到<code>org.apache.thrift.protocol.TType.STOP</code>为止。<code>iprot.readFieldBegin()</code>指明开始读取<strong>下一个字段</strong>的前需要读取<strong>字段开始标记</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>  schemeField = iprot.readFieldBegin();<br>  <span class="hljs-keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STOP) &#123;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 字段的读取，省略...</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>©. 根据<code>Thrift IDL</code>定义的<code>field-id</code>读取对应的字段，并赋值到<code>Pair</code>对象中，并设置<code>Pair</code>对象相应的字段为<strong>已读状态</strong>(前提：字段在<code>IDL</code>中被定义为<code>required</code>)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (schemeField.id) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// KEY</span><br>    <span class="hljs-keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STRING) &#123;<br>      struct.key = iprot.readString();<br>      struct.setKeyIsSet(<span class="hljs-keyword">true</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      org.apache.thrift.protocol.TProtocolUtil.skip(iprot， schemeField.type);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// VALUE</span><br>    <span class="hljs-keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STRING) &#123;<br>      struct.value = iprot.readString();<br>      struct.setValueIsSet(<span class="hljs-keyword">true</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      org.apache.thrift.protocol.TProtocolUtil.skip(iprot， schemeField.type);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    org.apache.thrift.protocol.TProtocolUtil.skip(iprot， schemeField.type);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>关于<strong>读取字段</strong>的值，根据字段的<strong>数据类型</strong>也分为以下实现：<code>readByte()</code>、<code>readBool()</code>、<code>readI32()</code>、<code>readI64()</code>、<code>readDouble()</code>、<code>readString()</code>和<code>readBinary()</code>方法。</p>
<ul>
<li><strong>readByte()</strong>：读取<strong>单个字节</strong>数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span> <span class="hljs-title">readByte</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  <span class="hljs-keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">byte</span> b = trans_.getBuffer()[trans_.getBufferPosition()];<br>    trans_.consumeBuffer(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> b;<br>  &#125;<br>  readAll(inoutTemp， <span class="hljs-number">0</span>， <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> inoutTemp[<span class="hljs-number">0</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>readBool()</strong>：读取<strong>布尔值</strong>数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readBool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  <span class="hljs-keyword">return</span> (readByte() == <span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>readI16()</strong>：读取<strong>短整型</strong><code>short</code>类型数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">short</span> <span class="hljs-title">readI16</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  <span class="hljs-keyword">byte</span>[] buf = inoutTemp;<br>  <span class="hljs-keyword">int</span> off = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="hljs-number">2</span>) &#123;<br>    buf = trans_.getBuffer();<br>    off = trans_.getBufferPosition();<br>    trans_.consumeBuffer(<span class="hljs-number">2</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    readAll(inoutTemp， <span class="hljs-number">0</span>， <span class="hljs-number">2</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">short</span>) (((buf[off] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">8</span>) |<br>                 ((buf[off+<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0xff</span>)));<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>readI32()</strong>：读取<strong>整型</strong><code>int</code>类型数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">readI32</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  <span class="hljs-keyword">byte</span>[] buf = inoutTemp;<br>  <span class="hljs-keyword">int</span> off = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="hljs-number">4</span>) &#123;<br>    buf = trans_.getBuffer();<br>    off = trans_.getBufferPosition();<br>    trans_.consumeBuffer(<span class="hljs-number">4</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    readAll(inoutTemp， <span class="hljs-number">0</span>， <span class="hljs-number">4</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ((buf[off] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">24</span>) |<br>         ((buf[off+<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">16</span>) |<br>         ((buf[off+<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt;  <span class="hljs-number">8</span>) |<br>         ((buf[off+<span class="hljs-number">3</span>] &amp; <span class="hljs-number">0xff</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>readI64()</strong>：读取<strong>长整型</strong><code>long</code>类型数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">readI64</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  <span class="hljs-keyword">byte</span>[] buf = inoutTemp;<br>  <span class="hljs-keyword">int</span> off = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="hljs-number">8</span>) &#123;<br>    buf = trans_.getBuffer();<br>    off = trans_.getBufferPosition();<br>    trans_.consumeBuffer(<span class="hljs-number">8</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    readAll(inoutTemp， <span class="hljs-number">0</span>， <span class="hljs-number">8</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">long</span>)(buf[off]   &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">56</span>) |<br>         ((<span class="hljs-keyword">long</span>)(buf[off+<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">48</span>) |<br>         ((<span class="hljs-keyword">long</span>)(buf[off+<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">40</span>) |<br>         ((<span class="hljs-keyword">long</span>)(buf[off+<span class="hljs-number">3</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">32</span>) |<br>         ((<span class="hljs-keyword">long</span>)(buf[off+<span class="hljs-number">4</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">24</span>) |<br>         ((<span class="hljs-keyword">long</span>)(buf[off+<span class="hljs-number">5</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">16</span>) |<br>         ((<span class="hljs-keyword">long</span>)(buf[off+<span class="hljs-number">6</span>] &amp; <span class="hljs-number">0xff</span>) &lt;&lt;  <span class="hljs-number">8</span>) |<br>         ((<span class="hljs-keyword">long</span>)(buf[off+<span class="hljs-number">7</span>] &amp; <span class="hljs-number">0xff</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>readDouble()</strong>：读取<strong>双精度浮点</strong><code>double</code>类型数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">readDouble</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  <span class="hljs-keyword">return</span> Double.longBitsToDouble(readI64());<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>readString()</strong>：读取<strong>字符串类型</strong>的数据，首先读取并校验<code>4</code>字节的<strong>字符串长度</strong>，然后检查<code>NIO</code><strong>缓冲区</strong>中是否有对应长度的字节<strong>未消费</strong>。如果有，直接从<strong>缓冲区</strong>中读取；否则，从<strong>传输通道</strong>中读取数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  <span class="hljs-keyword">int</span> size = readI32();<br>  checkStringReadLength(size);<br><br>  <span class="hljs-keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= size) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      String s = <span class="hljs-keyword">new</span> String(trans_.getBuffer()， trans_.getBufferPosition()， size， <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>      trans_.consumeBuffer(size);<br>      <span class="hljs-keyword">return</span> s;<br>    &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TException(<span class="hljs-string">&quot;JVM DOES NOT SUPPORT UTF-8&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> readStringBody(size);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>如果是从<strong>传输通道</strong>中读取数据，查看<code>readStringBody()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readStringBody</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[size];<br>    trans_.readAll(buf， <span class="hljs-number">0</span>， size);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buf， <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException uex) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TException(<span class="hljs-string">&quot;JVM DOES NOT SUPPORT UTF-8&quot;</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>readBinary()</strong>：读取<strong>二进制数组</strong>类型数据，和<strong>字符串读取</strong>类似，返回一个<code>ByteBuffer</code>字节缓存对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title">readBinary</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TException </span>&#123;<br>  <span class="hljs-keyword">int</span> size = readI32();<br>  checkStringReadLength(size);<br><br>  <span class="hljs-keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= size) &#123;<br>    ByteBuffer bb = ByteBuffer.wrap(trans_.getBuffer()， trans_.getBufferPosition()， size);<br>    trans_.consumeBuffer(size);<br>    <span class="hljs-keyword">return</span> bb;<br>  &#125;<br><br>  <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[size];<br>  trans_.readAll(buf， <span class="hljs-number">0</span>， size);<br>  <span class="hljs-keyword">return</span> ByteBuffer.wrap(buf);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>(d). 每个字段数据读取完成后，都需要再读取一个<strong>字段结束标记</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFieldEnd</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br></code></pre></td></tr></table></figure>
<p>(e). 当所有字段读取完成后，需要通过<code>readStructEnd()</code>再读入一个<strong>结构完成标记</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readStructEnd</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br></code></pre></td></tr></table></figure>
<p>(f). 读取结束后，同样需要校验在<code>Thrift IDL</code>中定义为<code>required</code>的字段是否为空，是否合法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> org.apache.thrift.TException </span>&#123;<br>  <span class="hljs-comment">// check for required fields</span><br>  <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="hljs-string">&quot;Required field &#x27;key&#x27; was not present! Struct: &quot;</span> + toString());<br>  &#125;<br>  <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="hljs-string">&quot;Required field &#x27;value&#x27; was not present! Struct: &quot;</span> + toString());<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h1>总结</h1>
<p>其实到这里，对于<code>Thrift</code>的<strong>序列化机制</strong>和<strong>反序列化机制</strong>的<strong>具体实现</strong>和<strong>高效性</strong>，相信各位已经有了比较深入的认识！</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/dajiangdahe/categories/Thrift/">Thrift</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/dajiangdahe/tags/Thrift/">Thrift</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/dajiangdahe/2022/07/04/%E6%8E%A5%E5%8F%A3%E5%A4%9A%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">接口多实现类动态调用的两种方式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/dajiangdahe/2022/04/10/%E5%AD%97%E6%AE%B5%E8%84%B1%E6%95%8F/">
                        <span class="hidden-mobile">敏感型数据进行脱敏设置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP证123456号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/dajiangdahe/img/police_beian.png" alt="police-icon"/>
            
            <span>京公网安备12345678号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/dajiangdahe/js/events.js" ></script>
<script  src="/dajiangdahe/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/dajiangdahe/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/dajiangdahe/js/boot.js" ></script>


</body>
</html>
